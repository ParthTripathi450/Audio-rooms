// node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.esm.mjs
function e(e9, t2) {
  return t2.forEach(function(t3) {
    t3 && "string" != typeof t3 && !Array.isArray(t3) && Object.keys(t3).forEach(function(i2) {
      if ("default" !== i2 && !(i2 in e9)) {
        var n2 = Object.getOwnPropertyDescriptor(t3, i2);
        Object.defineProperty(e9, i2, n2.get ? n2 : { enumerable: true, get: function() {
          return t3[i2];
        } });
      }
    });
  }), Object.freeze(e9);
}
var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function i(e9) {
  return e9 && e9.__esModule && Object.prototype.hasOwnProperty.call(e9, "default") ? e9.default : e9;
}
var n = function(e9) {
  try {
    return !!e9();
  } catch (e10) {
    return true;
  }
};
var r = !n(function() {
  var e9 = (function() {
  }).bind();
  return "function" != typeof e9 || e9.hasOwnProperty("prototype");
});
var o = r;
var s = Function.prototype;
var a = s.call;
var c = o && s.bind.bind(a, a);
var d = o ? c : function(e9) {
  return function() {
    return a.apply(e9, arguments);
  };
};
var l = d({}.isPrototypeOf);
var u = function(e9) {
  return e9 && e9.Math == Math && e9;
};
var h = u("object" == typeof globalThis && globalThis) || u("object" == typeof window && window) || u("object" == typeof self && self) || u("object" == typeof t && t) || /* @__PURE__ */ function() {
  return this;
}() || t || Function("return this")();
var p = r;
var _ = Function.prototype;
var E = _.apply;
var f = _.call;
var m = "object" == typeof Reflect && Reflect.apply || (p ? f.bind(E) : function() {
  return f.apply(E, arguments);
});
var T = d;
var S = T({}.toString);
var g = T("".slice);
var R = function(e9) {
  return g(S(e9), 8, -1);
};
var C = R;
var I = d;
var v = function(e9) {
  if ("Function" === C(e9)) return I(e9);
};
var y = "object" == typeof document && document.all;
var A = { all: y, IS_HTMLDDA: void 0 === y && void 0 !== y };
var b = A.all;
var w = A.IS_HTMLDDA ? function(e9) {
  return "function" == typeof e9 || e9 === b;
} : function(e9) {
  return "function" == typeof e9;
};
var O = {};
var N = !n(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
});
var D = r;
var P = Function.prototype.call;
var L = D ? P.bind(P) : function() {
  return P.apply(P, arguments);
};
var k = {};
var M = {}.propertyIsEnumerable;
var U = Object.getOwnPropertyDescriptor;
var x = U && !M.call({ 1: 2 }, 1);
k.f = x ? function(e9) {
  var t2 = U(this, e9);
  return !!t2 && t2.enumerable;
} : M;
var V;
var F;
var B = function(e9, t2) {
  return { enumerable: !(1 & e9), configurable: !(2 & e9), writable: !(4 & e9), value: t2 };
};
var j = n;
var G = R;
var W = Object;
var H = d("".split);
var K = j(function() {
  return !W("z").propertyIsEnumerable(0);
}) ? function(e9) {
  return "String" == G(e9) ? H(e9, "") : W(e9);
} : W;
var Y = function(e9) {
  return null == e9;
};
var q = Y;
var z = TypeError;
var J = function(e9) {
  if (q(e9)) throw z("Can't call method on " + e9);
  return e9;
};
var X = K;
var Q = J;
var Z = function(e9) {
  return X(Q(e9));
};
var $ = w;
var ee = A.all;
var te = A.IS_HTMLDDA ? function(e9) {
  return "object" == typeof e9 ? null !== e9 : $(e9) || e9 === ee;
} : function(e9) {
  return "object" == typeof e9 ? null !== e9 : $(e9);
};
var ie = {};
var ne = ie;
var re = h;
var oe = w;
var se = function(e9) {
  return oe(e9) ? e9 : void 0;
};
var ae = function(e9, t2) {
  return arguments.length < 2 ? se(ne[e9]) || se(re[e9]) : ne[e9] && ne[e9][t2] || re[e9] && re[e9][t2];
};
var ce = "undefined" != typeof navigator && String(navigator.userAgent) || "";
var de = h;
var le = ce;
var ue = de.process;
var he = de.Deno;
var pe = ue && ue.versions || he && he.version;
var _e = pe && pe.v8;
_e && (F = (V = _e.split("."))[0] > 0 && V[0] < 4 ? 1 : +(V[0] + V[1])), !F && le && (!(V = le.match(/Edge\/(\d+)/)) || V[1] >= 74) && (V = le.match(/Chrome\/(\d+)/)) && (F = +V[1]);
var Ee = F;
var fe = Ee;
var me = n;
var Te = h.String;
var Se = !!Object.getOwnPropertySymbols && !me(function() {
  var e9 = Symbol();
  return !Te(e9) || !(Object(e9) instanceof Symbol) || !Symbol.sham && fe && fe < 41;
});
var ge = Se && !Symbol.sham && "symbol" == typeof Symbol.iterator;
var Re = ae;
var Ce = w;
var Ie = l;
var ve = Object;
var ye = ge ? function(e9) {
  return "symbol" == typeof e9;
} : function(e9) {
  var t2 = Re("Symbol");
  return Ce(t2) && Ie(t2.prototype, ve(e9));
};
var Ae = String;
var be = function(e9) {
  try {
    return Ae(e9);
  } catch (e10) {
    return "Object";
  }
};
var we = w;
var Oe = be;
var Ne = TypeError;
var De = function(e9) {
  if (we(e9)) return e9;
  throw Ne(Oe(e9) + " is not a function");
};
var Pe = De;
var Le = Y;
var ke = function(e9, t2) {
  var i2 = e9[t2];
  return Le(i2) ? void 0 : Pe(i2);
};
var Me = L;
var Ue = w;
var xe = te;
var Ve = TypeError;
var Fe = { exports: {} };
var Be = h;
var je = Object.defineProperty;
var Ge = function(e9, t2) {
  try {
    je(Be, e9, { value: t2, configurable: true, writable: true });
  } catch (i2) {
    Be[e9] = t2;
  }
  return t2;
};
var We = "__core-js_shared__";
var He = h[We] || Ge(We, {});
var Ke = He;
(Fe.exports = function(e9, t2) {
  return Ke[e9] || (Ke[e9] = void 0 !== t2 ? t2 : {});
})("versions", []).push({ version: "3.31.1", mode: "pure", copyright: "Â© 2014-2023 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.31.1/LICENSE", source: "https://github.com/zloirock/core-js" });
var Ye = Fe.exports;
var qe = J;
var ze = Object;
var Je = function(e9) {
  return ze(qe(e9));
};
var Xe = Je;
var Qe = d({}.hasOwnProperty);
var Ze = Object.hasOwn || function(e9, t2) {
  return Qe(Xe(e9), t2);
};
var $e = d;
var et = 0;
var tt = Math.random();
var it = $e(1 .toString);
var nt = function(e9) {
  return "Symbol(" + (void 0 === e9 ? "" : e9) + ")_" + it(++et + tt, 36);
};
var rt = Ye;
var ot = Ze;
var st = nt;
var at = Se;
var ct = ge;
var dt = h.Symbol;
var lt = rt("wks");
var ut = ct ? dt.for || dt : dt && dt.withoutSetter || st;
var ht = function(e9) {
  return ot(lt, e9) || (lt[e9] = at && ot(dt, e9) ? dt[e9] : ut("Symbol." + e9)), lt[e9];
};
var pt = L;
var _t = te;
var Et = ye;
var ft = ke;
var mt = function(e9, t2) {
  var i2, n2;
  if ("string" === t2 && Ue(i2 = e9.toString) && !xe(n2 = Me(i2, e9))) return n2;
  if (Ue(i2 = e9.valueOf) && !xe(n2 = Me(i2, e9))) return n2;
  if ("string" !== t2 && Ue(i2 = e9.toString) && !xe(n2 = Me(i2, e9))) return n2;
  throw Ve("Can't convert object to primitive value");
};
var Tt = TypeError;
var St = ht("toPrimitive");
var gt = function(e9, t2) {
  if (!_t(e9) || Et(e9)) return e9;
  var i2, n2 = ft(e9, St);
  if (n2) {
    if (void 0 === t2 && (t2 = "default"), i2 = pt(n2, e9, t2), !_t(i2) || Et(i2)) return i2;
    throw Tt("Can't convert object to primitive value");
  }
  return void 0 === t2 && (t2 = "number"), mt(e9, t2);
};
var Rt = ye;
var Ct = function(e9) {
  var t2 = gt(e9, "string");
  return Rt(t2) ? t2 : t2 + "";
};
var It = te;
var vt = h.document;
var yt = It(vt) && It(vt.createElement);
var At = function(e9) {
  return yt ? vt.createElement(e9) : {};
};
var bt = At;
var wt = !N && !n(function() {
  return 7 != Object.defineProperty(bt("div"), "a", { get: function() {
    return 7;
  } }).a;
});
var Ot = N;
var Nt = L;
var Dt = k;
var Pt = B;
var Lt = Z;
var kt = Ct;
var Mt = Ze;
var Ut = wt;
var xt = Object.getOwnPropertyDescriptor;
O.f = Ot ? xt : function(e9, t2) {
  if (e9 = Lt(e9), t2 = kt(t2), Ut) try {
    return xt(e9, t2);
  } catch (e10) {
  }
  if (Mt(e9, t2)) return Pt(!Nt(Dt.f, e9, t2), e9[t2]);
};
var Vt = n;
var Ft = w;
var Bt = /#|\.prototype\./;
var jt = function(e9, t2) {
  var i2 = Wt[Gt(e9)];
  return i2 == Kt || i2 != Ht && (Ft(t2) ? Vt(t2) : !!t2);
};
var Gt = jt.normalize = function(e9) {
  return String(e9).replace(Bt, ".").toLowerCase();
};
var Wt = jt.data = {};
var Ht = jt.NATIVE = "N";
var Kt = jt.POLYFILL = "P";
var Yt = jt;
var qt = De;
var zt = r;
var Jt = v(v.bind);
var Xt = function(e9, t2) {
  return qt(e9), void 0 === t2 ? e9 : zt ? Jt(e9, t2) : function() {
    return e9.apply(t2, arguments);
  };
};
var Qt = {};
var Zt = N && n(function() {
  return 42 != Object.defineProperty(function() {
  }, "prototype", { value: 42, writable: false }).prototype;
});
var $t = te;
var ei = String;
var ti = TypeError;
var ii = function(e9) {
  if ($t(e9)) return e9;
  throw ti(ei(e9) + " is not an object");
};
var ni = N;
var ri = wt;
var oi = Zt;
var si = ii;
var ai = Ct;
var ci = TypeError;
var di = Object.defineProperty;
var li = Object.getOwnPropertyDescriptor;
var ui = "enumerable";
var hi = "configurable";
var pi = "writable";
Qt.f = ni ? oi ? function(e9, t2, i2) {
  if (si(e9), t2 = ai(t2), si(i2), "function" == typeof e9 && "prototype" === t2 && "value" in i2 && pi in i2 && !i2[pi]) {
    var n2 = li(e9, t2);
    n2 && n2[pi] && (e9[t2] = i2.value, i2 = { configurable: hi in i2 ? i2[hi] : n2[hi], enumerable: ui in i2 ? i2[ui] : n2[ui], writable: false });
  }
  return di(e9, t2, i2);
} : di : function(e9, t2, i2) {
  if (si(e9), t2 = ai(t2), si(i2), ri) try {
    return di(e9, t2, i2);
  } catch (e10) {
  }
  if ("get" in i2 || "set" in i2) throw ci("Accessors not supported");
  return "value" in i2 && (e9[t2] = i2.value), e9;
};
var _i = Qt;
var Ei = B;
var fi = N ? function(e9, t2, i2) {
  return _i.f(e9, t2, Ei(1, i2));
} : function(e9, t2, i2) {
  return e9[t2] = i2, e9;
};
var mi = h;
var Ti = m;
var Si = v;
var gi = w;
var Ri = O.f;
var Ci = Yt;
var Ii = ie;
var vi = Xt;
var yi = fi;
var Ai = Ze;
var bi = function(e9) {
  var t2 = function(i2, n2, r2) {
    if (this instanceof t2) {
      switch (arguments.length) {
        case 0:
          return new e9();
        case 1:
          return new e9(i2);
        case 2:
          return new e9(i2, n2);
      }
      return new e9(i2, n2, r2);
    }
    return Ti(e9, this, arguments);
  };
  return t2.prototype = e9.prototype, t2;
};
var wi = function(e9, t2) {
  var i2, n2, r2, o2, s2, a2, c2, d2, l2, u2 = e9.target, h2 = e9.global, p2 = e9.stat, _2 = e9.proto, E2 = h2 ? mi : p2 ? mi[u2] : (mi[u2] || {}).prototype, f2 = h2 ? Ii : Ii[u2] || yi(Ii, u2, {})[u2], m2 = f2.prototype;
  for (o2 in t2) n2 = !(i2 = Ci(h2 ? o2 : u2 + (p2 ? "." : "#") + o2, e9.forced)) && E2 && Ai(E2, o2), a2 = f2[o2], n2 && (c2 = e9.dontCallGetSet ? (l2 = Ri(E2, o2)) && l2.value : E2[o2]), s2 = n2 && c2 ? c2 : t2[o2], n2 && typeof a2 == typeof s2 || (d2 = e9.bind && n2 ? vi(s2, mi) : e9.wrap && n2 ? bi(s2) : _2 && gi(s2) ? Si(s2) : s2, (e9.sham || s2 && s2.sham || a2 && a2.sham) && yi(d2, "sham", true), yi(f2, o2, d2), _2 && (Ai(Ii, r2 = u2 + "Prototype") || yi(Ii, r2, {}), yi(Ii[r2], o2, s2), e9.real && m2 && (i2 || !m2[o2]) && yi(m2, o2, s2)));
};
var Oi = Math.ceil;
var Ni = Math.floor;
var Di = Math.trunc || function(e9) {
  var t2 = +e9;
  return (t2 > 0 ? Ni : Oi)(t2);
};
var Pi = Di;
var Li = function(e9) {
  var t2 = +e9;
  return t2 != t2 || 0 === t2 ? 0 : Pi(t2);
};
var ki = Li;
var Mi = Math.max;
var Ui = Math.min;
var xi = function(e9, t2) {
  var i2 = ki(e9);
  return i2 < 0 ? Mi(i2 + t2, 0) : Ui(i2, t2);
};
var Vi = Li;
var Fi = Math.min;
var Bi = function(e9) {
  return e9 > 0 ? Fi(Vi(e9), 9007199254740991) : 0;
};
var ji = Bi;
var Gi = function(e9) {
  return ji(e9.length);
};
var Wi = Z;
var Hi = xi;
var Ki = Gi;
var Yi = function(e9) {
  return function(t2, i2, n2) {
    var r2, o2 = Wi(t2), s2 = Ki(o2), a2 = Hi(n2, s2);
    if (e9 && i2 != i2) {
      for (; s2 > a2; ) if ((r2 = o2[a2++]) != r2) return true;
    } else for (; s2 > a2; a2++) if ((e9 || a2 in o2) && o2[a2] === i2) return e9 || a2 || 0;
    return !e9 && -1;
  };
};
var qi = { includes: Yi(true), indexOf: Yi(false) };
var zi = qi.includes;
wi({ target: "Array", proto: true, forced: n(function() {
  return !Array(1).includes();
}) }, { includes: function(e9) {
  return zi(this, e9, arguments.length > 1 ? arguments[1] : void 0);
} });
var Ji = ie;
var Xi = function(e9) {
  return Ji[e9 + "Prototype"];
};
var Qi = Xi("Array").includes;
var Zi = te;
var $i = R;
var en = ht("match");
var tn = function(e9) {
  var t2;
  return Zi(e9) && (void 0 !== (t2 = e9[en]) ? !!t2 : "RegExp" == $i(e9));
};
var nn = tn;
var rn = TypeError;
var on = {};
on[ht("toStringTag")] = "z";
var sn = "[object z]" === String(on);
var an = sn;
var cn = w;
var dn = R;
var ln = ht("toStringTag");
var un = Object;
var hn = "Arguments" == dn(/* @__PURE__ */ function() {
  return arguments;
}());
var pn = an ? dn : function(e9) {
  var t2, i2, n2;
  return void 0 === e9 ? "Undefined" : null === e9 ? "Null" : "string" == typeof (i2 = function(e10, t3) {
    try {
      return e10[t3];
    } catch (e11) {
    }
  }(t2 = un(e9), ln)) ? i2 : hn ? dn(t2) : "Object" == (n2 = dn(t2)) && cn(t2.callee) ? "Arguments" : n2;
};
var _n = pn;
var En = String;
var fn = function(e9) {
  if ("Symbol" === _n(e9)) throw TypeError("Cannot convert a Symbol value to a string");
  return En(e9);
};
var mn = ht("match");
var Tn = wi;
var Sn = function(e9) {
  if (nn(e9)) throw rn("The method doesn't accept regular expressions");
  return e9;
};
var gn = J;
var Rn = fn;
var Cn = function(e9) {
  var t2 = /./;
  try {
    "/./"[e9](t2);
  } catch (i2) {
    try {
      return t2[mn] = false, "/./"[e9](t2);
    } catch (e10) {
    }
  }
  return false;
};
var In = d("".indexOf);
Tn({ target: "String", proto: true, forced: !Cn("includes") }, { includes: function(e9) {
  return !!~In(Rn(gn(this)), Rn(Sn(e9)), arguments.length > 1 ? arguments[1] : void 0);
} });
var vn = Xi("String").includes;
var yn = l;
var An = Qi;
var bn = vn;
var wn = Array.prototype;
var On = String.prototype;
var Nn = function(e9) {
  var t2 = e9.includes;
  return e9 === wn || yn(wn, e9) && t2 === wn.includes ? An : "string" == typeof e9 || e9 === On || yn(On, e9) && t2 === On.includes ? bn : t2;
};
var Dn = i(Nn);
var Pn = De;
var Ln = Je;
var kn = K;
var Mn = Gi;
var Un = TypeError;
var xn = function(e9) {
  return function(t2, i2, n2, r2) {
    Pn(i2);
    var o2 = Ln(t2), s2 = kn(o2), a2 = Mn(o2), c2 = e9 ? a2 - 1 : 0, d2 = e9 ? -1 : 1;
    if (n2 < 2) for (; ; ) {
      if (c2 in s2) {
        r2 = s2[c2], c2 += d2;
        break;
      }
      if (c2 += d2, e9 ? c2 < 0 : a2 <= c2) throw Un("Reduce of empty array with no initial value");
    }
    for (; e9 ? c2 >= 0 : a2 > c2; c2 += d2) c2 in s2 && (r2 = i2(r2, s2[c2], c2, o2));
    return r2;
  };
};
var Vn = { left: xn(false), right: xn(true) };
var Fn = n;
var Bn = function(e9, t2) {
  var i2 = [][e9];
  return !!i2 && Fn(function() {
    i2.call(null, t2 || function() {
      return 1;
    }, 1);
  });
};
var jn = "undefined" != typeof process && "process" == R(process);
var Gn = Vn.left;
wi({ target: "Array", proto: true, forced: !jn && Ee > 79 && Ee < 83 || !Bn("reduce") }, { reduce: function(e9) {
  var t2 = arguments.length;
  return Gn(this, e9, t2, t2 > 1 ? arguments[1] : void 0);
} });
var Wn = Xi("Array").reduce;
var Hn = l;
var Kn = Wn;
var Yn = Array.prototype;
var qn = function(e9) {
  var t2 = e9.reduce;
  return e9 === Yn || Hn(Yn, e9) && t2 === Yn.reduce ? Kn : t2;
};
var zn = qn;
var Jn = i(zn);
var Xn = true;
var Qn = true;
function Zn(e9, t2, i2) {
  const n2 = e9.match(t2);
  return n2 && n2.length >= i2 && parseInt(n2[i2], 10);
}
function $n(e9, t2, i2) {
  if (!e9.RTCPeerConnection) return;
  const n2 = e9.RTCPeerConnection.prototype, r2 = n2.addEventListener;
  n2.addEventListener = function(e10, n3) {
    if (e10 !== t2) return r2.apply(this, arguments);
    const o3 = (e11) => {
      const t3 = i2(e11);
      t3 && (n3.handleEvent ? n3.handleEvent(t3) : n3(t3));
    };
    return this._eventMap = this._eventMap || {}, this._eventMap[t2] || (this._eventMap[t2] = /* @__PURE__ */ new Map()), this._eventMap[t2].set(n3, o3), r2.apply(this, [e10, o3]);
  };
  const o2 = n2.removeEventListener;
  n2.removeEventListener = function(e10, i3) {
    if (e10 !== t2 || !this._eventMap || !this._eventMap[t2]) return o2.apply(this, arguments);
    if (!this._eventMap[t2].has(i3)) return o2.apply(this, arguments);
    const n3 = this._eventMap[t2].get(i3);
    return this._eventMap[t2].delete(i3), 0 === this._eventMap[t2].size && delete this._eventMap[t2], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o2.apply(this, [e10, n3]);
  }, Object.defineProperty(n2, "on" + t2, { get() {
    return this["_on" + t2];
  }, set(e10) {
    this["_on" + t2] && (this.removeEventListener(t2, this["_on" + t2]), delete this["_on" + t2]), e10 && this.addEventListener(t2, this["_on" + t2] = e10);
  }, enumerable: true, configurable: true });
}
function er(e9) {
  return "boolean" != typeof e9 ? new Error("Argument type: " + typeof e9 + ". Please use a boolean.") : (Xn = e9, e9 ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function tr(e9) {
  return "boolean" != typeof e9 ? new Error("Argument type: " + typeof e9 + ". Please use a boolean.") : (Qn = !e9, "adapter.js deprecation warnings " + (e9 ? "disabled" : "enabled"));
}
function ir() {
  if ("object" == typeof window) {
    if (Xn) return;
    "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments);
  }
}
function nr(e9, t2) {
  Qn && console.warn(e9 + " is deprecated, please use " + t2 + " instead.");
}
function rr(e9) {
  return "[object Object]" === Object.prototype.toString.call(e9);
}
function or(e9) {
  var t2;
  return rr(e9) ? Jn(t2 = Object.keys(e9)).call(t2, function(t3, i2) {
    const n2 = rr(e9[i2]), r2 = n2 ? or(e9[i2]) : e9[i2], o2 = n2 && !Object.keys(r2).length;
    return void 0 === r2 || o2 ? t3 : Object.assign(t3, { [i2]: r2 });
  }, {}) : e9;
}
function sr(e9, t2, i2) {
  t2 && !i2.has(t2.id) && (i2.set(t2.id, t2), Object.keys(t2).forEach((n2) => {
    n2.endsWith("Id") ? sr(e9, e9.get(t2[n2]), i2) : n2.endsWith("Ids") && t2[n2].forEach((t3) => {
      sr(e9, e9.get(t3), i2);
    });
  }));
}
function ar(e9, t2, i2) {
  const n2 = i2 ? "outbound-rtp" : "inbound-rtp", r2 = /* @__PURE__ */ new Map();
  if (null === t2) return r2;
  const o2 = [];
  return e9.forEach((e10) => {
    "track" === e10.type && e10.trackIdentifier === t2.id && o2.push(e10);
  }), o2.forEach((t3) => {
    e9.forEach((i3) => {
      i3.type === n2 && i3.trackId === t3.id && sr(e9, i3, r2);
    });
  }), r2;
}
var cr = nt;
var dr = Ye("keys");
var lr = function(e9) {
  return dr[e9] || (dr[e9] = cr(e9));
};
var ur = !n(function() {
  function e9() {
  }
  return e9.prototype.constructor = null, Object.getPrototypeOf(new e9()) !== e9.prototype;
});
var hr = Ze;
var pr = w;
var _r = Je;
var Er = ur;
var fr = lr("IE_PROTO");
var mr = Object;
var Tr = mr.prototype;
var Sr = Er ? mr.getPrototypeOf : function(e9) {
  var t2 = _r(e9);
  if (hr(t2, fr)) return t2[fr];
  var i2 = t2.constructor;
  return pr(i2) && t2 instanceof i2 ? i2.prototype : t2 instanceof mr ? Tr : null;
};
var gr = d;
var Rr = De;
var Cr = w;
var Ir = String;
var vr = TypeError;
var yr = function(e9, t2, i2) {
  try {
    return gr(Rr(Object.getOwnPropertyDescriptor(e9, t2)[i2]));
  } catch (e10) {
  }
};
var Ar = ii;
var br = function(e9) {
  if ("object" == typeof e9 || Cr(e9)) return e9;
  throw vr("Can't set " + Ir(e9) + " as a prototype");
};
var wr = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var e9, t2 = false, i2 = {};
  try {
    (e9 = yr(Object.prototype, "__proto__", "set"))(i2, []), t2 = i2 instanceof Array;
  } catch (e10) {
  }
  return function(i3, n2) {
    return Ar(i3), br(n2), t2 ? e9(i3, n2) : i3.__proto__ = n2, i3;
  };
}() : void 0);
var Or = {};
var Nr = {};
var Dr = Ze;
var Pr = Z;
var Lr = qi.indexOf;
var kr = Nr;
var Mr = d([].push);
var Ur = function(e9, t2) {
  var i2, n2 = Pr(e9), r2 = 0, o2 = [];
  for (i2 in n2) !Dr(kr, i2) && Dr(n2, i2) && Mr(o2, i2);
  for (; t2.length > r2; ) Dr(n2, i2 = t2[r2++]) && (~Lr(o2, i2) || Mr(o2, i2));
  return o2;
};
var xr = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
var Vr = Ur;
var Fr = xr.concat("length", "prototype");
Or.f = Object.getOwnPropertyNames || function(e9) {
  return Vr(e9, Fr);
};
var Br = {};
Br.f = Object.getOwnPropertySymbols;
var jr = ae;
var Gr = Or;
var Wr = Br;
var Hr = ii;
var Kr = d([].concat);
var Yr = jr("Reflect", "ownKeys") || function(e9) {
  var t2 = Gr.f(Hr(e9)), i2 = Wr.f;
  return i2 ? Kr(t2, i2(e9)) : t2;
};
var qr = Ze;
var zr = Yr;
var Jr = O;
var Xr = Qt;
var Qr = {};
var Zr = Ur;
var $r = xr;
var eo = Object.keys || function(e9) {
  return Zr(e9, $r);
};
var to = N;
var io = Zt;
var no = Qt;
var ro = ii;
var oo = Z;
var so = eo;
Qr.f = to && !io ? Object.defineProperties : function(e9, t2) {
  ro(e9);
  for (var i2, n2 = oo(t2), r2 = so(t2), o2 = r2.length, s2 = 0; o2 > s2; ) no.f(e9, i2 = r2[s2++], n2[i2]);
  return e9;
};
var ao;
var co = ae("document", "documentElement");
var lo = ii;
var uo = Qr;
var ho = xr;
var po = Nr;
var _o = co;
var Eo = At;
var fo = "prototype";
var mo = "script";
var To = lr("IE_PROTO");
var So = function() {
};
var go = function(e9) {
  return "<" + mo + ">" + e9 + "</" + mo + ">";
};
var Ro = function(e9) {
  e9.write(go("")), e9.close();
  var t2 = e9.parentWindow.Object;
  return e9 = null, t2;
};
var Co = function() {
  try {
    ao = new ActiveXObject("htmlfile");
  } catch (e10) {
  }
  var e9, t2, i2;
  Co = "undefined" != typeof document ? document.domain && ao ? Ro(ao) : (t2 = Eo("iframe"), i2 = "java" + mo + ":", t2.style.display = "none", _o.appendChild(t2), t2.src = String(i2), (e9 = t2.contentWindow.document).open(), e9.write(go("document.F=Object")), e9.close(), e9.F) : Ro(ao);
  for (var n2 = ho.length; n2--; ) delete Co[fo][ho[n2]];
  return Co();
};
po[To] = true;
var Io = Object.create || function(e9, t2) {
  var i2;
  return null !== e9 ? (So[fo] = lo(e9), i2 = new So(), So[fo] = null, i2[To] = e9) : i2 = Co(), void 0 === t2 ? i2 : uo.f(i2, t2);
};
var vo = te;
var yo = fi;
var Ao = Error;
var bo = d("".replace);
var wo = String(Ao("zxcasd").stack);
var Oo = /\n\s*at [^:]*:[^\n]*/;
var No = Oo.test(wo);
var Do = B;
var Po = !n(function() {
  var e9 = Error("a");
  return !("stack" in e9) || (Object.defineProperty(e9, "stack", Do(1, 7)), 7 !== e9.stack);
});
var Lo = fi;
var ko = function(e9, t2) {
  if (No && "string" == typeof e9 && !Ao.prepareStackTrace) for (; t2--; ) e9 = bo(e9, Oo, "");
  return e9;
};
var Mo = Po;
var Uo = Error.captureStackTrace;
var xo = {};
var Vo = xo;
var Fo = ht("iterator");
var Bo = Array.prototype;
var jo = function(e9) {
  return void 0 !== e9 && (Vo.Array === e9 || Bo[Fo] === e9);
};
var Go = pn;
var Wo = ke;
var Ho = Y;
var Ko = xo;
var Yo = ht("iterator");
var qo = function(e9) {
  if (!Ho(e9)) return Wo(e9, Yo) || Wo(e9, "@@iterator") || Ko[Go(e9)];
};
var zo = L;
var Jo = De;
var Xo = ii;
var Qo = be;
var Zo = qo;
var $o = TypeError;
var es = function(e9, t2) {
  var i2 = arguments.length < 2 ? Zo(e9) : t2;
  if (Jo(i2)) return Xo(zo(i2, e9));
  throw $o(Qo(e9) + " is not iterable");
};
var ts = L;
var is = ii;
var ns = ke;
var rs = function(e9, t2, i2) {
  var n2, r2;
  is(e9);
  try {
    if (!(n2 = ns(e9, "return"))) {
      if ("throw" === t2) throw i2;
      return i2;
    }
    n2 = ts(n2, e9);
  } catch (e10) {
    r2 = true, n2 = e10;
  }
  if ("throw" === t2) throw i2;
  if (r2) throw n2;
  return is(n2), i2;
};
var os = Xt;
var ss = L;
var as = ii;
var cs = be;
var ds = jo;
var ls = Gi;
var us = l;
var hs = es;
var ps = qo;
var _s = rs;
var Es = TypeError;
var fs = function(e9, t2) {
  this.stopped = e9, this.result = t2;
};
var ms = fs.prototype;
var Ts = function(e9, t2, i2) {
  var n2, r2, o2, s2, a2, c2, d2, l2 = i2 && i2.that, u2 = !(!i2 || !i2.AS_ENTRIES), h2 = !(!i2 || !i2.IS_RECORD), p2 = !(!i2 || !i2.IS_ITERATOR), _2 = !(!i2 || !i2.INTERRUPTED), E2 = os(t2, l2), f2 = function(e10) {
    return n2 && _s(n2, "normal", e10), new fs(true, e10);
  }, m2 = function(e10) {
    return u2 ? (as(e10), _2 ? E2(e10[0], e10[1], f2) : E2(e10[0], e10[1])) : _2 ? E2(e10, f2) : E2(e10);
  };
  if (h2) n2 = e9.iterator;
  else if (p2) n2 = e9;
  else {
    if (!(r2 = ps(e9))) throw Es(cs(e9) + " is not iterable");
    if (ds(r2)) {
      for (o2 = 0, s2 = ls(e9); s2 > o2; o2++) if ((a2 = m2(e9[o2])) && us(ms, a2)) return a2;
      return new fs(false);
    }
    n2 = hs(e9, r2);
  }
  for (c2 = h2 ? e9.next : n2.next; !(d2 = ss(c2, n2)).done; ) {
    try {
      a2 = m2(d2.value);
    } catch (e10) {
      _s(n2, "throw", e10);
    }
    if ("object" == typeof a2 && a2 && us(ms, a2)) return a2;
  }
  return new fs(false);
};
var Ss = fn;
var gs = wi;
var Rs = l;
var Cs = Sr;
var Is = wr;
var vs = function(e9, t2, i2) {
  for (var n2 = zr(t2), r2 = Xr.f, o2 = Jr.f, s2 = 0; s2 < n2.length; s2++) {
    var a2 = n2[s2];
    qr(e9, a2) || i2 && qr(i2, a2) || r2(e9, a2, o2(t2, a2));
  }
};
var ys = Io;
var As = fi;
var bs = B;
var ws = function(e9, t2) {
  vo(t2) && "cause" in t2 && yo(e9, "cause", t2.cause);
};
var Os = function(e9, t2, i2, n2) {
  Mo && (Uo ? Uo(e9, t2) : Lo(e9, "stack", ko(i2, n2)));
};
var Ns = Ts;
var Ds = function(e9, t2) {
  return void 0 === e9 ? arguments.length < 2 ? "" : t2 : Ss(e9);
};
var Ps = ht("toStringTag");
var Ls = Error;
var ks = [].push;
var Ms = function(e9, t2) {
  var i2, n2 = Rs(Us, this);
  Is ? i2 = Is(Ls(), n2 ? Cs(this) : Us) : (i2 = n2 ? this : ys(Us), As(i2, Ps, "Error")), void 0 !== t2 && As(i2, "message", Ds(t2)), Os(i2, Ms, i2.stack, 1), arguments.length > 2 && ws(i2, arguments[2]);
  var r2 = [];
  return Ns(e9, ks, { that: r2 }), As(i2, "errors", r2), i2;
};
Is ? Is(Ms, Ls) : vs(Ms, Ls, { name: true });
var Us = Ms.prototype = ys(Ls.prototype, { constructor: bs(1, Ms), message: bs(1, ""), name: bs(1, "AggregateError") });
gs({ global: true, constructor: true, arity: 2 }, { AggregateError: Ms });
var xs;
var Vs;
var Fs;
var Bs = w;
var js = h.WeakMap;
var Gs = Bs(js) && /native code/.test(String(js));
var Ws = h;
var Hs = te;
var Ks = fi;
var Ys = Ze;
var qs = He;
var zs = lr;
var Js = Nr;
var Xs = "Object already initialized";
var Qs = Ws.TypeError;
var Zs = Ws.WeakMap;
if (Gs || qs.state) {
  $s = qs.state || (qs.state = new Zs());
  $s.get = $s.get, $s.has = $s.has, $s.set = $s.set, xs = function(e9, t2) {
    if ($s.has(e9)) throw Qs(Xs);
    return t2.facade = e9, $s.set(e9, t2), t2;
  }, Vs = function(e9) {
    return $s.get(e9) || {};
  }, Fs = function(e9) {
    return $s.has(e9);
  };
} else {
  ea = zs("state");
  Js[ea] = true, xs = function(e9, t2) {
    if (Ys(e9, ea)) throw Qs(Xs);
    return t2.facade = e9, Ks(e9, ea, t2), t2;
  }, Vs = function(e9) {
    return Ys(e9, ea) ? e9[ea] : {};
  }, Fs = function(e9) {
    return Ys(e9, ea);
  };
}
var $s;
var ea;
var ta;
var ia;
var na;
var ra = { set: xs, get: Vs, has: Fs, enforce: function(e9) {
  return Fs(e9) ? Vs(e9) : xs(e9, {});
}, getterFor: function(e9) {
  return function(t2) {
    var i2;
    if (!Hs(t2) || (i2 = Vs(t2)).type !== e9) throw Qs("Incompatible receiver, " + e9 + " required");
    return i2;
  };
} };
var oa = N;
var sa = Ze;
var aa = Function.prototype;
var ca = oa && Object.getOwnPropertyDescriptor;
var da = sa(aa, "name");
var la = { EXISTS: da, PROPER: da && "something" === (function() {
}).name, CONFIGURABLE: da && (!oa || oa && ca(aa, "name").configurable) };
var ua = fi;
var ha = function(e9, t2, i2, n2) {
  return n2 && n2.enumerable ? e9[t2] = i2 : ua(e9, t2, i2), e9;
};
var pa = n;
var _a = w;
var Ea = te;
var fa = Io;
var ma = Sr;
var Ta = ha;
var Sa = ht("iterator");
var ga = false;
[].keys && ("next" in (na = [].keys()) ? (ia = ma(ma(na))) !== Object.prototype && (ta = ia) : ga = true);
var Ra = !Ea(ta) || pa(function() {
  var e9 = {};
  return ta[Sa].call(e9) !== e9;
});
_a((ta = Ra ? {} : fa(ta))[Sa]) || Ta(ta, Sa, function() {
  return this;
});
var Ca = { IteratorPrototype: ta, BUGGY_SAFARI_ITERATORS: ga };
var Ia = pn;
var va = sn ? {}.toString : function() {
  return "[object " + Ia(this) + "]";
};
var ya = sn;
var Aa = Qt.f;
var ba = fi;
var wa = Ze;
var Oa = va;
var Na = ht("toStringTag");
var Da = function(e9, t2, i2, n2) {
  if (e9) {
    var r2 = i2 ? e9 : e9.prototype;
    wa(r2, Na) || Aa(r2, Na, { configurable: true, value: t2 }), n2 && !ya && ba(r2, "toString", Oa);
  }
};
var Pa = Ca.IteratorPrototype;
var La = Io;
var ka = B;
var Ma = Da;
var Ua = xo;
var xa = function() {
  return this;
};
var Va = function(e9, t2, i2, n2) {
  var r2 = t2 + " Iterator";
  return e9.prototype = La(Pa, { next: ka(+!n2, i2) }), Ma(e9, r2, false, true), Ua[r2] = xa, e9;
};
var Fa = wi;
var Ba = L;
var ja = la;
var Ga = Va;
var Wa = Sr;
var Ha = Da;
var Ka = ha;
var Ya = xo;
var qa = Ca;
var za = ja.PROPER;
var Ja = qa.BUGGY_SAFARI_ITERATORS;
var Xa = ht("iterator");
var Qa = "keys";
var Za = "values";
var $a = "entries";
var ec = function() {
  return this;
};
var tc = function(e9, t2, i2, n2, r2, o2, s2) {
  Ga(i2, t2, n2);
  var a2, c2, d2, l2 = function(e10) {
    if (e10 === r2 && E2) return E2;
    if (!Ja && e10 in p2) return p2[e10];
    switch (e10) {
      case Qa:
      case Za:
      case $a:
        return function() {
          return new i2(this, e10);
        };
    }
    return function() {
      return new i2(this);
    };
  }, u2 = t2 + " Iterator", h2 = false, p2 = e9.prototype, _2 = p2[Xa] || p2["@@iterator"] || r2 && p2[r2], E2 = !Ja && _2 || l2(r2), f2 = "Array" == t2 && p2.entries || _2;
  if (f2 && (a2 = Wa(f2.call(new e9()))) !== Object.prototype && a2.next && (Ha(a2, u2, true, true), Ya[u2] = ec), za && r2 == Za && _2 && _2.name !== Za && (h2 = true, E2 = function() {
    return Ba(_2, this);
  }), r2) if (c2 = { values: l2(Za), keys: o2 ? E2 : l2(Qa), entries: l2($a) }, s2) for (d2 in c2) (Ja || h2 || !(d2 in p2)) && Ka(p2, d2, c2[d2]);
  else Fa({ target: t2, proto: true, forced: Ja || h2 }, c2);
  return s2 && p2[Xa] !== E2 && Ka(p2, Xa, E2, { name: r2 }), Ya[t2] = E2, c2;
};
var ic = function(e9, t2) {
  return { value: e9, done: t2 };
};
var nc = Z;
var rc = xo;
var oc = ra;
Qt.f;
var sc = tc;
var ac = ic;
var cc = "Array Iterator";
var dc = oc.set;
var lc = oc.getterFor(cc);
sc(Array, "Array", function(e9, t2) {
  dc(this, { type: cc, target: nc(e9), index: 0, kind: t2 });
}, function() {
  var e9 = lc(this), t2 = e9.target, i2 = e9.kind, n2 = e9.index++;
  return !t2 || n2 >= t2.length ? (e9.target = void 0, ac(void 0, true)) : ac("keys" == i2 ? n2 : "values" == i2 ? t2[n2] : [n2, t2[n2]], false);
}, "values"), rc.Arguments = rc.Array;
var uc = Qt;
var hc = function(e9, t2, i2) {
  return uc.f(e9, t2, i2);
};
var pc = ae;
var _c = hc;
var Ec = N;
var fc = ht("species");
var mc = l;
var Tc = TypeError;
var Sc = function(e9, t2) {
  if (mc(t2, e9)) return e9;
  throw Tc("Incorrect invocation");
};
var gc = w;
var Rc = He;
var Cc = d(Function.toString);
gc(Rc.inspectSource) || (Rc.inspectSource = function(e9) {
  return Cc(e9);
});
var Ic = Rc.inspectSource;
var vc = d;
var yc = n;
var Ac = w;
var bc = pn;
var wc = Ic;
var Oc = function() {
};
var Nc = [];
var Dc = ae("Reflect", "construct");
var Pc = /^\s*(?:class|function)\b/;
var Lc = vc(Pc.exec);
var kc = !Pc.exec(Oc);
var Mc = function(e9) {
  if (!Ac(e9)) return false;
  try {
    return Dc(Oc, Nc, e9), true;
  } catch (e10) {
    return false;
  }
};
var Uc = function(e9) {
  if (!Ac(e9)) return false;
  switch (bc(e9)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return kc || !!Lc(Pc, wc(e9));
  } catch (e10) {
    return true;
  }
};
Uc.sham = true;
var xc;
var Vc;
var Fc;
var Bc;
var jc = !Dc || yc(function() {
  var e9;
  return Mc(Mc.call) || !Mc(Object) || !Mc(function() {
    e9 = true;
  }) || e9;
}) ? Uc : Mc;
var Gc = jc;
var Wc = be;
var Hc = TypeError;
var Kc = ii;
var Yc = function(e9) {
  if (Gc(e9)) return e9;
  throw Hc(Wc(e9) + " is not a constructor");
};
var qc = Y;
var zc = ht("species");
var Jc = function(e9, t2) {
  var i2, n2 = Kc(e9).constructor;
  return void 0 === n2 || qc(i2 = Kc(n2)[zc]) ? t2 : Yc(i2);
};
var Xc = d([].slice);
var Qc = TypeError;
var Zc = function(e9, t2) {
  if (e9 < t2) throw Qc("Not enough arguments");
  return e9;
};
var $c = /(?:ipad|iphone|ipod).*applewebkit/i.test(ce);
var ed = h;
var td = m;
var id = Xt;
var nd = w;
var rd = Ze;
var od = n;
var sd = co;
var ad = Xc;
var cd = At;
var dd = Zc;
var ld = $c;
var ud = jn;
var hd = ed.setImmediate;
var pd = ed.clearImmediate;
var _d = ed.process;
var Ed = ed.Dispatch;
var fd = ed.Function;
var md = ed.MessageChannel;
var Td = ed.String;
var Sd = 0;
var gd = {};
var Rd = "onreadystatechange";
od(function() {
  xc = ed.location;
});
var Cd = function(e9) {
  if (rd(gd, e9)) {
    var t2 = gd[e9];
    delete gd[e9], t2();
  }
};
var Id = function(e9) {
  return function() {
    Cd(e9);
  };
};
var vd = function(e9) {
  Cd(e9.data);
};
var yd = function(e9) {
  ed.postMessage(Td(e9), xc.protocol + "//" + xc.host);
};
hd && pd || (hd = function(e9) {
  dd(arguments.length, 1);
  var t2 = nd(e9) ? e9 : fd(e9), i2 = ad(arguments, 1);
  return gd[++Sd] = function() {
    td(t2, void 0, i2);
  }, Vc(Sd), Sd;
}, pd = function(e9) {
  delete gd[e9];
}, ud ? Vc = function(e9) {
  _d.nextTick(Id(e9));
} : Ed && Ed.now ? Vc = function(e9) {
  Ed.now(Id(e9));
} : md && !ld ? (Bc = (Fc = new md()).port2, Fc.port1.onmessage = vd, Vc = id(Bc.postMessage, Bc)) : ed.addEventListener && nd(ed.postMessage) && !ed.importScripts && xc && "file:" !== xc.protocol && !od(yd) ? (Vc = yd, ed.addEventListener("message", vd, false)) : Vc = Rd in cd("script") ? function(e9) {
  sd.appendChild(cd("script"))[Rd] = function() {
    sd.removeChild(this), Cd(e9);
  };
} : function(e9) {
  setTimeout(Id(e9), 0);
});
var Ad = { set: hd, clear: pd };
var bd = function() {
  this.head = null, this.tail = null;
};
bd.prototype = { add: function(e9) {
  var t2 = { item: e9, next: null }, i2 = this.tail;
  i2 ? i2.next = t2 : this.head = t2, this.tail = t2;
}, get: function() {
  var e9 = this.head;
  if (e9) return null === (this.head = e9.next) && (this.tail = null), e9.item;
} };
var wd;
var Od;
var Nd;
var Dd;
var Pd;
var Ld = bd;
var kd = /ipad|iphone|ipod/i.test(ce) && "undefined" != typeof Pebble;
var Md = /web0s(?!.*chrome)/i.test(ce);
var Ud = h;
var xd = Xt;
var Vd = O.f;
var Fd = Ad.set;
var Bd = Ld;
var jd = $c;
var Gd = kd;
var Wd = Md;
var Hd = jn;
var Kd = Ud.MutationObserver || Ud.WebKitMutationObserver;
var Yd = Ud.document;
var qd = Ud.process;
var zd = Ud.Promise;
var Jd = Vd(Ud, "queueMicrotask");
var Xd = Jd && Jd.value;
if (!Xd) {
  Qd = new Bd(), Zd = function() {
    var e9, t2;
    for (Hd && (e9 = qd.domain) && e9.exit(); t2 = Qd.get(); ) try {
      t2();
    } catch (e10) {
      throw Qd.head && wd(), e10;
    }
    e9 && e9.enter();
  };
  jd || Hd || Wd || !Kd || !Yd ? !Gd && zd && zd.resolve ? ((Dd = zd.resolve(void 0)).constructor = zd, Pd = xd(Dd.then, Dd), wd = function() {
    Pd(Zd);
  }) : Hd ? wd = function() {
    qd.nextTick(Zd);
  } : (Fd = xd(Fd, Ud), wd = function() {
    Fd(Zd);
  }) : (Od = true, Nd = Yd.createTextNode(""), new Kd(Zd).observe(Nd, { characterData: true }), wd = function() {
    Nd.data = Od = !Od;
  }), Xd = function(e9) {
    Qd.head || wd(), Qd.add(e9);
  };
}
var Qd;
var Zd;
var $d = Xd;
var el = function(e9) {
  try {
    return { error: false, value: e9() };
  } catch (e10) {
    return { error: true, value: e10 };
  }
};
var tl = h.Promise;
var il = "object" == typeof Deno && Deno && "object" == typeof Deno.version;
var nl = !il && !jn && "object" == typeof window && "object" == typeof document;
var rl = h;
var ol = tl;
var sl = w;
var al = Yt;
var cl = Ic;
var dl = ht;
var ll = nl;
var ul = il;
var hl = Ee;
var pl = ol && ol.prototype;
var _l = dl("species");
var El = false;
var fl = sl(rl.PromiseRejectionEvent);
var ml = al("Promise", function() {
  var e9 = cl(ol), t2 = e9 !== String(ol);
  if (!t2 && 66 === hl) return true;
  if (!pl.catch || !pl.finally) return true;
  if (!hl || hl < 51 || !/native code/.test(e9)) {
    var i2 = new ol(function(e10) {
      e10(1);
    }), n2 = function(e10) {
      e10(function() {
      }, function() {
      });
    };
    if ((i2.constructor = {})[_l] = n2, !(El = i2.then(function() {
    }) instanceof n2)) return true;
  }
  return !t2 && (ll || ul) && !fl;
});
var Tl = { CONSTRUCTOR: ml, REJECTION_EVENT: fl, SUBCLASSING: El };
var Sl = {};
var gl = De;
var Rl = TypeError;
var Cl = function(e9) {
  var t2, i2;
  this.promise = new e9(function(e10, n2) {
    if (void 0 !== t2 || void 0 !== i2) throw Rl("Bad Promise constructor");
    t2 = e10, i2 = n2;
  }), this.resolve = gl(t2), this.reject = gl(i2);
};
Sl.f = function(e9) {
  return new Cl(e9);
};
var Il;
var vl;
var yl = wi;
var Al = jn;
var bl = h;
var wl = L;
var Ol = ha;
var Nl = Da;
var Dl = function(e9) {
  var t2 = pc(e9);
  Ec && t2 && !t2[fc] && _c(t2, fc, { configurable: true, get: function() {
    return this;
  } });
};
var Pl = De;
var Ll = w;
var kl = te;
var Ml = Sc;
var Ul = Jc;
var xl = Ad.set;
var Vl = $d;
var Fl = function(e9, t2) {
  try {
    1 == arguments.length ? console.error(e9) : console.error(e9, t2);
  } catch (e10) {
  }
};
var Bl = el;
var jl = Ld;
var Gl = ra;
var Wl = tl;
var Hl = Tl;
var Kl = Sl;
var Yl = "Promise";
var ql = Hl.CONSTRUCTOR;
var zl = Hl.REJECTION_EVENT;
var Jl = Gl.getterFor(Yl);
var Xl = Gl.set;
var Ql = Wl && Wl.prototype;
var Zl = Wl;
var $l = Ql;
var eu = bl.TypeError;
var tu = bl.document;
var iu = bl.process;
var nu = Kl.f;
var ru = nu;
var ou = !!(tu && tu.createEvent && bl.dispatchEvent);
var su = "unhandledrejection";
var au = function(e9) {
  var t2;
  return !(!kl(e9) || !Ll(t2 = e9.then)) && t2;
};
var cu = function(e9, t2) {
  var i2, n2, r2, o2 = t2.value, s2 = 1 == t2.state, a2 = s2 ? e9.ok : e9.fail, c2 = e9.resolve, d2 = e9.reject, l2 = e9.domain;
  try {
    a2 ? (s2 || (2 === t2.rejection && pu(t2), t2.rejection = 1), true === a2 ? i2 = o2 : (l2 && l2.enter(), i2 = a2(o2), l2 && (l2.exit(), r2 = true)), i2 === e9.promise ? d2(eu("Promise-chain cycle")) : (n2 = au(i2)) ? wl(n2, i2, c2, d2) : c2(i2)) : d2(o2);
  } catch (e10) {
    l2 && !r2 && l2.exit(), d2(e10);
  }
};
var du = function(e9, t2) {
  e9.notified || (e9.notified = true, Vl(function() {
    for (var i2, n2 = e9.reactions; i2 = n2.get(); ) cu(i2, e9);
    e9.notified = false, t2 && !e9.rejection && uu(e9);
  }));
};
var lu = function(e9, t2, i2) {
  var n2, r2;
  ou ? ((n2 = tu.createEvent("Event")).promise = t2, n2.reason = i2, n2.initEvent(e9, false, true), bl.dispatchEvent(n2)) : n2 = { promise: t2, reason: i2 }, !zl && (r2 = bl["on" + e9]) ? r2(n2) : e9 === su && Fl("Unhandled promise rejection", i2);
};
var uu = function(e9) {
  wl(xl, bl, function() {
    var t2, i2 = e9.facade, n2 = e9.value;
    if (hu(e9) && (t2 = Bl(function() {
      Al ? iu.emit("unhandledRejection", n2, i2) : lu(su, i2, n2);
    }), e9.rejection = Al || hu(e9) ? 2 : 1, t2.error)) throw t2.value;
  });
};
var hu = function(e9) {
  return 1 !== e9.rejection && !e9.parent;
};
var pu = function(e9) {
  wl(xl, bl, function() {
    var t2 = e9.facade;
    Al ? iu.emit("rejectionHandled", t2) : lu("rejectionhandled", t2, e9.value);
  });
};
var _u = function(e9, t2, i2) {
  return function(n2) {
    e9(t2, n2, i2);
  };
};
var Eu = function(e9, t2, i2) {
  e9.done || (e9.done = true, i2 && (e9 = i2), e9.value = t2, e9.state = 2, du(e9, true));
};
var fu = function(e9, t2, i2) {
  if (!e9.done) {
    e9.done = true, i2 && (e9 = i2);
    try {
      if (e9.facade === t2) throw eu("Promise can't be resolved itself");
      var n2 = au(t2);
      n2 ? Vl(function() {
        var i3 = { done: false };
        try {
          wl(n2, t2, _u(fu, i3, e9), _u(Eu, i3, e9));
        } catch (t3) {
          Eu(i3, t3, e9);
        }
      }) : (e9.value = t2, e9.state = 1, du(e9, false));
    } catch (t3) {
      Eu({ done: false }, t3, e9);
    }
  }
};
ql && ($l = (Zl = function(e9) {
  Ml(this, $l), Pl(e9), wl(Il, this);
  var t2 = Jl(this);
  try {
    e9(_u(fu, t2), _u(Eu, t2));
  } catch (e10) {
    Eu(t2, e10);
  }
}).prototype, (Il = function(e9) {
  Xl(this, { type: Yl, done: false, notified: false, parent: false, reactions: new jl(), rejection: false, state: 0, value: void 0 });
}).prototype = Ol($l, "then", function(e9, t2) {
  var i2 = Jl(this), n2 = nu(Ul(this, Zl));
  return i2.parent = true, n2.ok = !Ll(e9) || e9, n2.fail = Ll(t2) && t2, n2.domain = Al ? iu.domain : void 0, 0 == i2.state ? i2.reactions.add(n2) : Vl(function() {
    cu(n2, i2);
  }), n2.promise;
}), vl = function() {
  var e9 = new Il(), t2 = Jl(e9);
  this.promise = e9, this.resolve = _u(fu, t2), this.reject = _u(Eu, t2);
}, Kl.f = nu = function(e9) {
  return e9 === Zl || void 0 === e9 ? new vl(e9) : ru(e9);
}), yl({ global: true, constructor: true, wrap: true, forced: ql }, { Promise: Zl }), Nl(Zl, Yl, false, true), Dl(Yl);
var mu = ht("iterator");
var Tu = false;
try {
  Su = 0, gu = { next: function() {
    return { done: !!Su++ };
  }, return: function() {
    Tu = true;
  } };
  gu[mu] = function() {
    return this;
  }, Array.from(gu, function() {
    throw 2;
  });
} catch (e9) {
}
var Su;
var gu;
var Ru = tl;
var Cu = function(e9, t2) {
  if (!t2 && !Tu) return false;
  var i2 = false;
  try {
    var n2 = {};
    n2[mu] = function() {
      return { next: function() {
        return { done: i2 = true };
      } };
    }, e9(n2);
  } catch (e10) {
  }
  return i2;
};
var Iu = Tl.CONSTRUCTOR || !Cu(function(e9) {
  Ru.all(e9).then(void 0, function() {
  });
});
var vu = L;
var yu = De;
var Au = Sl;
var bu = el;
var wu = Ts;
wi({ target: "Promise", stat: true, forced: Iu }, { all: function(e9) {
  var t2 = this, i2 = Au.f(t2), n2 = i2.resolve, r2 = i2.reject, o2 = bu(function() {
    var i3 = yu(t2.resolve), o3 = [], s2 = 0, a2 = 1;
    wu(e9, function(e10) {
      var c2 = s2++, d2 = false;
      a2++, vu(i3, t2, e10).then(function(e11) {
        d2 || (d2 = true, o3[c2] = e11, --a2 || n2(o3));
      }, r2);
    }), --a2 || n2(o3);
  });
  return o2.error && r2(o2.value), i2.promise;
} });
var Ou = wi;
var Nu = Tl.CONSTRUCTOR;
tl && tl.prototype, Ou({ target: "Promise", proto: true, forced: Nu, real: true }, { catch: function(e9) {
  return this.then(void 0, e9);
} });
var Du = L;
var Pu = De;
var Lu = Sl;
var ku = el;
var Mu = Ts;
wi({ target: "Promise", stat: true, forced: Iu }, { race: function(e9) {
  var t2 = this, i2 = Lu.f(t2), n2 = i2.reject, r2 = ku(function() {
    var r3 = Pu(t2.resolve);
    Mu(e9, function(e10) {
      Du(r3, t2, e10).then(i2.resolve, n2);
    });
  });
  return r2.error && n2(r2.value), i2.promise;
} });
var Uu = L;
var xu = Sl;
wi({ target: "Promise", stat: true, forced: Tl.CONSTRUCTOR }, { reject: function(e9) {
  var t2 = xu.f(this);
  return Uu(t2.reject, void 0, e9), t2.promise;
} });
var Vu = ii;
var Fu = te;
var Bu = Sl;
var ju = function(e9, t2) {
  if (Vu(e9), Fu(t2) && t2.constructor === e9) return t2;
  var i2 = Bu.f(e9);
  return (0, i2.resolve)(t2), i2.promise;
};
var Gu = wi;
var Wu = tl;
var Hu = Tl.CONSTRUCTOR;
var Ku = ju;
var Yu = ae("Promise");
var qu = !Hu;
Gu({ target: "Promise", stat: true, forced: true }, { resolve: function(e9) {
  return Ku(qu && this === Yu ? Wu : this, e9);
} });
var zu = L;
var Ju = De;
var Xu = Sl;
var Qu = el;
var Zu = Ts;
wi({ target: "Promise", stat: true, forced: Iu }, { allSettled: function(e9) {
  var t2 = this, i2 = Xu.f(t2), n2 = i2.resolve, r2 = i2.reject, o2 = Qu(function() {
    var i3 = Ju(t2.resolve), r3 = [], o3 = 0, s2 = 1;
    Zu(e9, function(e10) {
      var a2 = o3++, c2 = false;
      s2++, zu(i3, t2, e10).then(function(e11) {
        c2 || (c2 = true, r3[a2] = { status: "fulfilled", value: e11 }, --s2 || n2(r3));
      }, function(e11) {
        c2 || (c2 = true, r3[a2] = { status: "rejected", reason: e11 }, --s2 || n2(r3));
      });
    }), --s2 || n2(r3);
  });
  return o2.error && r2(o2.value), i2.promise;
} });
var $u = L;
var eh = De;
var th = ae;
var ih = Sl;
var nh = el;
var rh = Ts;
var oh = "No one promise resolved";
wi({ target: "Promise", stat: true, forced: Iu }, { any: function(e9) {
  var t2 = this, i2 = th("AggregateError"), n2 = ih.f(t2), r2 = n2.resolve, o2 = n2.reject, s2 = nh(function() {
    var n3 = eh(t2.resolve), s3 = [], a2 = 0, c2 = 1, d2 = false;
    rh(e9, function(e10) {
      var l2 = a2++, u2 = false;
      c2++, $u(n3, t2, e10).then(function(e11) {
        u2 || d2 || (d2 = true, r2(e11));
      }, function(e11) {
        u2 || d2 || (u2 = true, s3[l2] = e11, --c2 || o2(new i2(s3, oh)));
      });
    }), --c2 || o2(new i2(s3, oh));
  });
  return s2.error && o2(s2.value), n2.promise;
} });
var sh = wi;
var ah = tl;
var ch = n;
var dh = ae;
var lh = w;
var uh = Jc;
var hh = ju;
var ph = ah && ah.prototype;
sh({ target: "Promise", proto: true, real: true, forced: !!ah && ch(function() {
  ph.finally.call({ then: function() {
  } }, function() {
  });
}) }, { finally: function(e9) {
  var t2 = uh(this, dh("Promise")), i2 = lh(e9);
  return this.then(i2 ? function(i3) {
    return hh(t2, e9()).then(function() {
      return i3;
    });
  } : e9, i2 ? function(i3) {
    return hh(t2, e9()).then(function() {
      throw i3;
    });
  } : e9);
} });
var _h = d;
var Eh = Li;
var fh = fn;
var mh = J;
var Th = _h("".charAt);
var Sh = _h("".charCodeAt);
var gh = _h("".slice);
var Rh = function(e9) {
  return function(t2, i2) {
    var n2, r2, o2 = fh(mh(t2)), s2 = Eh(i2), a2 = o2.length;
    return s2 < 0 || s2 >= a2 ? e9 ? "" : void 0 : (n2 = Sh(o2, s2)) < 55296 || n2 > 56319 || s2 + 1 === a2 || (r2 = Sh(o2, s2 + 1)) < 56320 || r2 > 57343 ? e9 ? Th(o2, s2) : n2 : e9 ? gh(o2, s2, s2 + 2) : r2 - 56320 + (n2 - 55296 << 10) + 65536;
  };
};
var Ch = { codeAt: Rh(false), charAt: Rh(true) };
var Ih = Ch.charAt;
var vh = fn;
var yh = ra;
var Ah = tc;
var bh = ic;
var wh = "String Iterator";
var Oh = yh.set;
var Nh = yh.getterFor(wh);
Ah(String, "String", function(e9) {
  Oh(this, { type: wh, string: vh(e9), index: 0 });
}, function() {
  var e9, t2 = Nh(this), i2 = t2.string, n2 = t2.index;
  return n2 >= i2.length ? bh(void 0, true) : (e9 = Ih(i2, n2), t2.index += e9.length, bh(e9, false));
});
var Dh = ie.Promise;
var Ph = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
var Lh = h;
var kh = pn;
var Mh = fi;
var Uh = xo;
var xh = ht("toStringTag");
for (Vh in Ph) {
  Fh = Lh[Vh], Bh = Fh && Fh.prototype;
  Bh && kh(Bh) !== xh && Mh(Bh, xh, Vh), Uh[Vh] = Uh.Array;
}
var Fh;
var Bh;
var Vh;
var jh = Dh;
var Gh = i(jh);
var Wh = ir;
function Hh(e9, t2) {
  const i2 = e9 && e9.navigator;
  if (!i2.mediaDevices) return;
  const n2 = function(e10) {
    if ("object" != typeof e10 || e10.mandatory || e10.optional) return e10;
    const t3 = {};
    return Object.keys(e10).forEach((i3) => {
      if ("require" === i3 || "advanced" === i3 || "mediaSource" === i3) return;
      const n3 = "object" == typeof e10[i3] ? e10[i3] : { ideal: e10[i3] };
      void 0 !== n3.exact && "number" == typeof n3.exact && (n3.min = n3.max = n3.exact);
      const r3 = function(e11, t4) {
        return e11 ? e11 + t4.charAt(0).toUpperCase() + t4.slice(1) : "deviceId" === t4 ? "sourceId" : t4;
      };
      if (void 0 !== n3.ideal) {
        t3.optional = t3.optional || [];
        let e11 = {};
        "number" == typeof n3.ideal ? (e11[r3("min", i3)] = n3.ideal, t3.optional.push(e11), e11 = {}, e11[r3("max", i3)] = n3.ideal, t3.optional.push(e11)) : (e11[r3("", i3)] = n3.ideal, t3.optional.push(e11));
      }
      void 0 !== n3.exact && "number" != typeof n3.exact ? (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3("", i3)] = n3.exact) : ["min", "max"].forEach((e11) => {
        void 0 !== n3[e11] && (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3(e11, i3)] = n3[e11]);
      });
    }), e10.advanced && (t3.optional = (t3.optional || []).concat(e10.advanced)), t3;
  }, r2 = function(e10, r3) {
    if (t2.version >= 61) return r3(e10);
    if ((e10 = JSON.parse(JSON.stringify(e10))) && "object" == typeof e10.audio) {
      const t3 = function(e11, t4, i3) {
        t4 in e11 && !(i3 in e11) && (e11[i3] = e11[t4], delete e11[t4]);
      };
      t3((e10 = JSON.parse(JSON.stringify(e10))).audio, "autoGainControl", "googAutoGainControl"), t3(e10.audio, "noiseSuppression", "googNoiseSuppression"), e10.audio = n2(e10.audio);
    }
    if (e10 && "object" == typeof e10.video) {
      let o3 = e10.video.facingMode;
      o3 = o3 && ("object" == typeof o3 ? o3 : { ideal: o3 });
      const s2 = t2.version < 66;
      if (o3 && ("user" === o3.exact || "environment" === o3.exact || "user" === o3.ideal || "environment" === o3.ideal) && (!i2.mediaDevices.getSupportedConstraints || !i2.mediaDevices.getSupportedConstraints().facingMode || s2)) {
        let t3;
        if (delete e10.video.facingMode, "environment" === o3.exact || "environment" === o3.ideal ? t3 = ["back", "rear"] : "user" !== o3.exact && "user" !== o3.ideal || (t3 = ["front"]), t3) return i2.mediaDevices.enumerateDevices().then((i3) => {
          let s3 = (i3 = i3.filter((e11) => "videoinput" === e11.kind)).find((e11) => t3.some((t4) => {
            var i4;
            return Dn(i4 = e11.label.toLowerCase()).call(i4, t4);
          }));
          return !s3 && i3.length && Dn(t3).call(t3, "back") && (s3 = i3[i3.length - 1]), s3 && (e10.video.deviceId = o3.exact ? { exact: s3.deviceId } : { ideal: s3.deviceId }), e10.video = n2(e10.video), Wh("chrome: " + JSON.stringify(e10)), r3(e10);
        });
      }
      e10.video = n2(e10.video);
    }
    return Wh("chrome: " + JSON.stringify(e10)), r3(e10);
  }, o2 = function(e10) {
    return t2.version >= 64 ? e10 : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e10.name] || e10.name, message: e10.message, constraint: e10.constraint || e10.constraintName, toString() {
      return this.name + (this.message && ": ") + this.message;
    } };
  };
  if (i2.getUserMedia = (function(e10, t3, n3) {
    r2(e10, (e11) => {
      i2.webkitGetUserMedia(e11, t3, (e12) => {
        n3 && n3(o2(e12));
      });
    });
  }).bind(i2), i2.mediaDevices.getUserMedia) {
    const e10 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
    i2.mediaDevices.getUserMedia = function(t3) {
      return r2(t3, (t4) => e10(t4).then((e11) => {
        if (t4.audio && !e11.getAudioTracks().length || t4.video && !e11.getVideoTracks().length) throw e11.getTracks().forEach((e12) => {
          e12.stop();
        }), new DOMException("", "NotFoundError");
        return e11;
      }, (e11) => Gh.reject(o2(e11))));
    };
  }
}
function Kh(e9) {
  e9.MediaStream = e9.MediaStream || e9.webkitMediaStream;
}
function Yh(e9) {
  if ("object" == typeof e9 && e9.RTCPeerConnection && !("ontrack" in e9.RTCPeerConnection.prototype)) {
    Object.defineProperty(e9.RTCPeerConnection.prototype, "ontrack", { get() {
      return this._ontrack;
    }, set(e10) {
      this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e10);
    }, enumerable: true, configurable: true });
    const t2 = e9.RTCPeerConnection.prototype.setRemoteDescription;
    e9.RTCPeerConnection.prototype.setRemoteDescription = function() {
      return this._ontrackpoly || (this._ontrackpoly = (t3) => {
        t3.stream.addEventListener("addtrack", (i2) => {
          let n2;
          n2 = e9.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e10) => e10.track && e10.track.id === i2.track.id) : { track: i2.track };
          const r2 = new Event("track");
          r2.track = i2.track, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
        }), t3.stream.getTracks().forEach((i2) => {
          let n2;
          n2 = e9.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e10) => e10.track && e10.track.id === i2.id) : { track: i2 };
          const r2 = new Event("track");
          r2.track = i2, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
        });
      }, this.addEventListener("addstream", this._ontrackpoly)), t2.apply(this, arguments);
    };
  } else $n(e9, "track", (e10) => (e10.transceiver || Object.defineProperty(e10, "transceiver", { value: { receiver: e10.receiver } }), e10));
}
function qh(e9) {
  if ("object" == typeof e9 && e9.RTCPeerConnection && !("getSenders" in e9.RTCPeerConnection.prototype) && "createDTMFSender" in e9.RTCPeerConnection.prototype) {
    const t2 = function(e10, t3) {
      return { track: t3, get dtmf() {
        return void 0 === this._dtmf && ("audio" === t3.kind ? this._dtmf = e10.createDTMFSender(t3) : this._dtmf = null), this._dtmf;
      }, _pc: e10 };
    };
    if (!e9.RTCPeerConnection.prototype.getSenders) {
      e9.RTCPeerConnection.prototype.getSenders = function() {
        return this._senders = this._senders || [], this._senders.slice();
      };
      const i3 = e9.RTCPeerConnection.prototype.addTrack;
      e9.RTCPeerConnection.prototype.addTrack = function(e10, n4) {
        let r2 = i3.apply(this, arguments);
        return r2 || (r2 = t2(this, e10), this._senders.push(r2)), r2;
      };
      const n3 = e9.RTCPeerConnection.prototype.removeTrack;
      e9.RTCPeerConnection.prototype.removeTrack = function(e10) {
        n3.apply(this, arguments);
        const t3 = this._senders.indexOf(e10);
        -1 !== t3 && this._senders.splice(t3, 1);
      };
    }
    const i2 = e9.RTCPeerConnection.prototype.addStream;
    e9.RTCPeerConnection.prototype.addStream = function(e10) {
      this._senders = this._senders || [], i2.apply(this, [e10]), e10.getTracks().forEach((e11) => {
        this._senders.push(t2(this, e11));
      });
    };
    const n2 = e9.RTCPeerConnection.prototype.removeStream;
    e9.RTCPeerConnection.prototype.removeStream = function(e10) {
      this._senders = this._senders || [], n2.apply(this, [e10]), e10.getTracks().forEach((e11) => {
        const t3 = this._senders.find((t4) => t4.track === e11);
        t3 && this._senders.splice(this._senders.indexOf(t3), 1);
      });
    };
  } else if ("object" == typeof e9 && e9.RTCPeerConnection && "getSenders" in e9.RTCPeerConnection.prototype && "createDTMFSender" in e9.RTCPeerConnection.prototype && e9.RTCRtpSender && !("dtmf" in e9.RTCRtpSender.prototype)) {
    const t2 = e9.RTCPeerConnection.prototype.getSenders;
    e9.RTCPeerConnection.prototype.getSenders = function() {
      const e10 = t2.apply(this, []);
      return e10.forEach((e11) => e11._pc = this), e10;
    }, Object.defineProperty(e9.RTCRtpSender.prototype, "dtmf", { get() {
      return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
    } });
  }
}
function zh(e9) {
  if (!e9.RTCPeerConnection) return;
  const t2 = e9.RTCPeerConnection.prototype.getStats;
  e9.RTCPeerConnection.prototype.getStats = function() {
    const [e10, i2, n2] = arguments;
    if (arguments.length > 0 && "function" == typeof e10) return t2.apply(this, arguments);
    if (0 === t2.length && (0 === arguments.length || "function" != typeof e10)) return t2.apply(this, []);
    const r2 = function(e11) {
      const t3 = {};
      return e11.result().forEach((e12) => {
        const i3 = { id: e12.id, timestamp: e12.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e12.type] || e12.type };
        e12.names().forEach((t4) => {
          i3[t4] = e12.stat(t4);
        }), t3[i3.id] = i3;
      }), t3;
    }, o2 = function(e11) {
      return new Map(Object.keys(e11).map((t3) => [t3, e11[t3]]));
    };
    if (arguments.length >= 2) {
      const n3 = function(e11) {
        i2(o2(r2(e11)));
      };
      return t2.apply(this, [n3, e10]);
    }
    return new Gh((e11, i3) => {
      t2.apply(this, [function(t3) {
        e11(o2(r2(t3)));
      }, i3]);
    }).then(i2, n2);
  };
}
function Jh(e9) {
  if (!("object" == typeof e9 && e9.RTCPeerConnection && e9.RTCRtpSender && e9.RTCRtpReceiver)) return;
  if (!("getStats" in e9.RTCRtpSender.prototype)) {
    const t3 = e9.RTCPeerConnection.prototype.getSenders;
    t3 && (e9.RTCPeerConnection.prototype.getSenders = function() {
      const e10 = t3.apply(this, []);
      return e10.forEach((e11) => e11._pc = this), e10;
    });
    const i2 = e9.RTCPeerConnection.prototype.addTrack;
    i2 && (e9.RTCPeerConnection.prototype.addTrack = function() {
      const e10 = i2.apply(this, arguments);
      return e10._pc = this, e10;
    }), e9.RTCRtpSender.prototype.getStats = function() {
      const e10 = this;
      return this._pc.getStats().then((t4) => ar(t4, e10.track, true));
    };
  }
  if (!("getStats" in e9.RTCRtpReceiver.prototype)) {
    const t3 = e9.RTCPeerConnection.prototype.getReceivers;
    t3 && (e9.RTCPeerConnection.prototype.getReceivers = function() {
      const e10 = t3.apply(this, []);
      return e10.forEach((e11) => e11._pc = this), e10;
    }), $n(e9, "track", (e10) => (e10.receiver._pc = e10.srcElement, e10)), e9.RTCRtpReceiver.prototype.getStats = function() {
      const e10 = this;
      return this._pc.getStats().then((t4) => ar(t4, e10.track, false));
    };
  }
  if (!("getStats" in e9.RTCRtpSender.prototype) || !("getStats" in e9.RTCRtpReceiver.prototype)) return;
  const t2 = e9.RTCPeerConnection.prototype.getStats;
  e9.RTCPeerConnection.prototype.getStats = function() {
    if (arguments.length > 0 && arguments[0] instanceof e9.MediaStreamTrack) {
      const e10 = arguments[0];
      let t3, i2, n2;
      return this.getSenders().forEach((i3) => {
        i3.track === e10 && (t3 ? n2 = true : t3 = i3);
      }), this.getReceivers().forEach((t4) => (t4.track === e10 && (i2 ? n2 = true : i2 = t4), t4.track === e10)), n2 || t3 && i2 ? Gh.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t3 ? t3.getStats() : i2 ? i2.getStats() : Gh.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
    }
    return t2.apply(this, arguments);
  };
}
function Xh(e9) {
  e9.RTCPeerConnection.prototype.getLocalStreams = function() {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e10) => this._shimmedLocalStreams[e10][0]);
  };
  const t2 = e9.RTCPeerConnection.prototype.addTrack;
  e9.RTCPeerConnection.prototype.addTrack = function(e10, i3) {
    if (!i3) return t2.apply(this, arguments);
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const n3 = t2.apply(this, arguments);
    return this._shimmedLocalStreams[i3.id] ? -1 === this._shimmedLocalStreams[i3.id].indexOf(n3) && this._shimmedLocalStreams[i3.id].push(n3) : this._shimmedLocalStreams[i3.id] = [i3, n3], n3;
  };
  const i2 = e9.RTCPeerConnection.prototype.addStream;
  e9.RTCPeerConnection.prototype.addStream = function(e10) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e10.getTracks().forEach((e11) => {
      const t4 = this.getSenders().find((t5) => t5.track === e11);
      if (t4) throw new DOMException("Track already exists.", "InvalidAccessError");
    });
    const t3 = this.getSenders();
    i2.apply(this, arguments);
    const n3 = this.getSenders().filter((e11) => -1 === t3.indexOf(e11));
    this._shimmedLocalStreams[e10.id] = [e10].concat(n3);
  };
  const n2 = e9.RTCPeerConnection.prototype.removeStream;
  e9.RTCPeerConnection.prototype.removeStream = function(e10) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e10.id], n2.apply(this, arguments);
  };
  const r2 = e9.RTCPeerConnection.prototype.removeTrack;
  e9.RTCPeerConnection.prototype.removeTrack = function(e10) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e10 && Object.keys(this._shimmedLocalStreams).forEach((t3) => {
      const i3 = this._shimmedLocalStreams[t3].indexOf(e10);
      -1 !== i3 && this._shimmedLocalStreams[t3].splice(i3, 1), 1 === this._shimmedLocalStreams[t3].length && delete this._shimmedLocalStreams[t3];
    }), r2.apply(this, arguments);
  };
}
function Qh(e9, t2) {
  if (!e9.RTCPeerConnection) return;
  if (e9.RTCPeerConnection.prototype.addTrack && t2.version >= 65) return Xh(e9);
  const i2 = e9.RTCPeerConnection.prototype.getLocalStreams;
  e9.RTCPeerConnection.prototype.getLocalStreams = function() {
    const e10 = i2.apply(this);
    return this._reverseStreams = this._reverseStreams || {}, e10.map((e11) => this._reverseStreams[e11.id]);
  };
  const n2 = e9.RTCPeerConnection.prototype.addStream;
  e9.RTCPeerConnection.prototype.addStream = function(t3) {
    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t3.getTracks().forEach((e10) => {
      const t4 = this.getSenders().find((t5) => t5.track === e10);
      if (t4) throw new DOMException("Track already exists.", "InvalidAccessError");
    }), !this._reverseStreams[t3.id]) {
      const i3 = new e9.MediaStream(t3.getTracks());
      this._streams[t3.id] = i3, this._reverseStreams[i3.id] = t3, t3 = i3;
    }
    n2.apply(this, [t3]);
  };
  const r2 = e9.RTCPeerConnection.prototype.removeStream;
  function o2(e10, t3) {
    let i3 = t3.sdp;
    return Object.keys(e10._reverseStreams || []).forEach((t4) => {
      const n3 = e10._reverseStreams[t4], r3 = e10._streams[n3.id];
      i3 = i3.replace(new RegExp(r3.id, "g"), n3.id);
    }), new RTCSessionDescription({ type: t3.type, sdp: i3 });
  }
  e9.RTCPeerConnection.prototype.removeStream = function(e10) {
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r2.apply(this, [this._streams[e10.id] || e10]), delete this._reverseStreams[this._streams[e10.id] ? this._streams[e10.id].id : e10.id], delete this._streams[e10.id];
  }, e9.RTCPeerConnection.prototype.addTrack = function(t3, i3) {
    if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    const n3 = [].slice.call(arguments, 1);
    if (1 !== n3.length || !n3[0].getTracks().find((e10) => e10 === t3)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
    const r3 = this.getSenders().find((e10) => e10.track === t3);
    if (r3) throw new DOMException("Track already exists.", "InvalidAccessError");
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
    const o3 = this._streams[i3.id];
    if (o3) o3.addTrack(t3), Gh.resolve().then(() => {
      this.dispatchEvent(new Event("negotiationneeded"));
    });
    else {
      const n4 = new e9.MediaStream([t3]);
      this._streams[i3.id] = n4, this._reverseStreams[n4.id] = i3, this.addStream(n4);
    }
    return this.getSenders().find((e10) => e10.track === t3);
  }, ["createOffer", "createAnswer"].forEach(function(t3) {
    const i3 = e9.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
      const e10 = arguments;
      return arguments.length && "function" == typeof arguments[0] ? i3.apply(this, [(t4) => {
        const i4 = o2(this, t4);
        e10[0].apply(null, [i4]);
      }, (t4) => {
        e10[1] && e10[1].apply(null, t4);
      }, arguments[2]]) : i3.apply(this, arguments).then((e11) => o2(this, e11));
    } };
    e9.RTCPeerConnection.prototype[t3] = n3[t3];
  });
  const s2 = e9.RTCPeerConnection.prototype.setLocalDescription;
  e9.RTCPeerConnection.prototype.setLocalDescription = function() {
    return arguments.length && arguments[0].type ? (arguments[0] = function(e10, t3) {
      let i3 = t3.sdp;
      return Object.keys(e10._reverseStreams || []).forEach((t4) => {
        const n3 = e10._reverseStreams[t4], r3 = e10._streams[n3.id];
        i3 = i3.replace(new RegExp(n3.id, "g"), r3.id);
      }), new RTCSessionDescription({ type: t3.type, sdp: i3 });
    }(this, arguments[0]), s2.apply(this, arguments)) : s2.apply(this, arguments);
  };
  const a2 = Object.getOwnPropertyDescriptor(e9.RTCPeerConnection.prototype, "localDescription");
  Object.defineProperty(e9.RTCPeerConnection.prototype, "localDescription", { get() {
    const e10 = a2.get.apply(this);
    return "" === e10.type ? e10 : o2(this, e10);
  } }), e9.RTCPeerConnection.prototype.removeTrack = function(e10) {
    if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    if (!e10._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    if (!(e10._pc === this)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
    let t3;
    this._streams = this._streams || {}, Object.keys(this._streams).forEach((i3) => {
      this._streams[i3].getTracks().find((t4) => e10.track === t4) && (t3 = this._streams[i3]);
    }), t3 && (1 === t3.getTracks().length ? this.removeStream(this._reverseStreams[t3.id]) : t3.removeTrack(e10.track), this.dispatchEvent(new Event("negotiationneeded")));
  };
}
function Zh(e9, t2) {
  !e9.RTCPeerConnection && e9.webkitRTCPeerConnection && (e9.RTCPeerConnection = e9.webkitRTCPeerConnection), e9.RTCPeerConnection && t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
    const i2 = e9.RTCPeerConnection.prototype[t3], n2 = { [t3]() {
      return arguments[0] = new ("addIceCandidate" === t3 ? e9.RTCIceCandidate : e9.RTCSessionDescription)(arguments[0]), i2.apply(this, arguments);
    } };
    e9.RTCPeerConnection.prototype[t3] = n2[t3];
  });
}
function $h(e9, t2) {
  $n(e9, "negotiationneeded", (e10) => {
    const i2 = e10.target;
    if (!(t2.version < 72 || i2.getConfiguration && "plan-b" === i2.getConfiguration().sdpSemantics) || "stable" === i2.signalingState) return e10;
  });
}
var ep = Object.freeze({ __proto__: null, fixNegotiationNeeded: $h, shimAddTrackRemoveTrack: Qh, shimAddTrackRemoveTrackWithNative: Xh, shimGetDisplayMedia: function(e9, t2) {
  e9.navigator.mediaDevices && "getDisplayMedia" in e9.navigator.mediaDevices || e9.navigator.mediaDevices && ("function" == typeof t2 ? e9.navigator.mediaDevices.getDisplayMedia = function(i2) {
    return t2(i2).then((t3) => {
      const n2 = i2.video && i2.video.width, r2 = i2.video && i2.video.height, o2 = i2.video && i2.video.frameRate;
      return i2.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t3, maxFrameRate: o2 || 3 } }, n2 && (i2.video.mandatory.maxWidth = n2), r2 && (i2.video.mandatory.maxHeight = r2), e9.navigator.mediaDevices.getUserMedia(i2);
    });
  } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
}, shimGetSendersWithDtmf: qh, shimGetStats: zh, shimGetUserMedia: Hh, shimMediaStream: Kh, shimOnTrack: Yh, shimPeerConnection: Zh, shimSenderReceiverGetStats: Jh });
function tp(e9, t2) {
  const i2 = e9 && e9.navigator, n2 = e9 && e9.MediaStreamTrack;
  if (i2.getUserMedia = function(e10, t3, n3) {
    nr("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i2.mediaDevices.getUserMedia(e10).then(t3, n3);
  }, !(t2.version > 55 && "autoGainControl" in i2.mediaDevices.getSupportedConstraints())) {
    const e10 = function(e11, t4, i3) {
      t4 in e11 && !(i3 in e11) && (e11[i3] = e11[t4], delete e11[t4]);
    }, t3 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
    if (i2.mediaDevices.getUserMedia = function(i3) {
      return "object" == typeof i3 && "object" == typeof i3.audio && (i3 = JSON.parse(JSON.stringify(i3)), e10(i3.audio, "autoGainControl", "mozAutoGainControl"), e10(i3.audio, "noiseSuppression", "mozNoiseSuppression")), t3(i3);
    }, n2 && n2.prototype.getSettings) {
      const t4 = n2.prototype.getSettings;
      n2.prototype.getSettings = function() {
        const i3 = t4.apply(this, arguments);
        return e10(i3, "mozAutoGainControl", "autoGainControl"), e10(i3, "mozNoiseSuppression", "noiseSuppression"), i3;
      };
    }
    if (n2 && n2.prototype.applyConstraints) {
      const t4 = n2.prototype.applyConstraints;
      n2.prototype.applyConstraints = function(i3) {
        return "audio" === this.kind && "object" == typeof i3 && (i3 = JSON.parse(JSON.stringify(i3)), e10(i3, "autoGainControl", "mozAutoGainControl"), e10(i3, "noiseSuppression", "mozNoiseSuppression")), t4.apply(this, [i3]);
      };
    }
  }
}
function ip(e9) {
  "object" == typeof e9 && e9.RTCTrackEvent && "receiver" in e9.RTCTrackEvent.prototype && !("transceiver" in e9.RTCTrackEvent.prototype) && Object.defineProperty(e9.RTCTrackEvent.prototype, "transceiver", { get() {
    return { receiver: this.receiver };
  } });
}
function np(e9, t2) {
  if ("object" != typeof e9 || !e9.RTCPeerConnection && !e9.mozRTCPeerConnection) return;
  !e9.RTCPeerConnection && e9.mozRTCPeerConnection && (e9.RTCPeerConnection = e9.mozRTCPeerConnection), t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
    const i3 = e9.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
      return arguments[0] = new ("addIceCandidate" === t3 ? e9.RTCIceCandidate : e9.RTCSessionDescription)(arguments[0]), i3.apply(this, arguments);
    } };
    e9.RTCPeerConnection.prototype[t3] = n3[t3];
  });
  const i2 = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n2 = e9.RTCPeerConnection.prototype.getStats;
  e9.RTCPeerConnection.prototype.getStats = function() {
    const [e10, r2, o2] = arguments;
    return n2.apply(this, [e10 || null]).then((e11) => {
      if (t2.version < 53 && !r2) try {
        e11.forEach((e12) => {
          e12.type = i2[e12.type] || e12.type;
        });
      } catch (t3) {
        if ("TypeError" !== t3.name) throw t3;
        e11.forEach((t4, n3) => {
          e11.set(n3, Object.assign({}, t4, { type: i2[t4.type] || t4.type }));
        });
      }
      return e11;
    }).then(r2, o2);
  };
}
function rp(e9) {
  if ("object" != typeof e9 || !e9.RTCPeerConnection || !e9.RTCRtpSender) return;
  if (e9.RTCRtpSender && "getStats" in e9.RTCRtpSender.prototype) return;
  const t2 = e9.RTCPeerConnection.prototype.getSenders;
  t2 && (e9.RTCPeerConnection.prototype.getSenders = function() {
    const e10 = t2.apply(this, []);
    return e10.forEach((e11) => e11._pc = this), e10;
  });
  const i2 = e9.RTCPeerConnection.prototype.addTrack;
  i2 && (e9.RTCPeerConnection.prototype.addTrack = function() {
    const e10 = i2.apply(this, arguments);
    return e10._pc = this, e10;
  }), e9.RTCRtpSender.prototype.getStats = function() {
    return this.track ? this._pc.getStats(this.track) : Gh.resolve(/* @__PURE__ */ new Map());
  };
}
function op(e9) {
  if ("object" != typeof e9 || !e9.RTCPeerConnection || !e9.RTCRtpSender) return;
  if (e9.RTCRtpSender && "getStats" in e9.RTCRtpReceiver.prototype) return;
  const t2 = e9.RTCPeerConnection.prototype.getReceivers;
  t2 && (e9.RTCPeerConnection.prototype.getReceivers = function() {
    const e10 = t2.apply(this, []);
    return e10.forEach((e11) => e11._pc = this), e10;
  }), $n(e9, "track", (e10) => (e10.receiver._pc = e10.srcElement, e10)), e9.RTCRtpReceiver.prototype.getStats = function() {
    return this._pc.getStats(this.track);
  };
}
function sp(e9) {
  e9.RTCPeerConnection && !("removeStream" in e9.RTCPeerConnection.prototype) && (e9.RTCPeerConnection.prototype.removeStream = function(e10) {
    nr("removeStream", "removeTrack"), this.getSenders().forEach((t2) => {
      var i2;
      t2.track && Dn(i2 = e10.getTracks()).call(i2, t2.track) && this.removeTrack(t2);
    });
  });
}
function ap(e9) {
  e9.DataChannel && !e9.RTCDataChannel && (e9.RTCDataChannel = e9.DataChannel);
}
function cp(e9) {
  if ("object" != typeof e9 || !e9.RTCPeerConnection) return;
  const t2 = e9.RTCPeerConnection.prototype.addTransceiver;
  t2 && (e9.RTCPeerConnection.prototype.addTransceiver = function() {
    this.setParametersPromises = [];
    let e10 = arguments[1] && arguments[1].sendEncodings;
    void 0 === e10 && (e10 = []), e10 = [...e10];
    const i2 = e10.length > 0;
    i2 && e10.forEach((e11) => {
      if ("rid" in e11) {
        if (!/^[a-z0-9]{0,16}$/i.test(e11.rid)) throw new TypeError("Invalid RID value provided.");
      }
      if ("scaleResolutionDownBy" in e11 && !(parseFloat(e11.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
      if ("maxFramerate" in e11 && !(parseFloat(e11.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0");
    });
    const n2 = t2.apply(this, arguments);
    if (i2) {
      const { sender: t3 } = n2, i3 = t3.getParameters();
      (!("encodings" in i3) || 1 === i3.encodings.length && 0 === Object.keys(i3.encodings[0]).length) && (i3.encodings = e10, t3.sendEncodings = e10, this.setParametersPromises.push(t3.setParameters(i3).then(() => {
        delete t3.sendEncodings;
      }).catch(() => {
        delete t3.sendEncodings;
      })));
    }
    return n2;
  });
}
function dp(e9) {
  if ("object" != typeof e9 || !e9.RTCRtpSender) return;
  const t2 = e9.RTCRtpSender.prototype.getParameters;
  t2 && (e9.RTCRtpSender.prototype.getParameters = function() {
    const e10 = t2.apply(this, arguments);
    return "encodings" in e10 || (e10.encodings = [].concat(this.sendEncodings || [{}])), e10;
  });
}
function lp(e9) {
  if ("object" != typeof e9 || !e9.RTCPeerConnection) return;
  const t2 = e9.RTCPeerConnection.prototype.createOffer;
  e9.RTCPeerConnection.prototype.createOffer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Gh.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : t2.apply(this, arguments);
  };
}
function up(e9) {
  if ("object" != typeof e9 || !e9.RTCPeerConnection) return;
  const t2 = e9.RTCPeerConnection.prototype.createAnswer;
  e9.RTCPeerConnection.prototype.createAnswer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Gh.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : t2.apply(this, arguments);
  };
}
var hp = Object.freeze({ __proto__: null, shimAddTransceiver: cp, shimCreateAnswer: up, shimCreateOffer: lp, shimGetDisplayMedia: function(e9, t2) {
  e9.navigator.mediaDevices && "getDisplayMedia" in e9.navigator.mediaDevices || e9.navigator.mediaDevices && (e9.navigator.mediaDevices.getDisplayMedia = function(i2) {
    if (!i2 || !i2.video) {
      const e10 = new DOMException("getDisplayMedia without video constraints is undefined");
      return e10.name = "NotFoundError", e10.code = 8, Gh.reject(e10);
    }
    return true === i2.video ? i2.video = { mediaSource: t2 } : i2.video.mediaSource = t2, e9.navigator.mediaDevices.getUserMedia(i2);
  });
}, shimGetParameters: dp, shimGetUserMedia: tp, shimOnTrack: ip, shimPeerConnection: np, shimRTCDataChannel: ap, shimReceiverGetStats: op, shimRemoveStream: sp, shimSenderGetStats: rp });
function pp(e9) {
  if ("object" == typeof e9 && e9.RTCPeerConnection) {
    if ("getLocalStreams" in e9.RTCPeerConnection.prototype || (e9.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this._localStreams || (this._localStreams = []), this._localStreams;
    }), !("addStream" in e9.RTCPeerConnection.prototype)) {
      const t2 = e9.RTCPeerConnection.prototype.addTrack;
      e9.RTCPeerConnection.prototype.addStream = function(e10) {
        var i2;
        this._localStreams || (this._localStreams = []), Dn(i2 = this._localStreams).call(i2, e10) || this._localStreams.push(e10), e10.getAudioTracks().forEach((i3) => t2.call(this, i3, e10)), e10.getVideoTracks().forEach((i3) => t2.call(this, i3, e10));
      }, e9.RTCPeerConnection.prototype.addTrack = function(e10) {
        for (var i2 = arguments.length, n2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) n2[r2 - 1] = arguments[r2];
        return n2 && n2.forEach((e11) => {
          var t3;
          this._localStreams ? Dn(t3 = this._localStreams).call(t3, e11) || this._localStreams.push(e11) : this._localStreams = [e11];
        }), t2.apply(this, arguments);
      };
    }
    "removeStream" in e9.RTCPeerConnection.prototype || (e9.RTCPeerConnection.prototype.removeStream = function(e10) {
      this._localStreams || (this._localStreams = []);
      const t2 = this._localStreams.indexOf(e10);
      if (-1 === t2) return;
      this._localStreams.splice(t2, 1);
      const i2 = e10.getTracks();
      this.getSenders().forEach((e11) => {
        Dn(i2).call(i2, e11.track) && this.removeTrack(e11);
      });
    });
  }
}
function _p(e9) {
  if ("object" == typeof e9 && e9.RTCPeerConnection && ("getRemoteStreams" in e9.RTCPeerConnection.prototype || (e9.RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this._remoteStreams ? this._remoteStreams : [];
  }), !("onaddstream" in e9.RTCPeerConnection.prototype))) {
    Object.defineProperty(e9.RTCPeerConnection.prototype, "onaddstream", { get() {
      return this._onaddstream;
    }, set(e10) {
      this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e10), this.addEventListener("track", this._onaddstreampoly = (e11) => {
        e11.streams.forEach((e12) => {
          var t3;
          if (this._remoteStreams || (this._remoteStreams = []), Dn(t3 = this._remoteStreams).call(t3, e12)) return;
          this._remoteStreams.push(e12);
          const i2 = new Event("addstream");
          i2.stream = e12, this.dispatchEvent(i2);
        });
      });
    } });
    const t2 = e9.RTCPeerConnection.prototype.setRemoteDescription;
    e9.RTCPeerConnection.prototype.setRemoteDescription = function() {
      const e10 = this;
      return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t3) {
        t3.streams.forEach((t4) => {
          if (e10._remoteStreams || (e10._remoteStreams = []), e10._remoteStreams.indexOf(t4) >= 0) return;
          e10._remoteStreams.push(t4);
          const i2 = new Event("addstream");
          i2.stream = t4, e10.dispatchEvent(i2);
        });
      }), t2.apply(e10, arguments);
    };
  }
}
function Ep(e9) {
  if ("object" != typeof e9 || !e9.RTCPeerConnection) return;
  const t2 = e9.RTCPeerConnection.prototype, i2 = t2.createOffer, n2 = t2.createAnswer, r2 = t2.setLocalDescription, o2 = t2.setRemoteDescription, s2 = t2.addIceCandidate;
  t2.createOffer = function(e10, t3) {
    const n3 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = i2.apply(this, [n3]);
    return t3 ? (r3.then(e10, t3), Gh.resolve()) : r3;
  }, t2.createAnswer = function(e10, t3) {
    const i3 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = n2.apply(this, [i3]);
    return t3 ? (r3.then(e10, t3), Gh.resolve()) : r3;
  };
  let a2 = function(e10, t3, i3) {
    const n3 = r2.apply(this, [e10]);
    return i3 ? (n3.then(t3, i3), Gh.resolve()) : n3;
  };
  t2.setLocalDescription = a2, a2 = function(e10, t3, i3) {
    const n3 = o2.apply(this, [e10]);
    return i3 ? (n3.then(t3, i3), Gh.resolve()) : n3;
  }, t2.setRemoteDescription = a2, a2 = function(e10, t3, i3) {
    const n3 = s2.apply(this, [e10]);
    return i3 ? (n3.then(t3, i3), Gh.resolve()) : n3;
  }, t2.addIceCandidate = a2;
}
function fp(e9) {
  const t2 = e9 && e9.navigator;
  if (t2.mediaDevices && t2.mediaDevices.getUserMedia) {
    const e10 = t2.mediaDevices, i2 = e10.getUserMedia.bind(e10);
    t2.mediaDevices.getUserMedia = (e11) => i2(mp(e11));
  }
  !t2.getUserMedia && t2.mediaDevices && t2.mediaDevices.getUserMedia && (t2.getUserMedia = (function(e10, i2, n2) {
    t2.mediaDevices.getUserMedia(e10).then(i2, n2);
  }).bind(t2));
}
function mp(e9) {
  return e9 && void 0 !== e9.video ? Object.assign({}, e9, { video: or(e9.video) }) : e9;
}
function Tp(e9) {
  if (!e9.RTCPeerConnection) return;
  const t2 = e9.RTCPeerConnection;
  e9.RTCPeerConnection = function(e10, i2) {
    if (e10 && e10.iceServers) {
      const t3 = [];
      for (let i3 = 0; i3 < e10.iceServers.length; i3++) {
        let n2 = e10.iceServers[i3];
        !n2.hasOwnProperty("urls") && n2.hasOwnProperty("url") ? (nr("RTCIceServer.url", "RTCIceServer.urls"), n2 = JSON.parse(JSON.stringify(n2)), n2.urls = n2.url, delete n2.url, t3.push(n2)) : t3.push(e10.iceServers[i3]);
      }
      e10.iceServers = t3;
    }
    return new t2(e10, i2);
  }, e9.RTCPeerConnection.prototype = t2.prototype, "generateCertificate" in t2 && Object.defineProperty(e9.RTCPeerConnection, "generateCertificate", { get: () => t2.generateCertificate });
}
function Sp(e9) {
  "object" == typeof e9 && e9.RTCTrackEvent && "receiver" in e9.RTCTrackEvent.prototype && !("transceiver" in e9.RTCTrackEvent.prototype) && Object.defineProperty(e9.RTCTrackEvent.prototype, "transceiver", { get() {
    return { receiver: this.receiver };
  } });
}
function gp(e9) {
  const t2 = e9.RTCPeerConnection.prototype.createOffer;
  e9.RTCPeerConnection.prototype.createOffer = function(e10) {
    if (e10) {
      void 0 !== e10.offerToReceiveAudio && (e10.offerToReceiveAudio = !!e10.offerToReceiveAudio);
      const t3 = this.getTransceivers().find((e11) => "audio" === e11.receiver.track.kind);
      false === e10.offerToReceiveAudio && t3 ? "sendrecv" === t3.direction ? t3.setDirection ? t3.setDirection("sendonly") : t3.direction = "sendonly" : "recvonly" === t3.direction && (t3.setDirection ? t3.setDirection("inactive") : t3.direction = "inactive") : true !== e10.offerToReceiveAudio || t3 || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e10.offerToReceiveVideo && (e10.offerToReceiveVideo = !!e10.offerToReceiveVideo);
      const i2 = this.getTransceivers().find((e11) => "video" === e11.receiver.track.kind);
      false === e10.offerToReceiveVideo && i2 ? "sendrecv" === i2.direction ? i2.setDirection ? i2.setDirection("sendonly") : i2.direction = "sendonly" : "recvonly" === i2.direction && (i2.setDirection ? i2.setDirection("inactive") : i2.direction = "inactive") : true !== e10.offerToReceiveVideo || i2 || this.addTransceiver("video", { direction: "recvonly" });
    }
    return t2.apply(this, arguments);
  };
}
function Rp(e9) {
  "object" != typeof e9 || e9.AudioContext || (e9.AudioContext = e9.webkitAudioContext);
}
var Cp = Object.freeze({ __proto__: null, shimAudioContext: Rp, shimCallbacksAPI: Ep, shimConstraints: mp, shimCreateOfferLegacy: gp, shimGetUserMedia: fp, shimLocalStreamsAPI: pp, shimRTCIceServerUrls: Tp, shimRemoteStreamsAPI: _p, shimTrackEventTransceiver: Sp });
var Ip = "	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF";
var vp = J;
var yp = fn;
var Ap = Ip;
var bp = d("".replace);
var wp = RegExp("^[" + Ap + "]+");
var Op = RegExp("(^|[^" + Ap + "])[" + Ap + "]+$");
var Np = function(e9) {
  return function(t2) {
    var i2 = yp(vp(t2));
    return 1 & e9 && (i2 = bp(i2, wp, "")), 2 & e9 && (i2 = bp(i2, Op, "$1")), i2;
  };
};
var Dp = { start: Np(1), end: Np(2), trim: Np(3) };
var Pp = la.PROPER;
var Lp = n;
var kp = Ip;
var Mp = Dp.trim;
wi({ target: "String", proto: true, forced: function(e9) {
  return Lp(function() {
    return !!kp[e9]() || "âÂá " !== "âÂá "[e9]() || Pp && kp[e9].name !== e9;
  });
}("trim") }, { trim: function() {
  return Mp(this);
} });
var Up = Xi("String").trim;
var xp = l;
var Vp = Up;
var Fp = String.prototype;
var Bp = function(e9) {
  var t2 = e9.trim;
  return "string" == typeof e9 || e9 === Fp || xp(Fp, e9) && t2 === Fp.trim ? Vp : t2;
};
var jp = i(Bp);
var Gp = { exports: {} };
!function(e9) {
  const t2 = { generateIdentifier: function() {
    return Math.random().toString(36).substring(2, 12);
  } };
  t2.localCName = t2.generateIdentifier(), t2.splitLines = function(e10) {
    return e10.trim().split("\n").map((e11) => e11.trim());
  }, t2.splitSections = function(e10) {
    return e10.split("\nm=").map((e11, t3) => (t3 > 0 ? "m=" + e11 : e11).trim() + "\r\n");
  }, t2.getDescription = function(e10) {
    const i2 = t2.splitSections(e10);
    return i2 && i2[0];
  }, t2.getMediaSections = function(e10) {
    const i2 = t2.splitSections(e10);
    return i2.shift(), i2;
  }, t2.matchPrefix = function(e10, i2) {
    return t2.splitLines(e10).filter((e11) => 0 === e11.indexOf(i2));
  }, t2.parseCandidate = function(e10) {
    let t3;
    t3 = 0 === e10.indexOf("a=candidate:") ? e10.substring(12).split(" ") : e10.substring(10).split(" ");
    const i2 = { foundation: t3[0], component: { 1: "rtp", 2: "rtcp" }[t3[1]] || t3[1], protocol: t3[2].toLowerCase(), priority: parseInt(t3[3], 10), ip: t3[4], address: t3[4], port: parseInt(t3[5], 10), type: t3[7] };
    for (let e11 = 8; e11 < t3.length; e11 += 2) switch (t3[e11]) {
      case "raddr":
        i2.relatedAddress = t3[e11 + 1];
        break;
      case "rport":
        i2.relatedPort = parseInt(t3[e11 + 1], 10);
        break;
      case "tcptype":
        i2.tcpType = t3[e11 + 1];
        break;
      case "ufrag":
        i2.ufrag = t3[e11 + 1], i2.usernameFragment = t3[e11 + 1];
        break;
      default:
        void 0 === i2[t3[e11]] && (i2[t3[e11]] = t3[e11 + 1]);
    }
    return i2;
  }, t2.writeCandidate = function(e10) {
    const t3 = [];
    t3.push(e10.foundation);
    const i2 = e10.component;
    "rtp" === i2 ? t3.push(1) : "rtcp" === i2 ? t3.push(2) : t3.push(i2), t3.push(e10.protocol.toUpperCase()), t3.push(e10.priority), t3.push(e10.address || e10.ip), t3.push(e10.port);
    const n2 = e10.type;
    return t3.push("typ"), t3.push(n2), "host" !== n2 && e10.relatedAddress && e10.relatedPort && (t3.push("raddr"), t3.push(e10.relatedAddress), t3.push("rport"), t3.push(e10.relatedPort)), e10.tcpType && "tcp" === e10.protocol.toLowerCase() && (t3.push("tcptype"), t3.push(e10.tcpType)), (e10.usernameFragment || e10.ufrag) && (t3.push("ufrag"), t3.push(e10.usernameFragment || e10.ufrag)), "candidate:" + t3.join(" ");
  }, t2.parseIceOptions = function(e10) {
    return e10.substring(14).split(" ");
  }, t2.parseRtpMap = function(e10) {
    let t3 = e10.substring(9).split(" ");
    const i2 = { payloadType: parseInt(t3.shift(), 10) };
    return t3 = t3[0].split("/"), i2.name = t3[0], i2.clockRate = parseInt(t3[1], 10), i2.channels = 3 === t3.length ? parseInt(t3[2], 10) : 1, i2.numChannels = i2.channels, i2;
  }, t2.writeRtpMap = function(e10) {
    let t3 = e10.payloadType;
    void 0 !== e10.preferredPayloadType && (t3 = e10.preferredPayloadType);
    const i2 = e10.channels || e10.numChannels || 1;
    return "a=rtpmap:" + t3 + " " + e10.name + "/" + e10.clockRate + (1 !== i2 ? "/" + i2 : "") + "\r\n";
  }, t2.parseExtmap = function(e10) {
    const t3 = e10.substring(9).split(" ");
    return { id: parseInt(t3[0], 10), direction: t3[0].indexOf("/") > 0 ? t3[0].split("/")[1] : "sendrecv", uri: t3[1], attributes: t3.slice(2).join(" ") };
  }, t2.writeExtmap = function(e10) {
    return "a=extmap:" + (e10.id || e10.preferredId) + (e10.direction && "sendrecv" !== e10.direction ? "/" + e10.direction : "") + " " + e10.uri + (e10.attributes ? " " + e10.attributes : "") + "\r\n";
  }, t2.parseFmtp = function(e10) {
    const t3 = {};
    let i2;
    const n2 = e10.substring(e10.indexOf(" ") + 1).split(";");
    for (let e11 = 0; e11 < n2.length; e11++) i2 = n2[e11].trim().split("="), t3[i2[0].trim()] = i2[1];
    return t3;
  }, t2.writeFmtp = function(e10) {
    let t3 = "", i2 = e10.payloadType;
    if (void 0 !== e10.preferredPayloadType && (i2 = e10.preferredPayloadType), e10.parameters && Object.keys(e10.parameters).length) {
      const n2 = [];
      Object.keys(e10.parameters).forEach((t4) => {
        void 0 !== e10.parameters[t4] ? n2.push(t4 + "=" + e10.parameters[t4]) : n2.push(t4);
      }), t3 += "a=fmtp:" + i2 + " " + n2.join(";") + "\r\n";
    }
    return t3;
  }, t2.parseRtcpFb = function(e10) {
    const t3 = e10.substring(e10.indexOf(" ") + 1).split(" ");
    return { type: t3.shift(), parameter: t3.join(" ") };
  }, t2.writeRtcpFb = function(e10) {
    let t3 = "", i2 = e10.payloadType;
    return void 0 !== e10.preferredPayloadType && (i2 = e10.preferredPayloadType), e10.rtcpFeedback && e10.rtcpFeedback.length && e10.rtcpFeedback.forEach((e11) => {
      t3 += "a=rtcp-fb:" + i2 + " " + e11.type + (e11.parameter && e11.parameter.length ? " " + e11.parameter : "") + "\r\n";
    }), t3;
  }, t2.parseSsrcMedia = function(e10) {
    const t3 = e10.indexOf(" "), i2 = { ssrc: parseInt(e10.substring(7, t3), 10) }, n2 = e10.indexOf(":", t3);
    return n2 > -1 ? (i2.attribute = e10.substring(t3 + 1, n2), i2.value = e10.substring(n2 + 1)) : i2.attribute = e10.substring(t3 + 1), i2;
  }, t2.parseSsrcGroup = function(e10) {
    const t3 = e10.substring(13).split(" ");
    return { semantics: t3.shift(), ssrcs: t3.map((e11) => parseInt(e11, 10)) };
  }, t2.getMid = function(e10) {
    const i2 = t2.matchPrefix(e10, "a=mid:")[0];
    if (i2) return i2.substring(6);
  }, t2.parseFingerprint = function(e10) {
    const t3 = e10.substring(14).split(" ");
    return { algorithm: t3[0].toLowerCase(), value: t3[1].toUpperCase() };
  }, t2.getDtlsParameters = function(e10, i2) {
    return { role: "auto", fingerprints: t2.matchPrefix(e10 + i2, "a=fingerprint:").map(t2.parseFingerprint) };
  }, t2.writeDtlsParameters = function(e10, t3) {
    let i2 = "a=setup:" + t3 + "\r\n";
    return e10.fingerprints.forEach((e11) => {
      i2 += "a=fingerprint:" + e11.algorithm + " " + e11.value + "\r\n";
    }), i2;
  }, t2.parseCryptoLine = function(e10) {
    const t3 = e10.substring(9).split(" ");
    return { tag: parseInt(t3[0], 10), cryptoSuite: t3[1], keyParams: t3[2], sessionParams: t3.slice(3) };
  }, t2.writeCryptoLine = function(e10) {
    return "a=crypto:" + e10.tag + " " + e10.cryptoSuite + " " + ("object" == typeof e10.keyParams ? t2.writeCryptoKeyParams(e10.keyParams) : e10.keyParams) + (e10.sessionParams ? " " + e10.sessionParams.join(" ") : "") + "\r\n";
  }, t2.parseCryptoKeyParams = function(e10) {
    if (0 !== e10.indexOf("inline:")) return null;
    const t3 = e10.substring(7).split("|");
    return { keyMethod: "inline", keySalt: t3[0], lifeTime: t3[1], mkiValue: t3[2] ? t3[2].split(":")[0] : void 0, mkiLength: t3[2] ? t3[2].split(":")[1] : void 0 };
  }, t2.writeCryptoKeyParams = function(e10) {
    return e10.keyMethod + ":" + e10.keySalt + (e10.lifeTime ? "|" + e10.lifeTime : "") + (e10.mkiValue && e10.mkiLength ? "|" + e10.mkiValue + ":" + e10.mkiLength : "");
  }, t2.getCryptoParameters = function(e10, i2) {
    return t2.matchPrefix(e10 + i2, "a=crypto:").map(t2.parseCryptoLine);
  }, t2.getIceParameters = function(e10, i2) {
    const n2 = t2.matchPrefix(e10 + i2, "a=ice-ufrag:")[0], r2 = t2.matchPrefix(e10 + i2, "a=ice-pwd:")[0];
    return n2 && r2 ? { usernameFragment: n2.substring(12), password: r2.substring(10) } : null;
  }, t2.writeIceParameters = function(e10) {
    let t3 = "a=ice-ufrag:" + e10.usernameFragment + "\r\na=ice-pwd:" + e10.password + "\r\n";
    return e10.iceLite && (t3 += "a=ice-lite\r\n"), t3;
  }, t2.parseRtpParameters = function(e10) {
    const i2 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, n2 = t2.splitLines(e10)[0].split(" ");
    i2.profile = n2[2];
    for (let r3 = 3; r3 < n2.length; r3++) {
      const o2 = n2[r3], s2 = t2.matchPrefix(e10, "a=rtpmap:" + o2 + " ")[0];
      if (s2) {
        const n3 = t2.parseRtpMap(s2), r4 = t2.matchPrefix(e10, "a=fmtp:" + o2 + " ");
        switch (n3.parameters = r4.length ? t2.parseFmtp(r4[0]) : {}, n3.rtcpFeedback = t2.matchPrefix(e10, "a=rtcp-fb:" + o2 + " ").map(t2.parseRtcpFb), i2.codecs.push(n3), n3.name.toUpperCase()) {
          case "RED":
          case "ULPFEC":
            i2.fecMechanisms.push(n3.name.toUpperCase());
        }
      }
    }
    t2.matchPrefix(e10, "a=extmap:").forEach((e11) => {
      i2.headerExtensions.push(t2.parseExtmap(e11));
    });
    const r2 = t2.matchPrefix(e10, "a=rtcp-fb:* ").map(t2.parseRtcpFb);
    return i2.codecs.forEach((e11) => {
      r2.forEach((t3) => {
        e11.rtcpFeedback.find((e12) => e12.type === t3.type && e12.parameter === t3.parameter) || e11.rtcpFeedback.push(t3);
      });
    }), i2;
  }, t2.writeRtpDescription = function(e10, i2) {
    let n2 = "";
    n2 += "m=" + e10 + " ", n2 += i2.codecs.length > 0 ? "9" : "0", n2 += " " + (i2.profile || "UDP/TLS/RTP/SAVPF") + " ", n2 += i2.codecs.map((e11) => void 0 !== e11.preferredPayloadType ? e11.preferredPayloadType : e11.payloadType).join(" ") + "\r\n", n2 += "c=IN IP4 0.0.0.0\r\n", n2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", i2.codecs.forEach((e11) => {
      n2 += t2.writeRtpMap(e11), n2 += t2.writeFmtp(e11), n2 += t2.writeRtcpFb(e11);
    });
    let r2 = 0;
    return i2.codecs.forEach((e11) => {
      e11.maxptime > r2 && (r2 = e11.maxptime);
    }), r2 > 0 && (n2 += "a=maxptime:" + r2 + "\r\n"), i2.headerExtensions && i2.headerExtensions.forEach((e11) => {
      n2 += t2.writeExtmap(e11);
    }), n2;
  }, t2.parseRtpEncodingParameters = function(e10) {
    const i2 = [], n2 = t2.parseRtpParameters(e10), r2 = -1 !== n2.fecMechanisms.indexOf("RED"), o2 = -1 !== n2.fecMechanisms.indexOf("ULPFEC"), s2 = t2.matchPrefix(e10, "a=ssrc:").map((e11) => t2.parseSsrcMedia(e11)).filter((e11) => "cname" === e11.attribute), a2 = s2.length > 0 && s2[0].ssrc;
    let c2;
    const d2 = t2.matchPrefix(e10, "a=ssrc-group:FID").map((e11) => e11.substring(17).split(" ").map((e12) => parseInt(e12, 10)));
    d2.length > 0 && d2[0].length > 1 && d2[0][0] === a2 && (c2 = d2[0][1]), n2.codecs.forEach((e11) => {
      if ("RTX" === e11.name.toUpperCase() && e11.parameters.apt) {
        let t3 = { ssrc: a2, codecPayloadType: parseInt(e11.parameters.apt, 10) };
        a2 && c2 && (t3.rtx = { ssrc: c2 }), i2.push(t3), r2 && (t3 = JSON.parse(JSON.stringify(t3)), t3.fec = { ssrc: a2, mechanism: o2 ? "red+ulpfec" : "red" }, i2.push(t3));
      }
    }), 0 === i2.length && a2 && i2.push({ ssrc: a2 });
    let l2 = t2.matchPrefix(e10, "b=");
    return l2.length && (l2 = 0 === l2[0].indexOf("b=TIAS:") ? parseInt(l2[0].substring(7), 10) : 0 === l2[0].indexOf("b=AS:") ? 1e3 * parseInt(l2[0].substring(5), 10) * 0.95 - 16e3 : void 0, i2.forEach((e11) => {
      e11.maxBitrate = l2;
    })), i2;
  }, t2.parseRtcpParameters = function(e10) {
    const i2 = {}, n2 = t2.matchPrefix(e10, "a=ssrc:").map((e11) => t2.parseSsrcMedia(e11)).filter((e11) => "cname" === e11.attribute)[0];
    n2 && (i2.cname = n2.value, i2.ssrc = n2.ssrc);
    const r2 = t2.matchPrefix(e10, "a=rtcp-rsize");
    i2.reducedSize = r2.length > 0, i2.compound = 0 === r2.length;
    const o2 = t2.matchPrefix(e10, "a=rtcp-mux");
    return i2.mux = o2.length > 0, i2;
  }, t2.writeRtcpParameters = function(e10) {
    let t3 = "";
    return e10.reducedSize && (t3 += "a=rtcp-rsize\r\n"), e10.mux && (t3 += "a=rtcp-mux\r\n"), void 0 !== e10.ssrc && e10.cname && (t3 += "a=ssrc:" + e10.ssrc + " cname:" + e10.cname + "\r\n"), t3;
  }, t2.parseMsid = function(e10) {
    let i2;
    const n2 = t2.matchPrefix(e10, "a=msid:");
    if (1 === n2.length) return i2 = n2[0].substring(7).split(" "), { stream: i2[0], track: i2[1] };
    const r2 = t2.matchPrefix(e10, "a=ssrc:").map((e11) => t2.parseSsrcMedia(e11)).filter((e11) => "msid" === e11.attribute);
    return r2.length > 0 ? (i2 = r2[0].value.split(" "), { stream: i2[0], track: i2[1] }) : void 0;
  }, t2.parseSctpDescription = function(e10) {
    const i2 = t2.parseMLine(e10), n2 = t2.matchPrefix(e10, "a=max-message-size:");
    let r2;
    n2.length > 0 && (r2 = parseInt(n2[0].substring(19), 10)), isNaN(r2) && (r2 = 65536);
    const o2 = t2.matchPrefix(e10, "a=sctp-port:");
    if (o2.length > 0) return { port: parseInt(o2[0].substring(12), 10), protocol: i2.fmt, maxMessageSize: r2 };
    const s2 = t2.matchPrefix(e10, "a=sctpmap:");
    if (s2.length > 0) {
      const e11 = s2[0].substring(10).split(" ");
      return { port: parseInt(e11[0], 10), protocol: e11[1], maxMessageSize: r2 };
    }
  }, t2.writeSctpDescription = function(e10, t3) {
    let i2 = [];
    return i2 = "DTLS/SCTP" !== e10.protocol ? ["m=" + e10.kind + " 9 " + e10.protocol + " " + t3.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t3.port + "\r\n"] : ["m=" + e10.kind + " 9 " + e10.protocol + " " + t3.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t3.port + " " + t3.protocol + " 65535\r\n"], void 0 !== t3.maxMessageSize && i2.push("a=max-message-size:" + t3.maxMessageSize + "\r\n"), i2.join("");
  }, t2.generateSessionId = function() {
    return Math.random().toString().substr(2, 22);
  }, t2.writeSessionBoilerplate = function(e10, i2, n2) {
    let r2;
    const o2 = void 0 !== i2 ? i2 : 2;
    r2 = e10 || t2.generateSessionId();
    return "v=0\r\no=" + (n2 || "thisisadapterortc") + " " + r2 + " " + o2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
  }, t2.getDirection = function(e10, i2) {
    const n2 = t2.splitLines(e10);
    for (let e11 = 0; e11 < n2.length; e11++) switch (n2[e11]) {
      case "a=sendrecv":
      case "a=sendonly":
      case "a=recvonly":
      case "a=inactive":
        return n2[e11].substring(2);
    }
    return i2 ? t2.getDirection(i2) : "sendrecv";
  }, t2.getKind = function(e10) {
    return t2.splitLines(e10)[0].split(" ")[0].substring(2);
  }, t2.isRejected = function(e10) {
    return "0" === e10.split(" ", 2)[1];
  }, t2.parseMLine = function(e10) {
    const i2 = t2.splitLines(e10)[0].substring(2).split(" ");
    return { kind: i2[0], port: parseInt(i2[1], 10), protocol: i2[2], fmt: i2.slice(3).join(" ") };
  }, t2.parseOLine = function(e10) {
    const i2 = t2.matchPrefix(e10, "o=")[0].substring(2).split(" ");
    return { username: i2[0], sessionId: i2[1], sessionVersion: parseInt(i2[2], 10), netType: i2[3], addressType: i2[4], address: i2[5] };
  }, t2.isValidSDP = function(e10) {
    if ("string" != typeof e10 || 0 === e10.length) return false;
    const i2 = t2.splitLines(e10);
    for (let e11 = 0; e11 < i2.length; e11++) if (i2[e11].length < 2 || "=" !== i2[e11].charAt(1)) return false;
    return true;
  }, e9.exports = t2;
}(Gp);
var Wp = Gp.exports;
var Hp = i(Wp);
var Kp = e({ __proto__: null, default: Hp }, [Wp]);
function Yp(e9) {
  if (!e9.RTCIceCandidate || e9.RTCIceCandidate && "foundation" in e9.RTCIceCandidate.prototype) return;
  const t2 = e9.RTCIceCandidate;
  e9.RTCIceCandidate = function(e10) {
    if ("object" == typeof e10 && e10.candidate && 0 === e10.candidate.indexOf("a=") && ((e10 = JSON.parse(JSON.stringify(e10))).candidate = e10.candidate.substr(2)), e10.candidate && e10.candidate.length) {
      const i2 = new t2(e10), n2 = Hp.parseCandidate(e10.candidate), r2 = Object.assign(i2, n2);
      return r2.toJSON = function() {
        return { candidate: r2.candidate, sdpMid: r2.sdpMid, sdpMLineIndex: r2.sdpMLineIndex, usernameFragment: r2.usernameFragment };
      }, r2;
    }
    return new t2(e10);
  }, e9.RTCIceCandidate.prototype = t2.prototype, $n(e9, "icecandidate", (t3) => (t3.candidate && Object.defineProperty(t3, "candidate", { value: new e9.RTCIceCandidate(t3.candidate), writable: "false" }), t3));
}
function qp(e9) {
  !e9.RTCIceCandidate || e9.RTCIceCandidate && "relayProtocol" in e9.RTCIceCandidate.prototype || $n(e9, "icecandidate", (e10) => {
    if (e10.candidate) {
      const t2 = Hp.parseCandidate(e10.candidate.candidate);
      "relay" === t2.type && (e10.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[t2.priority >> 24]);
    }
    return e10;
  });
}
function zp(e9, t2) {
  if (!e9.RTCPeerConnection) return;
  "sctp" in e9.RTCPeerConnection.prototype || Object.defineProperty(e9.RTCPeerConnection.prototype, "sctp", { get() {
    return void 0 === this._sctp ? null : this._sctp;
  } });
  const i2 = function(e10) {
    if (!e10 || !e10.sdp) return false;
    const t3 = Hp.splitSections(e10.sdp);
    return t3.shift(), t3.some((e11) => {
      const t4 = Hp.parseMLine(e11);
      return t4 && "application" === t4.kind && -1 !== t4.protocol.indexOf("SCTP");
    });
  }, n2 = function(e10) {
    const t3 = e10.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (null === t3 || t3.length < 2) return -1;
    const i3 = parseInt(t3[1], 10);
    return i3 != i3 ? -1 : i3;
  }, r2 = function(e10) {
    let i3 = 65536;
    return "firefox" === t2.browser && (i3 = t2.version < 57 ? -1 === e10 ? 16384 : 2147483637 : t2.version < 60 ? 57 === t2.version ? 65535 : 65536 : 2147483637), i3;
  }, o2 = function(e10, i3) {
    let n3 = 65536;
    "firefox" === t2.browser && 57 === t2.version && (n3 = 65535);
    const r3 = Hp.matchPrefix(e10.sdp, "a=max-message-size:");
    return r3.length > 0 ? n3 = parseInt(r3[0].substr(19), 10) : "firefox" === t2.browser && -1 !== i3 && (n3 = 2147483637), n3;
  }, s2 = e9.RTCPeerConnection.prototype.setRemoteDescription;
  e9.RTCPeerConnection.prototype.setRemoteDescription = function() {
    if (this._sctp = null, "chrome" === t2.browser && t2.version >= 76) {
      const { sdpSemantics: e10 } = this.getConfiguration();
      "plan-b" === e10 && Object.defineProperty(this, "sctp", { get() {
        return void 0 === this._sctp ? null : this._sctp;
      }, enumerable: true, configurable: true });
    }
    if (i2(arguments[0])) {
      const e10 = n2(arguments[0]), t3 = r2(e10), i3 = o2(arguments[0], e10);
      let s3;
      s3 = 0 === t3 && 0 === i3 ? Number.POSITIVE_INFINITY : 0 === t3 || 0 === i3 ? Math.max(t3, i3) : Math.min(t3, i3);
      const a2 = {};
      Object.defineProperty(a2, "maxMessageSize", { get: () => s3 }), this._sctp = a2;
    }
    return s2.apply(this, arguments);
  };
}
function Jp(e9) {
  if (!e9.RTCPeerConnection || !("createDataChannel" in e9.RTCPeerConnection.prototype)) return;
  function t2(e10, t3) {
    const i3 = e10.send;
    e10.send = function() {
      const n2 = arguments[0], r2 = n2.length || n2.size || n2.byteLength;
      if ("open" === e10.readyState && t3.sctp && r2 > t3.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t3.sctp.maxMessageSize + " bytes)");
      return i3.apply(e10, arguments);
    };
  }
  const i2 = e9.RTCPeerConnection.prototype.createDataChannel;
  e9.RTCPeerConnection.prototype.createDataChannel = function() {
    const e10 = i2.apply(this, arguments);
    return t2(e10, this), e10;
  }, $n(e9, "datachannel", (e10) => (t2(e10.channel, e10.target), e10));
}
function Xp(e9) {
  if (!e9.RTCPeerConnection || "connectionState" in e9.RTCPeerConnection.prototype) return;
  const t2 = e9.RTCPeerConnection.prototype;
  Object.defineProperty(t2, "connectionState", { get() {
    return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
  }, enumerable: true, configurable: true }), Object.defineProperty(t2, "onconnectionstatechange", { get() {
    return this._onconnectionstatechange || null;
  }, set(e10) {
    this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e10 && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e10);
  }, enumerable: true, configurable: true }), ["setLocalDescription", "setRemoteDescription"].forEach((e10) => {
    const i2 = t2[e10];
    t2[e10] = function() {
      return this._connectionstatechangepoly || (this._connectionstatechangepoly = (e11) => {
        const t3 = e11.target;
        if (t3._lastConnectionState !== t3.connectionState) {
          t3._lastConnectionState = t3.connectionState;
          const i3 = new Event("connectionstatechange", e11);
          t3.dispatchEvent(i3);
        }
        return e11;
      }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i2.apply(this, arguments);
    };
  });
}
function Qp(e9, t2) {
  if (!e9.RTCPeerConnection) return;
  if ("chrome" === t2.browser && t2.version >= 71) return;
  if ("safari" === t2.browser && t2.version >= 605) return;
  const i2 = e9.RTCPeerConnection.prototype.setRemoteDescription;
  e9.RTCPeerConnection.prototype.setRemoteDescription = function(t3) {
    if (t3 && t3.sdp && -1 !== t3.sdp.indexOf("\na=extmap-allow-mixed")) {
      const i3 = t3.sdp.split("\n").filter((e10) => "a=extmap-allow-mixed" !== jp(e10).call(e10)).join("\n");
      e9.RTCSessionDescription && t3 instanceof e9.RTCSessionDescription ? arguments[0] = new e9.RTCSessionDescription({ type: t3.type, sdp: i3 }) : t3.sdp = i3;
    }
    return i2.apply(this, arguments);
  };
}
function Zp(e9, t2) {
  if (!e9.RTCPeerConnection || !e9.RTCPeerConnection.prototype) return;
  const i2 = e9.RTCPeerConnection.prototype.addIceCandidate;
  i2 && 0 !== i2.length && (e9.RTCPeerConnection.prototype.addIceCandidate = function() {
    return arguments[0] ? ("chrome" === t2.browser && t2.version < 78 || "firefox" === t2.browser && t2.version < 68 || "safari" === t2.browser) && arguments[0] && "" === arguments[0].candidate ? Gh.resolve() : i2.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Gh.resolve());
  });
}
function $p(e9, t2) {
  if (!e9.RTCPeerConnection || !e9.RTCPeerConnection.prototype) return;
  const i2 = e9.RTCPeerConnection.prototype.setLocalDescription;
  i2 && 0 !== i2.length && (e9.RTCPeerConnection.prototype.setLocalDescription = function() {
    let e10 = arguments[0] || {};
    if ("object" != typeof e10 || e10.type && e10.sdp) return i2.apply(this, arguments);
    if (e10 = { type: e10.type, sdp: e10.sdp }, !e10.type) switch (this.signalingState) {
      case "stable":
      case "have-local-offer":
      case "have-remote-pranswer":
        e10.type = "offer";
        break;
      default:
        e10.type = "answer";
    }
    if (e10.sdp || "offer" !== e10.type && "answer" !== e10.type) return i2.apply(this, [e10]);
    return ("offer" === e10.type ? this.createOffer : this.createAnswer).apply(this).then((e11) => i2.apply(this, [e11]));
  });
}
var e_ = Object.freeze({ __proto__: null, removeExtmapAllowMixed: Qp, shimAddIceCandidateNullOrEmpty: Zp, shimConnectionState: Xp, shimMaxMessageSize: zp, shimParameterlessSetLocalDescription: $p, shimRTCIceCandidate: Yp, shimRTCIceCandidateRelayProtocol: qp, shimSendThrowTypeError: Jp });
!function() {
  let { window: e9 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: true, shimFirefox: true, shimSafari: true };
  const i2 = ir, n2 = function(e10) {
    const t3 = { browser: null, version: null };
    if (void 0 === e10 || !e10.navigator) return t3.browser = "Not a browser.", t3;
    const { navigator: i3 } = e10;
    if (i3.mozGetUserMedia) t3.browser = "firefox", t3.version = Zn(i3.userAgent, /Firefox\/(\d+)\./, 1);
    else if (i3.webkitGetUserMedia || false === e10.isSecureContext && e10.webkitRTCPeerConnection) t3.browser = "chrome", t3.version = Zn(i3.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
    else {
      if (!e10.RTCPeerConnection || !i3.userAgent.match(/AppleWebKit\/(\d+)\./)) return t3.browser = "Not a supported browser.", t3;
      t3.browser = "safari", t3.version = Zn(i3.userAgent, /AppleWebKit\/(\d+)\./, 1), t3.supportsUnifiedPlan = e10.RTCRtpTransceiver && "currentDirection" in e10.RTCRtpTransceiver.prototype;
    }
    return t3;
  }(e9), r2 = { browserDetails: n2, commonShim: e_, extractVersion: Zn, disableLog: er, disableWarnings: tr, sdp: Kp };
  switch (n2.browser) {
    case "chrome":
      if (!ep || !Zh || !t2.shimChrome) return i2("Chrome shim is not included in this adapter release."), r2;
      if (null === n2.version) return i2("Chrome shim can not determine version, not shimming."), r2;
      i2("adapter.js shimming chrome."), r2.browserShim = ep, Zp(e9, n2), $p(e9), Hh(e9, n2), Kh(e9), Zh(e9, n2), Yh(e9), Qh(e9, n2), qh(e9), zh(e9), Jh(e9), $h(e9, n2), Yp(e9), qp(e9), Xp(e9), zp(e9, n2), Jp(e9), Qp(e9, n2);
      break;
    case "firefox":
      if (!hp || !np || !t2.shimFirefox) return i2("Firefox shim is not included in this adapter release."), r2;
      i2("adapter.js shimming firefox."), r2.browserShim = hp, Zp(e9, n2), $p(e9), tp(e9, n2), np(e9, n2), ip(e9), sp(e9), rp(e9), op(e9), ap(e9), cp(e9), dp(e9), lp(e9), up(e9), Yp(e9), Xp(e9), zp(e9, n2), Jp(e9);
      break;
    case "safari":
      if (!Cp || !t2.shimSafari) return i2("Safari shim is not included in this adapter release."), r2;
      i2("adapter.js shimming safari."), r2.browserShim = Cp, Zp(e9, n2), $p(e9), Tp(e9), gp(e9), Ep(e9), pp(e9), _p(e9), Sp(e9), fp(e9), Rp(e9), Yp(e9), qp(e9), zp(e9, n2), Jp(e9), Qp(e9, n2);
      break;
    default:
      i2("Unsupported browser!");
  }
}({ window: "undefined" == typeof window ? void 0 : window });
var t_ = Xi("Array").keys;
var i_ = pn;
var n_ = Ze;
var r_ = l;
var o_ = t_;
var s_ = Array.prototype;
var a_ = { DOMTokenList: true, NodeList: true };
var c_ = function(e9) {
  var t2 = e9.keys;
  return e9 === s_ || r_(s_, e9) && t2 === s_.keys || n_(a_, i_(e9)) ? o_ : t2;
};
var d_ = i(c_);
var l_ = be;
var u_ = TypeError;
var h_ = Ct;
var p_ = Qt;
var __ = B;
var E_ = function(e9, t2, i2) {
  var n2 = h_(t2);
  n2 in e9 ? p_.f(e9, n2, __(0, i2)) : e9[n2] = i2;
};
var f_ = xi;
var m_ = Gi;
var T_ = E_;
var S_ = Array;
var g_ = Math.max;
var R_ = function(e9, t2, i2) {
  for (var n2 = m_(e9), r2 = f_(t2, n2), o2 = f_(void 0 === i2 ? n2 : i2, n2), s2 = S_(g_(o2 - r2, 0)), a2 = 0; r2 < o2; r2++, a2++) T_(s2, a2, e9[r2]);
  return s2.length = a2, s2;
};
var C_ = R_;
var I_ = Math.floor;
var v_ = function(e9, t2) {
  var i2 = e9.length, n2 = I_(i2 / 2);
  return i2 < 8 ? y_(e9, t2) : A_(e9, v_(C_(e9, 0, n2), t2), v_(C_(e9, n2), t2), t2);
};
var y_ = function(e9, t2) {
  for (var i2, n2, r2 = e9.length, o2 = 1; o2 < r2; ) {
    for (n2 = o2, i2 = e9[o2]; n2 && t2(e9[n2 - 1], i2) > 0; ) e9[n2] = e9[--n2];
    n2 !== o2++ && (e9[n2] = i2);
  }
  return e9;
};
var A_ = function(e9, t2, i2, n2) {
  for (var r2 = t2.length, o2 = i2.length, s2 = 0, a2 = 0; s2 < r2 || a2 < o2; ) e9[s2 + a2] = s2 < r2 && a2 < o2 ? n2(t2[s2], i2[a2]) <= 0 ? t2[s2++] : i2[a2++] : s2 < r2 ? t2[s2++] : i2[a2++];
  return e9;
};
var b_ = v_;
var w_ = ce.match(/firefox\/(\d+)/i);
var O_ = !!w_ && +w_[1];
var N_ = /MSIE|Trident/.test(ce);
var D_ = ce.match(/AppleWebKit\/(\d+)\./);
var P_ = !!D_ && +D_[1];
var L_ = wi;
var k_ = d;
var M_ = De;
var U_ = Je;
var x_ = Gi;
var V_ = function(e9, t2) {
  if (!delete e9[t2]) throw u_("Cannot delete property " + l_(t2) + " of " + l_(e9));
};
var F_ = fn;
var B_ = n;
var j_ = b_;
var G_ = Bn;
var W_ = O_;
var H_ = N_;
var K_ = Ee;
var Y_ = P_;
var q_ = [];
var z_ = k_(q_.sort);
var J_ = k_(q_.push);
var X_ = B_(function() {
  q_.sort(void 0);
});
var Q_ = B_(function() {
  q_.sort(null);
});
var Z_ = G_("sort");
var $_ = !B_(function() {
  if (K_) return K_ < 70;
  if (!(W_ && W_ > 3)) {
    if (H_) return true;
    if (Y_) return Y_ < 603;
    var e9, t2, i2, n2, r2 = "";
    for (e9 = 65; e9 < 76; e9++) {
      switch (t2 = String.fromCharCode(e9), e9) {
        case 66:
        case 69:
        case 70:
        case 72:
          i2 = 3;
          break;
        case 68:
        case 71:
          i2 = 4;
          break;
        default:
          i2 = 2;
      }
      for (n2 = 0; n2 < 47; n2++) q_.push({ k: t2 + n2, v: i2 });
    }
    for (q_.sort(function(e10, t3) {
      return t3.v - e10.v;
    }), n2 = 0; n2 < q_.length; n2++) t2 = q_[n2].k.charAt(0), r2.charAt(r2.length - 1) !== t2 && (r2 += t2);
    return "DGBEFHACIJK" !== r2;
  }
});
L_({ target: "Array", proto: true, forced: X_ || !Q_ || !Z_ || !$_ }, { sort: function(e9) {
  void 0 !== e9 && M_(e9);
  var t2 = U_(this);
  if ($_) return void 0 === e9 ? z_(t2) : z_(t2, e9);
  var i2, n2, r2 = [], o2 = x_(t2);
  for (n2 = 0; n2 < o2; n2++) n2 in t2 && J_(r2, t2[n2]);
  for (j_(r2, /* @__PURE__ */ function(e10) {
    return function(t3, i3) {
      return void 0 === i3 ? -1 : void 0 === t3 ? 1 : void 0 !== e10 ? +e10(t3, i3) || 0 : F_(t3) > F_(i3) ? 1 : -1;
    };
  }(e9)), i2 = x_(r2), n2 = 0; n2 < i2; ) t2[n2] = r2[n2++];
  for (; n2 < o2; ) V_(t2, n2++);
  return t2;
} });
var eE;
var tE;
var iE = Xi("Array").sort;
var nE = l;
var rE = iE;
var oE = Array.prototype;
var sE = function(e9) {
  var t2 = e9.sort;
  return e9 === oE || nE(oE, e9) && t2 === oE.sort ? rE : t2;
};
var aE = i(sE);
var cE = { exports: {} };
eE = cE, tE = cE.exports, function(e9, t2) {
  var i2 = "function", n2 = "undefined", r2 = "object", o2 = "string", s2 = "major", a2 = "model", c2 = "name", d2 = "type", l2 = "vendor", u2 = "version", h2 = "architecture", p2 = "console", _2 = "mobile", E2 = "tablet", f2 = "smarttv", m2 = "wearable", T2 = "embedded", S2 = "Amazon", g2 = "Apple", R2 = "ASUS", C2 = "BlackBerry", I2 = "Browser", v2 = "Chrome", y2 = "Firefox", A2 = "Google", b2 = "Huawei", w2 = "LG", O2 = "Microsoft", N2 = "Motorola", D2 = "Opera", P2 = "Samsung", L2 = "Sharp", k2 = "Sony", M2 = "Xiaomi", U2 = "Zebra", x2 = "Facebook", V2 = "Chromium OS", F2 = "Mac OS", B2 = function(e10) {
    for (var t3 = {}, i3 = 0; i3 < e10.length; i3++) t3[e10[i3].toUpperCase()] = e10[i3];
    return t3;
  }, j2 = function(e10, t3) {
    return typeof e10 === o2 && -1 !== G2(t3).indexOf(G2(e10));
  }, G2 = function(e10) {
    return e10.toLowerCase();
  }, W2 = function(e10, t3) {
    if (typeof e10 === o2) return e10 = e10.replace(/^\s\s*/, ""), typeof t3 === n2 ? e10 : e10.substring(0, 350);
  }, H2 = function(e10, n3) {
    for (var o3, s3, a3, c3, d3, l3, u3 = 0; u3 < n3.length && !d3; ) {
      var h3 = n3[u3], p3 = n3[u3 + 1];
      for (o3 = s3 = 0; o3 < h3.length && !d3 && h3[o3]; ) if (d3 = h3[o3++].exec(e10)) for (a3 = 0; a3 < p3.length; a3++) l3 = d3[++s3], typeof (c3 = p3[a3]) === r2 && c3.length > 0 ? 2 === c3.length ? typeof c3[1] == i2 ? this[c3[0]] = c3[1].call(this, l3) : this[c3[0]] = c3[1] : 3 === c3.length ? typeof c3[1] !== i2 || c3[1].exec && c3[1].test ? this[c3[0]] = l3 ? l3.replace(c3[1], c3[2]) : t2 : this[c3[0]] = l3 ? c3[1].call(this, l3, c3[2]) : t2 : 4 === c3.length && (this[c3[0]] = l3 ? c3[3].call(this, l3.replace(c3[1], c3[2])) : t2) : this[c3] = l3 || t2;
      u3 += 2;
    }
  }, K2 = function(e10, i3) {
    for (var n3 in i3) if (typeof i3[n3] === r2 && i3[n3].length > 0) {
      for (var o3 = 0; o3 < i3[n3].length; o3++) if (j2(i3[n3][o3], e10)) return "?" === n3 ? t2 : n3;
    } else if (j2(i3[n3], e10)) return "?" === n3 ? t2 : n3;
    return e10;
  }, Y2 = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, q2 = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [u2, [c2, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [u2, [c2, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [c2, u2], [/opios[\/ ]+([\w\.]+)/i], [u2, [c2, D2 + " Mini"]], [/\bopr\/([\w\.]+)/i], [u2, [c2, D2]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [c2, u2], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [u2, [c2, "UC" + I2]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [u2, [c2, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [u2, [c2, "WeChat"]], [/konqueror\/([\w\.]+)/i], [u2, [c2, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [u2, [c2, "IE"]], [/yabrowser\/([\w\.]+)/i], [u2, [c2, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[c2, /(.+)/, "$1 Secure " + I2], u2], [/\bfocus\/([\w\.]+)/i], [u2, [c2, y2 + " Focus"]], [/\bopt\/([\w\.]+)/i], [u2, [c2, D2 + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [u2, [c2, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [u2, [c2, "Dolphin"]], [/coast\/([\w\.]+)/i], [u2, [c2, D2 + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [u2, [c2, "MIUI " + I2]], [/fxios\/([-\w\.]+)/i], [u2, [c2, y2]], [/\bqihu|(qi?ho?o?|360)browser/i], [[c2, "360 " + I2]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[c2, /(.+)/, "$1 " + I2], u2], [/(comodo_dragon)\/([\w\.]+)/i], [[c2, /_/g, " "], u2], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [c2, u2], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [c2], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[c2, x2], u2], [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [c2, u2], [/\bgsa\/([\w\.]+) .*safari\//i], [u2, [c2, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [u2, [c2, v2 + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[c2, v2 + " WebView"], u2], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [u2, [c2, "Android " + I2]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [c2, u2], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [u2, [c2, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [u2, c2], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [c2, [u2, K2, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [c2, u2], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[c2, "Netscape"], u2], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [u2, [c2, y2 + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [c2, u2], [/(cobalt)\/([\w\.]+)/i], [c2, [u2, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[h2, "amd64"]], [/(ia32(?=;))/i], [[h2, G2]], [/((?:i[346]|x)86)[;\)]/i], [[h2, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[h2, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[h2, "armhf"]], [/windows (ce|mobile); ppc;/i], [[h2, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[h2, /ower/, "", G2]], [/(sun4\w)[;\)]/i], [[h2, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[h2, G2]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [a2, [l2, P2], [d2, E2]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [a2, [l2, P2], [d2, _2]], [/\((ip(?:hone|od)[\w ]*);/i], [a2, [l2, g2], [d2, _2]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [a2, [l2, g2], [d2, E2]], [/(macintosh);/i], [a2, [l2, g2]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [a2, [l2, L2], [d2, _2]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [a2, [l2, b2], [d2, E2]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [a2, [l2, b2], [d2, _2]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[a2, /_/g, " "], [l2, M2], [d2, _2]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[a2, /_/g, " "], [l2, M2], [d2, E2]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [a2, [l2, "OPPO"], [d2, _2]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [a2, [l2, "Vivo"], [d2, _2]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [a2, [l2, "Realme"], [d2, _2]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [a2, [l2, N2], [d2, _2]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [a2, [l2, N2], [d2, E2]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [a2, [l2, w2], [d2, E2]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [a2, [l2, w2], [d2, _2]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [a2, [l2, "Lenovo"], [d2, E2]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[a2, /_/g, " "], [l2, "Nokia"], [d2, _2]], [/(pixel c)\b/i], [a2, [l2, A2], [d2, E2]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [a2, [l2, A2], [d2, _2]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [a2, [l2, k2], [d2, _2]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[a2, "Xperia Tablet"], [l2, k2], [d2, E2]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [a2, [l2, "OnePlus"], [d2, _2]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [a2, [l2, S2], [d2, E2]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[a2, /(.+)/g, "Fire Phone $1"], [l2, S2], [d2, _2]], [/(playbook);[-\w\),; ]+(rim)/i], [a2, l2, [d2, E2]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [a2, [l2, C2], [d2, _2]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [a2, [l2, R2], [d2, E2]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [a2, [l2, R2], [d2, _2]], [/(nexus 9)/i], [a2, [l2, "HTC"], [d2, E2]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [l2, [a2, /_/g, " "], [d2, _2]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [a2, [l2, "Acer"], [d2, E2]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [a2, [l2, "Meizu"], [d2, _2]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [l2, a2, [d2, _2]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [l2, a2, [d2, E2]], [/(surface duo)/i], [a2, [l2, O2], [d2, E2]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [a2, [l2, "Fairphone"], [d2, _2]], [/(u304aa)/i], [a2, [l2, "AT&T"], [d2, _2]], [/\bsie-(\w*)/i], [a2, [l2, "Siemens"], [d2, _2]], [/\b(rct\w+) b/i], [a2, [l2, "RCA"], [d2, E2]], [/\b(venue[\d ]{2,7}) b/i], [a2, [l2, "Dell"], [d2, E2]], [/\b(q(?:mv|ta)\w+) b/i], [a2, [l2, "Verizon"], [d2, E2]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [a2, [l2, "Barnes & Noble"], [d2, E2]], [/\b(tm\d{3}\w+) b/i], [a2, [l2, "NuVision"], [d2, E2]], [/\b(k88) b/i], [a2, [l2, "ZTE"], [d2, E2]], [/\b(nx\d{3}j) b/i], [a2, [l2, "ZTE"], [d2, _2]], [/\b(gen\d{3}) b.+49h/i], [a2, [l2, "Swiss"], [d2, _2]], [/\b(zur\d{3}) b/i], [a2, [l2, "Swiss"], [d2, E2]], [/\b((zeki)?tb.*\b) b/i], [a2, [l2, "Zeki"], [d2, E2]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[l2, "Dragon Touch"], a2, [d2, E2]], [/\b(ns-?\w{0,9}) b/i], [a2, [l2, "Insignia"], [d2, E2]], [/\b((nxa|next)-?\w{0,9}) b/i], [a2, [l2, "NextBook"], [d2, E2]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[l2, "Voice"], a2, [d2, _2]], [/\b(lvtel\-)?(v1[12]) b/i], [[l2, "LvTel"], a2, [d2, _2]], [/\b(ph-1) /i], [a2, [l2, "Essential"], [d2, _2]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [a2, [l2, "Envizen"], [d2, E2]], [/\b(trio[-\w\. ]+) b/i], [a2, [l2, "MachSpeed"], [d2, E2]], [/\btu_(1491) b/i], [a2, [l2, "Rotor"], [d2, E2]], [/(shield[\w ]+) b/i], [a2, [l2, "Nvidia"], [d2, E2]], [/(sprint) (\w+)/i], [l2, a2, [d2, _2]], [/(kin\.[onetw]{3})/i], [[a2, /\./g, " "], [l2, O2], [d2, _2]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [a2, [l2, U2], [d2, E2]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [a2, [l2, U2], [d2, _2]], [/smart-tv.+(samsung)/i], [l2, [d2, f2]], [/hbbtv.+maple;(\d+)/i], [[a2, /^/, "SmartTV"], [l2, P2], [d2, f2]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[l2, w2], [d2, f2]], [/(apple) ?tv/i], [l2, [a2, g2 + " TV"], [d2, f2]], [/crkey/i], [[a2, v2 + "cast"], [l2, A2], [d2, f2]], [/droid.+aft(\w)( bui|\))/i], [a2, [l2, S2], [d2, f2]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [a2, [l2, L2], [d2, f2]], [/(bravia[\w ]+)( bui|\))/i], [a2, [l2, k2], [d2, f2]], [/(mitv-\w{5}) bui/i], [a2, [l2, M2], [d2, f2]], [/Hbbtv.*(technisat) (.*);/i], [l2, a2, [d2, f2]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[l2, W2], [a2, W2], [d2, f2]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[d2, f2]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [l2, a2, [d2, p2]], [/droid.+; (shield) bui/i], [a2, [l2, "Nvidia"], [d2, p2]], [/(playstation [345portablevi]+)/i], [a2, [l2, k2], [d2, p2]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [a2, [l2, O2], [d2, p2]], [/((pebble))app/i], [l2, a2, [d2, m2]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [a2, [l2, g2], [d2, m2]], [/droid.+; (glass) \d/i], [a2, [l2, A2], [d2, m2]], [/droid.+; (wt63?0{2,3})\)/i], [a2, [l2, U2], [d2, m2]], [/(quest( 2| pro)?)/i], [a2, [l2, x2], [d2, m2]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [l2, [d2, T2]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [a2, [d2, _2]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [a2, [d2, E2]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[d2, E2]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[d2, _2]], [/(android[-\w\. ]{0,9});.+buil/i], [a2, [l2, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [u2, [c2, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [u2, [c2, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [c2, u2], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [u2, c2]], os: [[/microsoft (windows) (vista|xp)/i], [c2, u2], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [c2, [u2, K2, Y2]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[c2, "Windows"], [u2, K2, Y2]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[u2, /_/g, "."], [c2, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[c2, F2], [u2, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [u2, c2], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [c2, u2], [/\(bb(10);/i], [u2, [c2, C2]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [u2, [c2, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [u2, [c2, y2 + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [u2, [c2, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [u2, [c2, "watchOS"]], [/crkey\/([\d\.]+)/i], [u2, [c2, v2 + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[c2, V2], u2], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [c2, u2], [/(sunos) ?([\w\.\d]*)/i], [[c2, "Solaris"], u2], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [c2, u2]] }, z2 = function(p3, f3) {
    if (typeof p3 === r2 && (f3 = p3, p3 = t2), !(this instanceof z2)) return new z2(p3, f3).getResult();
    var m3 = typeof e9 !== n2 && e9.navigator ? e9.navigator : t2, T3 = p3 || (m3 && m3.userAgent ? m3.userAgent : ""), S3 = m3 && m3.userAgentData ? m3.userAgentData : t2, g3 = f3 ? function(e10, t3) {
      var i3 = {};
      for (var n3 in e10) t3[n3] && t3[n3].length % 2 == 0 ? i3[n3] = t3[n3].concat(e10[n3]) : i3[n3] = e10[n3];
      return i3;
    }(q2, f3) : q2;
    return this.getBrowser = function() {
      var e10 = {};
      return e10[c2] = t2, e10[u2] = t2, H2.call(e10, T3, g3.browser), e10[s2] = function(e11) {
        return typeof e11 === o2 ? e11.replace(/[^\d\.]/g, "").split(".")[0] : t2;
      }(e10[u2]), m3 && m3.brave && typeof m3.brave.isBrave == i2 && (e10[c2] = "Brave"), e10;
    }, this.getCPU = function() {
      var e10 = {};
      return e10[h2] = t2, H2.call(e10, T3, g3.cpu), e10;
    }, this.getDevice = function() {
      var e10 = {};
      return e10[l2] = t2, e10[a2] = t2, e10[d2] = t2, H2.call(e10, T3, g3.device), !e10[d2] && S3 && S3.mobile && (e10[d2] = _2), "Macintosh" == e10[a2] && m3 && typeof m3.standalone !== n2 && m3.maxTouchPoints && m3.maxTouchPoints > 2 && (e10[a2] = "iPad", e10[d2] = E2), e10;
    }, this.getEngine = function() {
      var e10 = {};
      return e10[c2] = t2, e10[u2] = t2, H2.call(e10, T3, g3.engine), e10;
    }, this.getOS = function() {
      var e10 = {};
      return e10[c2] = t2, e10[u2] = t2, H2.call(e10, T3, g3.os), !e10[c2] && S3 && "Unknown" != S3.platform && (e10[c2] = S3.platform.replace(/chrome os/i, V2).replace(/macos/i, F2)), e10;
    }, this.getResult = function() {
      return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
    }, this.getUA = function() {
      return T3;
    }, this.setUA = function(e10) {
      return T3 = typeof e10 === o2 && e10.length > 350 ? W2(e10, 350) : e10, this;
    }, this.setUA(T3), this;
  };
  z2.VERSION = "0.7.34", z2.BROWSER = B2([c2, u2, s2]), z2.CPU = B2([h2]), z2.DEVICE = B2([a2, l2, d2, p2, _2, f2, E2, m2, T2]), z2.ENGINE = z2.OS = B2([c2, u2]), eE.exports && (tE = eE.exports = z2), tE.UAParser = z2;
  var J2 = typeof e9 !== n2 && (e9.jQuery || e9.Zepto);
  if (J2 && !J2.ua) {
    var X2 = new z2();
    J2.ua = X2.getResult(), J2.ua.get = function() {
      return X2.getUA();
    }, J2.ua.set = function(e10) {
      X2.setUA(e10);
      var t3 = X2.getResult();
      for (var i3 in t3) J2.ua[i3] = t3[i3];
    };
  }
}("object" == typeof window ? window : t);
var dE = i(cE.exports);
var lE = pn;
var uE = Ze;
var hE = Y;
var pE = xo;
var _E = ht("iterator");
var EE = Object;
var fE = function(e9) {
  if (hE(e9)) return false;
  var t2 = EE(e9);
  return void 0 !== t2[_E] || "@@iterator" in t2 || uE(pE, lE(t2));
};
var mE = i(fE);
var TE = h;
wi({ global: true, forced: TE.globalThis !== TE }, { globalThis: TE });
var SE = i(h);
var gE = Ad.clear;
wi({ global: true, bind: true, enumerable: true, forced: h.clearImmediate !== gE }, { clearImmediate: gE });
var RE = "function" == typeof Bun && Bun && "string" == typeof Bun.version;
var CE = h;
var IE = m;
var vE = w;
var yE = RE;
var AE = ce;
var bE = Xc;
var wE = Zc;
var OE = CE.Function;
var NE = /MSIE .\./.test(AE) || yE && function() {
  var e9 = CE.Bun.version.split(".");
  return e9.length < 3 || 0 == e9[0] && (e9[1] < 3 || 3 == e9[1] && 0 == e9[2]);
}();
var DE = wi;
var PE = h;
var LE = Ad.set;
var kE = function(e9, t2) {
  var i2 = t2 ? 2 : 1;
  return NE ? function(n2, r2) {
    var o2 = wE(arguments.length, 1) > i2, s2 = vE(n2) ? n2 : OE(n2), a2 = o2 ? bE(arguments, i2) : [], c2 = o2 ? function() {
      IE(s2, this, a2);
    } : s2;
    return t2 ? e9(c2, r2) : e9(c2);
  } : e9;
};
var ME = PE.setImmediate ? kE(LE, false) : LE;
DE({ global: true, bind: true, enumerable: true, forced: PE.setImmediate !== ME }, { setImmediate: ME });
var UE = i(ie.setImmediate);
var xE = wi;
var VE = $d;
var FE = De;
var BE = Zc;
var jE = jn;
var GE = h.process;
xE({ global: true, enumerable: true, dontCallGetSet: true }, { queueMicrotask: function(e9) {
  BE(arguments.length, 1), FE(e9);
  var t2 = jE && GE.domain;
  VE(t2 ? t2.bind(e9) : e9);
} });
var WE = i(ie.queueMicrotask);
function HE(e9, t2) {
  return function() {
    return e9.apply(t2, arguments);
  };
}
var { toString: KE } = Object.prototype;
var { getPrototypeOf: YE } = Object;
var qE = (zE = /* @__PURE__ */ Object.create(null), (e9) => {
  const t2 = KE.call(e9);
  return zE[t2] || (zE[t2] = t2.slice(8, -1).toLowerCase());
});
var zE;
var JE = (e9) => (e9 = e9.toLowerCase(), (t2) => qE(t2) === e9);
var XE = (e9) => (t2) => typeof t2 === e9;
var { isArray: QE } = Array;
var ZE = XE("undefined");
var $E = JE("ArrayBuffer");
var ef = XE("string");
var tf = XE("function");
var nf = XE("number");
var rf = (e9) => null !== e9 && "object" == typeof e9;
var of = (e9) => {
  if ("object" !== qE(e9)) return false;
  const t2 = YE(e9);
  return !(null !== t2 && t2 !== Object.prototype && null !== Object.getPrototypeOf(t2) || Symbol.toStringTag in e9 || mE(e9));
};
var sf = JE("Date");
var af = JE("File");
var cf = JE("Blob");
var df = JE("FileList");
var lf = JE("URLSearchParams");
var [uf, hf, pf, _f] = ["ReadableStream", "Request", "Response", "Headers"].map(JE);
function Ef(e9, t2) {
  let i2, n2, { allOwnKeys: r2 = false } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
  if (null != e9) if ("object" != typeof e9 && (e9 = [e9]), QE(e9)) for (i2 = 0, n2 = e9.length; i2 < n2; i2++) t2.call(null, e9[i2], i2, e9);
  else {
    const n3 = r2 ? Object.getOwnPropertyNames(e9) : Object.keys(e9), o2 = n3.length;
    let s2;
    for (i2 = 0; i2 < o2; i2++) s2 = n3[i2], t2.call(null, e9[s2], s2, e9);
  }
}
function ff(e9, t2) {
  t2 = t2.toLowerCase();
  const i2 = Object.keys(e9);
  let n2, r2 = i2.length;
  for (; r2-- > 0; ) if (n2 = i2[r2], t2 === n2.toLowerCase()) return n2;
  return null;
}
var mf = void 0 !== SE ? SE : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global;
var Tf = (e9) => !ZE(e9) && e9 !== mf;
var Sf = (gf = "undefined" != typeof Uint8Array && YE(Uint8Array), (e9) => gf && e9 instanceof gf);
var gf;
var Rf = JE("HTMLFormElement");
var Cf = ((e9) => {
  let { hasOwnProperty: t2 } = e9;
  return (e10, i2) => t2.call(e10, i2);
})(Object.prototype);
var If = JE("RegExp");
var vf = (e9, t2) => {
  const i2 = Object.getOwnPropertyDescriptors(e9), n2 = {};
  Ef(i2, (i3, r2) => {
    let o2;
    false !== (o2 = t2(i3, r2, e9)) && (n2[r2] = o2 || i3);
  }), Object.defineProperties(e9, n2);
};
var yf = "abcdefghijklmnopqrstuvwxyz";
var Af = "0123456789";
var bf = { DIGIT: Af, ALPHA: yf, ALPHA_DIGIT: yf + yf.toUpperCase() + Af };
var wf = JE("AsyncFunction");
var Of = (Nf = "function" == typeof UE, Df = tf(mf.postMessage), Nf ? UE : Df ? (Pf = "axios@".concat(Math.random()), Lf = [], mf.addEventListener("message", (e9) => {
  let { source: t2, data: i2 } = e9;
  t2 === mf && i2 === Pf && Lf.length && Lf.shift()();
}, false), (e9) => {
  Lf.push(e9), mf.postMessage(Pf, "*");
}) : (e9) => setTimeout(e9));
var Nf;
var Df;
var Pf;
var Lf;
var kf = void 0 !== WE ? WE.bind(mf) : "undefined" != typeof process && process.nextTick || Of;
var Mf = { isArray: QE, isArrayBuffer: $E, isBuffer: function(e9) {
  return null !== e9 && !ZE(e9) && null !== e9.constructor && !ZE(e9.constructor) && tf(e9.constructor.isBuffer) && e9.constructor.isBuffer(e9);
}, isFormData: (e9) => {
  let t2;
  return e9 && ("function" == typeof FormData && e9 instanceof FormData || tf(e9.append) && ("formdata" === (t2 = qE(e9)) || "object" === t2 && tf(e9.toString) && "[object FormData]" === e9.toString()));
}, isArrayBufferView: function(e9) {
  let t2;
  return t2 = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e9) : e9 && e9.buffer && $E(e9.buffer), t2;
}, isString: ef, isNumber: nf, isBoolean: (e9) => true === e9 || false === e9, isObject: rf, isPlainObject: of, isReadableStream: uf, isRequest: hf, isResponse: pf, isHeaders: _f, isUndefined: ZE, isDate: sf, isFile: af, isBlob: cf, isRegExp: If, isFunction: tf, isStream: (e9) => rf(e9) && tf(e9.pipe), isURLSearchParams: lf, isTypedArray: Sf, isFileList: df, forEach: Ef, merge: function e2() {
  const { caseless: t2 } = Tf(this) && this || {}, i2 = {}, n2 = (n3, r2) => {
    const o2 = t2 && ff(i2, r2) || r2;
    of(i2[o2]) && of(n3) ? i2[o2] = e2(i2[o2], n3) : of(n3) ? i2[o2] = e2({}, n3) : QE(n3) ? i2[o2] = n3.slice() : i2[o2] = n3;
  };
  for (let e9 = 0, t3 = arguments.length; e9 < t3; e9++) arguments[e9] && Ef(arguments[e9], n2);
  return i2;
}, extend: function(e9, t2, i2) {
  let { allOwnKeys: n2 } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
  return Ef(t2, (t3, n3) => {
    i2 && tf(t3) ? e9[n3] = HE(t3, i2) : e9[n3] = t3;
  }, { allOwnKeys: n2 }), e9;
}, trim: (e9) => jp(e9) ? jp(e9).call(e9) : e9.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: (e9) => (65279 === e9.charCodeAt(0) && (e9 = e9.slice(1)), e9), inherits: (e9, t2, i2, n2) => {
  e9.prototype = Object.create(t2.prototype, n2), e9.prototype.constructor = e9, Object.defineProperty(e9, "super", { value: t2.prototype }), i2 && Object.assign(e9.prototype, i2);
}, toFlatObject: (e9, t2, i2, n2) => {
  let r2, o2, s2;
  const a2 = {};
  if (t2 = t2 || {}, null == e9) return t2;
  do {
    for (r2 = Object.getOwnPropertyNames(e9), o2 = r2.length; o2-- > 0; ) s2 = r2[o2], n2 && !n2(s2, e9, t2) || a2[s2] || (t2[s2] = e9[s2], a2[s2] = true);
    e9 = false !== i2 && YE(e9);
  } while (e9 && (!i2 || i2(e9, t2)) && e9 !== Object.prototype);
  return t2;
}, kindOf: qE, kindOfTest: JE, endsWith: (e9, t2, i2) => {
  e9 = String(e9), (void 0 === i2 || i2 > e9.length) && (i2 = e9.length), i2 -= t2.length;
  const n2 = e9.indexOf(t2, i2);
  return -1 !== n2 && n2 === i2;
}, toArray: (e9) => {
  if (!e9) return null;
  if (QE(e9)) return e9;
  let t2 = e9.length;
  if (!nf(t2)) return null;
  const i2 = new Array(t2);
  for (; t2-- > 0; ) i2[t2] = e9[t2];
  return i2;
}, forEachEntry: (e9, t2) => {
  const i2 = (e9 && e9[Symbol.iterator]).call(e9);
  let n2;
  for (; (n2 = i2.next()) && !n2.done; ) {
    const i3 = n2.value;
    t2.call(e9, i3[0], i3[1]);
  }
}, matchAll: (e9, t2) => {
  let i2;
  const n2 = [];
  for (; null !== (i2 = e9.exec(t2)); ) n2.push(i2);
  return n2;
}, isHTMLForm: Rf, hasOwnProperty: Cf, hasOwnProp: Cf, reduceDescriptors: vf, freezeMethods: (e9) => {
  vf(e9, (t2, i2) => {
    if (tf(e9) && -1 !== ["arguments", "caller", "callee"].indexOf(i2)) return false;
    const n2 = e9[i2];
    tf(n2) && (t2.enumerable = false, "writable" in t2 ? t2.writable = false : t2.set || (t2.set = () => {
      throw Error("Can not rewrite read-only method '" + i2 + "'");
    }));
  });
}, toObjectSet: (e9, t2) => {
  const i2 = {}, n2 = (e10) => {
    e10.forEach((e11) => {
      i2[e11] = true;
    });
  };
  return QE(e9) ? n2(e9) : n2(String(e9).split(t2)), i2;
}, toCamelCase: (e9) => e9.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(e10, t2, i2) {
  return t2.toUpperCase() + i2;
}), noop: () => {
}, toFiniteNumber: (e9, t2) => null != e9 && Number.isFinite(e9 = +e9) ? e9 : t2, findKey: ff, global: mf, isContextDefined: Tf, ALPHABET: bf, generateString: function() {
  let e9 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 16, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : bf.ALPHA_DIGIT, i2 = "";
  const { length: n2 } = t2;
  for (; e9--; ) i2 += t2[Math.random() * n2 | 0];
  return i2;
}, isSpecCompliantForm: function(e9) {
  return !!(e9 && tf(e9.append) && "FormData" === e9[Symbol.toStringTag] && e9[Symbol.iterator]);
}, toJSONObject: (e9) => {
  const t2 = new Array(10), i2 = (e10, n2) => {
    if (rf(e10)) {
      if (t2.indexOf(e10) >= 0) return;
      if (!("toJSON" in e10)) {
        t2[n2] = e10;
        const r2 = QE(e10) ? [] : {};
        return Ef(e10, (e11, t3) => {
          const o2 = i2(e11, n2 + 1);
          !ZE(o2) && (r2[t3] = o2);
        }), t2[n2] = void 0, r2;
      }
    }
    return e10;
  };
  return i2(e9, 0);
}, isAsyncFn: wf, isThenable: (e9) => e9 && (rf(e9) || tf(e9)) && tf(e9.then) && tf(e9.catch), setImmediate: Of, asap: kf };
function Uf(e9, t2, i2, n2, r2) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e9, this.name = "AxiosError", t2 && (this.code = t2), i2 && (this.config = i2), n2 && (this.request = n2), r2 && (this.response = r2, this.status = r2.status ? r2.status : null);
}
Mf.inherits(Uf, Error, { toJSON: function() {
  return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: Mf.toJSONObject(this.config), code: this.code, status: this.status };
} });
var xf = Uf.prototype;
var Vf = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e9) => {
  Vf[e9] = { value: e9 };
}), Object.defineProperties(Uf, Vf), Object.defineProperty(xf, "isAxiosError", { value: true }), Uf.from = (e9, t2, i2, n2, r2, o2) => {
  const s2 = Object.create(xf);
  return Mf.toFlatObject(e9, s2, function(e10) {
    return e10 !== Error.prototype;
  }, (e10) => "isAxiosError" !== e10), Uf.call(s2, e9.message, t2, i2, n2, r2), s2.cause = e9, s2.name = e9.name, o2 && Object.assign(s2, o2), s2;
};
function Ff(e9) {
  return Mf.isPlainObject(e9) || Mf.isArray(e9);
}
function Bf(e9) {
  return Mf.endsWith(e9, "[]") ? e9.slice(0, -2) : e9;
}
function jf(e9, t2, i2) {
  return e9 ? e9.concat(t2).map(function(e10, t3) {
    return e10 = Bf(e10), !i2 && t3 ? "[" + e10 + "]" : e10;
  }).join(i2 ? "." : "") : t2;
}
var Gf = Mf.toFlatObject(Mf, {}, null, function(e9) {
  return /^is[A-Z]/.test(e9);
});
function Wf(e9, t2, i2) {
  if (!Mf.isObject(e9)) throw new TypeError("target must be an object");
  t2 = t2 || new FormData();
  const n2 = (i2 = Mf.toFlatObject(i2, { metaTokens: true, dots: false, indexes: false }, false, function(e10, t3) {
    return !Mf.isUndefined(t3[e10]);
  })).metaTokens, r2 = i2.visitor || d2, o2 = i2.dots, s2 = i2.indexes, a2 = (i2.Blob || "undefined" != typeof Blob && Blob) && Mf.isSpecCompliantForm(t2);
  if (!Mf.isFunction(r2)) throw new TypeError("visitor must be a function");
  function c2(e10) {
    if (null === e10) return "";
    if (Mf.isDate(e10)) return e10.toISOString();
    if (!a2 && Mf.isBlob(e10)) throw new Uf("Blob is not supported. Use a Buffer instead.");
    return Mf.isArrayBuffer(e10) || Mf.isTypedArray(e10) ? a2 && "function" == typeof Blob ? new Blob([e10]) : Buffer.from(e10) : e10;
  }
  function d2(e10, i3, r3) {
    let a3 = e10;
    if (e10 && !r3 && "object" == typeof e10) {
      if (Mf.endsWith(i3, "{}")) i3 = n2 ? i3 : i3.slice(0, -2), e10 = JSON.stringify(e10);
      else if (Mf.isArray(e10) && function(e11) {
        return Mf.isArray(e11) && !e11.some(Ff);
      }(e10) || (Mf.isFileList(e10) || Mf.endsWith(i3, "[]")) && (a3 = Mf.toArray(e10))) return i3 = Bf(i3), a3.forEach(function(e11, n3) {
        !Mf.isUndefined(e11) && null !== e11 && t2.append(true === s2 ? jf([i3], n3, o2) : null === s2 ? i3 : i3 + "[]", c2(e11));
      }), false;
    }
    return !!Ff(e10) || (t2.append(jf(r3, i3, o2), c2(e10)), false);
  }
  const l2 = [], u2 = Object.assign(Gf, { defaultVisitor: d2, convertValue: c2, isVisitable: Ff });
  if (!Mf.isObject(e9)) throw new TypeError("data must be an object");
  return function e10(i3, n3) {
    if (!Mf.isUndefined(i3)) {
      if (-1 !== l2.indexOf(i3)) throw Error("Circular reference detected in " + n3.join("."));
      l2.push(i3), Mf.forEach(i3, function(i4, o3) {
        true === (!(Mf.isUndefined(i4) || null === i4) && r2.call(t2, i4, Mf.isString(o3) ? jp(o3).call(o3) : o3, n3, u2)) && e10(i4, n3 ? n3.concat(o3) : [o3]);
      }), l2.pop();
    }
  }(e9), t2;
}
function Hf(e9) {
  const t2 = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
  return encodeURIComponent(e9).replace(/[!'()~]|%20|%00/g, function(e10) {
    return t2[e10];
  });
}
function Kf(e9, t2) {
  this._pairs = [], e9 && Wf(e9, this, t2);
}
var Yf = Kf.prototype;
function qf(e9) {
  return encodeURIComponent(e9).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function zf(e9, t2, i2) {
  if (!t2) return e9;
  const n2 = i2 && i2.encode || qf, r2 = i2 && i2.serialize;
  let o2;
  if (o2 = r2 ? r2(t2, i2) : Mf.isURLSearchParams(t2) ? t2.toString() : new Kf(t2, i2).toString(n2), o2) {
    const t3 = e9.indexOf("#");
    -1 !== t3 && (e9 = e9.slice(0, t3)), e9 += (-1 === e9.indexOf("?") ? "?" : "&") + o2;
  }
  return e9;
}
Yf.append = function(e9, t2) {
  this._pairs.push([e9, t2]);
}, Yf.toString = function(e9) {
  const t2 = e9 ? function(t3) {
    return e9.call(this, t3, Hf);
  } : Hf;
  return this._pairs.map(function(e10) {
    return t2(e10[0]) + "=" + t2(e10[1]);
  }, "").join("&");
};
var Jf = class {
  constructor() {
    this.handlers = [];
  }
  use(e9, t2, i2) {
    return this.handlers.push({ fulfilled: e9, rejected: t2, synchronous: !!i2 && i2.synchronous, runWhen: i2 ? i2.runWhen : null }), this.handlers.length - 1;
  }
  eject(e9) {
    this.handlers[e9] && (this.handlers[e9] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach(e9) {
    Mf.forEach(this.handlers, function(t2) {
      null !== t2 && e9(t2);
    });
  }
};
var Xf = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false };
var Qf = { exports: {} };
var Zf = wi;
var $f = N;
var em = Qt.f;
Zf({ target: "Object", stat: true, forced: Object.defineProperty !== em, sham: !$f }, { defineProperty: em });
var tm = ie.Object;
var im = Qf.exports = function(e9, t2, i2) {
  return tm.defineProperty(e9, t2, i2);
};
tm.defineProperty.sham && (im.sham = true);
var nm = i(Qf.exports);
var rm = R;
var om = Array.isArray || function(e9) {
  return "Array" == rm(e9);
};
var sm = TypeError;
var am = om;
var cm = jc;
var dm = te;
var lm = ht("species");
var um = Array;
var hm = function(e9) {
  var t2;
  return am(e9) && (t2 = e9.constructor, (cm(t2) && (t2 === um || am(t2.prototype)) || dm(t2) && null === (t2 = t2[lm])) && (t2 = void 0)), void 0 === t2 ? um : t2;
};
var pm = function(e9, t2) {
  return new (hm(e9))(0 === t2 ? 0 : t2);
};
var _m = n;
var Em = Ee;
var fm = ht("species");
var mm = function(e9) {
  return Em >= 51 || !_m(function() {
    var t2 = [];
    return (t2.constructor = {})[fm] = function() {
      return { foo: 1 };
    }, 1 !== t2[e9](Boolean).foo;
  });
};
var Tm = wi;
var Sm = n;
var gm = om;
var Rm = te;
var Cm = Je;
var Im = Gi;
var vm = function(e9) {
  if (e9 > 9007199254740991) throw sm("Maximum allowed index exceeded");
  return e9;
};
var ym = E_;
var Am = pm;
var bm = mm;
var wm = Ee;
var Om = ht("isConcatSpreadable");
var Nm = wm >= 51 || !Sm(function() {
  var e9 = [];
  return e9[Om] = false, e9.concat()[0] !== e9;
});
var Dm = function(e9) {
  if (!Rm(e9)) return false;
  var t2 = e9[Om];
  return void 0 !== t2 ? !!t2 : gm(e9);
};
Tm({ target: "Array", proto: true, arity: 1, forced: !Nm || !bm("concat") }, { concat: function(e9) {
  var t2, i2, n2, r2, o2, s2 = Cm(this), a2 = Am(s2, 0), c2 = 0;
  for (t2 = -1, n2 = arguments.length; t2 < n2; t2++) if (Dm(o2 = -1 === t2 ? s2 : arguments[t2])) for (r2 = Im(o2), vm(c2 + r2), i2 = 0; i2 < r2; i2++, c2++) i2 in o2 && ym(a2, c2, o2[i2]);
  else vm(c2 + 1), ym(a2, c2++, o2);
  return a2.length = c2, a2;
} });
var Pm = {};
var Lm = R;
var km = Z;
var Mm = Or.f;
var Um = R_;
var xm = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
Pm.f = function(e9) {
  return xm && "Window" == Lm(e9) ? function(e10) {
    try {
      return Mm(e10);
    } catch (e11) {
      return Um(xm);
    }
  }(e9) : Mm(km(e9));
};
var Vm = {};
var Fm = ht;
Vm.f = Fm;
var Bm = ie;
var jm = Ze;
var Gm = Vm;
var Wm = Qt.f;
var Hm = function(e9) {
  var t2 = Bm.Symbol || (Bm.Symbol = {});
  jm(t2, e9) || Wm(t2, e9, { value: Gm.f(e9) });
};
var Km = L;
var Ym = ae;
var qm = ht;
var zm = ha;
var Jm = function() {
  var e9 = Ym("Symbol"), t2 = e9 && e9.prototype, i2 = t2 && t2.valueOf, n2 = qm("toPrimitive");
  t2 && !t2[n2] && zm(t2, n2, function(e10) {
    return Km(i2, this);
  }, { arity: 1 });
};
var Xm = Xt;
var Qm = K;
var Zm = Je;
var $m = Gi;
var eT = pm;
var tT = d([].push);
var iT = function(e9) {
  var t2 = 1 == e9, i2 = 2 == e9, n2 = 3 == e9, r2 = 4 == e9, o2 = 6 == e9, s2 = 7 == e9, a2 = 5 == e9 || o2;
  return function(c2, d2, l2, u2) {
    for (var h2, p2, _2 = Zm(c2), E2 = Qm(_2), f2 = Xm(d2, l2), m2 = $m(E2), T2 = 0, S2 = u2 || eT, g2 = t2 ? S2(c2, m2) : i2 || s2 ? S2(c2, 0) : void 0; m2 > T2; T2++) if ((a2 || T2 in E2) && (p2 = f2(h2 = E2[T2], T2, _2), e9)) if (t2) g2[T2] = p2;
    else if (p2) switch (e9) {
      case 3:
        return true;
      case 5:
        return h2;
      case 6:
        return T2;
      case 2:
        tT(g2, h2);
    }
    else switch (e9) {
      case 4:
        return false;
      case 7:
        tT(g2, h2);
    }
    return o2 ? -1 : n2 || r2 ? r2 : g2;
  };
};
var nT = { forEach: iT(0), map: iT(1), filter: iT(2), some: iT(3), every: iT(4), find: iT(5), findIndex: iT(6), filterReject: iT(7) };
var rT = wi;
var oT = h;
var sT = L;
var aT = d;
var cT = N;
var dT = Se;
var lT = n;
var uT = Ze;
var hT = l;
var pT = ii;
var _T = Z;
var ET = Ct;
var fT = fn;
var mT = B;
var TT = Io;
var ST = eo;
var gT = Or;
var RT = Pm;
var CT = Br;
var IT = O;
var vT = Qt;
var yT = Qr;
var AT = k;
var bT = ha;
var wT = hc;
var OT = Ye;
var NT = Nr;
var DT = nt;
var PT = ht;
var LT = Vm;
var kT = Hm;
var MT = Jm;
var UT = Da;
var xT = ra;
var VT = nT.forEach;
var FT = lr("hidden");
var BT = "Symbol";
var jT = "prototype";
var GT = xT.set;
var WT = xT.getterFor(BT);
var HT = Object[jT];
var KT = oT.Symbol;
var YT = KT && KT[jT];
var qT = oT.TypeError;
var zT = oT.QObject;
var JT = IT.f;
var XT = vT.f;
var QT = RT.f;
var ZT = AT.f;
var $T = aT([].push);
var eS = OT("symbols");
var tS = OT("op-symbols");
var iS = OT("wks");
var nS = !zT || !zT[jT] || !zT[jT].findChild;
var rS = cT && lT(function() {
  return 7 != TT(XT({}, "a", { get: function() {
    return XT(this, "a", { value: 7 }).a;
  } })).a;
}) ? function(e9, t2, i2) {
  var n2 = JT(HT, t2);
  n2 && delete HT[t2], XT(e9, t2, i2), n2 && e9 !== HT && XT(HT, t2, n2);
} : XT;
var oS = function(e9, t2) {
  var i2 = eS[e9] = TT(YT);
  return GT(i2, { type: BT, tag: e9, description: t2 }), cT || (i2.description = t2), i2;
};
var sS = function(e9, t2, i2) {
  e9 === HT && sS(tS, t2, i2), pT(e9);
  var n2 = ET(t2);
  return pT(i2), uT(eS, n2) ? (i2.enumerable ? (uT(e9, FT) && e9[FT][n2] && (e9[FT][n2] = false), i2 = TT(i2, { enumerable: mT(0, false) })) : (uT(e9, FT) || XT(e9, FT, mT(1, {})), e9[FT][n2] = true), rS(e9, n2, i2)) : XT(e9, n2, i2);
};
var aS = function(e9, t2) {
  pT(e9);
  var i2 = _T(t2), n2 = ST(i2).concat(uS(i2));
  return VT(n2, function(t3) {
    cT && !sT(cS, i2, t3) || sS(e9, t3, i2[t3]);
  }), e9;
};
var cS = function(e9) {
  var t2 = ET(e9), i2 = sT(ZT, this, t2);
  return !(this === HT && uT(eS, t2) && !uT(tS, t2)) && (!(i2 || !uT(this, t2) || !uT(eS, t2) || uT(this, FT) && this[FT][t2]) || i2);
};
var dS = function(e9, t2) {
  var i2 = _T(e9), n2 = ET(t2);
  if (i2 !== HT || !uT(eS, n2) || uT(tS, n2)) {
    var r2 = JT(i2, n2);
    return !r2 || !uT(eS, n2) || uT(i2, FT) && i2[FT][n2] || (r2.enumerable = true), r2;
  }
};
var lS = function(e9) {
  var t2 = QT(_T(e9)), i2 = [];
  return VT(t2, function(e10) {
    uT(eS, e10) || uT(NT, e10) || $T(i2, e10);
  }), i2;
};
var uS = function(e9) {
  var t2 = e9 === HT, i2 = QT(t2 ? tS : _T(e9)), n2 = [];
  return VT(i2, function(e10) {
    !uT(eS, e10) || t2 && !uT(HT, e10) || $T(n2, eS[e10]);
  }), n2;
};
dT || (bT(YT = (KT = function() {
  if (hT(YT, this)) throw qT("Symbol is not a constructor");
  var e9 = arguments.length && void 0 !== arguments[0] ? fT(arguments[0]) : void 0, t2 = DT(e9), i2 = function(e10) {
    this === HT && sT(i2, tS, e10), uT(this, FT) && uT(this[FT], t2) && (this[FT][t2] = false), rS(this, t2, mT(1, e10));
  };
  return cT && nS && rS(HT, t2, { configurable: true, set: i2 }), oS(t2, e9);
})[jT], "toString", function() {
  return WT(this).tag;
}), bT(KT, "withoutSetter", function(e9) {
  return oS(DT(e9), e9);
}), AT.f = cS, vT.f = sS, yT.f = aS, IT.f = dS, gT.f = RT.f = lS, CT.f = uS, LT.f = function(e9) {
  return oS(PT(e9), e9);
}, cT && wT(YT, "description", { configurable: true, get: function() {
  return WT(this).description;
} })), rT({ global: true, constructor: true, wrap: true, forced: !dT, sham: !dT }, { Symbol: KT }), VT(ST(iS), function(e9) {
  kT(e9);
}), rT({ target: BT, stat: true, forced: !dT }, { useSetter: function() {
  nS = true;
}, useSimple: function() {
  nS = false;
} }), rT({ target: "Object", stat: true, forced: !dT, sham: !cT }, { create: function(e9, t2) {
  return void 0 === t2 ? TT(e9) : aS(TT(e9), t2);
}, defineProperty: sS, defineProperties: aS, getOwnPropertyDescriptor: dS }), rT({ target: "Object", stat: true, forced: !dT }, { getOwnPropertyNames: lS }), MT(), UT(KT, BT), NT[FT] = true;
var hS = Se && !!Symbol.for && !!Symbol.keyFor;
var pS = wi;
var _S = ae;
var ES = Ze;
var fS = fn;
var mS = Ye;
var TS = hS;
var SS = mS("string-to-symbol-registry");
var gS = mS("symbol-to-string-registry");
pS({ target: "Symbol", stat: true, forced: !TS }, { for: function(e9) {
  var t2 = fS(e9);
  if (ES(SS, t2)) return SS[t2];
  var i2 = _S("Symbol")(t2);
  return SS[t2] = i2, gS[i2] = t2, i2;
} });
var RS = wi;
var CS = Ze;
var IS = ye;
var vS = be;
var yS = hS;
var AS = Ye("symbol-to-string-registry");
RS({ target: "Symbol", stat: true, forced: !yS }, { keyFor: function(e9) {
  if (!IS(e9)) throw TypeError(vS(e9) + " is not a symbol");
  if (CS(AS, e9)) return AS[e9];
} });
var bS = om;
var wS = w;
var OS = R;
var NS = fn;
var DS = d([].push);
var PS = wi;
var LS = ae;
var kS = m;
var MS = L;
var US = d;
var xS = n;
var VS = w;
var FS = ye;
var BS = Xc;
var jS = function(e9) {
  if (wS(e9)) return e9;
  if (bS(e9)) {
    for (var t2 = e9.length, i2 = [], n2 = 0; n2 < t2; n2++) {
      var r2 = e9[n2];
      "string" == typeof r2 ? DS(i2, r2) : "number" != typeof r2 && "Number" != OS(r2) && "String" != OS(r2) || DS(i2, NS(r2));
    }
    var o2 = i2.length, s2 = true;
    return function(e10, t3) {
      if (s2) return s2 = false, t3;
      if (bS(this)) return t3;
      for (var n3 = 0; n3 < o2; n3++) if (i2[n3] === e10) return t3;
    };
  }
};
var GS = Se;
var WS = String;
var HS = LS("JSON", "stringify");
var KS = US(/./.exec);
var YS = US("".charAt);
var qS = US("".charCodeAt);
var zS = US("".replace);
var JS = US(1 .toString);
var XS = /[\uD800-\uDFFF]/g;
var QS = /^[\uD800-\uDBFF]$/;
var ZS = /^[\uDC00-\uDFFF]$/;
var $S = !GS || xS(function() {
  var e9 = LS("Symbol")();
  return "[null]" != HS([e9]) || "{}" != HS({ a: e9 }) || "{}" != HS(Object(e9));
});
var eg = xS(function() {
  return '"\\udf06\\ud834"' !== HS("\uDF06\uD834") || '"\\udead"' !== HS("\uDEAD");
});
var tg = function(e9, t2) {
  var i2 = BS(arguments), n2 = jS(t2);
  if (VS(n2) || void 0 !== e9 && !FS(e9)) return i2[1] = function(e10, t3) {
    if (VS(n2) && (t3 = MS(n2, this, WS(e10), t3)), !FS(t3)) return t3;
  }, kS(HS, null, i2);
};
var ig = function(e9, t2, i2) {
  var n2 = YS(i2, t2 - 1), r2 = YS(i2, t2 + 1);
  return KS(QS, e9) && !KS(ZS, r2) || KS(ZS, e9) && !KS(QS, n2) ? "\\u" + JS(qS(e9, 0), 16) : e9;
};
HS && PS({ target: "JSON", stat: true, arity: 3, forced: $S || eg }, { stringify: function(e9, t2, i2) {
  var n2 = BS(arguments), r2 = kS($S ? tg : HS, null, n2);
  return eg && "string" == typeof r2 ? zS(r2, XS, ig) : r2;
} });
var ng = Br;
var rg = Je;
wi({ target: "Object", stat: true, forced: !Se || n(function() {
  ng.f(1);
}) }, { getOwnPropertySymbols: function(e9) {
  var t2 = ng.f;
  return t2 ? t2(rg(e9)) : [];
} }), Hm("asyncIterator"), Hm("hasInstance"), Hm("isConcatSpreadable"), Hm("iterator"), Hm("match"), Hm("matchAll"), Hm("replace"), Hm("search"), Hm("species"), Hm("split");
var og = Jm;
Hm("toPrimitive"), og();
var sg = ae;
var ag = Da;
Hm("toStringTag"), ag(sg("Symbol"), "Symbol"), Hm("unscopables"), Da(h.JSON, "JSON", true);
var cg = ie.Symbol;
var dg = ht;
var lg = Qt.f;
var ug = dg("metadata");
var hg = Function.prototype;
void 0 === hg[ug] && lg(hg, ug, { value: null }), Hm("dispose"), Hm("metadata");
var pg = cg;
Hm("asyncDispose");
var _g = d;
var Eg = ae("Symbol");
var fg = Eg.keyFor;
var mg = _g(Eg.prototype.valueOf);
var Tg = Eg.isRegisteredSymbol || function(e9) {
  try {
    return void 0 !== fg(mg(e9));
  } catch (e10) {
    return false;
  }
};
wi({ target: "Symbol", stat: true }, { isRegisteredSymbol: Tg });
for (Sg = Ye, gg = ae, Rg = d, Cg = ye, Ig = ht, vg = gg("Symbol"), yg = vg.isWellKnownSymbol, Ag = gg("Object", "getOwnPropertyNames"), bg = Rg(vg.prototype.valueOf), wg = Sg("wks"), Og = 0, Ng = Ag(vg), Dg = Ng.length; Og < Dg; Og++) try {
  Pg = Ng[Og];
  Cg(vg[Pg]) && Ig(Pg);
} catch (e9) {
}
var Pg;
var Sg;
var gg;
var Rg;
var Cg;
var Ig;
var vg;
var yg;
var Ag;
var bg;
var wg;
var Og;
var Ng;
var Dg;
var Lg = function(e9) {
  if (yg && yg(e9)) return true;
  try {
    for (var t2 = bg(e9), i2 = 0, n2 = Ag(wg), r2 = n2.length; i2 < r2; i2++) if (wg[n2[i2]] == t2) return true;
  } catch (e10) {
  }
  return false;
};
wi({ target: "Symbol", stat: true, forced: true }, { isWellKnownSymbol: Lg }), Hm("matcher"), Hm("observable"), wi({ target: "Symbol", stat: true, name: "isRegisteredSymbol" }, { isRegistered: Tg }), wi({ target: "Symbol", stat: true, name: "isWellKnownSymbol", forced: true }, { isWellKnown: Lg }), Hm("metadataKey"), Hm("patternMatch"), Hm("replaceAll");
var kg = i(pg);
var Mg = i(Vm.f("iterator"));
function Ug(e9) {
  return Ug = "function" == typeof kg && "symbol" == typeof Mg ? function(e10) {
    return typeof e10;
  } : function(e10) {
    return e10 && "function" == typeof kg && e10.constructor === kg && e10 !== kg.prototype ? "symbol" : typeof e10;
  }, Ug(e9);
}
var xg = i(Vm.f("toPrimitive"));
function Vg(e9) {
  var t2 = function(e10, t3) {
    if ("object" !== Ug(e10) || null === e10) return e10;
    var i2 = e10[xg];
    if (void 0 !== i2) {
      var n2 = i2.call(e10, t3 || "default");
      if ("object" !== Ug(n2)) return n2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === t3 ? String : Number)(e10);
  }(e9, "string");
  return "symbol" === Ug(t2) ? t2 : String(t2);
}
function Fg(e9, t2, i2) {
  return (t2 = Vg(t2)) in e9 ? nm(e9, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e9[t2] = i2, e9;
}
var Bg = n;
var jg = ht("iterator");
var Gg = !Bg(function() {
  var e9 = new URL("b?a=1&b=2&c=3", "http://a"), t2 = e9.searchParams, i2 = new URLSearchParams("a=1&a=2"), n2 = "";
  return e9.pathname = "c%20d", t2.forEach(function(e10, i3) {
    t2.delete("b"), n2 += i3 + e10;
  }), i2.delete("a", 2), !e9.toJSON || !i2.has("a", 1) || i2.has("a", 2) || !t2.size && true || !t2.sort || "http://a/c%20d?a=1&c=3" !== e9.href || "3" !== t2.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t2[jg] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://ÑÐµÑÑ").host || "#%D0%B1" !== new URL("http://a#Ð±").hash || "a1c3" !== n2 || "x" !== new URL("http://x", void 0).host;
});
var Wg = ha;
var Hg = wi;
var Kg = h;
var Yg = L;
var qg = d;
var zg = N;
var Jg = Gg;
var Xg = ha;
var Qg = hc;
var Zg = function(e9, t2, i2) {
  for (var n2 in t2) i2 && i2.unsafe && e9[n2] ? e9[n2] = t2[n2] : Wg(e9, n2, t2[n2], i2);
  return e9;
};
var $g = Da;
var eR = Va;
var tR = ra;
var iR = Sc;
var nR = w;
var rR = Ze;
var oR = Xt;
var sR = pn;
var aR = ii;
var cR = te;
var dR = fn;
var lR = Io;
var uR = B;
var hR = es;
var pR = qo;
var _R = Zc;
var ER = b_;
var fR = ht("iterator");
var mR = "URLSearchParams";
var TR = mR + "Iterator";
var SR = tR.set;
var gR = tR.getterFor(mR);
var RR = tR.getterFor(TR);
var CR = Object.getOwnPropertyDescriptor;
var IR = function(e9) {
  if (!zg) return Kg[e9];
  var t2 = CR(Kg, e9);
  return t2 && t2.value;
};
var vR = IR("fetch");
var yR = IR("Request");
var AR = IR("Headers");
var bR = yR && yR.prototype;
var wR = AR && AR.prototype;
var OR = Kg.RegExp;
var NR = Kg.TypeError;
var DR = Kg.decodeURIComponent;
var PR = Kg.encodeURIComponent;
var LR = qg("".charAt);
var kR = qg([].join);
var MR = qg([].push);
var UR = qg("".replace);
var xR = qg([].shift);
var VR = qg([].splice);
var FR = qg("".split);
var BR = qg("".slice);
var jR = /\+/g;
var GR = Array(4);
var WR = function(e9) {
  return GR[e9 - 1] || (GR[e9 - 1] = OR("((?:%[\\da-f]{2}){" + e9 + "})", "gi"));
};
var HR = function(e9) {
  try {
    return DR(e9);
  } catch (t2) {
    return e9;
  }
};
var KR = function(e9) {
  var t2 = UR(e9, jR, " "), i2 = 4;
  try {
    return DR(t2);
  } catch (e10) {
    for (; i2; ) t2 = UR(t2, WR(i2--), HR);
    return t2;
  }
};
var YR = /[!'()~]|%20/g;
var qR = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" };
var zR = function(e9) {
  return qR[e9];
};
var JR = function(e9) {
  return UR(PR(e9), YR, zR);
};
var XR = eR(function(e9, t2) {
  SR(this, { type: TR, iterator: hR(gR(e9).entries), kind: t2 });
}, "Iterator", function() {
  var e9 = RR(this), t2 = e9.kind, i2 = e9.iterator.next(), n2 = i2.value;
  return i2.done || (i2.value = "keys" === t2 ? n2.key : "values" === t2 ? n2.value : [n2.key, n2.value]), i2;
}, true);
var QR = function(e9) {
  this.entries = [], this.url = null, void 0 !== e9 && (cR(e9) ? this.parseObject(e9) : this.parseQuery("string" == typeof e9 ? "?" === LR(e9, 0) ? BR(e9, 1) : e9 : dR(e9)));
};
QR.prototype = { type: mR, bindURL: function(e9) {
  this.url = e9, this.update();
}, parseObject: function(e9) {
  var t2, i2, n2, r2, o2, s2, a2, c2 = pR(e9);
  if (c2) for (i2 = (t2 = hR(e9, c2)).next; !(n2 = Yg(i2, t2)).done; ) {
    if (o2 = (r2 = hR(aR(n2.value))).next, (s2 = Yg(o2, r2)).done || (a2 = Yg(o2, r2)).done || !Yg(o2, r2).done) throw NR("Expected sequence with length 2");
    MR(this.entries, { key: dR(s2.value), value: dR(a2.value) });
  }
  else for (var d2 in e9) rR(e9, d2) && MR(this.entries, { key: d2, value: dR(e9[d2]) });
}, parseQuery: function(e9) {
  if (e9) for (var t2, i2, n2 = FR(e9, "&"), r2 = 0; r2 < n2.length; ) (t2 = n2[r2++]).length && (i2 = FR(t2, "="), MR(this.entries, { key: KR(xR(i2)), value: KR(kR(i2, "=")) }));
}, serialize: function() {
  for (var e9, t2 = this.entries, i2 = [], n2 = 0; n2 < t2.length; ) e9 = t2[n2++], MR(i2, JR(e9.key) + "=" + JR(e9.value));
  return kR(i2, "&");
}, update: function() {
  this.entries.length = 0, this.parseQuery(this.url.query);
}, updateURL: function() {
  this.url && this.url.update();
} };
var ZR = function() {
  iR(this, $R);
  var e9 = SR(this, new QR(arguments.length > 0 ? arguments[0] : void 0));
  zg || (this.size = e9.entries.length);
};
var $R = ZR.prototype;
if (Zg($R, { append: function(e9, t2) {
  var i2 = gR(this);
  _R(arguments.length, 2), MR(i2.entries, { key: dR(e9), value: dR(t2) }), zg || this.length++, i2.updateURL();
}, delete: function(e9) {
  for (var t2 = gR(this), i2 = _R(arguments.length, 1), n2 = t2.entries, r2 = dR(e9), o2 = i2 < 2 ? void 0 : arguments[1], s2 = void 0 === o2 ? o2 : dR(o2), a2 = 0; a2 < n2.length; ) {
    var c2 = n2[a2];
    if (c2.key !== r2 || void 0 !== s2 && c2.value !== s2) a2++;
    else if (VR(n2, a2, 1), void 0 !== s2) break;
  }
  zg || (this.size = n2.length), t2.updateURL();
}, get: function(e9) {
  var t2 = gR(this).entries;
  _R(arguments.length, 1);
  for (var i2 = dR(e9), n2 = 0; n2 < t2.length; n2++) if (t2[n2].key === i2) return t2[n2].value;
  return null;
}, getAll: function(e9) {
  var t2 = gR(this).entries;
  _R(arguments.length, 1);
  for (var i2 = dR(e9), n2 = [], r2 = 0; r2 < t2.length; r2++) t2[r2].key === i2 && MR(n2, t2[r2].value);
  return n2;
}, has: function(e9) {
  for (var t2 = gR(this).entries, i2 = _R(arguments.length, 1), n2 = dR(e9), r2 = i2 < 2 ? void 0 : arguments[1], o2 = void 0 === r2 ? r2 : dR(r2), s2 = 0; s2 < t2.length; ) {
    var a2 = t2[s2++];
    if (a2.key === n2 && (void 0 === o2 || a2.value === o2)) return true;
  }
  return false;
}, set: function(e9, t2) {
  var i2 = gR(this);
  _R(arguments.length, 1);
  for (var n2, r2 = i2.entries, o2 = false, s2 = dR(e9), a2 = dR(t2), c2 = 0; c2 < r2.length; c2++) (n2 = r2[c2]).key === s2 && (o2 ? VR(r2, c2--, 1) : (o2 = true, n2.value = a2));
  o2 || MR(r2, { key: s2, value: a2 }), zg || (this.size = r2.length), i2.updateURL();
}, sort: function() {
  var e9 = gR(this);
  ER(e9.entries, function(e10, t2) {
    return e10.key > t2.key ? 1 : -1;
  }), e9.updateURL();
}, forEach: function(e9) {
  for (var t2, i2 = gR(this).entries, n2 = oR(e9, arguments.length > 1 ? arguments[1] : void 0), r2 = 0; r2 < i2.length; ) n2((t2 = i2[r2++]).value, t2.key, this);
}, keys: function() {
  return new XR(this, "keys");
}, values: function() {
  return new XR(this, "values");
}, entries: function() {
  return new XR(this, "entries");
} }, { enumerable: true }), Xg($R, fR, $R.entries, { name: "entries" }), Xg($R, "toString", function() {
  return gR(this).serialize();
}, { enumerable: true }), zg && Qg($R, "size", { get: function() {
  return gR(this).entries.length;
}, configurable: true, enumerable: true }), $g(ZR, mR), Hg({ global: true, constructor: true, forced: !Jg }, { URLSearchParams: ZR }), !Jg && nR(AR)) {
  eC = qg(wR.has), tC = qg(wR.set), iC = function(e9) {
    if (cR(e9)) {
      var t2, i2 = e9.body;
      if (sR(i2) === mR) return t2 = e9.headers ? new AR(e9.headers) : new AR(), eC(t2, "content-type") || tC(t2, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), lR(e9, { body: uR(0, dR(i2)), headers: uR(0, t2) });
    }
    return e9;
  };
  if (nR(vR) && Hg({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, { fetch: function(e9) {
    return vR(e9, arguments.length > 1 ? iC(arguments[1]) : {});
  } }), nR(yR)) {
    nC = function(e9) {
      return iR(this, bR), new yR(e9, arguments.length > 1 ? iC(arguments[1]) : {});
    };
    bR.constructor = nC, nC.prototype = bR, Hg({ global: true, constructor: true, dontCallGetSet: true, forced: true }, { Request: nC });
  }
}
var eC;
var tC;
var iC;
var nC;
var rC = { URLSearchParams: ZR, getState: gR };
var oC = i(ie.URLSearchParams);
var sC = { isBrowser: true, classes: { URLSearchParams: void 0 !== oC ? oC : Kf, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] };
var aC = "undefined" != typeof window && "undefined" != typeof document;
var cC = "object" == typeof navigator && navigator || void 0;
var dC = aC && (!cC || ["ReactNative", "NativeScript", "NS"].indexOf(cC.product) < 0);
var lC = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts;
var uC = aC && window.location.href || "http://localhost";
function hC(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function pC(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? hC(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : hC(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var _C = pC(pC({}, Object.freeze({ __proto__: null, hasBrowserEnv: aC, hasStandardBrowserEnv: dC, hasStandardBrowserWebWorkerEnv: lC, navigator: cC, origin: uC })), sC);
var EC = ii;
var fC = L;
var mC = Ze;
var TC = l;
var SC = function() {
  var e9 = EC(this), t2 = "";
  return e9.hasIndices && (t2 += "d"), e9.global && (t2 += "g"), e9.ignoreCase && (t2 += "i"), e9.multiline && (t2 += "m"), e9.dotAll && (t2 += "s"), e9.unicode && (t2 += "u"), e9.unicodeSets && (t2 += "v"), e9.sticky && (t2 += "y"), t2;
};
var gC = RegExp.prototype;
var RC = function(e9) {
  var t2 = e9.flags;
  return void 0 !== t2 || "flags" in gC || mC(e9, "flags") || !TC(gC, e9) ? t2 : fC(SC, e9);
};
var CC = Ch.charAt;
var IC = L;
var vC = ii;
var yC = w;
var AC = R;
var bC = /./.exec;
var wC = TypeError;
var OC = wi;
var NC = L;
var DC = v;
var PC = Va;
var LC = ic;
var kC = J;
var MC = Bi;
var UC = fn;
var xC = ii;
var VC = Y;
var FC = R;
var BC = tn;
var jC = RC;
var GC = ke;
var WC = n;
var HC = Jc;
var KC = function(e9, t2, i2) {
  return t2 + (i2 ? CC(e9, t2).length : 1);
};
var YC = function(e9, t2) {
  var i2 = e9.exec;
  if (yC(i2)) {
    var n2 = IC(i2, e9, t2);
    return null !== n2 && vC(n2), n2;
  }
  if ("RegExp" === AC(e9)) return IC(bC, e9, t2);
  throw wC("RegExp#exec called on incompatible receiver");
};
var qC = ra;
var zC = ht("matchAll");
var JC = "RegExp String";
var XC = JC + " Iterator";
var QC = qC.set;
var ZC = qC.getterFor(XC);
var $C = TypeError;
var eI = DC("".indexOf);
var tI = DC("".matchAll);
var iI = !!tI && !WC(function() {
  tI("a", /./);
});
var nI = PC(function(e9, t2, i2, n2) {
  QC(this, { type: XC, regexp: e9, string: t2, global: i2, unicode: n2, done: false });
}, JC, function() {
  var e9 = ZC(this);
  if (e9.done) return LC(void 0, true);
  var t2 = e9.regexp, i2 = e9.string, n2 = YC(t2, i2);
  return null === n2 ? (e9.done = true, LC(void 0, true)) : e9.global ? ("" === UC(n2[0]) && (t2.lastIndex = KC(i2, MC(t2.lastIndex), e9.unicode)), LC(n2, false)) : (e9.done = true, LC(n2, false));
});
var rI = function(e9) {
  var t2, i2, n2, r2 = xC(this), o2 = UC(e9), s2 = HC(r2, RegExp), a2 = UC(jC(r2));
  return t2 = new s2(s2 === RegExp ? r2.source : r2, a2), i2 = !!~eI(a2, "g"), n2 = !!~eI(a2, "u"), t2.lastIndex = MC(r2.lastIndex), new nI(t2, o2, i2, n2);
};
OC({ target: "String", proto: true, forced: iI }, { matchAll: function(e9) {
  var t2, i2, n2, r2, o2 = kC(this);
  if (VC(e9)) {
    if (iI) return tI(o2, e9);
  } else {
    if (BC(e9) && (t2 = UC(kC(jC(e9))), !~eI(t2, "g"))) throw $C("`.matchAll` does not allow non-global regexes");
    if (iI) return tI(o2, e9);
    if (void 0 === (n2 = GC(e9, zC)) && "RegExp" == FC(e9) && (n2 = rI), n2) return NC(n2, e9, o2);
  }
  return i2 = UC(o2), r2 = new RegExp(e9, "g"), NC(rI, r2, i2);
} });
var oI = Xi("String").matchAll;
var sI = l;
var aI = oI;
var cI = String.prototype;
var dI = function(e9) {
  var t2 = e9.matchAll;
  return "string" == typeof e9 || e9 === cI || sI(cI, e9) && t2 === cI.matchAll ? aI : t2;
};
var lI = i(dI);
function uI(e9) {
  function t2(e10, i2, n2, r2) {
    let o2 = e10[r2++];
    if ("__proto__" === o2) return true;
    const s2 = Number.isFinite(+o2), a2 = r2 >= e10.length;
    if (o2 = !o2 && Mf.isArray(n2) ? n2.length : o2, a2) return Mf.hasOwnProp(n2, o2) ? n2[o2] = [n2[o2], i2] : n2[o2] = i2, !s2;
    n2[o2] && Mf.isObject(n2[o2]) || (n2[o2] = []);
    return t2(e10, i2, n2[o2], r2) && Mf.isArray(n2[o2]) && (n2[o2] = function(e11) {
      const t3 = {}, i3 = Object.keys(e11);
      let n3;
      const r3 = i3.length;
      let o3;
      for (n3 = 0; n3 < r3; n3++) o3 = i3[n3], t3[o3] = e11[o3];
      return t3;
    }(n2[o2])), !s2;
  }
  if (Mf.isFormData(e9) && Mf.isFunction(e9.entries)) {
    const i2 = {};
    return Mf.forEachEntry(e9, (e10, n2) => {
      t2(function(e11) {
        return lI(Mf).call(Mf, /\w+|\[(\w*)]/g, e11).map((e12) => "[]" === e12[0] ? "" : e12[1] || e12[0]);
      }(e10), n2, i2, 0);
    }), i2;
  }
  return null;
}
var hI = { transitional: Xf, adapter: ["xhr", "http", "fetch"], transformRequest: [function(e9, t2) {
  const i2 = t2.getContentType() || "", n2 = i2.indexOf("application/json") > -1, r2 = Mf.isObject(e9);
  r2 && Mf.isHTMLForm(e9) && (e9 = new FormData(e9));
  if (Mf.isFormData(e9)) return n2 ? JSON.stringify(uI(e9)) : e9;
  if (Mf.isArrayBuffer(e9) || Mf.isBuffer(e9) || Mf.isStream(e9) || Mf.isFile(e9) || Mf.isBlob(e9) || Mf.isReadableStream(e9)) return e9;
  if (Mf.isArrayBufferView(e9)) return e9.buffer;
  if (Mf.isURLSearchParams(e9)) return t2.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), e9.toString();
  let o2;
  if (r2) {
    if (i2.indexOf("application/x-www-form-urlencoded") > -1) return function(e10, t3) {
      return Wf(e10, new _C.classes.URLSearchParams(), Object.assign({ visitor: function(e11, t4, i3, n3) {
        return _C.isNode && Mf.isBuffer(e11) ? (this.append(t4, e11.toString("base64")), false) : n3.defaultVisitor.apply(this, arguments);
      } }, t3));
    }(e9, this.formSerializer).toString();
    if ((o2 = Mf.isFileList(e9)) || i2.indexOf("multipart/form-data") > -1) {
      const t3 = this.env && this.env.FormData;
      return Wf(o2 ? { "files[]": e9 } : e9, t3 && new t3(), this.formSerializer);
    }
  }
  return r2 || n2 ? (t2.setContentType("application/json", false), function(e10, t3, i3) {
    if (Mf.isString(e10)) try {
      return (t3 || JSON.parse)(e10), jp(Mf).call(Mf, e10);
    } catch (e11) {
      if ("SyntaxError" !== e11.name) throw e11;
    }
    return (i3 || JSON.stringify)(e10);
  }(e9)) : e9;
}], transformResponse: [function(e9) {
  const t2 = this.transitional || hI.transitional, i2 = t2 && t2.forcedJSONParsing, n2 = "json" === this.responseType;
  if (Mf.isResponse(e9) || Mf.isReadableStream(e9)) return e9;
  if (e9 && Mf.isString(e9) && (i2 && !this.responseType || n2)) {
    const i3 = !(t2 && t2.silentJSONParsing) && n2;
    try {
      return JSON.parse(e9);
    } catch (e10) {
      if (i3) {
        if ("SyntaxError" === e10.name) throw Uf.from(e10, Uf.ERR_BAD_RESPONSE, this, null, this.response);
        throw e10;
      }
    }
  }
  return e9;
}], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: _C.classes.FormData, Blob: _C.classes.Blob }, validateStatus: function(e9) {
  return e9 >= 200 && e9 < 300;
}, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } };
Mf.forEach(["delete", "get", "head", "post", "put", "patch"], (e9) => {
  hI.headers[e9] = {};
});
var pI = hI;
var _I = Mf.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
var EI = Symbol("internals");
function fI(e9) {
  var t2;
  return e9 && jp(t2 = String(e9)).call(t2).toLowerCase();
}
function mI(e9) {
  return false === e9 || null == e9 ? e9 : Mf.isArray(e9) ? e9.map(mI) : String(e9);
}
function TI(e9, t2, i2, n2, r2) {
  return Mf.isFunction(n2) ? n2.call(this, t2, i2) : (r2 && (t2 = i2), Mf.isString(t2) ? Mf.isString(n2) ? -1 !== t2.indexOf(n2) : Mf.isRegExp(n2) ? n2.test(t2) : void 0 : void 0);
}
var SI = class {
  constructor(e9) {
    e9 && this.set(e9);
  }
  set(e9, t2, i2) {
    const n2 = this;
    function r2(e10, t3, i3) {
      const r3 = fI(t3);
      if (!r3) throw new Error("header name must be a non-empty string");
      const o3 = Mf.findKey(n2, r3);
      (!o3 || void 0 === n2[o3] || true === i3 || void 0 === i3 && false !== n2[o3]) && (n2[o3 || t3] = mI(e10));
    }
    const o2 = (e10, t3) => Mf.forEach(e10, (e11, i3) => r2(e11, i3, t3));
    if (Mf.isPlainObject(e9) || e9 instanceof this.constructor) o2(e9, t2);
    else if (Mf.isString(e9) && (e9 = jp(e9).call(e9)) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(jp(s2 = e9).call(s2))) o2(((e10) => {
      const t3 = {};
      let i3, n3, r3;
      return e10 && e10.split("\n").forEach(function(e11) {
        var o3, s3;
        r3 = e11.indexOf(":"), i3 = jp(o3 = e11.substring(0, r3)).call(o3).toLowerCase(), n3 = jp(s3 = e11.substring(r3 + 1)).call(s3), !i3 || t3[i3] && _I[i3] || ("set-cookie" === i3 ? t3[i3] ? t3[i3].push(n3) : t3[i3] = [n3] : t3[i3] = t3[i3] ? t3[i3] + ", " + n3 : n3);
      }), t3;
    })(e9), t2);
    else if (Mf.isHeaders(e9)) for (const [t3, n3] of e9.entries()) r2(n3, t3, i2);
    else null != e9 && r2(t2, e9, i2);
    var s2;
    return this;
  }
  get(e9, t2) {
    if (e9 = fI(e9)) {
      const i2 = Mf.findKey(this, e9);
      if (i2) {
        const e10 = this[i2];
        if (!t2) return e10;
        if (true === t2) return function(e11) {
          const t3 = /* @__PURE__ */ Object.create(null), i3 = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
          let n2;
          for (; n2 = i3.exec(e11); ) t3[n2[1]] = n2[2];
          return t3;
        }(e10);
        if (Mf.isFunction(t2)) return t2.call(this, e10, i2);
        if (Mf.isRegExp(t2)) return t2.exec(e10);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e9, t2) {
    if (e9 = fI(e9)) {
      const i2 = Mf.findKey(this, e9);
      return !(!i2 || void 0 === this[i2] || t2 && !TI(0, this[i2], i2, t2));
    }
    return false;
  }
  delete(e9, t2) {
    const i2 = this;
    let n2 = false;
    function r2(e10) {
      if (e10 = fI(e10)) {
        const r3 = Mf.findKey(i2, e10);
        !r3 || t2 && !TI(0, i2[r3], r3, t2) || (delete i2[r3], n2 = true);
      }
    }
    return Mf.isArray(e9) ? e9.forEach(r2) : r2(e9), n2;
  }
  clear(e9) {
    const t2 = Object.keys(this);
    let i2 = t2.length, n2 = false;
    for (; i2--; ) {
      const r2 = t2[i2];
      e9 && !TI(0, this[r2], r2, e9, true) || (delete this[r2], n2 = true);
    }
    return n2;
  }
  normalize(e9) {
    const t2 = this, i2 = {};
    return Mf.forEach(this, (n2, r2) => {
      var o2;
      const s2 = Mf.findKey(i2, r2);
      if (s2) return t2[s2] = mI(n2), void delete t2[r2];
      const a2 = e9 ? function(e10) {
        return jp(e10).call(e10).toLowerCase().replace(/([a-z\d])(\w*)/g, (e11, t3, i3) => t3.toUpperCase() + i3);
      }(r2) : jp(o2 = String(r2)).call(o2);
      a2 !== r2 && delete t2[r2], t2[a2] = mI(n2), i2[a2] = true;
    }), this;
  }
  concat() {
    for (var e9 = arguments.length, t2 = new Array(e9), i2 = 0; i2 < e9; i2++) t2[i2] = arguments[i2];
    return this.constructor.concat(this, ...t2);
  }
  toJSON(e9) {
    const t2 = /* @__PURE__ */ Object.create(null);
    return Mf.forEach(this, (i2, n2) => {
      null != i2 && false !== i2 && (t2[n2] = e9 && Mf.isArray(i2) ? i2.join(", ") : i2);
    }), t2;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map((e9) => {
      let [t2, i2] = e9;
      return t2 + ": " + i2;
    }).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e9) {
    return e9 instanceof this ? e9 : new this(e9);
  }
  static concat(e9) {
    const t2 = new this(e9);
    for (var i2 = arguments.length, n2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) n2[r2 - 1] = arguments[r2];
    return n2.forEach((e10) => t2.set(e10)), t2;
  }
  static accessor(e9) {
    const t2 = (this[EI] = this[EI] = { accessors: {} }).accessors, i2 = this.prototype;
    function n2(e10) {
      const n3 = fI(e10);
      t2[n3] || (!function(e11, t3) {
        const i3 = Mf.toCamelCase(" " + t3);
        ["get", "set", "has"].forEach((n4) => {
          Object.defineProperty(e11, n4 + i3, { value: function(e12, i4, r2) {
            return this[n4].call(this, t3, e12, i4, r2);
          }, configurable: true });
        });
      }(i2, e10), t2[n3] = true);
    }
    return Mf.isArray(e9) ? e9.forEach(n2) : n2(e9), this;
  }
};
SI.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), Mf.reduceDescriptors(SI.prototype, (e9, t2) => {
  let { value: i2 } = e9, n2 = t2[0].toUpperCase() + t2.slice(1);
  return { get: () => i2, set(e10) {
    this[n2] = e10;
  } };
}), Mf.freezeMethods(SI);
var gI = SI;
function RI(e9, t2) {
  const i2 = this || pI, n2 = t2 || i2, r2 = gI.from(n2.headers);
  let o2 = n2.data;
  return Mf.forEach(e9, function(e10) {
    o2 = e10.call(i2, o2, r2.normalize(), t2 ? t2.status : void 0);
  }), r2.normalize(), o2;
}
function CI(e9) {
  return !(!e9 || !e9.__CANCEL__);
}
function II(e9, t2, i2) {
  Uf.call(this, null == e9 ? "canceled" : e9, Uf.ERR_CANCELED, t2, i2), this.name = "CanceledError";
}
function vI(e9, t2, i2) {
  const n2 = i2.config.validateStatus;
  i2.status && n2 && !n2(i2.status) ? t2(new Uf("Request failed with status code " + i2.status, [Uf.ERR_BAD_REQUEST, Uf.ERR_BAD_RESPONSE][Math.floor(i2.status / 100) - 4], i2.config, i2.request, i2)) : e9(i2);
}
Mf.inherits(II, Uf, { __CANCEL__: true });
var yI = function(e9, t2) {
  let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3, n2 = 0;
  const r2 = function(e10, t3) {
    e10 = e10 || 10;
    const i3 = new Array(e10), n3 = new Array(e10);
    let r3, o2 = 0, s2 = 0;
    return t3 = void 0 !== t3 ? t3 : 1e3, function(a2) {
      const c2 = Date.now(), d2 = n3[s2];
      r3 || (r3 = c2), i3[o2] = a2, n3[o2] = c2;
      let l2 = s2, u2 = 0;
      for (; l2 !== o2; ) u2 += i3[l2++], l2 %= e10;
      if (o2 = (o2 + 1) % e10, o2 === s2 && (s2 = (s2 + 1) % e10), c2 - r3 < t3) return;
      const h2 = d2 && c2 - d2;
      return h2 ? Math.round(1e3 * u2 / h2) : void 0;
    };
  }(50, 250);
  return function(e10, t3) {
    let i3, n3, r3 = 0, o2 = 1e3 / t3;
    const s2 = function(t4) {
      let o3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Date.now();
      r3 = o3, i3 = null, n3 && (clearTimeout(n3), n3 = null), e10.apply(null, t4);
    };
    return [function() {
      const e11 = Date.now(), t4 = e11 - r3;
      for (var a2 = arguments.length, c2 = new Array(a2), d2 = 0; d2 < a2; d2++) c2[d2] = arguments[d2];
      t4 >= o2 ? s2(c2, e11) : (i3 = c2, n3 || (n3 = setTimeout(() => {
        n3 = null, s2(i3);
      }, o2 - t4)));
    }, () => i3 && s2(i3)];
  }((i3) => {
    const o2 = i3.loaded, s2 = i3.lengthComputable ? i3.total : void 0, a2 = o2 - n2, c2 = r2(a2);
    n2 = o2;
    e9({ loaded: o2, total: s2, progress: s2 ? o2 / s2 : void 0, bytes: a2, rate: c2 || void 0, estimated: c2 && s2 && o2 <= s2 ? (s2 - o2) / c2 : void 0, event: i3, lengthComputable: null != s2, [t2 ? "download" : "upload"]: true });
  }, i2);
};
var AI = (e9, t2) => {
  const i2 = null != e9;
  return [(n2) => t2[0]({ lengthComputable: i2, total: e9, loaded: n2 }), t2[1]];
};
var bI = (e9) => function() {
  for (var t2 = arguments.length, i2 = new Array(t2), n2 = 0; n2 < t2; n2++) i2[n2] = arguments[n2];
  return Mf.asap(() => e9(...i2));
};
var wI = _C.hasStandardBrowserEnv ? function() {
  const e9 = _C.navigator && /(msie|trident)/i.test(_C.navigator.userAgent), t2 = document.createElement("a");
  let i2;
  function n2(i3) {
    let n3 = i3;
    return e9 && (t2.setAttribute("href", n3), n3 = t2.href), t2.setAttribute("href", n3), { href: t2.href, protocol: t2.protocol ? t2.protocol.replace(/:$/, "") : "", host: t2.host, search: t2.search ? t2.search.replace(/^\?/, "") : "", hash: t2.hash ? t2.hash.replace(/^#/, "") : "", hostname: t2.hostname, port: t2.port, pathname: "/" === t2.pathname.charAt(0) ? t2.pathname : "/" + t2.pathname };
  }
  return i2 = n2(window.location.href), function(e10) {
    const t3 = Mf.isString(e10) ? n2(e10) : e10;
    return t3.protocol === i2.protocol && t3.host === i2.host;
  };
}() : function() {
  return true;
};
var OI = _C.hasStandardBrowserEnv ? { write(e9, t2, i2, n2, r2, o2) {
  const s2 = [e9 + "=" + encodeURIComponent(t2)];
  Mf.isNumber(i2) && s2.push("expires=" + new Date(i2).toGMTString()), Mf.isString(n2) && s2.push("path=" + n2), Mf.isString(r2) && s2.push("domain=" + r2), true === o2 && s2.push("secure"), document.cookie = s2.join("; ");
}, read(e9) {
  const t2 = document.cookie.match(new RegExp("(^|;\\s*)(" + e9 + ")=([^;]*)"));
  return t2 ? decodeURIComponent(t2[3]) : null;
}, remove(e9) {
  this.write(e9, "", Date.now() - 864e5);
} } : { write() {
}, read: () => null, remove() {
} };
function NI(e9, t2) {
  return e9 && !function(e10) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e10);
  }(t2) ? function(e10, t3) {
    return t3 ? e10.replace(/\/?\/$/, "") + "/" + t3.replace(/^\/+/, "") : e10;
  }(e9, t2) : t2;
}
function DI(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
var PI = (e9) => e9 instanceof gI ? function(e10) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? DI(Object(i2), true).forEach(function(t3) {
      Fg(e10, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e10, Object.getOwnPropertyDescriptors(i2)) : DI(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e10, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e10;
}({}, e9) : e9;
function LI(e9, t2) {
  t2 = t2 || {};
  const i2 = {};
  function n2(e10, t3, i3) {
    return Mf.isPlainObject(e10) && Mf.isPlainObject(t3) ? Mf.merge.call({ caseless: i3 }, e10, t3) : Mf.isPlainObject(t3) ? Mf.merge({}, t3) : Mf.isArray(t3) ? t3.slice() : t3;
  }
  function r2(e10, t3, i3) {
    return Mf.isUndefined(t3) ? Mf.isUndefined(e10) ? void 0 : n2(void 0, e10, i3) : n2(e10, t3, i3);
  }
  function o2(e10, t3) {
    if (!Mf.isUndefined(t3)) return n2(void 0, t3);
  }
  function s2(e10, t3) {
    return Mf.isUndefined(t3) ? Mf.isUndefined(e10) ? void 0 : n2(void 0, e10) : n2(void 0, t3);
  }
  function a2(i3, r3, o3) {
    return o3 in t2 ? n2(i3, r3) : o3 in e9 ? n2(void 0, i3) : void 0;
  }
  const c2 = { url: o2, method: o2, data: o2, baseURL: s2, transformRequest: s2, transformResponse: s2, paramsSerializer: s2, timeout: s2, timeoutMessage: s2, withCredentials: s2, withXSRFToken: s2, adapter: s2, responseType: s2, xsrfCookieName: s2, xsrfHeaderName: s2, onUploadProgress: s2, onDownloadProgress: s2, decompress: s2, maxContentLength: s2, maxBodyLength: s2, beforeRedirect: s2, transport: s2, httpAgent: s2, httpsAgent: s2, cancelToken: s2, socketPath: s2, responseEncoding: s2, validateStatus: a2, headers: (e10, t3) => r2(PI(e10), PI(t3), true) };
  return Mf.forEach(Object.keys(Object.assign({}, e9, t2)), function(n3) {
    const o3 = c2[n3] || r2, s3 = o3(e9[n3], t2[n3], n3);
    Mf.isUndefined(s3) && o3 !== a2 || (i2[n3] = s3);
  }), i2;
}
var kI = (e9) => {
  const t2 = LI({}, e9);
  let i2, { data: n2, withXSRFToken: r2, xsrfHeaderName: o2, xsrfCookieName: s2, headers: a2, auth: c2 } = t2;
  if (t2.headers = a2 = gI.from(a2), t2.url = zf(NI(t2.baseURL, t2.url), e9.params, e9.paramsSerializer), c2 && a2.set("Authorization", "Basic " + btoa((c2.username || "") + ":" + (c2.password ? unescape(encodeURIComponent(c2.password)) : ""))), Mf.isFormData(n2)) {
    if (_C.hasStandardBrowserEnv || _C.hasStandardBrowserWebWorkerEnv) a2.setContentType(void 0);
    else if (false !== (i2 = a2.getContentType())) {
      const [e10, ...t3] = i2 ? i2.split(";").map((e11) => jp(e11).call(e11)).filter(Boolean) : [];
      a2.setContentType([e10 || "multipart/form-data", ...t3].join("; "));
    }
  }
  if (_C.hasStandardBrowserEnv && (r2 && Mf.isFunction(r2) && (r2 = r2(t2)), r2 || false !== r2 && wI(t2.url))) {
    const e10 = o2 && s2 && OI.read(s2);
    e10 && a2.set(o2, e10);
  }
  return t2;
};
var MI = "undefined" != typeof XMLHttpRequest && function(e9) {
  return new Gh(function(t2, i2) {
    const n2 = kI(e9);
    let r2 = n2.data;
    const o2 = gI.from(n2.headers).normalize();
    let s2, a2, c2, d2, l2, { responseType: u2, onUploadProgress: h2, onDownloadProgress: p2 } = n2;
    function _2() {
      d2 && d2(), l2 && l2(), n2.cancelToken && n2.cancelToken.unsubscribe(s2), n2.signal && n2.signal.removeEventListener("abort", s2);
    }
    let E2 = new XMLHttpRequest();
    function f2() {
      if (!E2) return;
      const n3 = gI.from("getAllResponseHeaders" in E2 && E2.getAllResponseHeaders());
      vI(function(e10) {
        t2(e10), _2();
      }, function(e10) {
        i2(e10), _2();
      }, { data: u2 && "text" !== u2 && "json" !== u2 ? E2.response : E2.responseText, status: E2.status, statusText: E2.statusText, headers: n3, config: e9, request: E2 }), E2 = null;
    }
    E2.open(n2.method.toUpperCase(), n2.url, true), E2.timeout = n2.timeout, "onloadend" in E2 ? E2.onloadend = f2 : E2.onreadystatechange = function() {
      E2 && 4 === E2.readyState && (0 !== E2.status || E2.responseURL && 0 === E2.responseURL.indexOf("file:")) && setTimeout(f2);
    }, E2.onabort = function() {
      E2 && (i2(new Uf("Request aborted", Uf.ECONNABORTED, e9, E2)), E2 = null);
    }, E2.onerror = function() {
      i2(new Uf("Network Error", Uf.ERR_NETWORK, e9, E2)), E2 = null;
    }, E2.ontimeout = function() {
      let t3 = n2.timeout ? "timeout of " + n2.timeout + "ms exceeded" : "timeout exceeded";
      const r3 = n2.transitional || Xf;
      n2.timeoutErrorMessage && (t3 = n2.timeoutErrorMessage), i2(new Uf(t3, r3.clarifyTimeoutError ? Uf.ETIMEDOUT : Uf.ECONNABORTED, e9, E2)), E2 = null;
    }, void 0 === r2 && o2.setContentType(null), "setRequestHeader" in E2 && Mf.forEach(o2.toJSON(), function(e10, t3) {
      E2.setRequestHeader(t3, e10);
    }), Mf.isUndefined(n2.withCredentials) || (E2.withCredentials = !!n2.withCredentials), u2 && "json" !== u2 && (E2.responseType = n2.responseType), p2 && ([c2, l2] = yI(p2, true), E2.addEventListener("progress", c2)), h2 && E2.upload && ([a2, d2] = yI(h2), E2.upload.addEventListener("progress", a2), E2.upload.addEventListener("loadend", d2)), (n2.cancelToken || n2.signal) && (s2 = (t3) => {
      E2 && (i2(!t3 || t3.type ? new II(null, e9, E2) : t3), E2.abort(), E2 = null);
    }, n2.cancelToken && n2.cancelToken.subscribe(s2), n2.signal && (n2.signal.aborted ? s2() : n2.signal.addEventListener("abort", s2)));
    const m2 = function(e10) {
      const t3 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e10);
      return t3 && t3[1] || "";
    }(n2.url);
    m2 && -1 === _C.protocols.indexOf(m2) ? i2(new Uf("Unsupported protocol " + m2 + ":", Uf.ERR_BAD_REQUEST, e9)) : E2.send(r2 || null);
  });
};
var UI = (e9, t2) => {
  const { length: i2 } = e9 = e9 ? e9.filter(Boolean) : [];
  if (t2 || i2) {
    let i3, n2 = new AbortController();
    const r2 = function(e10) {
      if (!i3) {
        i3 = true, s2();
        const t3 = e10 instanceof Error ? e10 : this.reason;
        n2.abort(t3 instanceof Uf ? t3 : new II(t3 instanceof Error ? t3.message : t3));
      }
    };
    let o2 = t2 && setTimeout(() => {
      o2 = null, r2(new Uf("timeout ".concat(t2, " of ms exceeded"), Uf.ETIMEDOUT));
    }, t2);
    const s2 = () => {
      e9 && (o2 && clearTimeout(o2), o2 = null, e9.forEach((e10) => {
        e10.unsubscribe ? e10.unsubscribe(r2) : e10.removeEventListener("abort", r2);
      }), e9 = null);
    };
    e9.forEach((e10) => e10.addEventListener("abort", r2));
    const { signal: a2 } = n2;
    return a2.unsubscribe = () => Mf.asap(s2), a2;
  }
};
var xI = jh;
var VI = Sl;
wi({ target: "Promise", stat: true, forced: true }, { withResolvers: function() {
  var e9 = VI.f(this);
  return { promise: e9.promise, resolve: e9.resolve, reject: e9.reject };
} });
var FI = Sl;
var BI = el;
wi({ target: "Promise", stat: true, forced: true }, { try: function(e9) {
  var t2 = FI.f(this), i2 = BI(e9);
  return (i2.error ? t2.reject : t2.resolve)(i2.value), t2.promise;
} });
var jI = i(xI);
var GI = Vm.f("asyncIterator");
var WI = i(GI);
function HI(e9, t2) {
  this.v = e9, this.k = t2;
}
function KI(e9) {
  var t2, i2;
  function n2(t3, i3) {
    try {
      var o2 = e9[t3](i3), s2 = o2.value, a2 = s2 instanceof HI;
      jI.resolve(a2 ? s2.v : s2).then(function(i4) {
        if (a2) {
          var c2 = "return" === t3 ? "return" : "next";
          if (!s2.k || i4.done) return n2(c2, i4);
          i4 = e9[c2](i4).value;
        }
        r2(o2.done ? "return" : "normal", i4);
      }, function(e10) {
        n2("throw", e10);
      });
    } catch (e10) {
      r2("throw", e10);
    }
  }
  function r2(e10, r3) {
    switch (e10) {
      case "return":
        t2.resolve({ value: r3, done: true });
        break;
      case "throw":
        t2.reject(r3);
        break;
      default:
        t2.resolve({ value: r3, done: false });
    }
    (t2 = t2.next) ? n2(t2.key, t2.arg) : i2 = null;
  }
  this._invoke = function(e10, r3) {
    return new jI(function(o2, s2) {
      var a2 = { key: e10, arg: r3, resolve: o2, reject: s2, next: null };
      i2 ? i2 = i2.next = a2 : (t2 = i2 = a2, n2(e10, r3));
    });
  }, "function" != typeof e9.return && (this.return = void 0);
}
function YI(e9) {
  return function() {
    return new KI(e9.apply(this, arguments));
  };
}
function qI(e9) {
  return new HI(e9, 0);
}
function zI(e9) {
  var t2 = {}, i2 = false;
  function n2(t3, n3) {
    return i2 = true, { done: false, value: new HI(n3 = new jI(function(i3) {
      i3(e9[t3](n3));
    }), 1) };
  }
  return t2[void 0 !== kg && Mg || "@@iterator"] = function() {
    return this;
  }, t2.next = function(e10) {
    return i2 ? (i2 = false, e10) : n2("next", e10);
  }, "function" == typeof e9.throw && (t2.throw = function(e10) {
    if (i2) throw i2 = false, e10;
    return n2("throw", e10);
  }), "function" == typeof e9.return && (t2.return = function(e10) {
    return i2 ? (i2 = false, e10) : n2("return", e10);
  }), t2;
}
KI.prototype["function" == typeof kg && WI || "@@asyncIterator"] = function() {
  return this;
}, KI.prototype.next = function(e9) {
  return this._invoke("next", e9);
}, KI.prototype.throw = function(e9) {
  return this._invoke("throw", e9);
}, KI.prototype.return = function(e9) {
  return this._invoke("return", e9);
};
var JI = i(GI);
function XI(e9) {
  var t2, i2, n2, r2 = 2;
  for ("undefined" != typeof Symbol && (i2 = JI, n2 = Symbol.iterator); r2--; ) {
    if (i2 && null != (t2 = e9[i2])) return t2.call(e9);
    if (n2 && null != (t2 = e9[n2])) return new QI(t2.call(e9));
    i2 = "@@asyncIterator", n2 = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function QI(e9) {
  function t2(e10) {
    if (Object(e10) !== e10) return Gh.reject(new TypeError(e10 + " is not an object."));
    var t3 = e10.done;
    return Gh.resolve(e10.value).then(function(e11) {
      return { value: e11, done: t3 };
    });
  }
  return QI = function(e10) {
    this.s = e10, this.n = e10.next;
  }, QI.prototype = { s: null, n: null, next: function() {
    return t2(this.n.apply(this.s, arguments));
  }, return: function(e10) {
    var i2 = this.s.return;
    return void 0 === i2 ? Gh.resolve({ value: e10, done: true }) : t2(i2.apply(this.s, arguments));
  }, throw: function(e10) {
    var i2 = this.s.return;
    return void 0 === i2 ? Gh.reject(e10) : t2(i2.apply(this.s, arguments));
  } }, new QI(e9);
}
var ZI = function* (e9, t2) {
  let i2 = e9.byteLength;
  if (!t2 || i2 < t2) return void (yield e9);
  let n2, r2 = 0;
  for (; r2 < i2; ) n2 = r2 + t2, yield e9.slice(r2, n2), r2 = n2;
};
var $I = function() {
  var e9 = YI(function* (e10, t2) {
    var i2, n2 = false, r2 = false;
    try {
      for (var o2, s2 = XI(ev(e10)); n2 = !(o2 = yield qI(s2.next())).done; n2 = false) {
        const e11 = o2.value;
        yield* zI(XI(ZI(e11, t2)));
      }
    } catch (e11) {
      r2 = true, i2 = e11;
    } finally {
      try {
        n2 && null != s2.return && (yield qI(s2.return()));
      } finally {
        if (r2) throw i2;
      }
    }
  });
  return function(t2, i2) {
    return e9.apply(this, arguments);
  };
}();
var ev = function() {
  var e9 = YI(function* (e10) {
    if (e10[JI]) return void (yield* zI(XI(e10)));
    const t2 = e10.getReader();
    try {
      for (; ; ) {
        const { done: e11, value: i2 } = yield qI(t2.read());
        if (e11) break;
        yield i2;
      }
    } finally {
      yield qI(t2.cancel());
    }
  });
  return function(t2) {
    return e9.apply(this, arguments);
  };
}();
var tv = (e9, t2, i2, n2) => {
  const r2 = $I(e9, t2);
  let o2, s2 = 0, a2 = (e10) => {
    o2 || (o2 = true, n2 && n2(e10));
  };
  return new ReadableStream({ async pull(e10) {
    try {
      const { done: t3, value: n3 } = await r2.next();
      if (t3) return a2(), void e10.close();
      let o3 = n3.byteLength;
      if (i2) {
        let e11 = s2 += o3;
        i2(e11);
      }
      e10.enqueue(new Uint8Array(n3));
    } catch (e11) {
      throw a2(e11), e11;
    }
  }, cancel: (e10) => (a2(e10), r2.return()) }, { highWaterMark: 2 });
};
function iv(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function nv(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? iv(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : iv(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var rv = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response;
var ov = rv && "function" == typeof ReadableStream;
var sv = rv && ("function" == typeof TextEncoder ? (av = new TextEncoder(), (e9) => av.encode(e9)) : async (e9) => new Uint8Array(await new Response(e9).arrayBuffer()));
var av;
var cv = function(e9) {
  try {
    for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++) i2[n2 - 1] = arguments[n2];
    return !!e9(...i2);
  } catch (e10) {
    return false;
  }
};
var dv = ov && cv(() => {
  let e9 = false;
  const t2 = new Request(_C.origin, { body: new ReadableStream(), method: "POST", get duplex() {
    return e9 = true, "half";
  } }).headers.has("Content-Type");
  return e9 && !t2;
});
var lv = ov && cv(() => Mf.isReadableStream(new Response("").body));
var uv = { stream: lv && ((e9) => e9.body) };
var hv;
rv && (hv = new Response(), ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e9) => {
  !uv[e9] && (uv[e9] = Mf.isFunction(hv[e9]) ? (t2) => t2[e9]() : (t2, i2) => {
    throw new Uf("Response type '".concat(e9, "' is not supported"), Uf.ERR_NOT_SUPPORT, i2);
  });
}));
var pv = async (e9, t2) => {
  const i2 = Mf.toFiniteNumber(e9.getContentLength());
  return null == i2 ? (async (e10) => {
    if (null == e10) return 0;
    if (Mf.isBlob(e10)) return e10.size;
    if (Mf.isSpecCompliantForm(e10)) {
      const t3 = new Request(_C.origin, { method: "POST", body: e10 });
      return (await t3.arrayBuffer()).byteLength;
    }
    return Mf.isArrayBufferView(e10) || Mf.isArrayBuffer(e10) ? e10.byteLength : (Mf.isURLSearchParams(e10) && (e10 += ""), Mf.isString(e10) ? (await sv(e10)).byteLength : void 0);
  })(t2) : i2;
};
var _v = rv && (async (e9) => {
  let { url: t2, method: i2, data: n2, signal: r2, cancelToken: o2, timeout: s2, onDownloadProgress: a2, onUploadProgress: c2, responseType: d2, headers: l2, withCredentials: u2 = "same-origin", fetchOptions: h2 } = kI(e9);
  d2 = d2 ? (d2 + "").toLowerCase() : "text";
  let p2, _2 = UI([r2, o2 && o2.toAbortSignal()], s2);
  const E2 = _2 && _2.unsubscribe && (() => {
    _2.unsubscribe();
  });
  let f2;
  try {
    if (c2 && dv && "get" !== i2 && "head" !== i2 && 0 !== (f2 = await pv(l2, n2))) {
      let e10, i3 = new Request(t2, { method: "POST", body: n2, duplex: "half" });
      if (Mf.isFormData(n2) && (e10 = i3.headers.get("content-type")) && l2.setContentType(e10), i3.body) {
        const [e11, t3] = AI(f2, yI(bI(c2)));
        n2 = tv(i3.body, 65536, e11, t3);
      }
    }
    Mf.isString(u2) || (u2 = u2 ? "include" : "omit");
    const r3 = "credentials" in Request.prototype;
    p2 = new Request(t2, nv(nv({}, h2), {}, { signal: _2, method: i2.toUpperCase(), headers: l2.normalize().toJSON(), body: n2, duplex: "half", credentials: r3 ? u2 : void 0 }));
    let o3 = await fetch(p2);
    const s3 = lv && ("stream" === d2 || "response" === d2);
    if (lv && (a2 || s3 && E2)) {
      const e10 = {};
      ["status", "statusText", "headers"].forEach((t4) => {
        e10[t4] = o3[t4];
      });
      const t3 = Mf.toFiniteNumber(o3.headers.get("content-length")), [i3, n3] = a2 && AI(t3, yI(bI(a2), true)) || [];
      o3 = new Response(tv(o3.body, 65536, i3, () => {
        n3 && n3(), E2 && E2();
      }), e10);
    }
    d2 = d2 || "text";
    let m2 = await uv[Mf.findKey(uv, d2) || "text"](o3, e9);
    return !s3 && E2 && E2(), await new Gh((t3, i3) => {
      vI(t3, i3, { data: m2, headers: gI.from(o3.headers), status: o3.status, statusText: o3.statusText, config: e9, request: p2 });
    });
  } catch (t3) {
    if (E2 && E2(), t3 && "TypeError" === t3.name && /fetch/i.test(t3.message)) throw Object.assign(new Uf("Network Error", Uf.ERR_NETWORK, e9, p2), { cause: t3.cause || t3 });
    throw Uf.from(t3, t3 && t3.code, e9, p2);
  }
});
var Ev = { http: null, xhr: MI, fetch: _v };
Mf.forEach(Ev, (e9, t2) => {
  if (e9) {
    try {
      Object.defineProperty(e9, "name", { value: t2 });
    } catch (e10) {
    }
    Object.defineProperty(e9, "adapterName", { value: t2 });
  }
});
var fv = (e9) => "- ".concat(e9);
var mv = (e9) => Mf.isFunction(e9) || null === e9 || false === e9;
var Tv = { getAdapter: (e9) => {
  e9 = Mf.isArray(e9) ? e9 : [e9];
  const { length: t2 } = e9;
  let i2, n2;
  const r2 = {};
  for (let o2 = 0; o2 < t2; o2++) {
    let t3;
    if (i2 = e9[o2], n2 = i2, !mv(i2) && (n2 = Ev[(t3 = String(i2)).toLowerCase()], void 0 === n2)) throw new Uf("Unknown adapter '".concat(t3, "'"));
    if (n2) break;
    r2[t3 || "#" + o2] = n2;
  }
  if (!n2) {
    const e10 = Object.entries(r2).map((e11) => {
      let [t3, i3] = e11;
      return "adapter ".concat(t3, " ") + (false === i3 ? "is not supported by the environment" : "is not available in the build");
    });
    throw new Uf("There is no suitable adapter to dispatch the request " + (t2 ? e10.length > 1 ? "since :\n" + e10.map(fv).join("\n") : " " + fv(e10[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT");
  }
  return n2;
}, adapters: Ev };
function Sv(e9) {
  if (e9.cancelToken && e9.cancelToken.throwIfRequested(), e9.signal && e9.signal.aborted) throw new II(null, e9);
}
function gv(e9) {
  Sv(e9), e9.headers = gI.from(e9.headers), e9.data = RI.call(e9, e9.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e9.method) && e9.headers.setContentType("application/x-www-form-urlencoded", false);
  return Tv.getAdapter(e9.adapter || pI.adapter)(e9).then(function(t2) {
    return Sv(e9), t2.data = RI.call(e9, e9.transformResponse, t2), t2.headers = gI.from(t2.headers), t2;
  }, function(t2) {
    return CI(t2) || (Sv(e9), t2 && t2.response && (t2.response.data = RI.call(e9, e9.transformResponse, t2.response), t2.response.headers = gI.from(t2.response.headers))), Gh.reject(t2);
  });
}
var Rv = "1.7.7";
var Cv = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e9, t2) => {
  Cv[e9] = function(i2) {
    return typeof i2 === e9 || "a" + (t2 < 1 ? "n " : " ") + e9;
  };
});
var Iv = {};
Cv.transitional = function(e9, t2, i2) {
  function n2(e10, t3) {
    return "[Axios v" + Rv + "] Transitional option '" + e10 + "'" + t3 + (i2 ? ". " + i2 : "");
  }
  return (i3, r2, o2) => {
    if (false === e9) throw new Uf(n2(r2, " has been removed" + (t2 ? " in " + t2 : "")), Uf.ERR_DEPRECATED);
    return t2 && !Iv[r2] && (Iv[r2] = true, console.warn(n2(r2, " has been deprecated since v" + t2 + " and will be removed in the near future"))), !e9 || e9(i3, r2, o2);
  };
};
var vv = { assertOptions: function(e9, t2, i2) {
  if ("object" != typeof e9) throw new Uf("options must be an object", Uf.ERR_BAD_OPTION_VALUE);
  const n2 = Object.keys(e9);
  let r2 = n2.length;
  for (; r2-- > 0; ) {
    const o2 = n2[r2], s2 = t2[o2];
    if (s2) {
      const t3 = e9[o2], i3 = void 0 === t3 || s2(t3, o2, e9);
      if (true !== i3) throw new Uf("option " + o2 + " must be " + i3, Uf.ERR_BAD_OPTION_VALUE);
    } else if (true !== i2) throw new Uf("Unknown option " + o2, Uf.ERR_BAD_OPTION);
  }
}, validators: Cv };
var yv = vv.validators;
var Av = class {
  constructor(e9) {
    this.defaults = e9, this.interceptors = { request: new Jf(), response: new Jf() };
  }
  async request(e9, t2) {
    try {
      return await this._request(e9, t2);
    } catch (e10) {
      if (e10 instanceof Error) {
        let t3;
        Error.captureStackTrace ? Error.captureStackTrace(t3 = {}) : t3 = new Error();
        const i2 = t3.stack ? t3.stack.replace(/^.+\n/, "") : "";
        try {
          e10.stack ? i2 && !String(e10.stack).endsWith(i2.replace(/^.+\n.+\n/, "")) && (e10.stack += "\n" + i2) : e10.stack = i2;
        } catch (e11) {
        }
      }
      throw e10;
    }
  }
  _request(e9, t2) {
    "string" == typeof e9 ? (t2 = t2 || {}).url = e9 : t2 = e9 || {}, t2 = LI(this.defaults, t2);
    const { transitional: i2, paramsSerializer: n2, headers: r2 } = t2;
    void 0 !== i2 && vv.assertOptions(i2, { silentJSONParsing: yv.transitional(yv.boolean), forcedJSONParsing: yv.transitional(yv.boolean), clarifyTimeoutError: yv.transitional(yv.boolean) }, false), null != n2 && (Mf.isFunction(n2) ? t2.paramsSerializer = { serialize: n2 } : vv.assertOptions(n2, { encode: yv.function, serialize: yv.function }, true)), t2.method = (t2.method || this.defaults.method || "get").toLowerCase();
    let o2 = r2 && Mf.merge(r2.common, r2[t2.method]);
    r2 && Mf.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e10) => {
      delete r2[e10];
    }), t2.headers = gI.concat(o2, r2);
    const s2 = [];
    let a2 = true;
    this.interceptors.request.forEach(function(e10) {
      "function" == typeof e10.runWhen && false === e10.runWhen(t2) || (a2 = a2 && e10.synchronous, s2.unshift(e10.fulfilled, e10.rejected));
    });
    const c2 = [];
    let d2;
    this.interceptors.response.forEach(function(e10) {
      c2.push(e10.fulfilled, e10.rejected);
    });
    let l2, u2 = 0;
    if (!a2) {
      const e10 = [gv.bind(this), void 0];
      for (e10.unshift.apply(e10, s2), e10.push.apply(e10, c2), l2 = e10.length, d2 = Gh.resolve(t2); u2 < l2; ) d2 = d2.then(e10[u2++], e10[u2++]);
      return d2;
    }
    l2 = s2.length;
    let h2 = t2;
    for (u2 = 0; u2 < l2; ) {
      const e10 = s2[u2++], t3 = s2[u2++];
      try {
        h2 = e10(h2);
      } catch (e11) {
        t3.call(this, e11);
        break;
      }
    }
    try {
      d2 = gv.call(this, h2);
    } catch (e10) {
      return Gh.reject(e10);
    }
    for (u2 = 0, l2 = c2.length; u2 < l2; ) d2 = d2.then(c2[u2++], c2[u2++]);
    return d2;
  }
  getUri(e9) {
    return zf(NI((e9 = LI(this.defaults, e9)).baseURL, e9.url), e9.params, e9.paramsSerializer);
  }
};
Mf.forEach(["delete", "get", "head", "options"], function(e9) {
  Av.prototype[e9] = function(t2, i2) {
    return this.request(LI(i2 || {}, { method: e9, url: t2, data: (i2 || {}).data }));
  };
}), Mf.forEach(["post", "put", "patch"], function(e9) {
  function t2(t3) {
    return function(i2, n2, r2) {
      return this.request(LI(r2 || {}, { method: e9, headers: t3 ? { "Content-Type": "multipart/form-data" } : {}, url: i2, data: n2 }));
    };
  }
  Av.prototype[e9] = t2(), Av.prototype[e9 + "Form"] = t2(true);
});
var bv = Av;
var wv = class _wv {
  constructor(e9) {
    if ("function" != typeof e9) throw new TypeError("executor must be a function.");
    let t2;
    this.promise = new Gh(function(e10) {
      t2 = e10;
    });
    const i2 = this;
    this.promise.then((e10) => {
      if (!i2._listeners) return;
      let t3 = i2._listeners.length;
      for (; t3-- > 0; ) i2._listeners[t3](e10);
      i2._listeners = null;
    }), this.promise.then = (e10) => {
      let t3;
      const n2 = new Gh((e11) => {
        i2.subscribe(e11), t3 = e11;
      }).then(e10);
      return n2.cancel = function() {
        i2.unsubscribe(t3);
      }, n2;
    }, e9(function(e10, n2, r2) {
      i2.reason || (i2.reason = new II(e10, n2, r2), t2(i2.reason));
    });
  }
  throwIfRequested() {
    if (this.reason) throw this.reason;
  }
  subscribe(e9) {
    this.reason ? e9(this.reason) : this._listeners ? this._listeners.push(e9) : this._listeners = [e9];
  }
  unsubscribe(e9) {
    if (!this._listeners) return;
    const t2 = this._listeners.indexOf(e9);
    -1 !== t2 && this._listeners.splice(t2, 1);
  }
  toAbortSignal() {
    const e9 = new AbortController(), t2 = (t3) => {
      e9.abort(t3);
    };
    return this.subscribe(t2), e9.signal.unsubscribe = () => this.unsubscribe(t2), e9.signal;
  }
  static source() {
    let e9;
    return { token: new _wv(function(t2) {
      e9 = t2;
    }), cancel: e9 };
  }
};
var Ov = wv;
var Nv = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 };
Object.entries(Nv).forEach((e9) => {
  let [t2, i2] = e9;
  Nv[i2] = t2;
});
var Dv = Nv;
var Pv = function e3(t2) {
  const i2 = new bv(t2), n2 = HE(bv.prototype.request, i2);
  return Mf.extend(n2, bv.prototype, i2, { allOwnKeys: true }), Mf.extend(n2, i2, null, { allOwnKeys: true }), n2.create = function(i3) {
    return e3(LI(t2, i3));
  }, n2;
}(pI);
Pv.Axios = bv, Pv.CanceledError = II, Pv.CancelToken = Ov, Pv.isCancel = CI, Pv.VERSION = Rv, Pv.toFormData = Wf, Pv.AxiosError = Uf, Pv.Cancel = Pv.CanceledError, Pv.all = function(e9) {
  return Gh.all(e9);
}, Pv.spread = function(e9) {
  return function(t2) {
    return e9.apply(null, t2);
  };
}, Pv.isAxiosError = function(e9) {
  return Mf.isObject(e9) && true === e9.isAxiosError;
}, Pv.mergeConfig = LI, Pv.AxiosHeaders = gI, Pv.formToJSON = (e9) => uI(Mf.isHTMLForm(e9) ? new FormData(e9) : e9), Pv.getAdapter = Tv.getAdapter, Pv.HttpStatusCode = Dv, Pv.default = Pv;
var Lv = Pv;
var kv = () => {
};
function Mv() {
  const e9 = { promise: void 0, isResolved: false, isRejected: false, isFinished: false, resolve: void 0, reject: void 0, cancel: kv };
  return e9.promise = new Gh((t2, i2) => {
    e9.resolve = (i3) => {
      e9.isFinished || (e9.isResolved = true, e9.isFinished = true, t2(i3), e9.value = i3);
    }, e9.reject = (t3) => {
      e9.isFinished || (e9.isRejected = true, e9.isFinished = true, i2(t3));
    };
  }), e9;
}
var Uv = /* @__PURE__ */ new Map();
var xv = /* @__PURE__ */ new Map();
var Vv = /* @__PURE__ */ new Map();
var Fv = function(e9) {
  return e9.WIN_10 = "Windows 10", e9.WIN_81 = "Windows 8.1", e9.WIN_8 = "Windows 8", e9.WIN_7 = "Windows 7", e9.WIN_VISTA = "Windows Vista", e9.WIN_SERVER_2003 = "Windows Server 2003", e9.WIN_XP = "Windows XP", e9.WIN_2000 = "Windows 2000", e9.ANDROID = "Android", e9.HARMONY_OS = "HarmonyOS", e9.OPEN_BSD = "Open BSD", e9.SUN_OS = "Sun OS", e9.LINUX = "Linux", e9.IOS = "iOS", e9.MAC_OS = "Mac OS", e9.CHROMIUM_OS = "Chromium OS", e9.QNX = "QNX", e9.UNIX = "UNIX", e9.BEOS = "BeOS", e9.OS_2 = "OS/2", e9.SEARCH_BOT = "Search Bot", e9;
}({});
var Bv = function(e9) {
  return e9.CHROME = "Chrome", e9.SAFARI = "Safari", e9.EDGE = "Edge", e9.FIREFOX = "Firefox", e9.OPERA = "OPR", e9.QQ = "QQBrowser", e9.WECHAT = "MicroMessenger", e9;
}({});
var jv = new dE();
var Gv = jv.getResult();
var Wv = null;
function Hv(e9) {
  if (!Wv) {
    e9 && jv.setUA(e9), Gv = jv.getResult();
    const t2 = function(e10) {
      if ("Blink" === e10.engine.name && "WeChat" !== e10.browser.name) return Bv.CHROME;
      switch (e10.browser.name) {
        case "Chrome Headless":
        case "Chrome":
        case "Chromium":
          return Bv.CHROME;
        case "Safari":
        case "Mobile Safari":
          return Bv.SAFARI;
        case "Edge":
          return Bv.EDGE;
        case "Firefox":
          return Bv.FIREFOX;
        case "QQ":
        case "QQBrowser":
          return Bv.QQ;
        case "Opera":
          return Bv.OPERA;
        case "WeChat":
          return Bv.WECHAT;
        default:
          return e10.browser.name || "";
      }
    }(Gv), i2 = Kv(Gv), n2 = function(e10) {
      return "Windows" === e10.os.name ? e10.os.version ? e10.os.name + " " + e10.os.version : e10.os.name : e10.os.name || "";
    }(Gv), r2 = Gv.os.version, o2 = Kv(Gv, false), s2 = Gv.device.type;
    if (!(t2 && i2 && n2 && r2)) return { name: t2, version: i2, os: n2, osVersion: r2, browserVersion: o2, deviceType: s2 };
    Wv = { name: t2, version: i2, os: n2, osVersion: r2, browserVersion: o2, deviceType: s2 };
  }
  return Wv;
}
function Kv(e9) {
  let t2, i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
  return t2 = "Blink" === e9.engine.name ? e9.engine.version || "" : e9.browser.version || "", i2 ? t2.split(".")[0] : t2;
}
function Yv() {
  return Hv().os;
}
function qv() {
  const e9 = Hv();
  return "".concat(e9.os, " ").concat(e9.osVersion);
}
function zv() {
  const e9 = Hv();
  return !!("WebKit" === Gv.engine.name && e9.os === Fv.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e9.name !== Bv.SAFARI || $v() && e9.name !== Bv.SAFARI);
}
function Jv() {
  return Hv().name === Bv.CHROME;
}
function Xv() {
  return Hv().name === Bv.SAFARI;
}
function Qv() {
  return Hv().name === Bv.EDGE;
}
function Zv() {
  return Hv().name === Bv.FIREFOX;
}
function $v() {
  return Hv().os === Fv.IOS;
}
function ey(e9) {
  const t2 = Hv();
  return !(t2.name !== Bv.CHROME || !t2.osVersion) && Number(t2.version) >= e9;
}
function ty(e9) {
  const t2 = Hv();
  return !(t2.name !== Bv.CHROME || !t2.osVersion) && Number(t2.version) < e9;
}
function iy(e9) {
  const t2 = Hv();
  return !(t2.name !== Bv.EDGE || !t2.osVersion) && Number(t2.version) >= e9;
}
function ny(e9) {
  const t2 = Hv();
  return !(t2.name !== Bv.SAFARI || !t2.osVersion) && Number(t2.version) >= e9;
}
function ry(e9, t2, i2) {
  const n2 = Hv();
  if (n2.os !== Fv.IOS || !n2.osVersion) return false;
  const r2 = n2.osVersion.split(".");
  return i2 ? t2 && Number(r2[0]) === e9 && Number(r2[1]) < t2 || Number(r2[0]) < e9 : t2 ? Number(r2[0]) === e9 && Number(r2[1]) <= t2 || Number(r2[0]) < e9 : Number(r2[0]) <= e9;
}
function oy(e9, t2, i2) {
  const n2 = Hv();
  if (n2.name !== Bv.SAFARI || !n2.osVersion || !n2.browserVersion) return false;
  const r2 = n2.browserVersion.split(".");
  return i2 ? t2 && Number(r2[0]) === e9 && Number(r2[1]) < t2 || Number(r2[0]) < e9 : t2 ? Number(r2[0]) === e9 && Number(r2[1]) <= t2 || Number(r2[0]) < e9 : Number(r2[0]) <= e9;
}
function sy(e9) {
  const t2 = Hv();
  return !(t2.name !== Bv.OPERA || !t2.osVersion) && Number(t2.version) >= e9;
}
function ay() {
  const e9 = Hv();
  if (e9.os !== Fv.IOS || !e9.osVersion) return false;
  const t2 = e9.osVersion.split(".");
  return Number(t2[0]) < 14 || 14 === Number(t2[0]) && Number(t2[1]) <= 6;
}
function cy() {
  const e9 = Hv();
  if (e9.os !== Fv.IOS || !e9.osVersion) return false;
  const t2 = e9.osVersion.split(".");
  return 15 === Number(t2[0]);
}
function dy() {
  const e9 = Hv();
  if (e9.os !== Fv.IOS || !e9.osVersion) return false;
  const t2 = e9.osVersion.split(".");
  return 16 === Number(t2[0]);
}
function ly() {
  const e9 = Hv();
  if (e9.os !== Fv.IOS || !e9.osVersion) return false;
  const t2 = e9.osVersion.split(".");
  return 15 === Number(t2[0]) && Number(t2[1]) >= 1;
}
function uy() {
  return Xv() && navigator.maxTouchPoints > 0;
}
function hy() {
  return Hv().name === Bv.WECHAT;
}
function py() {
  return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35;
}
function _y() {
  const e9 = Yv();
  return function() {
    const { deviceType: e10 } = Hv();
    return "mobile" === e10 || "tablet" === e10;
  }() || e9 === Fv.ANDROID || e9 === Fv.IOS || e9 === Fv.HARMONY_OS;
}
function Ey() {
  const e9 = Hv();
  return e9.name !== Bv.EDGE && e9.name !== Bv.SAFARI && !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i);
}
function fy() {
  return Yv() === Fv.ANDROID;
}
function my() {
  const e9 = Hv();
  return fy() && (e9.name === Bv.CHROME || e9.name === Bv.WECHAT || /chrome|chromium/i.test(navigator.userAgent));
}
function Ty(e9, t2, i2) {
  return (t2 = function(e10) {
    var t3 = function(e11, t4) {
      if ("object" != typeof e11 || !e11) return e11;
      var i3 = e11[Symbol.toPrimitive];
      if (void 0 !== i3) {
        var n2 = i3.call(e11, "string");
        if ("object" != typeof n2) return n2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(e11);
    }(e10);
    return "symbol" == typeof t3 ? t3 : t3 + "";
  }(t2)) in e9 ? Object.defineProperty(e9, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e9[t2] = i2, e9;
}
function Sy(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function gy(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? Sy(Object(i2), true).forEach(function(t3) {
      Ty(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : Sy(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var Ry = function(e9) {
  return e9.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", e9.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", e9.TIMEOUT = "TIMEOUT", e9.INVALID_PARAMS = "INVALID_PARAMS", e9.NOT_READABLE = "NOT_READABLE", e9.NOT_SUPPORTED = "NOT_SUPPORTED", e9.INVALID_OPERATION = "INVALID_OPERATION", e9.OPERATION_ABORTED = "OPERATION_ABORTED", e9.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", e9.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", e9.ADD_CANDIDATE_FAILED = "ADD_CANDIDATE_FAILED", e9.DATACHANNEL_FAILED = "DATACHANNEL_FAILED", e9.NETWORK_ERROR = "NETWORK_ERROR", e9.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", e9.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", e9.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", e9.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", e9.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", e9.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", e9.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", e9.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", e9.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", e9.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", e9.PERMISSION_DENIED = "PERMISSION_DENIED", e9.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", e9.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", e9.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", e9.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", e9.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", e9.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", e9.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", e9.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", e9.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", e9.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", e9.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", e9.UID_CONFLICT = "UID_CONFLICT", e9.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", e9.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", e9.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", e9.INVALID_TRACK = "INVALID_TRACK", e9.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", e9.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", e9.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", e9.ICE_FAILED = "ICE_FAILED", e9.PC_CLOSED = "PC_CLOSED", e9.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", e9.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", e9.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", e9.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", e9.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", e9.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e9.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", e9.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", e9.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", e9.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", e9.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", e9.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", e9.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", e9.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", e9.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", e9.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", e9.WS_ABORT = "WS_ABORT", e9.WS_DISCONNECT = "WS_DISCONNECT", e9.WS_ERR = "WS_ERR", e9.EXTERNAL_SIGNAL_ABORT = "EXTERNAL_SIGNAL_ABORT", e9.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", e9.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", e9.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", e9.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", e9.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", e9.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", e9.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", e9.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", e9.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", e9.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", e9.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", e9.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", e9.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", e9.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", e9.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", e9.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", e9.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", e9.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", e9.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", e9.INVALID_PLUGIN = "INVALID_PLUGIN", e9.DISCONNECT_P2P = "DISCONNECT_P2P", e9.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = "CONVERTING_IMAGEDATA_TO_BLOB_FAILED", e9.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED", e9.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT", e9.CREATE_DATACHANNEL_ERROR = "CREATE_DATACHANNEL_ERROR", e9.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT", e9.PROHIBITED_OPERATION = "PROHIBITED_OPERATION", e9.IMAGE_MODERATION_UPLOAD_FAILED = "IMAGE_MODERATION_UPLOAD_FAILED", e9.P2P_MESSAGE_FAILED = "P2P_MESSAGE_FAILED", e9;
}({});
var Cy = class extends Error {
  constructor(e9) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", i2 = arguments.length > 2 ? arguments[2] : void 0;
    super(t2), Ty(this, "code", void 0), Ty(this, "message", void 0), Ty(this, "data", void 0), Ty(this, "name", "AgoraRTCException"), this.code = e9, this.message = "AgoraRTCError ".concat(this.code, ": ").concat(t2), this.data = i2;
  }
  toString() {
    return this.data ? "data: ".concat(JSON.stringify(this.data), "\n").concat(this.stack) : "".concat(this.stack);
  }
  print() {
    let e9 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error", t2 = arguments.length > 1 ? arguments[1] : void 0;
    return "error" === e9 && (t2 || console).error(this.toString()), "warning" === e9 && (t2 || console).warn(this.toString()), this;
  }
  throw(e9) {
    throw this.print("error", e9), this;
  }
};
function Iy(e9, t2) {
  if ("boolean" != typeof e9) throw new Cy(Ry.INVALID_PARAMS, "Invalid ".concat(t2, ": The value is of the boolean type."));
}
function vy(e9, t2, i2) {
  if (!Dn(i2).call(i2, e9)) throw new Cy(Ry.INVALID_PARAMS, "".concat(t2, " can only be set as ").concat(JSON.stringify(i2)));
}
function yy(e9, t2) {
  let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4;
  if (e9 < i2 || e9 > n2 || (!(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]) && !function(e10) {
    return "number" == typeof e10 && e10 % 1 == 0;
  }(e9)) throw new Cy(Ry.INVALID_PARAMS, "invalid ".concat(t2, ": the value range is [").concat(i2, ", ").concat(n2, "]. integer only"));
}
function Ay(e9, t2) {
  if ("number" != typeof e9) {
    if (!(e9.min || e9.max || e9.ideal || e9.exact)) throw new Cy(Ry.INVALID_PARAMS, "".concat(t2, " is not a valid ConstrainLong"));
    void 0 !== e9.min && yy(e9.min, "".concat(t2, ".min"), 0, 1 / 0), void 0 !== e9.max && yy(e9.max, "".concat(t2, ".max"), 1, 1 / 0), void 0 !== e9.exact && yy(e9.exact, "".concat(t2, ".exact"), 1, 1 / 0), void 0 !== e9.ideal && yy(e9.ideal, "".concat(t2, ".ideal"), 1, 1 / 0);
  } else yy(e9, t2, 1, 1 / 0);
}
function by(e9, t2) {
  let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255, r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
  if (null == e9) throw new Cy(Ry.INVALID_PARAMS, "".concat(t2 || "param", " cannot be empty"));
  if (!Ny(e9, i2, n2, r2)) throw new Cy(Ry.INVALID_PARAMS, "Invalid ".concat(t2 || "string param", ": Length of the string: [").concat(i2, ",").concat(n2, "].").concat(r2 ? " ASCII characters only." : ""));
}
function wy(e9, t2) {
  if (!Array.isArray(e9)) throw new Cy(Ry.INVALID_PARAMS, "".concat(t2, " should be an array"));
}
function Oy(e9) {
  return null == e9;
}
function Ny(e9) {
  let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255, n2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
  return "string" == typeof e9 && e9.length <= i2 && e9.length >= t2 && (!n2 || function(e10) {
    if ("string" != typeof e10) return false;
    for (let t3 = 0; t3 < e10.length; t3 += 1) {
      const i3 = e10.charCodeAt(t3);
      if (i3 < 0 || i3 > 255) return false;
    }
    return true;
  }(e9));
}
var Dy = function(e9) {
  return e9.COVERED = "COVERED", e9.POSITION = "POSITION", e9.SIZE = "SIZE", e9.STYLE = "STYLE", e9;
}(Dy || {});
var Py = function(e9) {
  return e9.UNMOUNTED = "UNMOUNTED", e9.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT", e9;
}(Py || {});
var Ly = new class {
  constructor() {
    Ty(this, "_clientSize", null), Ty(this, "getClientWidth", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), Ty(this, "getClientHeight", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), Ty(this, "getStyle", (e9) => window.getComputedStyle(e9, null)), Ty(this, "checkCssVisibleProperty", (e9) => {
      var t2;
      let i2 = true;
      const n2 = this.getStyle(e9), { display: r2, visibility: o2, opacity: s2, filter: a2 } = n2;
      return ("none" === r2 || Dn(t2 = ["hidden", "collapse"]).call(t2, o2) || Number(s2) < 0.1) && (i2 = false), !!i2 && (a2 && a2.split(" ").filter((e10) => {
        var t3;
        const i3 = e10.split("(")[0];
        return Dn(t3 = ["brightness", "blur", "opacity"]).call(t3, i3);
      }).map((e10) => {
        const [t3, i3] = e10.split(/\(|\)/);
        return [t3, Number(i3.match(/^[0-9\.]+/))];
      }).forEach((e10) => {
        const [t3, n3] = e10;
        switch (t3) {
          case "brightness":
            (n3 < 0.1 || n3 > 3) && (i2 = false);
            break;
          case "blur":
            n3 > 3 && (i2 = false);
            break;
          case "opacity":
            n3 < 0.1 && (i2 = false);
        }
      }), i2);
    }), Ty(this, "checkPropertyUpToAllParentNodes", (e9, t2) => {
      let i2 = true, n2 = true;
      const r2 = (e10) => t2(e10);
      let o2 = e9;
      for (; o2 && n2; ) r2(o2) || (i2 = false, n2 = false), o2 = o2.parentElement, o2 || (n2 = false);
      return i2;
    }), Ty(this, "checkActualCssVisibleIncludeInherit", (e9) => this.checkPropertyUpToAllParentNodes(e9, this.checkCssVisibleProperty)), Ty(this, "getSizeAboutClient", (e9) => {
      const { width: t2, height: i2, left: n2, right: r2, top: o2, bottom: s2 } = e9.getBoundingClientRect(), a2 = this.getClientWidth(), c2 = this.getClientHeight();
      return { width: t2, height: i2, left: n2, right: r2, top: o2, bottom: s2, clientWidth: a2, clientHeight: c2, clientMin: Math.min(a2, c2) };
    }), Ty(this, "checkActualSize", () => {
      const { width: e9, height: t2, clientMin: i2 } = this._clientSize;
      return this.checkSizeIsVisible(e9, t2, i2);
    }), Ty(this, "elementFromPoint", (e9, t2) => document.elementFromPoint ? document.elementFromPoint(e9, t2) : null), Ty(this, "checkCoverForAPoint", (e9, t2, i2) => {
      const n2 = this.elementFromPoint(e9, t2);
      return null !== n2 && n2 !== i2;
    }), Ty(this, "getPointPositionList", () => {
      const { width: e9, height: t2, left: i2, top: n2 } = this._clientSize, r2 = e9 / 6, o2 = t2 / 6, s2 = [], a2 = 10 ** 6;
      for (let e10 = 0; e10 < 5; e10++) for (let t3 = 0; t3 < 5; t3++) {
        const c2 = (i2 * a2 + (0 === e10 ? 0.1 : 4 === e10 ? (r2 * e10 * a2 - 1e5) / a2 : r2 * e10) * a2) / a2, d2 = (n2 * a2 + (0 === t3 ? 0.1 : 4 === t3 ? (o2 * t3 * a2 - 1e5) / a2 : o2 * t3) * a2) / a2;
        s2.push({ x: c2, y: d2 });
      }
      return [...s2];
    }), Ty(this, "checkElementCover", (e9) => this.getPointPositionList().map((t2) => this.checkCoverForAPoint(t2.x, t2.y, e9)).filter((e10) => !!e10).length > 6), Ty(this, "checkSizeIsVisible", (e9, t2, i2) => (e9 > 50 || i2 / e9 <= 10) && (t2 > 50 || i2 / t2 <= 10)), Ty(this, "checkSizeOfPartInClient", () => {
      const { left: e9, right: t2, top: i2, bottom: n2, clientHeight: r2, clientWidth: o2, clientMin: s2 } = this._clientSize;
      let a2, c2, d2, l2;
      if (e9 < 0) a2 = 0;
      else {
        if (!(e9 < o2)) return false;
        a2 = e9;
      }
      if (t2 < 0) return false;
      if (c2 = t2 < o2 ? t2 : o2, i2 < 0) d2 = 0;
      else {
        if (!(i2 < r2)) return false;
        d2 = i2;
      }
      if (n2 < 0) return false;
      l2 = n2 < r2 ? n2 : r2;
      const u2 = c2 - a2, h2 = l2 - d2;
      return this.checkSizeIsVisible(u2, h2, s2);
    }), Ty(this, "returnHiddenResult", (e9) => (this._clientSize = null, { visible: false, reason: e9 })), Ty(this, "checkOneElementVisible", (e9) => {
      if (e9 instanceof HTMLElement) {
        if (this.checkElementIsMountedOnDom(e9)) {
          if (this.checkActualCssVisibleIncludeInherit(e9)) {
            if (this._clientSize = this.getSizeAboutClient(e9), this.checkElementCover(e9)) return this.returnHiddenResult(Dy.COVERED);
            {
              const e10 = this.checkActualSize(), t2 = this.checkSizeOfPartInClient();
              return e10 && !t2 ? this.returnHiddenResult(Dy.POSITION) : e10 ? (this._clientSize = null, { visible: true }) : this.returnHiddenResult(Dy.SIZE);
            }
          }
          return this.returnHiddenResult(Dy.STYLE);
        }
        return this.returnHiddenResult(Py.UNMOUNTED);
      }
      return this.returnHiddenResult(Py.INVALID_HTML_ELEMENT);
    }), Ty(this, "checkElementIsMountedOnDom", (e9) => this.checkPropertyUpToAllParentNodes(e9, (e10) => "HTML" !== e10.nodeName.toUpperCase() ? null !== e10.parentElement : !!document.documentElement));
  }
}();
function ky(e9) {
  return new TextEncoder().encode(e9);
}
var My = function(e9, t2) {
  const i2 = new Uint8Array(e9.byteLength + t2.byteLength);
  return i2.set(new Uint8Array(e9), 0), i2.set(new Uint8Array(t2), e9.byteLength), i2;
};
var Uy = async (e9) => function(e10, t2) {
  let i2 = "";
  return new Uint8Array(e10).forEach((e11) => {
    i2 += e11.toString(t2).padStart(2, "0");
  }), i2;
}(await crypto.subtle.digest("SHA-256", ky(e9)), 16);
var xy = class {
  constructor() {
    Ty(this, "_events", {}), Ty(this, "addListener", this.on);
  }
  getListeners(e9) {
    return this._events[e9] ? this._events[e9].map((e10) => e10.listener) : [];
  }
  on(e9, t2) {
    this._events[e9] || (this._events[e9] = []);
    const i2 = this._events[e9];
    -1 === this._indexOfListener(i2, t2) && i2.push({ listener: t2, once: false });
  }
  once(e9, t2) {
    this._events[e9] || (this._events[e9] = []);
    const i2 = this._events[e9];
    -1 === this._indexOfListener(i2, t2) && i2.push({ listener: t2, once: true });
  }
  off(e9, t2) {
    if (!this._events[e9]) return;
    const i2 = this._events[e9], n2 = this._indexOfListener(i2, t2);
    -1 !== n2 && i2.splice(n2, 1), 0 === this._events[e9].length && delete this._events[e9];
  }
  removeAllListeners(e9) {
    e9 ? delete this._events[e9] : this._events = {};
  }
  emit(e9) {
    this._events[e9] || (this._events[e9] = []);
    const t2 = this._events[e9].map((e10) => e10);
    for (var i2 = arguments.length, n2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) n2[r2 - 1] = arguments[r2];
    for (let i3 = 0; i3 < t2.length; i3 += 1) {
      const r3 = t2[i3];
      r3.once && this.off(e9, r3.listener), r3.listener.apply(this, n2 || []);
    }
  }
  safeEmit(e9) {
    for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++) i2[n2 - 1] = arguments[n2];
    [...this._events[e9] || []].forEach((t3) => {
      t3.once && this.off(e9, t3.listener);
      try {
        t3.listener.apply(this, i2);
      } catch (t4) {
        console.error("safeEmit event:".concat(e9, " error ").concat(null == t4 ? void 0 : t4.toString()));
      }
    });
  }
  _indexOfListener(e9, t2) {
    let i2 = e9.length;
    for (; i2--; ) if (e9[i2].listener === t2) return i2;
    return -1;
  }
};
var Vy = null;
function Fy() {
  if (Vy) return Vy;
  if (window.electron) return Vy = window.electron;
  if (!window.require) return null;
  try {
    return Vy = window.require("electron"), Vy;
  } catch (e9) {
    return null;
  }
}
var By = function(e9) {
  return e9.CREATE_CLIENT = "createClient", e9.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements", e9.SET_AREA = "setArea", e9.PRELOAD = "PRELOAD", e9.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive", e9.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive", e9.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack", e9.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack", e9.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack", e9.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack", e9.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack", e9.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks", e9.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack", e9.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig", e9.START_PROXY_SERVER = "Client.startProxyServer", e9.STOP_PROXY_SERVER = "Client.stopProxyServer", e9.SET_PROXY_SERVER = "Client.setProxyServer", e9.SET_TURN_SERVER = "Client.setTurnServer", e9.SET_CLIENT_ROLE = "Client.setClientRole", e9.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter", e9.ENABLE_DUAL_STREAM = "Client.enableDualStream", e9.DISABLE_DUAL_STREAM = "Client.disableDualStream", e9.JOIN = "Client.join", e9.LEAVE = "Client.leave", e9.PUBLISH = "Client.publish", e9.UNPUBLISH = "Client.unpublish", e9.SUBSCRIBE = "Client.subscribe", e9.MASS_SUBSCRIBE = "Client.massSubscribe", e9.MASS_UNSUBSCRIBE = "Client.massUnsubscribe", e9.UNSUBSCRIBE = "Client.unsubscribe", e9.RENEW_TOKEN = "Client.renewToken", e9.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType", e9.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption", e9.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator", e9.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage", e9.INSPECT_VIDEO_CONTENT = "Client.inspectVideoContent", e9.STOP_INSPECT_VIDEO_CONTENT = "Client.stopInspectVideoContent", e9.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy", e9.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning", e9.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError", e9.START_LIVE_STREAMING = "Client.startLiveStreaming", e9.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding", e9.STOP_LIVE_STREAMING = "Client.stopLiveStreaming", e9.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay", e9.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay", e9.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay", e9.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request", e9.SET_CONFIG_DISTRIBUTE = "_configDistribute", e9.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute", e9.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play", e9.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement", e9.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop", e9.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume", e9.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice", e9.BUFFER_AUDIO_TRACK_START = "BufferSourceAudioTrack.startProcessAudioBuffer", e9.BUFFER_AUDIO_TRACK_STOP = "BufferSourceAudioTrack.stopProcessAudioBuffer", e9.BUFFER_AUDIO_TRACK_PAUSE = "BufferSourceAudioTrack.pauseProcessAudioBuffer", e9.BUFFER_AUDIO_TRACK_RESUME = "BufferSourceAudioTrack.resumeProcessAudioBuffer", e9.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer", e9.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play", e9.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop", e9.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = "LocalVideoTrack.getVideoElementVisibleStatus", e9.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect", e9.LOCAL_VIDEO_SEND_SEI_DATA = "LocalVideoTrack.sendSeiData", e9.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice", e9.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = "CameraVideoTrack.setEncoderConfiguration", e9.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play", e9.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop", e9.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = "RemoteVideoTrack.getVideoElementVisibleStatus", e9.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play", e9.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop", e9.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume", e9.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice", e9.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack", e9.STREAM_TYPE_CHANGE = "streamTypeChange", e9.CONNECTION_STATE_CHANGE = "connectionStateChange", e9.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage", e9.IMAGE_MODERATION_UPLOAD = "imageModerationUpload", e9;
}({});
var jy = function(e9) {
  return e9.TRACER = "tracer", e9;
}({});
function Gy(e9) {
  return yy(e9.timeout, "config.timeout", 0, 1e5), yy(e9.timeoutFactor, "config.timeoutFactor", 0, 100, false), yy(e9.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0), yy(e9.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0), true;
}
var Wy = function(e9) {
  return e9[e9.AUDIENCE_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LEVEL_LOW_LATENCY", e9[e9.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY", e9[e9.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = "AUDIENCE_LEVEL_SYNC_LATENCY", e9;
}({});
var Hy = function(e9) {
  return e9.LEAVE = "LEAVE", e9.NETWORK_ERROR = "NETWORK_ERROR", e9.SERVER_ERROR = "SERVER_ERROR", e9.UID_BANNED = "UID_BANNED", e9.FALLBACK = "FALLBACK", e9.IP_BANNED = "IP_BANNED", e9.CHANNEL_BANNED = "CHANNEL_BANNED", e9.LICENSE_MISSING = "LICENSE_MISSING", e9.LICENSE_EXPIRED = "LICENSE_EXPIRED", e9.LICENSE_MINUTES_EXCEEDED = "LICENSE_MINUTES_EXCEEDED", e9.LICENSE_PERIOD_INVALID = "LICENSE_PERIOD_INVALID", e9.LICENSE_MULTIPLE_SDK_SERVICE = "LICENSE_MULTIPLE_SDK_SERVICE", e9.LICENSE_ILLEGAL = "LICENSE_ILLEGAL", e9.TOKEN_EXPIRE = "TOKEN_EXPIRE", e9;
}({});
function Ky(e9) {
  if (!Array.isArray(e9) || e9.length < 1) return false;
  try {
    e9.forEach((e10) => {
      if (!e10.urls) throw Error();
    });
  } catch (e10) {
    return false;
  }
  return true;
}
function Yy(e9) {
  return by(e9.turnServerURL, "turnServerURL"), by(e9.username, "username"), by(e9.password, "password"), e9.udpport && yy(e9.udpport, "udpport", 1, 99999, true), e9.forceturn && Iy(e9.forceturn, "forceturn"), e9.security && Iy(e9.security, "security"), e9.tcpport && yy(e9.tcpport, "tcpport", 1, 99999, true), true;
}
function qy(e9) {
  return void 0 !== e9.level && vy(e9.level, "level", [1, 2, 3]), void 0 !== e9.delay && yy(e9.delay, "delay", 0, 3e3, true), true;
}
var zy = function(e9) {
  return e9.CONNECTION_STATE_CHANGE = "connection-state-change", e9.MEDIA_RECONNECT_START = "media-reconnect-start", e9.MEDIA_RECONNECT_END = "media-reconnect-end", e9.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy", e9.USER_JOINED = "user-joined", e9.USER_LEAVED = "user-left", e9.USER_PUBLISHED = "user-published", e9.USER_UNPUBLISHED = "user-unpublished", e9.USER_INFO_UPDATED = "user-info-updated", e9.CLIENT_BANNED = "client-banned", e9.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state", e9.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event", e9.VOLUME_INDICATOR = "volume-indicator", e9.CRYPT_ERROR = "crypt-error", e9.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire", e9.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire", e9.NETWORK_QUALITY = "network-quality", e9.STREAM_TYPE_CHANGED = "stream-type-changed", e9.STREAM_FALLBACK = "stream-fallback", e9.RECEIVE_METADATA = "receive-metadata", e9.STREAM_MESSAGE = "stream-message", e9.LIVE_STREAMING_ERROR = "live-streaming-error", e9.LIVE_STREAMING_WARNING = "live-streaming-warning", e9.EXCEPTION = "exception", e9.ERROR = "error", e9.P2P_LOST = "p2p_lost", e9.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy", e9.CHANNEL_FALLBACK_TO_WEBSOCKET = "channel-fallback-to-websocket", e9.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change", e9.PUBLISHED_USER_LIST = "published-user-list", e9.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = "content-inspect-connection-state-change", e9.CONTENT_INSPECT_ERROR = "content-inspect-error", e9.CONTENT_INSPECT_RESULT = "content-inspect-result", e9.IMAGE_MODERATION_CONNECTION_STATE_CHANGE = "image-moderation-connection-state-change", e9;
}({});
var Jy = function(e9) {
  return e9.NETWORK_ERROR = "NETWORK_ERROR", e9.SERVER_ERROR = "SERVER_ERROR", e9.MULTI_IP = "MULTI_IP", e9.TIMEOUT = "TIMEOUT", e9.OFFLINE = "OFFLINE", e9.LEAVE = "LEAVE", e9.P2P_FAILED = "P2P_FAILED", e9.FALLBACK = "FALLBACK", e9;
}({});
var Xy = function(e9) {
  return e9.ONLINE = "ONLINE", e9.OFFLINE = "OFFLINE", e9;
}({});
var Qy = function(e9) {
  return e9.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE", e9.ONLINE = "ONLINE", e9.OFFLINE = "OFFLINE", e9;
}({});
function Zy(e9, t2) {
  for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++) n2[r2 - 2] = arguments[r2];
  return 0 === e9.getListeners(t2).length ? Gh.reject(new Cy(Ry.UNEXPECTED_ERROR, "can not emit promise")) : new Gh((i3, r3) => {
    e9.emit(t2, ...n2, i3, r3);
  });
}
function $y(e9, t2) {
  if (0 === e9.getListeners(t2).length) return Gh.resolve();
  for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++) n2[r2 - 2] = arguments[r2];
  return Zy(e9, t2, ...n2);
}
function eA(e9, t2) {
  if (0 === e9.getListeners(t2).length) return null;
  for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++) n2[r2 - 2] = arguments[r2];
  return tA(e9, t2, ...n2);
}
function tA(e9, t2) {
  let i2 = null, n2 = null;
  for (var r2 = arguments.length, o2 = new Array(r2 > 2 ? r2 - 2 : 0), s2 = 2; s2 < r2; s2++) o2[s2 - 2] = arguments[s2];
  if (e9.emit(t2, ...o2, (e10) => {
    i2 = e10;
  }, (e10) => {
    n2 = e10;
  }), null !== n2) throw n2;
  if (null === i2) throw new Cy(Ry.UNEXPECTED_ERROR, "handler is not sync");
  return i2;
}
var iA = new class extends xy {
  set networkState(e9) {
    this.emit(Qy.NETWORK_STATE_CHANGE, e9, this._networkState), e9 === Xy.ONLINE ? this.emit(Qy.ONLINE) : e9 === Xy.OFFLINE && (this.onlineWaiter = new Gh((e10) => {
      this.once(Qy.ONLINE, () => {
        this.onlineWaiter = void 0, e10(Xy.ONLINE);
      });
    }), this.emit(Qy.OFFLINE)), this._networkState = e9;
  }
  get networkState() {
    return this._networkState;
  }
  get isOnline() {
    return this._networkState === Xy.ONLINE;
  }
  constructor() {
    super(), Ty(this, "_moduleName", "network-indicator"), Ty(this, "_networkState", Xy.ONLINE), Ty(this, "onlineWaiter", void 0), window.addEventListener("online", () => {
      this.networkState = Xy.ONLINE;
    }), window.addEventListener("offline", () => {
      this.networkState = Xy.OFFLINE;
    });
  }
}();
function nA(e9, t2) {
  const i2 = e9.indexOf(t2);
  -1 !== i2 && e9.splice(i2, 1);
}
function rA(e9) {
  const t2 = [];
  return e9.forEach((e10) => {
    -1 === t2.indexOf(e10) && t2.push(e10);
  }), t2;
}
function oA(e9) {
  void 0 !== Gh ? Gh.resolve().then(e9) : setTimeout(e9, 0);
}
function sA(e9) {
  return JSON.parse(JSON.stringify(e9));
}
function aA(e9) {
  try {
    return sA(e9);
  } catch (t2) {
    return e9;
  }
}
var cA = {};
function dA(e9, t2) {
  cA[t2] || (cA[t2] = true, e9());
}
function lA(e9) {
  const t2 = window.atob(e9), i2 = new Uint8Array(new ArrayBuffer(t2.length));
  for (let e10 = 0; e10 < t2.length; e10 += 1) i2[e10] = t2.charCodeAt(e10);
  return i2;
}
function uA(e9) {
  let t2 = "";
  for (let i2 = 0; i2 < e9.length; i2 += 1) t2 += String.fromCharCode(e9[i2]);
  return window.btoa(t2);
}
function hA(e9) {
  let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16, i2 = new TextEncoder().encode(e9);
  if (i2.length > t2) i2 = i2.slice(0, t2);
  else if (i2.length < t2) {
    const e10 = new Uint8Array(t2);
    e10.set(i2), i2 = e10;
  }
  return i2;
}
function pA() {
  for (var e9 = arguments.length, t2 = new Array(e9), i2 = 0; i2 < e9; i2++) t2[i2] = arguments[i2];
  const n2 = Jn(t2).call(t2, (e10, t3) => e10 + t3.length, 0), r2 = new Uint8Array(new ArrayBuffer(n2));
  let o2 = 0;
  return t2.forEach((e10) => {
    r2.set(e10, o2), o2 += e10.length;
  }), r2;
}
function _A(e9) {
  return window.TextEncoder ? new TextEncoder().encode(e9).length : e9.length;
}
function EA(e9) {
  let t2 = 0;
  return (/DingTalk/i.test(navigator.userAgent) || /AliApp/i.test(navigator.userAgent)) && e9.realFormData && (e9 = e9.realFormData), e9.forEach((e10) => {
    t2 += "string" == typeof e10 ? _A(e10) : e10.size;
  }), t2 + 138;
}
function fA(e9) {
  const t2 = new Cy(Ry.TIMEOUT, "timeout");
  return new Gh((i2, n2) => {
    window.setTimeout(() => n2(t2), e9);
  });
}
function mA(e9) {
  return new Gh((t2) => {
    window.setTimeout(t2, e9);
  });
}
function TA() {
  let e9 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7, t2 = arguments.length > 1 ? arguments[1] : void 0;
  const i2 = Math.random().toString(16).substr(2, e9).toLowerCase();
  return i2.length === e9 ? "".concat(t2).concat(i2) : "".concat(t2).concat(i2) + TA(e9 - i2.length, "");
}
function SA() {
  return TA(32, "").toUpperCase();
}
var gA = () => {
};
var RA = new class {
  constructor() {
    Ty(this, "fnMap", /* @__PURE__ */ new Map());
  }
  throttleByKey(e9, t2, i2, n2) {
    for (var r2 = arguments.length, o2 = new Array(r2 > 4 ? r2 - 4 : 0), s2 = 4; s2 < r2; s2++) o2[s2 - 4] = arguments[s2];
    if (this.fnMap.has(t2)) {
      const r3 = this.fnMap.get(t2);
      if (r3.threshold !== i2) {
        r3.fn(...r3.args), clearTimeout(r3.timer);
        const s3 = window.setTimeout(() => {
          const e10 = this.fnMap.get(t2);
          e10 && e10.fn(...e10.args), this.fnMap.delete(t2);
        }, i2);
        this.fnMap.set(t2, { fn: e9, threshold: i2, timer: s3, args: o2, skipFn: n2 });
      } else r3.skipFn && r3.skipFn(...r3.args), this.fnMap.set(t2, gy(gy({}, r3), {}, { fn: e9, args: o2, skipFn: n2 }));
    } else {
      const r3 = window.setTimeout(() => {
        const e10 = this.fnMap.get(t2);
        e10 && e10.fn(...e10.args), this.fnMap.delete(t2);
      }, i2);
      this.fnMap.set(t2, { fn: e9, threshold: i2, timer: r3, args: o2, skipFn: n2 });
    }
  }
}();
var CA = RA.throttleByKey.bind(RA);
function IA(e9) {
  return "object" == typeof e9 && null !== e9 && !(e9 instanceof RegExp);
}
function vA(e9, t2) {
  if (!IA(e9) || !IA(t2)) return t2;
  if (Array.isArray(e9) && !Array.isArray(t2) || !Array.isArray(e9) && Array.isArray(t2)) return t2;
  if (Array.isArray(t2) && Array.isArray(e9)) {
    const i2 = [...e9];
    for (let n2 = 0; n2 < t2.length; n2++) i2[n2] = vA(e9[n2], t2[n2]);
    return i2;
  }
  {
    const i2 = gy({}, e9);
    for (const n2 in t2) Object.prototype.hasOwnProperty.call(t2, n2) && (Object.prototype.hasOwnProperty.call(e9, n2) ? i2[n2] = vA(e9[n2], t2[n2]) : i2[n2] = t2[n2]);
    return i2;
  }
}
function yA(e9, t2) {
  let i2 = [0];
  if (t2 && (i2 = new Array(t2).fill(0)), 0 === e9) return i2;
  let n2 = 0;
  for (; e9 > 0 && (i2[n2] = 255 & e9, e9 >>= 8, n2++, !t2 || n2 !== t2); ) ;
  return i2;
}
function AA(e9) {
  return "number" == typeof e9 ? e9 : e9.exact || e9.ideal || e9.max || e9.min || 0;
}
function bA(e9) {
  const t2 = "0123456789abcdef";
  function i2(e10) {
    let i3, n3 = "";
    for (i3 = 0; i3 <= 3; i3++) n3 += t2.charAt(e10 >> 8 * i3 + 4 & 15) + t2.charAt(e10 >> 8 * i3 & 15);
    return n3;
  }
  function n2(e10, t3) {
    const i3 = (65535 & e10) + (65535 & t3);
    return (e10 >> 16) + (t3 >> 16) + (i3 >> 16) << 16 | 65535 & i3;
  }
  function r2(e10, t3, i3, r3, o3, s3) {
    return n2(function(e11, t4) {
      return e11 << t4 | e11 >>> 32 - t4;
    }(n2(n2(t3, e10), n2(r3, s3)), o3), i3);
  }
  function o2(e10, t3, i3, n3, o3, s3, a3) {
    return r2(t3 & i3 | ~t3 & n3, e10, t3, o3, s3, a3);
  }
  function s2(e10, t3, i3, n3, o3, s3, a3) {
    return r2(t3 & n3 | i3 & ~n3, e10, t3, o3, s3, a3);
  }
  function a2(e10, t3, i3, n3, o3, s3, a3) {
    return r2(t3 ^ i3 ^ n3, e10, t3, o3, s3, a3);
  }
  function c2(e10, t3, i3, n3, o3, s3, a3) {
    return r2(i3 ^ (t3 | ~n3), e10, t3, o3, s3, a3);
  }
  const d2 = function(e10) {
    let t3;
    const i3 = 1 + (e10.length + 8 >> 6), n3 = new Array(16 * i3);
    for (t3 = 0; t3 < 16 * i3; t3++) n3[t3] = 0;
    for (t3 = 0; t3 < e10.length; t3++) n3[t3 >> 2] |= e10.charCodeAt(t3) << t3 % 4 * 8;
    return n3[t3 >> 2] |= 128 << t3 % 4 * 8, n3[16 * i3 - 2] = 8 * e10.length, n3;
  }(e9);
  let l2, u2, h2, p2, _2, E2 = 1732584193, f2 = -271733879, m2 = -1732584194, T2 = 271733878;
  for (l2 = 0; l2 < d2.length; l2 += 16) u2 = E2, h2 = f2, p2 = m2, _2 = T2, E2 = o2(E2, f2, m2, T2, d2[l2 + 0], 7, -680876936), T2 = o2(T2, E2, f2, m2, d2[l2 + 1], 12, -389564586), m2 = o2(m2, T2, E2, f2, d2[l2 + 2], 17, 606105819), f2 = o2(f2, m2, T2, E2, d2[l2 + 3], 22, -1044525330), E2 = o2(E2, f2, m2, T2, d2[l2 + 4], 7, -176418897), T2 = o2(T2, E2, f2, m2, d2[l2 + 5], 12, 1200080426), m2 = o2(m2, T2, E2, f2, d2[l2 + 6], 17, -1473231341), f2 = o2(f2, m2, T2, E2, d2[l2 + 7], 22, -45705983), E2 = o2(E2, f2, m2, T2, d2[l2 + 8], 7, 1770035416), T2 = o2(T2, E2, f2, m2, d2[l2 + 9], 12, -1958414417), m2 = o2(m2, T2, E2, f2, d2[l2 + 10], 17, -42063), f2 = o2(f2, m2, T2, E2, d2[l2 + 11], 22, -1990404162), E2 = o2(E2, f2, m2, T2, d2[l2 + 12], 7, 1804603682), T2 = o2(T2, E2, f2, m2, d2[l2 + 13], 12, -40341101), m2 = o2(m2, T2, E2, f2, d2[l2 + 14], 17, -1502002290), f2 = o2(f2, m2, T2, E2, d2[l2 + 15], 22, 1236535329), E2 = s2(E2, f2, m2, T2, d2[l2 + 1], 5, -165796510), T2 = s2(T2, E2, f2, m2, d2[l2 + 6], 9, -1069501632), m2 = s2(m2, T2, E2, f2, d2[l2 + 11], 14, 643717713), f2 = s2(f2, m2, T2, E2, d2[l2 + 0], 20, -373897302), E2 = s2(E2, f2, m2, T2, d2[l2 + 5], 5, -701558691), T2 = s2(T2, E2, f2, m2, d2[l2 + 10], 9, 38016083), m2 = s2(m2, T2, E2, f2, d2[l2 + 15], 14, -660478335), f2 = s2(f2, m2, T2, E2, d2[l2 + 4], 20, -405537848), E2 = s2(E2, f2, m2, T2, d2[l2 + 9], 5, 568446438), T2 = s2(T2, E2, f2, m2, d2[l2 + 14], 9, -1019803690), m2 = s2(m2, T2, E2, f2, d2[l2 + 3], 14, -187363961), f2 = s2(f2, m2, T2, E2, d2[l2 + 8], 20, 1163531501), E2 = s2(E2, f2, m2, T2, d2[l2 + 13], 5, -1444681467), T2 = s2(T2, E2, f2, m2, d2[l2 + 2], 9, -51403784), m2 = s2(m2, T2, E2, f2, d2[l2 + 7], 14, 1735328473), f2 = s2(f2, m2, T2, E2, d2[l2 + 12], 20, -1926607734), E2 = a2(E2, f2, m2, T2, d2[l2 + 5], 4, -378558), T2 = a2(T2, E2, f2, m2, d2[l2 + 8], 11, -2022574463), m2 = a2(m2, T2, E2, f2, d2[l2 + 11], 16, 1839030562), f2 = a2(f2, m2, T2, E2, d2[l2 + 14], 23, -35309556), E2 = a2(E2, f2, m2, T2, d2[l2 + 1], 4, -1530992060), T2 = a2(T2, E2, f2, m2, d2[l2 + 4], 11, 1272893353), m2 = a2(m2, T2, E2, f2, d2[l2 + 7], 16, -155497632), f2 = a2(f2, m2, T2, E2, d2[l2 + 10], 23, -1094730640), E2 = a2(E2, f2, m2, T2, d2[l2 + 13], 4, 681279174), T2 = a2(T2, E2, f2, m2, d2[l2 + 0], 11, -358537222), m2 = a2(m2, T2, E2, f2, d2[l2 + 3], 16, -722521979), f2 = a2(f2, m2, T2, E2, d2[l2 + 6], 23, 76029189), E2 = a2(E2, f2, m2, T2, d2[l2 + 9], 4, -640364487), T2 = a2(T2, E2, f2, m2, d2[l2 + 12], 11, -421815835), m2 = a2(m2, T2, E2, f2, d2[l2 + 15], 16, 530742520), f2 = a2(f2, m2, T2, E2, d2[l2 + 2], 23, -995338651), E2 = c2(E2, f2, m2, T2, d2[l2 + 0], 6, -198630844), T2 = c2(T2, E2, f2, m2, d2[l2 + 7], 10, 1126891415), m2 = c2(m2, T2, E2, f2, d2[l2 + 14], 15, -1416354905), f2 = c2(f2, m2, T2, E2, d2[l2 + 5], 21, -57434055), E2 = c2(E2, f2, m2, T2, d2[l2 + 12], 6, 1700485571), T2 = c2(T2, E2, f2, m2, d2[l2 + 3], 10, -1894986606), m2 = c2(m2, T2, E2, f2, d2[l2 + 10], 15, -1051523), f2 = c2(f2, m2, T2, E2, d2[l2 + 1], 21, -2054922799), E2 = c2(E2, f2, m2, T2, d2[l2 + 8], 6, 1873313359), T2 = c2(T2, E2, f2, m2, d2[l2 + 15], 10, -30611744), m2 = c2(m2, T2, E2, f2, d2[l2 + 6], 15, -1560198380), f2 = c2(f2, m2, T2, E2, d2[l2 + 13], 21, 1309151649), E2 = c2(E2, f2, m2, T2, d2[l2 + 4], 6, -145523070), T2 = c2(T2, E2, f2, m2, d2[l2 + 11], 10, -1120210379), m2 = c2(m2, T2, E2, f2, d2[l2 + 2], 15, 718787259), f2 = c2(f2, m2, T2, E2, d2[l2 + 9], 21, -343485551), E2 = n2(E2, u2), f2 = n2(f2, h2), m2 = n2(m2, p2), T2 = n2(T2, _2);
  return i2(E2) + i2(f2) + i2(m2) + i2(T2);
}
var wA = 1;
var OA = console;
var NA = class {
  static setLogger(e9) {
    OA = e9;
  }
  constructor(e9) {
    Ty(this, "lockingPromise", Gh.resolve()), Ty(this, "locks", 0), Ty(this, "name", ""), Ty(this, "lockId", void 0), this.lockId = wA++, e9 && (this.name = e9), OA.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is created."));
  }
  get isLocked() {
    return this.locks > 0;
  }
  lock(e9) {
    let t2;
    this.locks += 1, OA.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e9 ? e9 : ""));
    const i2 = new Gh((i3) => {
      t2 = () => {
        this.locks -= 1, OA.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is not locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e9 ? e9 : "")), i3();
      };
    }), n2 = this.lockingPromise.then(() => t2);
    return this.lockingPromise = this.lockingPromise.then(() => i2), n2;
  }
};
function DA(e9, t2) {
  return function(i2, n2, r2) {
    const o2 = r2.value;
    if ("function" != typeof o2) throw new Error("Cannot use mutex on object property.");
    return r2.value = async function() {
      const i3 = this[t2];
      if (!i3) throw new Error("mutex property key ".concat(t2, " doesn't exist on ").concat(e9));
      const r3 = await i3.lock("From ".concat(e9, ".").concat(n2));
      try {
        for (var s2 = arguments.length, a2 = new Array(s2), c2 = 0; c2 < s2; c2++) a2[c2] = arguments[c2];
        return await o2.apply(this, a2);
      } finally {
        r3();
      }
    }, r2;
  };
}
var PA = { timeout: 500, timeoutFactor: 1.5, maxRetryCount: 1 / 0, maxRetryTimeout: 1e4 };
function LA(e9, t2) {
  const i2 = Math.floor(t2.timeout * Math.pow(t2.timeoutFactor, e9));
  return Math.min(t2.maxRetryTimeout, i2);
}
function kA(e9, t2, i2, n2) {
  const r2 = Object.assign({}, PA, n2);
  let o2 = r2.timeout;
  const s2 = async () => {
    await function(e10) {
      return new Gh((t3) => {
        window.setTimeout(t3, e10);
      });
    }(o2), o2 *= r2.timeoutFactor, o2 = Math.min(r2.maxRetryTimeout, o2);
  };
  let a2 = false;
  const c2 = new Gh(async (n3, o3) => {
    t2 = t2 || (() => false), i2 = i2 || (() => true);
    for (let c3 = 0; c3 < r2.maxRetryCount; c3 += 1) {
      if (a2) return o3(new Cy(Ry.OPERATION_ABORTED));
      try {
        const i3 = await e9();
        if (!t2(i3, c3)) return n3(i3);
        if (c3 + 1 === r2.maxRetryCount) return n3(i3);
        await s2();
      } catch (e10) {
        if (!i2(e10, c3)) return o3(e10);
        if (c3 + 1 === r2.maxRetryCount) return o3(e10);
        await s2();
      }
    }
  });
  return c2.cancel = () => a2 = true, c2;
}
var MA = class {
  constructor(e9) {
    Ty(this, "input", []), Ty(this, "size", void 0), this.size = e9;
  }
  add(e9) {
    this.input.push(e9), this.input.length > this.size && this.input.splice(0, 1);
  }
  mean() {
    var e9;
    return 0 === this.input.length ? 0 : Jn(e9 = this.input).call(e9, (e10, t2) => e10 + t2) / this.input.length;
  }
};
var UA;
var xA = 0;
var VA = 0;
function FA(e9, t2, i2, n2) {
  return new Gh((r2, o2) => {
    t2.responseType = t2.responseType || "json", t2.data && !i2 ? (t2.data = JSON.stringify(t2.data), xA += _A(t2.data)) : i2 && (t2.data.size ? xA += t2.data.size : t2.data instanceof FormData ? xA += EA(t2.data) : xA += _A(JSON.stringify(t2.data))), t2.headers = t2.headers || {}, t2.headers["Content-Type"] = t2.headers["Content-Type"] || "application/json", t2.method = "POST", t2.url = e9, Lv.request(t2).then((e10) => {
      "string" == typeof e10.data ? VA += _A(e10.data) : e10.data instanceof ArrayBuffer || e10.data instanceof Uint8Array ? VA += e10.data.byteLength : VA += _A(JSON.stringify(e10.data)), n2 && r2({ data: e10.data, headers: e10.headers }), r2(e10.data);
    }).catch((e10) => {
      Lv.isCancel(e10) ? o2(new Cy(Ry.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e10.code ? o2(new Cy(Ry.NETWORK_TIMEOUT, e10.message)) : e10.response ? o2(new Cy(Ry.NETWORK_RESPONSE_ERROR, e10.response.status)) : o2(new Cy(Ry.NETWORK_ERROR, e10.message));
    });
  });
}
async function BA(e9, t2) {
  const i2 = new Blob([t2.data], { type: "buffer" });
  return await FA(e9, gy(gy({}, t2), {}, { data: i2, headers: { "Content-Type": "application/octet-stream" } }), true);
}
var jA = () => void 0 !== window.isSecureContext;
var GA = function(e9) {
  if (e9.match(/[0-9]+\.[0-9]+\.[0-9]+$/)) return e9;
  const t2 = e9.match(/([0-9]+\.[0-9]+\.[0-9]+)\-([0-9]+)/);
  if (t2 && t2[1] && t2[2]) {
    const e10 = t2[1], i2 = t2[2];
    return "".concat(e10, ".").concat(i2);
  }
  return "4.0.0.999";
}("4.22.1");
var WA = function() {
  try {
    return true === JSON.parse("true");
  } catch (e9) {
    return true;
  }
}();
var HA = function(e9) {
  return e9.Default = "default", e9.Auto = "auto", e9.Relay = "relay", e9.SdRtn = "sd-rtn", e9;
}({});
var KA = function() {
  const e9 = "us".concat("erna", "me"), t2 = "pa".concat("sswo", "rd"), i2 = ["t", "s", "t"];
  i2.splice(1, 0, "e");
  const n2 = i2.join(""), r2 = [];
  for (let e10 = 0; e10 < 6; e10++) r2.push("1");
  const o2 = r2.join(""), s2 = {};
  return s2[e9] = n2, s2[t2] = o2, Object.assign(s2, { turnServerURL: "", tcpport: 3433, udpport: 3478, forceturn: false });
}();
window.DEFAULT_TURN_CONFIG = KA;
var YA = { MIN_FRAME_RATE: 1, MAX_FRAME_RATE: 30, MAX_THRESHOLD_FRAMERATE: 30, BITRATE_MIN_THRESHOLD: 100, BITRATE_MAX_THRESHOLD: 100, MAX_SCALE: 5, BWE_SCALE_UP_THRESHOLD: 0.6, BWE_SCALE_DOWN_THRESHOLD: 0.6, PERF_SCALE_UP_THRESHOLD: 0.7, PERF_SCALE_DOWN_THRESHOLD: 0.6, MOTION_RESOLUTION_FACTOR: 0.8, MOTION_BITRATE_FACTOR: 0.6, DETAIL_FRAMERATE_FACTOR: 0.8, DETAIL_BITRATE_FACTOR: 0.6, BALANCE_RESOLUTION_FACTOR: 0.9, BALANCE_FRAMERATE_FACTOR: 0.9, BALANCE_BITRATE_FACTOR: 0.6, OVERUSE_TIMES_THRESHOLD: 10, UNDERUSE_TIMES_THRESHOLD: 40 };
var qA = "v4.22.1-0-g1c8e27e9(9/19/2024, 2:23:30 PM)";
var zA = gy(gy({ PROCESS_ID: "", ENCRYPT_AES: true, AREAS: ["CHINA", "GLOBAL"], WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-web-2.ap.sd-rtn.com", "cds-ap-web-3.agora.io", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-web-2.ap.sd-rtn.com", "sua-ap-web-3.agora.io", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-web-2.ap.sd-rtn.com", "uap-ap-web-3.agora.io", "uap-web-4.ap.sd-rtn.com"], LOG_UPLOAD_SERVER: "logservice.agora.io", EVENT_REPORT_DOMAIN: "statscollector-1.agora.io", EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com", ENABLE_EVENT_REPORT: true, GATEWAY_ADDRESS: [], GATEWAY_WSS_ADDRESS: "", LIVE_STREAMING_ADDRESS: "", HTTP_CONNECT_TIMEOUT: 5e3, SIGNAL_REQUEST_TIMEOUT: 1e4, REPORT_STATS: true, UPLOAD_LOG: false, NOT_REPORT_EVENT: [], PING_PONG_TIME_OUT: 10, WEBSOCKET_TIMEOUT_MIN: 1e4, EVENT_REPORT_SEND_INTERVAL: 3e3, CONFIG_DISTRIBUTE_INTERVAL: 3e5, ENABLE_CONFIG_DISTRIBUTE: true, CANDIDATE_TIMEOUT: 5e3, SHOW_REPORT_INVOKER_LOG: false, JOIN_EXTEND: "", PUB_EXTEND: "", SUB_EXTEND: "", FORCE_TURN: false, TURN_ENABLE_TCP: true, TURN_ENABLE_UDP: true, MAX_UPLOAD_CACHE: 50, UPLOAD_CACHE_INTERVAL: 2e3, AJAX_REQUEST_CONCURRENT: 3, REPORT_APP_SCENARIO: void 0, GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"], CONNECT_GATEWAY_WITHOUT_DOMAIN: false, WORKER_DOMAIN: "edge.agora.io", TURN_DOMAIN: "edge.agora.io", EVENT_REPORT_RETRY: true, CHROME_FORCE_PLAN_B: false, AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400, AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3, AUDIO_VOLUME_INDICATION_INTERVAL: 2e3, VOLUME_VOICE_WEIGHT: 10, GET_VOLUME_OF_MUTED_AUDIO_TRACK: false, STATS_UPDATE_INTERVAL: 250, NORMAL_EVENT_QUEUE_CAPACITY: 100, CUSTOM_REPORT: true, CUSTOM_REPORT_LIMIT: 20, PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io", PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com", "webrtc-cloud-proxy.agora.io"], CUSTOM_PUB_ANSWER_MODIFIER: null, CUSTOM_SUB_ANSWER_MODIFIER: null, CUSTOM_PUB_OFFER_MODIFIER: null, CUSTOM_SUB_OFFER_MODIFIER: null, DSCP_TYPE: "high", REMOVE_NEW_CODECS: true, FRAGEMENT_LENGTH: 3, WEBSOCKET_COMPRESS: false, SIMULCAST: false, PRELOAD_MEDIA_COUNT: 0, CHECK_VIDEO_VISIBLE_INTERVAL: 3e4, CHECK_LOCAL_STATS_INTERVAL: 250, PROFILE_SWITCH_INTERVAL: 2e3, UNSUPPORTED_VIDEO_CODEC: [], ENUMERATE_DEVICES_INTERVAL: false, ENUMERATE_DEVICES_INTERVAL_TIME: 1e4, USE_NEW_TOKEN: false, CLOSE_AFB_FOR_LOCAL_AP: true, JOIN_MAX_CONCURRENCY: 6, JOIN_WITH_FALLBACK_SIGNAL_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: false, JOIN_GATEWAY_TRY_443PORT_DURATION: 2e3, JOIN_GATEWAY_USE_443PORT_ONLY: false, JOIN_GATEWAY_USE_DUAL_DOMAIN: true, JOIN_GATEWAY_FALLBACK_PORT: 443, USE_TURN_SERVER_OF_GATEWAY: false, H264_PROFILE_LEVEL_ID: "", USE_NEW_LOG: false, LOG_VERSION: 3, MEDIA_DEVICE_CONSTRAINTS: null, ENCRYPT_PROXY_USERNAME_AND_PSW: true, SDP_LOGGING: false, CSP_DETECTED_HOSTNAME_LIST: ["agora.io", "sd-rtn.com"], REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: false, LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: false, BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE", AI_DENOISER_PARAMETERS: { excludedLinks: [] }, ADJUST_3A_FROM_PLUGINS: true, RAISE_H264_BASELINE_PRIORITY: true, FILTER_SEND_H264_BASELINE: false, X_GOOGLE_START_BITRATE: void 0, NEW_REPORT_SERVER: false, NEW_REPORT_SERVER_DOMAINS: ["data-reporting.agora.io", "data-reporting.agora.io"], VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3, VIDEO_INSPECT_QUALITY_RATIO: 0.9, VIDEO_INSPECT_WORKER_MANAGER_HOST: "edge.agora.io", VIDEO_INSPECT_WORKER_MANAGER_PORT: "", VIDEO_INSPECT_WORKER_PORT: "", SHOW_VIDEO_INSPECT_WORKER_MESSAGE: false, STATS_COLLECTOR_PORT: 443, FORCE_TURN_TCP: false, WEBAUDIO_INIT_OPTIONS: void 0, FILTER_VIDEO_FEC: true, FILTER_AUDIO_FEC: false, CHROME_DUAL_STREAM_USE_ENCODING: true, DISABLE_DUAL_STREAM_USE_ENCODING: false, EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4, ICE_RESTART: true, ICE_RESTART_INTERVAL: 1e4, NEW_ICE_RESTART: false, TRANSMITTER_INITIAL_RTT: 30, TRANSMITTER_INITIAL_RTO: 30, TRANSMITTER_MAX_BATCH_ACK_COUNT: 2, TRANSMITTER_MAX_RTO: 500, DATACHANNEL_COMPRESS: false, FINGERPRINT: null, DC_JOIN_WITH_FAILBACK: 5e3, ENABLE_VIDEO_FRAME_CALLBACK: true, VIDEO_FREEZE_DURATION: 500, SPATIALIZER_PARAMETERS: {}, UPLOAD_LOG_INTERVAL: 3e3, UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3, UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4, UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3, UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4, UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200, UPLOAD_LOG_LENGTH_EACH_TIME: 10, APP_TYPE: 0, DISABLE_WEBAUDIO: false, CHANNEL_MEDIA_RELAY_SERVERS: void 0, KEEP_LAST_FRAME: true, FORWARD_P2P_CREATION: true, SYNC_GROUP: true, BLOCK_LOCAL_CLIENT: false, AP_AREA: true, ENABLE_ENCODED_TRANSFORM: false, ENABLE_VIDEO_SEI: false, IMAGE_MODERATION_WORKER_HOST: "edge.agora.io", IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, IMAGE_MODERATION_INTERVAL_MINIMUM: 1e3, SHOW_IMAGE_MODERATION_WORKER_MESSAGE: false, IMAGE_MODERATION_QUALITY_RATIO: 0.9, IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL: 5e3, SHOW_GLOBAL_CLIENT_LIST: false, DATASTREAM_MAX_RETRANSMITS: 10, TCP_CANDIDATE_ONLY: false, EXTERNAL_SIGNAL_REQUEST_TIMEOUT: 3e3, SHOW_P2P_LOG: false, MAX_P2P_TIMEOUT: 3e4, P2P_TOKEN_INTERVAL: 1e3, SHOW_DATASTREAM2_LOG: false, RESTRICTION_SET_PLAYBACK_DEVICE: true, USE_PURE_ENCRYPTION_MASTER_KEY: false, ACCOUNT_REGISTER_RETRY_TIMEOUT: 1, ACCOUNT_REGISTER_RETRY_RATIO: 2, ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4, ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5, AUDIO_CONTEXT: null, WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3, PLAYER_STATE_DEFER: 2e3, SIGNAL_REQUEST_WATCH_INTERVAL: 1e3, FILEPATH_LENMAX: 255, DUALSTREAM_OPERATION_CHECK: true, MEDIA_ELEMENT_EXISTS_DEPTH: 3, SHIM_CANDIDATE: false, LEAVE_MSG_TIMEOUT: 2e3, STATS_FILTER: { transportId: true, googTrackId: true }, FILTER_VIDEO_CODEC: [], USE_NEW_NETWORK_CONFIG: false, AUTO_RESET_AUDIO_ROUTE: false, PLUGIN_INFO: [], OVERUSE_DETECTOR_PARAMS: YA, ENABLE_AG_ADAPTATION: true, FORCE_AG_HIGH_FRAMERATE: false, FORCE_SUPPORT_AG_ADAPTATION: false, CUSTOM_ADAPTATION_DEFAULT_MODE: "", ENCODER_CONFIG_LIMIT: {}, CAMERA_CAPTURE_CONFIG: void 0, HIDE_NO_POSTER: false, AP_CACHE_NUM: 10, AP_UPDATE_INTERVAL: 12e4, AP_CACHE_LIFETIME: 12e4, MAX_PRELOAD_ASYNC_LENGTH: 3, ENABLE_PRELOAD: true, DISABLE_SCREEN_SHARE_REMB: false }, { ENABLE_PUBLISHED_USER_LIST: true, MAX_SUBSCRIPTION: 50, SUBSCRIBE_AUDIO_FILTER_TOPN: void 0, ENABLE_PUBLISH_AUDIO_FILTER: void 0, ENABLE_USER_LICENSE_CHECK: true, USE_PUB_RTX: true, USE_SUB_RTX: true, DISABLE_FEC: void 0, ENABLE_NTP_REPORT: false, ENABLE_INSTANT_VIDEO: false, ENABLE_DATASTREAM_2: false, ENABLE_USER_AUTO_REBALANCE_CHECK: true, USE_XR: true, ENABLE_LOSSBASED_BWE: true, ENABLE_AUT_CC: false, ENABLE_CC_FALLBACK: void 0, ENABLE_PREALLOC_PC: false, SUBSCRIBE_TWCC: true, PUBLISH_TWCC: false, ENABLE_SVC: false, ENABLE_SVC_DEFAULT_CODECS: ["H264", "VP8", "VP9", "AV1"], SVC: [], ENABLE_FULL_LINK_AV_SYNC: false, SVC_MODE: null, PRE_SUB_NUM: 2, ENABLE_PRE_SUB: false, ENABLE_AUT_FEEDBACK: false }), {}, { USE_CANDIDATE_FROM_AP_DETAIL: false, AP_REQUEST_DETAIL: void 0 });
function JA(e9, t2, i2) {
  var n2, r2, o2;
  Dn(n2 = Object.keys(zA)).call(n2, e9) && (!i2 && Dn(r2 = Object.keys(QA)).call(r2, e9) || (zA[e9] = t2, "ENABLE_VIDEO_SEI" === e9 && true === t2 && (zA.ENABLE_ENCODED_TRANSFORM = true), "USE_NEW_NETWORK_CONFIG" === e9 && t2 && (o2 = !!t2, zA.USE_NEW_NETWORK_CONFIG = o2, o2 && (zA.WEBCS_DOMAIN = ["webrtc2-2.ap.sd-rtn.com"], zA.WEBCS_DOMAIN_BACKUP_LIST = ["webrtc2-4.ap.sd-rtn.com"], zA.CDS_AP = ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], zA.ACCOUNT_REGISTER = ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], zA.EVENT_REPORT_DOMAIN = "web-2.statscollector.sd-rtn.com", zA.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-1.agora.io", zA.GATEWAY_DOMAINS = ["edge.sd-rtn.com"])), "ENABLE_PRE_SUB" === e9 && t2 && (zA.ENABLE_INSTANT_VIDEO = true, zA.ENABLE_PREALLOC_PC = true), "ENABLE_SVC" === e9 && t2 && (zA.ENABLE_AUT_CC = true)));
}
function XA(e9) {
  return zA[e9];
}
WA || (zA.WEBCS_DOMAIN = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"], zA.WEBCS_DOMAIN_BACKUP_LIST = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"], zA.PROXY_CS = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"], zA.CDS_AP = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], zA.ACCOUNT_REGISTER = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], zA.UAP_AP = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], zA.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io", zA.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io", zA.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io", zA.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io", zA.AREAS = ["NORTH_AMERICA", "OVERSEA"]);
var QA = {};
var ZA = function(e9) {
  return e9.SET_SESSION_ID = "SET_SESSION_ID", e9.SET_P2P_ID = "SET_P2P_id", e9.SET_DC_ID = "SET_DC_id", e9.SET_UID = "SET_UID", e9.SET_INT_UID = "SET_INT_UID", e9.SET_PUB_ID = "SET_PUB_ID", e9.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE", e9.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED", e9.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START", e9.AVOID_JOIN_START = "AVOID_JOIN_START", e9.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END", e9.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START", e9.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END", e9.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START", e9.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END", e9.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START", e9.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END", e9.KEY_METRIC_DESCRIPTION_START = "KEY_METRIC_DESCRIPTION_START", e9.KEY_METRIC_ICE_CONNECTION_END = "KEY_METRIC_ICE_CONNECTION_END", e9.KEY_METRIC_SIGNAL_CHANNEL_OPEN = "KEY_METRIC_SIGNAL_CHANNEL_OPEN", e9.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH", e9.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE", e9.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE", e9.RESET_JOIN_CHANNEL_SERVICE_RECORDS = "RESET_JOIN_CHANNEL_SERVICE_RECORDS", e9.RESET_KEY_METRICS = "RESET_KEY_METRICS", e9.SET_USE_P2P = "SET_USE_P2P", e9.SET_TRANSPORT_TYPE = "SET_TRANSPORT_TYPE", e9;
}(ZA || {});
var $A = class {
  constructor(e9, t2, i2, n2) {
    Ty(this, "state", void 0), this.state = { codec: e9, audioCodec: t2, mode: i2, clientId: n2, sessionId: null, p2pId: 0, dcId: 0, pubId: 0, subId: 0, avoidJoinStart: 0, keyMetrics: { publish: [], subscribe: [] }, joinChannelServiceRecords: [], cloudProxyServerMode: "disabled", useP2P: false, p2pTransport: HA.Default };
  }
  dispatch(e9) {
    this.state = function(e10, t2) {
      switch (t2.type) {
        case ZA.SET_SESSION_ID:
          return gy(gy({}, e10), {}, { sessionId: t2.sessionId });
        case ZA.SET_P2P_ID:
          return gy(gy({}, e10), {}, { p2pId: t2.p2pId });
        case ZA.SET_UID:
          return gy(gy({}, e10), {}, { uid: t2.uid });
        case ZA.SET_INT_UID:
          return gy(gy({}, e10), {}, { intUid: t2.intUid });
        case ZA.SET_PUB_ID:
          return gy(gy({}, e10), {}, { pubId: t2.pubId });
        case ZA.KEY_METRIC_CLIENT_CREATED:
          return gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { clientCreated: t2.metric }) });
        case ZA.KEY_METRIC_JOIN_START:
          return gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { joinStart: t2.metric }) });
        case ZA.AVOID_JOIN_START:
          return gy(gy({}, e10), {}, { avoidJoinStart: t2.avoidJoinStart });
        case ZA.KEY_METRIC_JOIN_END:
          return gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { joinEnd: t2.metric }) });
        case ZA.KEY_METRIC_REQUEST_AP_START:
          return gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { requestAPStart: t2.metric }) });
        case ZA.KEY_METRIC_REQUEST_AP_END:
          return gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { requestAPEnd: t2.metric }) });
        case ZA.KEY_METRIC_JOIN_GATEWAY_START:
          return gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { joinGatewayStart: t2.metric }) });
        case ZA.KEY_METRIC_JOIN_GATEWAY_END:
          return gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { joinGatewayEnd: t2.metric }) });
        case ZA.KEY_METRIC_PEER_CONNECTION_START:
          return gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { peerConnectionStart: t2.metric }) });
        case ZA.KEY_METRIC_PEER_CONNECTION_END:
          return gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { peerConnectionEnd: t2.metric }) });
        case ZA.KEY_METRIC_DESCRIPTION_START:
          return gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { descriptionStart: t2.metric }) });
        case ZA.KEY_METRIC_SIGNAL_CHANNEL_OPEN:
          return gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { signalChannelOpen: t2.metric }) });
        case ZA.KEY_METRIC_ICE_CONNECTION_END:
          return gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { iceConnectionEnd: t2.metric }) });
        case ZA.KEY_METRIC_PUBLISH: {
          const i2 = e10.keyMetrics.publish, n2 = i2.findIndex((e11) => e11.trackId === t2.metric.trackId);
          return -1 !== n2 ? (i2[n2] = gy(gy({}, i2[n2]), t2.metric), gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { publish: [...i2] }) })) : gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { publish: [...e10.keyMetrics.publish, t2.metric] }) });
        }
        case ZA.KEY_METRIC_SUBSCRIBE: {
          const i2 = e10.keyMetrics.subscribe, n2 = i2.findIndex((e11) => e11.userId === t2.metric.userId && e11.type === t2.metric.type);
          return -1 !== n2 ? (i2[n2] = gy(gy({}, i2[n2]), t2.metric), gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { subscribe: [...i2] }) })) : gy(gy({}, e10), {}, { keyMetrics: gy(gy({}, e10.keyMetrics), {}, { subscribe: [...e10.keyMetrics.subscribe, t2.metric] }) });
        }
        case ZA.SET_CLOUD_PROXY_SERVER_MODE:
          return e10.cloudProxyServerMode = t2.mode, e10;
        case ZA.RECORD_JOIN_CHANNEL_SERVICE:
          return "number" != typeof t2.index ? e10.joinChannelServiceRecords = [...e10.joinChannelServiceRecords, t2.record] : (e10.joinChannelServiceRecords[t2.index] = gy(gy({}, e10.joinChannelServiceRecords[t2.index]), t2.record), e10.joinChannelServiceRecords = [...e10.joinChannelServiceRecords]), e10;
        case ZA.RESET_JOIN_CHANNEL_SERVICE_RECORDS:
          return e10.joinChannelServiceRecords = [], e10;
        case ZA.RESET_KEY_METRICS:
          return e10.keyMetrics = { publish: [], subscribe: [] }, e10;
        case ZA.SET_USE_P2P:
          return gy(gy({}, e10), {}, { useP2P: t2.val });
        case ZA.SET_TRANSPORT_TYPE:
          return gy(gy({}, e10), {}, { p2pTransport: t2.val });
        default:
          return e10;
      }
    }(this.state, e9);
  }
  set sessionId(e9) {
    this.dispatch({ type: ZA.SET_SESSION_ID, sessionId: e9 });
  }
  get sessionId() {
    return this.state.sessionId;
  }
  set codec(e9) {
    this.state.codec = e9;
  }
  get codec() {
    return this.state.codec;
  }
  get mode() {
    return this.state.mode;
  }
  get audioCodec() {
    return this.state.audioCodec;
  }
  get clientId() {
    return this.state.clientId;
  }
  set p2pId(e9) {
    this.dispatch({ type: ZA.SET_P2P_ID, p2pId: e9 });
  }
  get p2pId() {
    return this.state.p2pId;
  }
  set dcId(e9) {
    this.dispatch({ type: ZA.SET_DC_ID, dcId: e9 });
  }
  get dcId() {
    return this.state.dcId;
  }
  set uid(e9) {
    this.dispatch({ type: ZA.SET_UID, uid: e9 });
  }
  get uid() {
    return this.state.uid;
  }
  set intUid(e9) {
    this.dispatch({ type: ZA.SET_INT_UID, intUid: e9 });
  }
  get intUid() {
    return this.state.intUid;
  }
  set pubId(e9) {
    this.dispatch({ type: ZA.SET_PUB_ID, pubId: e9 });
  }
  get pubId() {
    return this.state.pubId;
  }
  set cloudProxyServerMode(e9) {
    this.dispatch({ type: ZA.SET_CLOUD_PROXY_SERVER_MODE, mode: e9 });
  }
  get cloudProxyServerMode() {
    return this.state.cloudProxyServerMode;
  }
  set useP2P(e9) {
    this.dispatch({ type: ZA.SET_USE_P2P, val: e9 });
  }
  get useP2P() {
    return this.state.useP2P;
  }
  set p2pTransport(e9) {
    this.dispatch({ type: ZA.SET_TRANSPORT_TYPE, val: e9 });
  }
  get p2pTransport() {
    return this.state.p2pTransport;
  }
  clientCreated() {
    this.dispatch({ type: ZA.KEY_METRIC_CLIENT_CREATED, metric: Date.now() });
  }
  joinStart() {
    this.dispatch({ type: ZA.KEY_METRIC_JOIN_START, metric: Date.now() });
  }
  joinEnd() {
    this.dispatch({ type: ZA.KEY_METRIC_JOIN_END, metric: Date.now() });
  }
  requestAPStart() {
    this.dispatch({ type: ZA.KEY_METRIC_REQUEST_AP_START, metric: Date.now() });
  }
  requestAPEnd() {
    this.dispatch({ type: ZA.KEY_METRIC_REQUEST_AP_END, metric: Date.now() });
  }
  joinGatewayStart() {
    this.dispatch({ type: ZA.KEY_METRIC_JOIN_GATEWAY_START, metric: Date.now() });
  }
  joinGatewayEnd() {
    this.dispatch({ type: ZA.KEY_METRIC_JOIN_GATEWAY_END, metric: Date.now() });
  }
  peerConnectionStart() {
    this.dispatch({ type: ZA.KEY_METRIC_PEER_CONNECTION_START, metric: Date.now() });
  }
  peerConnectionEnd() {
    this.dispatch({ type: ZA.KEY_METRIC_PEER_CONNECTION_END, metric: Date.now() });
  }
  descriptionStart() {
    this.dispatch({ type: ZA.KEY_METRIC_DESCRIPTION_START, metric: Date.now() });
  }
  signalChannelOpen() {
    this.dispatch({ type: ZA.KEY_METRIC_SIGNAL_CHANNEL_OPEN, metric: Date.now() });
  }
  iceConnectionEnd() {
    this.dispatch({ type: ZA.KEY_METRIC_ICE_CONNECTION_END, metric: Date.now() });
  }
  publish(e9, t2, i2, n2) {
    this.dispatch({ type: ZA.KEY_METRIC_PUBLISH, metric: gy(gy({ trackId: e9, type: t2 }, i2 && { publishStart: i2 }), n2 && { publishEnd: n2 }) });
  }
  subscribe(e9, t2, i2, n2, r2, o2, s2) {
    this.dispatch({ type: ZA.KEY_METRIC_SUBSCRIBE, metric: gy(gy(gy(gy(gy({ userId: e9, type: t2 }, i2 && { subscribeStart: i2 }), n2 && { subscribeEnd: n2 }), r2 && { firstFrame: r2 }), o2 && { streamAdded: o2 }), s2 && { firstDecoded: s2 }) });
  }
  massSubscribe(e9, t2, i2, n2) {
    e9.forEach((e10) => {
      this.dispatch({ type: ZA.KEY_METRIC_SUBSCRIBE, metric: gy(gy(gy({ userId: e10.userId, type: e10.type }, t2 && { subscribeStart: t2 }), i2 && { subscribeEnd: i2 }), n2 && { firstFrame: n2 }) });
    });
  }
  get keyMetrics() {
    return this.state.keyMetrics;
  }
  recordJoinChannelService(e9, t2) {
    "gateway" === e9.service && Array.isArray(e9.urls) && (e9.urls = e9.urls.map((e10) => e10.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2")));
    try {
      return "number" != typeof t2 ? (this.dispatch({ type: ZA.RECORD_JOIN_CHANNEL_SERVICE, record: gy(gy({}, e9), {}, { sessionId: this.sessionId, cloudProxyMode: this.cloudProxyServerMode, uid: this.uid }) }), this.state.joinChannelServiceRecords.length - 1) : (t2 < 0 || t2 >= this.state.joinChannelServiceRecords.length || this.dispatch({ type: ZA.RECORD_JOIN_CHANNEL_SERVICE, record: e9, index: t2 }), t2);
    } catch (e10) {
      return 0;
    }
  }
  resetJoinChannelServiceRecords() {
    this.dispatch({ type: ZA.RESET_JOIN_CHANNEL_SERVICE_RECORDS });
  }
  resetKeyMetrics() {
    this.dispatch({ type: ZA.RESET_KEY_METRICS });
  }
  get joinChannelServiceRecords() {
    try {
      return this.state.joinChannelServiceRecords;
    } catch (e9) {
      return [];
    }
  }
  get avoidJoinStart() {
    return this.state.avoidJoinStart;
  }
  set avoidJoinStart(e9) {
    this.dispatch({ type: ZA.AVOID_JOIN_START, avoidJoinStart: e9 });
  }
};
var eb = function(e9) {
  return e9.h264 = "h264", e9.h265 = "h265", e9.vp8 = "vp8", e9.vp9 = "vp9", e9.av1 = "av1", e9;
}({});
!function(e9) {
  e9.opus = "opus", e9.pcma = "pcma", e9.pcmu = "pcmu", e9.g722 = "g722";
}({});
var tb = 128;
var ib = 96;
var nb = 1e3;
var rb = 10;
var ob = 0;
function sb(e9, t2, i2) {
  return (t2 = function(e10) {
    var t3 = function(e11, t4) {
      if ("object" != typeof e11 || !e11) return e11;
      var i3 = e11[Symbol.toPrimitive];
      if (void 0 !== i3) {
        var n2 = i3.call(e11, "string");
        if ("object" != typeof n2) return n2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(e11);
    }(e10);
    return "symbol" == typeof t3 ? t3 : t3 + "";
  }(t2)) in e9 ? Object.defineProperty(e9, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e9[t2] = i2, e9;
}
function ab(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function cb(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? ab(Object(i2), true).forEach(function(t3) {
      sb(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : ab(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var db = new class extends xy {
  constructor() {
    super(...arguments), sb(this, "currentUploadLogID", 0);
  }
  reportLogUploadError(e9) {
    const { errorRange: t2 } = e9;
    t2[t2.length - 1] && t2[t2.length - 1] > this.currentUploadLogID && (this.currentUploadLogID = t2[t2.length - 1], this.emit("REPORT_LOG_UPLOAD", e9));
  }
}();
var lb = class {
  constructor(e9) {
    sb(this, "logger", void 0), sb(this, "prefixLists", []), this.logger = e9;
  }
  debug() {
    for (var e9 = arguments.length, t2 = new Array(e9), i2 = 0; i2 < e9; i2++) t2[i2] = arguments[i2];
    this.logger.debug(...this.prefixLists, ...t2);
  }
  info() {
    for (var e9 = arguments.length, t2 = new Array(e9), i2 = 0; i2 < e9; i2++) t2[i2] = arguments[i2];
    this.logger.info(...this.prefixLists, ...t2);
  }
  warning() {
    for (var e9 = arguments.length, t2 = new Array(e9), i2 = 0; i2 < e9; i2++) t2[i2] = arguments[i2];
    this.logger.warning(...this.prefixLists, ...t2);
  }
  error() {
    for (var e9 = arguments.length, t2 = new Array(e9), i2 = 0; i2 < e9; i2++) t2[i2] = arguments[i2];
    this.logger.error(...this.prefixLists, ...t2);
  }
  prefix(e9) {
    return this.prefixLists.push(e9), this;
  }
  popPrefix() {
    return this.prefixLists.pop(), this;
  }
};
function ub() {
  const e9 = /* @__PURE__ */ new Date();
  return e9.toTimeString().split(" ")[0] + ":" + e9.getMilliseconds();
}
function hb() {
  const e9 = /* @__PURE__ */ new Date(), t2 = /((\d+:){2}\d+)/.exec((/* @__PURE__ */ new Date()).toUTCString());
  return t2 ? (null == t2 ? void 0 : t2[0]) + ":" + e9.getUTCMilliseconds() : e9.toTimeString().split(" ")[0] + ":" + e9.getMilliseconds();
}
var pb = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 };
var _b = Date.now();
var Eb = (e9) => {
  for (const t2 in pb) if (Object.prototype.hasOwnProperty.call(pb, t2) && pb[t2] === e9) return t2;
  return "DEFAULT";
};
var fb = new class {
  constructor() {
    sb(this, "proxyServerURL", void 0), sb(this, "logLevel", pb.DEBUG), sb(this, "uploadState", "collecting"), sb(this, "uploadLogWaitingList", []), sb(this, "uploadLogUploadingList", []), sb(this, "uploadErrorCount", 0), sb(this, "currentLogID", 0), sb(this, "url", void 0), sb(this, "extLog", (e9, t2) => {
      this.appendLogToWaitingList(e9, ...t2);
    });
  }
  debug() {
    for (var e9 = arguments.length, t2 = new Array(e9), i2 = 0; i2 < e9; i2++) t2[i2] = arguments[i2];
    const n2 = [pb.DEBUG].concat(t2);
    this.log.apply(this, n2);
  }
  info() {
    for (var e9 = arguments.length, t2 = new Array(e9), i2 = 0; i2 < e9; i2++) t2[i2] = arguments[i2];
    const n2 = [pb.INFO].concat(t2);
    this.log.apply(this, n2);
  }
  warning() {
    for (var e9 = arguments.length, t2 = new Array(e9), i2 = 0; i2 < e9; i2++) t2[i2] = arguments[i2];
    const n2 = [pb.WARNING].concat(t2);
    this.log.apply(this, n2);
  }
  warn() {
    this.warning(...arguments);
  }
  error() {
    for (var e9 = arguments.length, t2 = new Array(e9), i2 = 0; i2 < e9; i2++) t2[i2] = arguments[i2];
    const n2 = [pb.ERROR].concat(t2);
    this.log.apply(this, n2);
  }
  upload() {
    for (var e9 = arguments.length, t2 = new Array(e9), i2 = 0; i2 < e9; i2++) t2[i2] = arguments[i2];
    const n2 = [pb.DEBUG].concat(t2);
    this.uploadLog.apply(this, n2);
  }
  setLogLevel(e9) {
    e9 = Math.min(Math.max(0, e9), 4), this.logLevel = e9;
  }
  enableLogUpload() {
    JA("UPLOAD_LOG", true);
  }
  disableLogUpload() {
    JA("UPLOAD_LOG", false), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];
  }
  setProxyServer(e9) {
    this.proxyServerURL = e9;
  }
  prefix(e9) {
    return new lb(this).prefix(e9);
  }
  log() {
    for (var e9 = arguments.length, t2 = new Array(e9), i2 = 0; i2 < e9; i2++) t2[i2] = arguments[i2];
    if (Date.now() - _b < 100) return void setTimeout(() => {
      this.log(...t2);
    }, Date.now() - _b);
    const n2 = Math.max(0, Math.min(4, t2[0]));
    if (t2[0] = ub() + " Agora-SDK [".concat(Eb(n2), "]:"), this.appendLogToWaitingList(n2, ...t2), n2 < this.logLevel) return;
    const r2 = ub() + " %cAgora-SDK [".concat(Eb(n2), "]:");
    let o2 = [];
    if (!XA("USE_NEW_LOG")) switch (n2) {
      case pb.DEBUG:
        o2 = [r2, "color: #64B5F6;"].concat(t2.slice(1)), console.log.apply(console, o2);
        break;
      case pb.INFO:
        o2 = [r2, "color: #1E88E5; font-weight: bold;"].concat(t2.slice(1)), console.log.apply(console, o2);
        break;
      case pb.WARNING:
        o2 = [r2, "color: #FB8C00; font-weight: bold;"].concat(t2.slice(1)), console.warn.apply(console, o2);
        break;
      case pb.ERROR:
        o2 = [r2, "color: #B00020; font-weight: bold;"].concat(t2.slice(1)), console.error.apply(console, o2);
    }
  }
  uploadLog() {
    for (var e9 = arguments.length, t2 = new Array(e9), i2 = 0; i2 < e9; i2++) t2[i2] = arguments[i2];
    if (Date.now() - _b < 100) return void setTimeout(() => {
      this.uploadLog(...t2);
    }, Date.now() - _b);
    const n2 = Math.max(0, Math.min(4, t2[0]));
    t2[0] = ub() + " Agora-SDK [".concat(Eb(n2), "]:"), this.appendLogToWaitingList(n2, ...t2);
  }
  appendLogToWaitingList(e9) {
    if (!XA("UPLOAD_LOG")) return;
    for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++) i2[n2 - 1] = arguments[n2];
    Array.isArray(i2[0]) ? i2[0][0] = hb() + " Agora-SDK [".concat(Eb(e9), "]:") : i2[0] = hb() + " Agora-SDK [".concat(Eb(e9), "]:");
    let r2 = "";
    i2.forEach((e10) => {
      "object" == typeof e10 && (e10 = JSON.stringify(e10)), r2 += "".concat(e10, " ");
    }), this.uploadLogWaitingList.push({ payload_str: r2, log_level: e9, log_item_id: this.currentLogID++ }), "uploading" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
  }
  startUpload() {
    this.uploadState = "uploading", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
  }
  async uploadLogs() {
    const e9 = this.uploadLogUploadingList, t2 = { sdk_version: GA, process_id: XA("PROCESS_ID"), payload: JSON.stringify(e9) };
    return kA(async () => {
      const e10 = await Lv.post(this.url || (this.proxyServerURL ? "https://".concat(this.proxyServerURL, "/ls/?h=").concat(XA("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(XA("LOG_UPLOAD_SERVER"), "/upload/v1")), t2, { responseType: "text" });
      if ("OK" !== e10.data) {
        const t3 = new Error("unexpected upload log response");
        throw t3.response = e10, t3;
      }
    }, () => (this.uploadLogUploadingList = [], false), (t3) => {
      const i2 = { status: -1, message: t3.message, errorRange: e9.map((e10) => e10.log_item_id) };
      return t3.response ? (i2.status = t3.response.status, i2.data = t3.response.data, i2.headers = t3.response.headers) : t3.request && (i2.status = t3.request.status), db.reportLogUploadError(i2), true;
    }, { timeout: XA("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"), maxRetryTimeout: XA("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL") });
  }
  uploadLogInterval() {
    0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, XA("UPLOAD_LOG_LENGTH_EACH_TIME"))), this.uploadLogs().then(() => {
      this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), XA("UPLOAD_LOG_INTERVAL"));
    }).catch((e9) => {
      this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), XA("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")) : window.setTimeout(() => this.uploadLogInterval(), XA("UPLOAD_LOG_RETRY_INTERVAL_V1"));
    }));
  }
}();
var mb;
function Tb(e9) {
  return by(e9.reportId, "params.reportId", 0, 100, false), by(e9.category, "params.category", 0, 100, false), by(e9.event, "params.event", 0, 100, false), by(e9.label, "params.label", 0, 100, false), yy(e9.value, "params.value", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, false), true;
}
(mb = {}).FREE = "free", mb.UPLOADING = "uploading", function(e9) {
  e9[e9.MISC = 0] = "MISC", e9[e9.INTERNAL_EVENT = 1] = "INTERNAL_EVENT", e9[e9.PUBLIC_EVENT = 2] = "PUBLIC_EVENT", e9[e9.WEB_EVENT = 3] = "WEB_EVENT", e9[e9.INTERNAL_API = 4] = "INTERNAL_API", e9[e9.WEB_API = 5] = "WEB_API", e9[e9.PUBLIC_API = 6] = "PUBLIC_API";
}({});
var Sb = { sid: "", lts: 0, success: null, cname: null, uid: null, peer: null, cid: null, elapse: null, extend: null, vid: 0 };
var gb = function(e9) {
  return e9.PUBLISH = "publish", e9.SUBSCRIBE = "subscribe", e9.WS_COMPRESSOR_INIT = "ws_compressor_init", e9.SESSION_INIT = "session_init", e9.JOIN_CHOOSE_SERVER = "join_choose_server", e9.REQ_USER_ACCOUNT = "req_user_account", e9.JOIN_GATEWAY = "join_gateway", e9.REJOIN_GATEWAY = "rejoin_gateway", e9.STREAM_SWITCH = "stream_switch", e9.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager", e9.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter", e9.FIRST_VIDEO_RECEIVED = "first_video_received", e9.FIRST_AUDIO_RECEIVED = "first_audio_received", e9.FIRST_VIDEO_DECODE = "first_video_decode", e9.FIRST_AUDIO_DECODE = "first_audio_decode", e9.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e9.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e9.ON_UPDATE_STREAM = "on_update_stream", e9.ON_REMOVE_STREAM = "on_remove_stream", e9.USER_ANALYTICS = "req_user_analytics", e9.PC_STATS = "pc_stats", e9.UPDATE_REMOTE_RTPCAPABILITIES = "update_remote_rtpCapabilities", e9;
}({});
var Rb = function(e9) {
  return e9.SESSION = "io.agora.pb.Wrtc.Session", e9.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer", e9.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount", e9.JOIN_GATEWAY = "io.agora.pb.Wrtc.JoinGateway", e9.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway", e9.PUBLISH = "io.agora.pb.Wrtc.Publish", e9.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe", e9.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit", e9.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch", e9.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped", e9.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped", e9.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter", e9.REQUEST_PROXY_WORKER_MANAGER = "io.agora.pb.Wrtc.RequestProxyWorkerManager", e9.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke", e9.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived", e9.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived", e9.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode", e9.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode", e9.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream", e9.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream", e9.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream", e9.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream", e9.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout", e9.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus", e9.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent", e9.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent", e9.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP", e9.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit", e9.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics", e9.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed", e9.PC_STATS = "io.agora.pb.Wrtc.PCStats", e9.UPDATE_REMOTE_RTPCAPABILITIES = "io.agora.pb.Wrtc.UpdateRemoteRTPCapabilities", e9;
}({});
!function(e9) {
  e9[e9.WORKER_EVENT = 156] = "WORKER_EVENT", e9[e9.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT";
}({});
var Cb = function(e9) {
  return e9[e9.SESSION = 26] = "SESSION", e9[e9.JOIN_CHOOSE_SERVER = 27] = "JOIN_CHOOSE_SERVER", e9[e9.REQ_USER_ACCOUNT = 196] = "REQ_USER_ACCOUNT", e9[e9.JOIN_GATEWAY = 28] = "JOIN_GATEWAY", e9[e9.PUBLISH = 30] = "PUBLISH", e9[e9.SUBSCRIBE = 29] = "SUBSCRIBE", e9[e9.WS_COMPRESSOR_INIT = 9430] = "WS_COMPRESSOR_INIT", e9[e9.STREAM_SWITCH = 32] = "STREAM_SWITCH", e9[e9.AUDIO_SENDING_STOPPED = 33] = "AUDIO_SENDING_STOPPED", e9[e9.VIDEO_SENDING_STOPPED = 34] = "VIDEO_SENDING_STOPPED", e9[e9.REQUEST_PROXY_APPCENTER = 35] = "REQUEST_PROXY_APPCENTER", e9[e9.REQUEST_PROXY_WORKER_MANAGER = 36] = "REQUEST_PROXY_WORKER_MANAGER", e9[e9.API_INVOKE = 41] = "API_INVOKE", e9[e9.FIRST_VIDEO_RECEIVED = 348] = "FIRST_VIDEO_RECEIVED", e9[e9.FIRST_AUDIO_RECEIVED = 349] = "FIRST_AUDIO_RECEIVED", e9[e9.FIRST_VIDEO_DECODE = 350] = "FIRST_VIDEO_DECODE", e9[e9.FIRST_AUDIO_DECODE = 351] = "FIRST_AUDIO_DECODE", e9[e9.ON_ADD_AUDIO_STREAM = 352] = "ON_ADD_AUDIO_STREAM", e9[e9.ON_ADD_VIDEO_STREAM = 353] = "ON_ADD_VIDEO_STREAM", e9[e9.ON_UPDATE_STREAM = 356] = "ON_UPDATE_STREAM", e9[e9.ON_REMOVE_STREAM = 355] = "ON_REMOVE_STREAM", e9[e9.JOIN_CHANNEL_TIMEOUT = 407] = "JOIN_CHANNEL_TIMEOUT", e9[e9.PEER_PUBLISH_STATUS = 408] = "PEER_PUBLISH_STATUS", e9[e9.WORKER_EVENT = 156] = "WORKER_EVENT", e9[e9.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT", e9[e9.JOIN_WEB_PROXY_AP = 700] = "JOIN_WEB_PROXY_AP", e9[e9.WEBSOCKET_QUIT = 671] = "WEBSOCKET_QUIT", e9[e9.USER_ANALYTICS = 1e4] = "USER_ANALYTICS", e9[e9.AUTOPLAY_FAILED = 9178] = "AUTOPLAY_FAILED", e9;
}({});
function Ib() {
  let e9 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  return function(t2, i2, n2) {
    const r2 = n2.value;
    if ("function" == typeof r2) {
      const o2 = e9.className || t2.__className__ || ("AgoraRTCClient" === t2.constructor.name ? "Client" : t2.constructor.name);
      n2.value = function() {
        for (var t3 = arguments.length, n3 = new Array(t3), s2 = 0; s2 < t3; s2++) n3[s2] = arguments[s2];
        let a2 = n3;
        if (e9.argsMap) try {
          a2 = e9.argsMap(this, ...n3);
        } catch (e10) {
          fb.warning(e10), a2 = [];
        }
        try {
          JSON.stringify(a2);
        } catch (e10) {
          fb.warning("arguments for method ".concat(o2, ".").concat(String(i2), " not serializable for apiInvoke.")), a2 = [];
        }
        const c2 = (e9.report || vb).reportApiInvoke(this._sessionId || null, { name: "".concat(o2, ".").concat(String(i2)), options: a2, tag: jy.TRACER, reportResult: e9.reportResult }, e9.throttleTime);
        try {
          const t4 = r2.apply(this, n3);
          return t4 instanceof Gh ? t4.then((t5) => (c2.onSuccess(e9.reportResult && t5), t5)).catch((e10) => {
            throw c2.onError(e10), e10;
          }) : (c2.onSuccess(e9.reportResult && t4), t4);
        } catch (e10) {
          throw c2.onError(e10), e10;
        }
      };
    }
    return n2;
  };
}
var vb = new class {
  constructor() {
    sb(this, "baseInfoMap", /* @__PURE__ */ new Map()), sb(this, "proxyServer", void 0), sb(this, "eventUploadTimer", void 0), sb(this, "setSessionIdTimer", void 0), sb(this, "url", void 0), sb(this, "sids", /* @__PURE__ */ new Set()), sb(this, "backupUrl", void 0), sb(this, "_appId", void 0), sb(this, "keyEventUploadPendingItems", []), sb(this, "normalEventUploadPendingItems", []), sb(this, "apiInvokeUploadPendingItems", []), sb(this, "apiInvokeCount", 0), sb(this, "ltsList", []), sb(this, "lastSendNormalEventTime", Date.now()), sb(this, "customReportCounterTimer", void 0), sb(this, "customReportCount", 0), sb(this, "extApiInvoke", async (e9) => {
      for (const t2 of e9) {
        const e10 = cb(cb({}, t2), {}, { sid: null, invokeId: ++this.apiInvokeCount, tag: jy.TRACER });
        this.sendApiInvoke(e10);
      }
    }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), XA("EVENT_REPORT_SEND_INTERVAL")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), XA("EVENT_REPORT_SEND_INTERVAL"));
  }
  getBaseInfoBySessionId(e9) {
    return this.baseInfoMap.get(e9);
  }
  adjustSessionStartTime(e9) {
    if (!this.baseInfoMap.has(e9) && !this.baseInfoMap.get(e9)) return void fb.error("adjust session ".concat(e9, " start time, sid is not exist or info is undefined"));
    const t2 = this.baseInfoMap.get(e9), i2 = Date.now(), n2 = t2.startTime;
    t2.startTime = i2, fb.debug("rewrite session ".concat(e9, " startTime: ").concat(i2, " , ").concat(i2 - n2, "ms")), this.baseInfoMap.set(e9, t2);
  }
  setAppId(e9) {
    this._appId = e9;
  }
  reportApiInvoke(e9, t2, i2) {
    t2.timeout = t2.timeout || 6e4, t2.reportResult = void 0 === t2.reportResult || t2.reportResult;
    const n2 = Date.now();
    this.apiInvokeCount += 1;
    const r2 = this.apiInvokeCount, o2 = () => ({ tag: t2.tag, invokeId: r2, sid: e9, name: t2.name, apiInvokeTime: n2, options: t2.options, states: t2.states || null }), s2 = !!XA("SHOW_REPORT_INVOKER_LOG");
    s2 && fb.info("".concat(t2.name, " start"), t2.options);
    let a2 = false;
    mA(t2.timeout).then(() => {
      a2 || (this.sendApiInvoke(cb(cb({}, o2()), {}, { error: Ry.API_INVOKE_TIMEOUT, success: false })), fb.debug("".concat(t2.name, " timeout")));
    });
    const c2 = new Cy(Ry.UNEXPECTED_ERROR, "".concat(t2.name, ": this api invoke is end"));
    return { onSuccess: (e10) => {
      const n3 = () => {
        if (a2) throw c2;
        return a2 = true, this.sendApiInvoke(cb(cb({}, o2()), {}, { success: true }, t2.reportResult && { result: e10 })), s2 && fb.info("".concat(t2.name, " onSuccess")), e10;
      };
      return i2 ? CA(n3, t2.name + "Success", i2, () => a2 = true) : n3();
    }, onError: (e10) => {
      const n3 = () => {
        if (a2) throw e10;
        a2 = true, this.sendApiInvoke(cb(cb({}, o2()), {}, { success: false, error: e10 })), s2 && fb.info("".concat(t2.name, " onFailure"), e10.toString());
      };
      return i2 ? CA(n3, t2.name + "Error", i2, () => a2 = true) : n3();
    } };
  }
  sessionInit(e9, t2) {
    if (this.baseInfoMap.has(e9)) return;
    const i2 = Date.now(), n2 = this.createBaseInfo(e9, i2);
    n2.cname = t2.cname;
    const r2 = Object.assign({}, { willUploadConsoleLog: XA("UPLOAD_LOG"), maxTouchPoints: navigator.maxTouchPoints, areaVersion: WA ? "global" : "oversea", areas: XA("AREAS") && XA("AREAS").join(",") }, t2.extend), { stringUid: o2, channelProfile: s2, channelMode: a2, isABTestSuccess: c2, lsid: d2, clientRole: l2 } = t2, u2 = Date.now(), h2 = cb(cb({}, n2), {}, { eventType: gb.SESSION_INIT, appid: t2.appid, browser: navigator.userAgent, buildFormat: t2.buildFormat, build: qA, lts: u2, elapse: u2 - i2, extend: JSON.stringify(r2), mode: t2.mode, process: XA("PROCESS_ID"), appType: XA("APP_TYPE"), success: true, version: GA, stringUid: o2, channelProfile: s2, channelMode: a2, isABTestSuccess: c2, lsid: d2, clientType: Dn(p2 = window.navigator.userAgent).call(p2, "AgoraWebView") ? 42 : 20, clientRole: l2, serviceId: XA("PROCESS_ID"), extensionID: XA("PLUGIN_INFO").join(",") || "" });
    var p2;
    this.send({ type: Rb.SESSION, data: h2 }, true);
  }
  joinChooseServer(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = i2.info, r2 = Date.now(), o2 = cb(cb({}, n2), {}, { eventType: gb.JOIN_CHOOSE_SERVER, lts: r2, eventElapse: t2.elapse || r2 - t2.lts, chooseServerAddr: t2.csAddr, errorCode: t2.ec, elapse: r2 - i2.startTime, success: t2.succ, chooseServerAddrList: JSON.stringify(t2.serverList), uid: t2.uid ? parseInt(t2.uid) : null, cid: t2.cid ? parseInt(t2.cid) : null, chooseServerIp: t2.csIp || "", opid: t2.opid, unilbsServerIds: t2.unilbsServerIds, extend: t2.extend || void 0, isHttp3: t2.isHttp3, corssRegionTagReq: t2.corssRegionTagReq || void 0, corssRegionTagRes: t2.corssRegionTagRes || void 0 });
    this.send({ type: Rb.JOIN_CHOOSE_SERVER, data: o2 }, true);
  }
  reqUserAccount(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = i2.info, r2 = Date.now(), o2 = cb(cb({}, n2), {}, { eventType: gb.REQ_USER_ACCOUNT, lts: r2, success: t2.success, serverAddress: t2.serverAddr, stringUid: t2.stringUid, uid: t2.uid, errorCode: t2.errorCode, elapse: t2.elapse || r2 - i2.startTime, eventElapse: r2 - t2.lts, extend: JSON.stringify(t2.extend) });
    this.send({ type: Rb.REQ_USER_ACCOUNT, data: o2 }, true);
  }
  joinGateway(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = i2.info;
    t2.vid && (n2.vid = t2.vid), n2.uid = t2.uid, n2.cid = t2.cid;
    const r2 = Date.now(), { firstSuccess: o2, avoidJoinStartTime: s2 } = t2, a2 = r2 - (o2 && s2 ? s2 : i2.startTime), c2 = cb(cb({}, n2), {}, { eventType: gb.JOIN_GATEWAY, lts: r2, gatewayAddr: t2.addr, success: t2.succ, errorCode: t2.ec, errorMsg: t2.errorMsg || "", elapse: a2, eventElapse: r2 - t2.lts, firstSuccess: o2, signalChannel: t2.signalChannel, preload: t2.preload ? 1 : 0 });
    t2.succ && (i2.lastJoinSuccessTime = r2), this.send({ type: Rb.JOIN_GATEWAY, data: c2 }, true);
  }
  joinChannelTimeout(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = Date.now(), r2 = cb(cb({}, i2.info), {}, { lts: n2, timeout: t2, elapse: n2 - i2.startTime });
    this.send({ type: Rb.JOIN_CHANNEL_TIMEOUT, data: r2 }, true);
  }
  publish(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = i2.info, r2 = Date.now(), o2 = cb(cb({}, n2), {}, { eventType: gb.PUBLISH, lts: r2, eventElapse: t2.eventElapse, elapse: r2 - i2.startTime, success: t2.succ, errorCode: t2.ec, videoName: t2.videoName, audioName: t2.audioName, screenName: t2.screenName, screenshare: t2.screenshare, audio: t2.audio, video: t2.video, p2pid: t2.p2pid, publishRequestid: t2.publishRequestid });
    this.send({ type: Rb.PUBLISH, data: o2 }, true);
  }
  subscribe(e9, t2, i2) {
    const n2 = this.baseInfoMap.get(e9);
    if (!n2) return;
    const r2 = n2.info, o2 = Date.now(), s2 = cb(cb({}, r2), {}, { eventType: gb.SUBSCRIBE, lts: o2, eventElapse: t2.eventElapse, elapse: o2 - n2.startTime, success: t2.succ, errorCode: t2.ec, video: t2.video, audio: t2.audio, subscribeRequestid: t2.subscribeRequestid, p2pid: t2.p2pid, preSsrc: t2.preSsrc ? 1 : 0 }, i2 && { extend: JSON.stringify({ isMassSubscribe: true }) });
    "string" == typeof t2.peerid ? s2.peerSuid = t2.peerid : s2.peer = t2.peerid, this.send({ type: Rb.SUBSCRIBE, data: s2 }, true);
  }
  wsCompressorInit(e9) {
    var t2;
    const i2 = [...d_(t2 = this.baseInfoMap).call(t2)], n2 = i2.length ? i2[0] : "UnableToGetSid", r2 = this.baseInfoMap.get(n2);
    if (!r2) return;
    const o2 = r2.info, s2 = Date.now(), a2 = cb(cb({}, o2), {}, { eventType: gb.WS_COMPRESSOR_INIT, lts: s2, eventElapse: e9.eventElapse, elapse: s2 - r2.startTime, status: e9.status ? 1 : 2 });
    this.send({ type: Rb.WS_COMPRESSOR_INIT, data: a2 }, true);
  }
  firstRemoteVideoDecode(e9, t2, i2, n2) {
    const r2 = this.baseInfoMap.get(e9);
    if (!r2) return;
    const o2 = r2.info, s2 = Date.now(), a2 = cb(cb(cb({}, o2), n2), {}, { elapse: s2 - r2.startTime, eventType: t2, lts: s2, firstDecodeFrame: Math.max((n2.firstFrame || s2) - r2.startTime, 0), apEnd: Math.max(n2.apEnd - r2.startTime, 0), apStart: Math.max(n2.apStart - r2.startTime, 0), joinGwEnd: Math.max(n2.joinGwEnd - r2.startTime, 0), joinGwStart: Math.max(n2.joinGwStart - r2.startTime, 0), pcEnd: Math.max(n2.pcEnd - r2.startTime, 0), pcStart: Math.max(n2.pcStart - r2.startTime, 0), subscriberEnd: Math.max(n2.subscriberEnd - r2.startTime, 0), subscriberStart: Math.max(n2.subscriberStart - r2.startTime, 0), videoAddNotify: Math.max(n2.videoAddNotify - r2.startTime, 0) });
    this.send({ type: i2, data: a2 }, true);
  }
  firstRemoteFrame(e9, t2, i2, n2) {
    const r2 = this.baseInfoMap.get(e9);
    if (!r2) return;
    const o2 = r2.info, s2 = Date.now(), a2 = cb(cb(cb({}, o2), n2), {}, { elapse: s2 - r2.startTime, eventType: t2, lts: s2 });
    this.send({ type: i2, data: a2 }, true);
  }
  pcStats(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = i2.info, r2 = Date.now(), o2 = cb(cb(cb({}, n2), t2), {}, { vid: void 0 === n2.vid ? 0 : Number(n2.vid), elapse: r2 - i2.startTime, eventType: gb.PC_STATS, lts: r2, preallocation: t2.preallocation ? 1 : 0 });
    this.send({ type: Rb.PC_STATS, data: o2 }, true);
  }
  updateRemoteRTPCapabilities(e9, t2) {
    if (e9) {
      const i2 = this.baseInfoMap.get(e9);
      if (!i2) return;
      const n2 = i2.info, r2 = Date.now(), o2 = cb(cb(cb({}, n2), t2), {}, { vid: void 0 === n2.vid ? 0 : Number(n2.vid), eventType: gb.UPDATE_REMOTE_RTPCAPABILITIES, lts: r2 });
      this.send({ type: Rb.UPDATE_REMOTE_RTPCAPABILITIES, data: o2 }, true);
    }
  }
  onGatewayStream(e9, t2, i2, n2) {
    const r2 = this.baseInfoMap.get(e9);
    if (!r2) return;
    const o2 = r2.info, s2 = Date.now(), a2 = cb(cb(cb({}, o2), n2), {}, { eventType: t2, lts: s2 });
    this.send({ type: i2, data: a2 }, true);
  }
  streamSwitch(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = i2.info, r2 = Date.now(), o2 = cb(cb({}, n2), {}, { eventType: gb.STREAM_SWITCH, lts: r2, isDual: t2.isdual, elapse: r2 - i2.startTime, success: t2.succ });
    this.send({ type: Rb.STREAM_SWITCH, data: o2 }, true);
  }
  requestProxyAppCenter(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = i2.info, r2 = Date.now(), o2 = cb(cb({}, n2), {}, { eventType: gb.REQUEST_PROXY_APPCENTER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i2.startTime, APAddr: t2.APAddr, workerManagerList: t2.workerManagerList, response: t2.response, errorCode: t2.ec, success: t2.succ });
    this.send({ type: Rb.REQUEST_PROXY_APPCENTER, data: o2 }, true);
  }
  requestProxyWorkerManager(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = i2.info, r2 = Date.now(), o2 = cb(cb({}, n2), {}, { eventType: gb.REQUEST_PROXY_WORKER_MANAGER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i2.startTime, workerManagerAddr: t2.workerManagerAddr, response: t2.response, errorCode: t2.ec, success: t2.succ });
    this.send({ type: Rb.REQUEST_PROXY_WORKER_MANAGER, data: o2 }, true);
  }
  setProxyServer(e9) {
    this.proxyServer = e9, e9 ? fb.debug("reportProxyServerurl: ".concat(e9)) : fb.debug("disable reportProxyServerurl: ".concat(e9));
  }
  peerPublishStatus(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = i2.info, r2 = Date.now(), o2 = cb(cb({}, n2), {}, { subscribeElapse: t2.subscribeElapse, peer: t2.peer, peerPublishDuration: Math.max(t2.audioPublishDuration, t2.videoPublishDuration), audiotag: t2.audioPublishDuration > 0 ? 1 : -1, videotag: t2.videoPublishDuration > 0 ? 1 : -1, lts: r2, elapse: r2 - i2.startTime, joinChannelSuccessElapse: r2 - (i2.lastJoinSuccessTime || r2), peerPublishDurationVideo: t2.videoPublishDuration, peerPublishDurationAudio: t2.audioPublishDuration });
    this.send({ type: Rb.PEER_PUBLISH_STATUS, data: o2 }, true);
  }
  workerEvent(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = i2.info, r2 = Date.now();
    (function(e10, t3, i3) {
      const n3 = e10[t3];
      if (!n3 || "string" != typeof n3) return [e10];
      e10[t3] = "";
      const r3 = _A(JSON.stringify(e10));
      let o2 = 0;
      const s2 = [];
      let a2 = 0;
      for (let c2 = 0; c2 < n3.length; c2++) a2 += n3.charCodeAt(c2) <= 127 ? 1 : 3, a2 <= i3 - r3 || (s2[s2.length] = gy(gy({}, e10), {}, { [t3]: n3.substring(o2, c2) }), o2 = c2, a2 = n3.charCodeAt(c2) <= 127 ? 1 : 3);
      return o2 !== n3.length - 1 && (s2[s2.length] = gy(gy({}, e10), {}, { [t3]: n3.substring(o2) })), s2;
    })(cb(cb(cb({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2, productType: "WebRTC" }), "payload", 1300).forEach((e10) => this.send({ type: Rb.WORKER_EVENT, data: e10 }, true));
  }
  apworkerEvent(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = i2.info, r2 = Date.now(), o2 = cb(cb(cb({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2 });
    this.send({ type: Rb.AP_WORKER_EVENT, data: o2 }, true);
  }
  joinWebProxyAP(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = i2.info, r2 = Date.now(), o2 = cb(cb(cb({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2, extend: t2.extend || void 0 });
    this.send({ type: Rb.JOIN_WEB_PROXY_AP, data: o2 }, true);
  }
  WebSocketQuit(e9, t2) {
    const i2 = this.baseInfoMap.get(e9);
    if (!i2) return;
    const n2 = i2.info, r2 = Date.now(), o2 = cb(cb(cb({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2 });
    this.send({ type: Rb.WEBSOCKET_QUIT, data: o2 }, true);
  }
  async sendCustomReportMessage(e9, t2) {
    if (this.customReportCount += t2.length, this.customReportCount > XA("CUSTOM_REPORT_LIMIT")) throw new Cy(Ry.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
    this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {
      this.customReportCount = 0;
    }, 5e3));
    const i2 = Date.now(), n2 = t2.map((t3) => ({ type: Rb.USER_ANALYTICS, data: cb(cb({ sid: e9 }, t3), {}, { lts: i2 }) }));
    try {
      XA("NEW_REPORT_SERVER") ? await this.postDataToStatsCollector2(n2) : await this.postDataToStatsCollector(n2);
    } catch (e10) {
      throw fb.error("send custom report message failed", e10.toString()), new Cy(Ry.CUSTOM_REPORT_SEND_FAILED, e10.message);
    }
  }
  sendApiInvoke(e9) {
    const t2 = XA("NOT_REPORT_EVENT");
    if (e9.tag && Dn(t2) && Dn(t2).call(t2, e9.tag)) return false;
    if (null === e9.sid) return this.apiInvokeUploadPendingItems.push(e9), false;
    const i2 = this.baseInfoMap.get(e9.sid);
    if (!i2) return this.apiInvokeUploadPendingItems.push(e9), false;
    const { cname: n2, uid: r2, cid: o2 } = i2.info;
    let s2;
    if (e9.lts = e9.lts || Date.now(), e9.error) if (e9.error instanceof Cy) {
      const { code: t3, message: i3 } = e9.error;
      s2 = t3 || i3 || e9.error.toString();
    } else s2 = e9.error.toString();
    const a2 = { invokeId: e9.invokeId, sid: e9.sid, cname: n2, cid: o2, uid: r2, lts: e9.lts, success: e9.success, elapse: e9.lts - i2.startTime, execElapse: e9.lts - e9.apiInvokeTime, apiName: e9.name, options: e9.options ? JSON.stringify(e9.options) : void 0, execStates: e9.states ? JSON.stringify(e9.states) : void 0, execResult: e9.result ? JSON.stringify(e9.result) : void 0, errorCode: e9.error ? s2 : void 0, errorMsg: e9.error ? JSON.stringify(e9.error) : void 0 };
    return this.send({ type: Rb.API_INVOKE, data: a2 }, false), true;
  }
  addSid(e9) {
    this.sids.add(e9);
  }
  removeSid(e9) {
    this.sids.delete(e9);
  }
  appendSessionId() {
    const e9 = this.apiInvokeUploadPendingItems;
    if (0 === e9.length) return;
    const t2 = Array.from(this.sids).find((e10) => null !== e10);
    t2 && e9.forEach((e10) => {
      e10 && (e10.sid = t2, this.sendApiInvoke(Object.assign({}, e10)));
    }), e9.length = 0;
  }
  send(e9, t2) {
    if (t2) return this.keyEventUploadPendingItems.push(e9), void this.sendItems(this.keyEventUploadPendingItems, true);
    this.normalEventUploadPendingItems.push(e9), this.normalEventUploadPendingItems.length > XA("NORMAL_EVENT_QUEUE_CAPACITY") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, false);
  }
  doSend() {
    this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, true), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, false);
  }
  sendItems(e9, t2) {
    const i2 = [], n2 = [];
    for (; e9.length; ) {
      const t3 = e9.shift();
      i2.length < 20 ? i2.push(t3) : n2.push(t3);
    }
    e9.push(...n2);
    for (const e10 of [...i2]) {
      var r2;
      -1 !== this.ltsList.indexOf(e10.data.lts) ? (e10.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e10.data.lts)) : (this.ltsList.push(e10.data.lts), aE(r2 = this.ltsList).call(r2, (e11, t3) => e11 - t3));
    }
    return t2 || (this.lastSendNormalEventTime = Date.now()), XA("ENABLE_EVENT_REPORT") ? (i2.length && (XA("NEW_REPORT_SERVER") ? this.postDataToStatsCollector2(i2) : this.postDataToStatsCollector(i2)).catch(/* @__PURE__ */ ((e10) => (i3) => {
      XA("EVENT_REPORT_RETRY") && (t2 ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e10) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e10), this.normalEventUploadPendingItems.length > XA("NORMAL_EVENT_QUEUE_CAPACITY") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - XA("NORMAL_EVENT_QUEUE_CAPACITY")), fb.warning("report: drop normal events"))));
    })(i2)), e9) : e9;
  }
  async postDataToStatsCollector2(e9) {
    iA.networkState === Xy.OFFLINE && await Gh.race([iA.onlineWaiter, mA(2 * PA.maxRetryTimeout)]);
    const t2 = (e10) => {
      let t3 = new Uint8Array();
      return e10.forEach((e11) => {
        const i3 = ky(JSON.stringify(e11.data)), n3 = new ArrayBuffer(5), r2 = ((e12) => {
          let t4 = 0;
          return Object.entries(Rb).forEach((i4) => {
            let [n4, r3] = i4;
            r3 === e12.type && (t4 = Cb[n4]);
          }), t4;
        })(e11), o2 = new DataView(n3);
        o2.setUint16(0, i3.byteLength, true), o2.setUint8(2, 255 & r2), o2.setUint8(3, r2 >>> 8 & 255), o2.setUint8(4, r2 >>> 16 & 255), t3 = My(t3, new Uint8Array(n3)), t3 = My(t3, i3);
      }), t3;
    }, i2 = "event";
    let n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(XA("NEW_REPORT_SERVER_DOMAINS")[0], "&p=443&d=").concat(i2) : "https://".concat(XA("NEW_REPORT_SERVER_DOMAINS")[0], "/").concat(i2);
    for (let r2 = 0; r2 < 2; r2 += 1) {
      1 === r2 && (n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(XA("NEW_REPORT_SERVER_DOMAINS")[1], "&p=443&d=").concat(i2) : "https://".concat(XA("NEW_REPORT_SERVER_DOMAINS")[1], "/").concat(i2));
      try {
        await FA(n2, { timeout: 1e4, data: t2(e9), headers: cb(cb({ biz: "webrtc", sendts: Math.round(Date.now() / 1e3), debug: "false" }, this._appId && { appid: this._appId }), {}, { "Content-Type": "application/octet-stream" }) }, true);
      } catch (e10) {
        if (1 === r2) throw e10;
        continue;
      }
      return;
    }
  }
  async postDataToStatsCollector(e9) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    const i2 = { msgType: "EventMessages", sentTs: Math.round(Date.now() / 1e3), payloads: e9.map((e10) => JSON.stringify(e10)), vid: ((e10) => {
      const t3 = e10 && e10.data.sid && this.baseInfoMap.get(e10.data.sid);
      return t3 && t3.info.vid && +t3.info.vid || 0;
    })(e9[0]) };
    iA.networkState === Xy.OFFLINE && await Gh.race([iA.onlineWaiter, mA(2 * PA.maxRetryTimeout)]);
    const n2 = t2 ? "/events/proto-raws" : "/events/messages";
    let r2 = this.url || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(XA("EVENT_REPORT_DOMAIN"), "&p=").concat(XA("STATS_COLLECTOR_PORT"), "&d=").concat(n2) : "https://".concat(XA("EVENT_REPORT_DOMAIN"), ":").concat(XA("STATS_COLLECTOR_PORT")).concat(n2));
    for (let e10 = 0; e10 < 2; e10 += 1) {
      1 === e10 && (r2 = this.backupUrl || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(XA("EVENT_REPORT_BACKUP_DOMAIN"), "&p=").concat(XA("STATS_COLLECTOR_PORT"), "&d=").concat(n2) : "https://".concat(XA("EVENT_REPORT_BACKUP_DOMAIN"), ":").concat(XA("STATS_COLLECTOR_PORT")).concat(n2)));
      try {
        t2 ? await BA(r2, { timeout: 1e4, data: i2 }) : await FA(r2, { timeout: 1e4, data: i2 });
      } catch (t3) {
        if (1 === e10) throw t3;
        continue;
      }
      return;
    }
  }
  createBaseInfo(e9, t2) {
    const i2 = Object.assign({}, Sb);
    return i2.sid = e9, this.baseInfoMap.set(e9, { info: i2, startTime: t2 }), i2;
  }
  reportResourceTiming(e9, t2) {
    const i2 = performance.getEntriesByName(e9), n2 = i2[i2.length - 1];
    n2 && this.reportApiInvoke(t2, { name: "Client.resourceTiming", options: n2, tag: jy.TRACER }).onSuccess();
  }
}();
db.on("REPORT_LOG_UPLOAD", (e9) => {
  e9.networkState = iA.networkState, vb.reportApiInvoke(null, { name: "logUploadError", options: e9, tag: jy.TRACER }).onSuccess("logUploadError");
});
var yb = class extends Cy {
  constructor(e9) {
    super(e9, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", arguments.length > 2 ? arguments[2] : void 0), sb(this, "name", "AgoraRTCException");
  }
  print() {
    let e9 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error";
    return super.print(e9, fb);
  }
  throw() {
    super.throw(fb);
  }
};
var Ab = ["CHINA", "GLOBAL"];
var bb = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]];
var wb = [];
function Ob(e9, t2) {
  return !!t2 && wb.some((i2) => i2.uid === e9 && i2.channelName === t2);
}
var Nb = nT.forEach;
var Db = Bn("forEach") ? [].forEach : function(e9) {
  return Nb(this, e9, arguments.length > 1 ? arguments[1] : void 0);
};
wi({ target: "Array", proto: true, forced: [].forEach != Db }, { forEach: Db });
var Pb = Xi("Array").forEach;
var Lb = pn;
var kb = Ze;
var Mb = l;
var Ub = Pb;
var xb = Array.prototype;
var Vb = { DOMTokenList: true, NodeList: true };
var Fb = function(e9) {
  var t2 = e9.forEach;
  return e9 === xb || Mb(xb, e9) && t2 === xb.forEach || kb(Vb, Lb(e9)) ? Ub : t2;
};
var Bb = i(Fb);
var jb = Je;
var Gb = eo;
wi({ target: "Object", stat: true, forced: n(function() {
  Gb(1);
}) }, { keys: function(e9) {
  return Gb(jb(e9));
} });
var Wb = i(ie.Object.keys);
var Hb = i(zn);
var Kb = wi;
var Yb = om;
var qb = d([].reverse);
var zb = [1, 2];
Kb({ target: "Array", proto: true, forced: String(zb) === String(zb.reverse()) }, { reverse: function() {
  return Yb(this) && (this.length = this.length), qb(this);
} });
var Jb = Xi("Array").reverse;
var Xb = l;
var Qb = Jb;
var Zb = Array.prototype;
var $b = function(e9) {
  var t2 = e9.reverse;
  return e9 === Zb || Xb(Zb, e9) && t2 === Zb.reverse ? Qb : t2;
};
var ew = $b;
var tw = i(ew);
var iw = wi;
var nw = om;
var rw = jc;
var ow = te;
var sw = xi;
var aw = Gi;
var cw = Z;
var dw = E_;
var lw = ht;
var uw = Xc;
var hw = mm("slice");
var pw = lw("species");
var _w = Array;
var Ew = Math.max;
iw({ target: "Array", proto: true, forced: !hw }, { slice: function(e9, t2) {
  var i2, n2, r2, o2 = cw(this), s2 = aw(o2), a2 = sw(e9, s2), c2 = sw(void 0 === t2 ? s2 : t2, s2);
  if (nw(o2) && (i2 = o2.constructor, (rw(i2) && (i2 === _w || nw(i2.prototype)) || ow(i2) && null === (i2 = i2[pw])) && (i2 = void 0), i2 === _w || void 0 === i2)) return uw(o2, a2, c2);
  for (n2 = new (void 0 === i2 ? _w : i2)(Ew(c2 - a2, 0)), r2 = 0; a2 < c2; a2++, r2++) a2 in o2 && dw(n2, r2, o2[a2]);
  return n2.length = r2, n2;
} });
var fw = Xi("Array").slice;
var mw = l;
var Tw = fw;
var Sw = Array.prototype;
var gw = function(e9) {
  var t2 = e9.slice;
  return e9 === Sw || mw(Sw, e9) && t2 === Sw.slice ? Tw : t2;
};
var Rw = i(gw);
function Cw(e9, t2, i2, n2, r2) {
  var o2, s2, a2, c2 = {};
  return Bb(o2 = Wb(n2)).call(o2, function(e10) {
    c2[e10] = n2[e10];
  }), c2.enumerable = !!c2.enumerable, c2.configurable = !!c2.configurable, ("value" in c2 || c2.initializer) && (c2.writable = true), c2 = Hb(s2 = tw(a2 = Rw(i2).call(i2)).call(a2)).call(s2, function(i3, n3) {
    return n3(e9, t2, i3) || i3;
  }, c2), r2 && void 0 !== c2.initializer && (c2.value = c2.initializer ? c2.initializer.call(r2) : void 0, c2.initializer = void 0), void 0 === c2.initializer && (nm(e9, t2, c2), c2 = null), c2;
}
var Iw = function(e9) {
  return e9.L1T1 = "L1T1", e9.L1T2 = "L1T2", e9.L1T3 = "L1T3", e9.L1T3_KEY = "L1T3_KEY", e9.L2T1_KEY = "L2T1_KEY", e9.L2T2_KEY = "L2T2_KEY", e9.L2T3_KEY = "L2T3_KEY", e9.L3T1_KEY = "L3T1_KEY", e9.L3T2_KEY = "L3T2_KEY", e9.L3T3_KEY = "L3T3_KEY", e9;
}({});
var vw = function(e9) {
  return e9.CERTIFICATE = "certificate", e9.CODEC = "codec", e9.CANDIDATE_PAIR = "candidate-pair", e9.LOCAL_CANDIDATE = "local-candidate", e9.REMOTE_CANDIDATE = "remote-candidate", e9.INBOUND = "inbound-rtp", e9.TRACK = "track", e9.OUTBOUND = "outbound-rtp", e9.PC = "peer-connection", e9.REMOTE_INBOUND = "remote-inbound-rtp", e9.REMOTE_OUTBOUND = "remote-outbound-rtp", e9.TRANSPORT = "transport", e9.CSRC = "csrc", e9.DATA_CHANNEL = "data-channel", e9.STREAM = "stream", e9.SENDER = "sender", e9.RECEIVER = "receiver", e9;
}({});
var yw = function(e9) {
  return e9[e9.ACCESS_POINT = 101] = "ACCESS_POINT", e9[e9.UNILBS = 201] = "UNILBS", e9[e9.STRING_UID_ALLOCATOR = 901] = "STRING_UID_ALLOCATOR", e9;
}({});
var Aw = function(e9) {
  return e9[e9.IIIEGAL_APPID = 1] = "IIIEGAL_APPID", e9[e9.IIIEGAL_UID = 2] = "IIIEGAL_UID", e9[e9.INTERNAL_ERROR = 3] = "INTERNAL_ERROR", e9;
}({});
var bw = function(e9) {
  return e9[e9.INVALID_VENDOR_KEY = 5] = "INVALID_VENDOR_KEY", e9[e9.INVALID_CHANNEL_NAME = 7] = "INVALID_CHANNEL_NAME", e9[e9.INTERNAL_ERROR = 8] = "INTERNAL_ERROR", e9[e9.NO_AUTHORIZED = 9] = "NO_AUTHORIZED", e9[e9.DYNAMIC_KEY_TIMEOUT = 10] = "DYNAMIC_KEY_TIMEOUT", e9[e9.NO_ACTIVE_STATUS = 11] = "NO_ACTIVE_STATUS", e9[e9.DYNAMIC_KEY_EXPIRED = 13] = "DYNAMIC_KEY_EXPIRED", e9[e9.STATIC_USE_DYNAMIC_KEY = 14] = "STATIC_USE_DYNAMIC_KEY", e9[e9.DYNAMIC_USE_STATIC_KEY = 15] = "DYNAMIC_USE_STATIC_KEY", e9[e9.USER_OVERLOAD = 16] = "USER_OVERLOAD", e9[e9.FORBIDDEN_REGION = 18] = "FORBIDDEN_REGION", e9[e9.CANNOT_MEET_AREA_DEMAND = 19] = "CANNOT_MEET_AREA_DEMAND", e9;
}({});
var ww = function(e9) {
  return e9[e9.NO_FLAG_SET = 100] = "NO_FLAG_SET", e9[e9.FLAG_SET_BUT_EMPTY = 101] = "FLAG_SET_BUT_EMPTY", e9[e9.INVALID_FALG_SET = 102] = "INVALID_FALG_SET", e9[e9.FLAG_SET_BUT_NO_RE = 103] = "FLAG_SET_BUT_NO_RE", e9[e9.INVALID_SERVICE_ID = 104] = "INVALID_SERVICE_ID", e9[e9.NO_SERVICE_AVAILABLE = 200] = "NO_SERVICE_AVAILABLE", e9[e9.NO_SERVICE_AVAILABLE_P2P = 201] = "NO_SERVICE_AVAILABLE_P2P", e9[e9.NO_SERVICE_AVAILABLE_VOICE = 202] = "NO_SERVICE_AVAILABLE_VOICE", e9[e9.NO_SERVICE_AVAILABLE_WEBRTC = 203] = "NO_SERVICE_AVAILABLE_WEBRTC", e9[e9.NO_SERVICE_AVAILABLE_CDS = 204] = "NO_SERVICE_AVAILABLE_CDS", e9[e9.NO_SERVICE_AVAILABLE_CDN = 205] = "NO_SERVICE_AVAILABLE_CDN", e9[e9.NO_SERVICE_AVAILABLE_TDS = 206] = "NO_SERVICE_AVAILABLE_TDS", e9[e9.NO_SERVICE_AVAILABLE_REPORT = 207] = "NO_SERVICE_AVAILABLE_REPORT", e9[e9.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER", e9[e9.NO_SERVICE_AVAILABLE_ENV0 = 209] = "NO_SERVICE_AVAILABLE_ENV0", e9[e9.NO_SERVICE_AVAILABLE_VOET = 210] = "NO_SERVICE_AVAILABLE_VOET", e9[e9.NO_SERVICE_AVAILABLE_STRING_UID = 211] = "NO_SERVICE_AVAILABLE_STRING_UID", e9[e9.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS", e9[e9.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV", e9;
}({});
var Ow = function(e9) {
  return e9[e9.K_TIMESTAMP_EXPIRED = 2] = "K_TIMESTAMP_EXPIRED", e9[e9.K_CHANNEL_PERMISSION_INVALID = 3] = "K_CHANNEL_PERMISSION_INVALID", e9[e9.K_CERTIFICATE_INVALID = 4] = "K_CERTIFICATE_INVALID", e9[e9.K_CHANNEL_NAME_EMPTY = 5] = "K_CHANNEL_NAME_EMPTY", e9[e9.K_CHANNEL_NOT_FOUND = 6] = "K_CHANNEL_NOT_FOUND", e9[e9.K_TICKET_INVALID = 7] = "K_TICKET_INVALID", e9[e9.K_CHANNEL_CONFLICTED = 8] = "K_CHANNEL_CONFLICTED", e9[e9.K_SERVICE_NOT_READY = 9] = "K_SERVICE_NOT_READY", e9[e9.K_SERVICE_TOO_HEAVY = 10] = "K_SERVICE_TOO_HEAVY", e9[e9.K_UID_BANNED = 14] = "K_UID_BANNED", e9[e9.K_IP_BANNED = 15] = "K_IP_BANNED", e9[e9.K_CHANNEL_BANNED = 16] = "K_CHANNEL_BANNED", e9[e9.K_AUTO_REBALANCE = 28] = "K_AUTO_REBALANCE", e9[e9.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", e9[e9.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", e9[e9.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", e9[e9.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", e9[e9.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", e9[e9.WARN_REQUEST_DEFERRED = 108] = "WARN_REQUEST_DEFERRED", e9[e9.ERR_DYNAMIC_KEY_TIMEOUT = 109] = "ERR_DYNAMIC_KEY_TIMEOUT", e9[e9.ERR_NO_AUTHORIZED = 110] = "ERR_NO_AUTHORIZED", e9[e9.ERR_VOM_SERVICE_UNAVAILABLE = 111] = "ERR_VOM_SERVICE_UNAVAILABLE", e9[e9.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE", e9[e9.ERR_MASTER_VOCS_UNAVAILABLE = 114] = "ERR_MASTER_VOCS_UNAVAILABLE", e9[e9.ERR_INTERNAL_ERROR = 115] = "ERR_INTERNAL_ERROR", e9[e9.ERR_NO_ACTIVE_STATUS = 116] = "ERR_NO_ACTIVE_STATUS", e9[e9.ERR_INVALID_UID = 117] = "ERR_INVALID_UID", e9[e9.ERR_DYNAMIC_KEY_EXPIRED = 118] = "ERR_DYNAMIC_KEY_EXPIRED", e9[e9.ERR_STATIC_USE_DYANMIC_KE = 119] = "ERR_STATIC_USE_DYANMIC_KE", e9[e9.ERR_DYNAMIC_USE_STATIC_KE = 120] = "ERR_DYNAMIC_USE_STATIC_KE", e9[e9.ERR_NO_VOCS_AVAILABLE = 2e3] = "ERR_NO_VOCS_AVAILABLE", e9[e9.ERR_NO_VOS_AVAILABLE = 2001] = "ERR_NO_VOS_AVAILABLE", e9[e9.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT", e9[e9.ERR_REPEAT_JOIN_CHANNEL = 2003] = "ERR_REPEAT_JOIN_CHANNEL", e9[e9.ERR_JOIN_BY_MULTI_IP = 2004] = "ERR_JOIN_BY_MULTI_IP", e9[e9.ERR_NOT_JOINED = 2011] = "ERR_NOT_JOINED", e9[e9.ERR_REPEAT_JOIN_REQUEST = 2012] = "ERR_REPEAT_JOIN_REQUEST", e9[e9.ERR_INVALID_VENDOR_KEY = 2013] = "ERR_INVALID_VENDOR_KEY", e9[e9.ERR_INVALID_CHANNEL_NAME = 2014] = "ERR_INVALID_CHANNEL_NAME", e9[e9.ERR_INVALID_STRINGUID = 2015] = "ERR_INVALID_STRINGUID", e9[e9.ERR_TOO_MANY_USERS = 2016] = "ERR_TOO_MANY_USERS", e9[e9.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT", e9[e9.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION", e9[e9.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", e9[e9.ERR_PUBLISH_REQUEST_INVALID = 2020] = "ERR_PUBLISH_REQUEST_INVALID", e9[e9.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID", e9[e9.ERR_NOT_SUPPORTED_MESSAGE = 2022] = "ERR_NOT_SUPPORTED_MESSAGE", e9[e9.ERR_ILLEAGAL_PLUGIN = 2023] = "ERR_ILLEAGAL_PLUGIN", e9[e9.ERR_REJOIN_TOKEN_INVALID = 2024] = "ERR_REJOIN_TOKEN_INVALID", e9[e9.ERR_REJOIN_USER_NOT_JOINED = 2025] = "ERR_REJOIN_USER_NOT_JOINED", e9[e9.ERR_INVALID_OPTIONAL_INFO = 2027] = "ERR_INVALID_OPTIONAL_INFO", e9[e9.ILLEGAL_AES_PASSWORD = 2028] = "ILLEGAL_AES_PASSWORD", e9[e9.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = "ILLEGAL_CLIENT_ROLE_LEVEL", e9[e9.ERR_TOO_MANY_BROADCASTERS = 2031] = "ERR_TOO_MANY_BROADCASTERS", e9[e9.ERR_TOO_MANY_SUBSCRIBERS = 2032] = "ERR_TOO_MANY_SUBSCRIBERS", e9[e9.ERR_LICENSE_MISSING = 32769] = "ERR_LICENSE_MISSING", e9[e9.ERR_LICENSE_EXPIRED = 32771] = "ERR_LICENSE_EXPIRED", e9[e9.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = "ERR_LICENSE_MINUTES_EXCEEDED", e9[e9.ERR_LICENSE_PERIOD_INVALID = 32774] = "ERR_LICENSE_PERIOD_INVALID", e9[e9.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = "ERR_LICENSE_MULTIPLE_SDK_SERVICE", e9[e9.ERR_LICENSE_ILLEGAL = 32783] = "ERR_LICENSE_ILLEGAL", e9[e9.ERR_TEST_RECOVER = 9e3] = "ERR_TEST_RECOVER", e9[e9.ERR_TEST_TRYNEXT = 9001] = "ERR_TEST_TRYNEXT", e9[e9.ERR_TEST_RETRY = 9002] = "ERR_TEST_RETRY", e9;
}({});
var Nw = function(e9) {
  return e9.CONNECTING = "connecting", e9.CONNECTED = "connected", e9.RECONNECTING = "reconnecting", e9.CLOSED = "closed", e9;
}({});
var Dw = function(e9) {
  return e9.WS_CONNECTED = "ws_connected", e9.WS_RECONNECTING = "ws_reconnecting", e9.WS_CLOSED = "ws_closed", e9.WS_RECONNECT_WAITTING_FINISH = "ws_reconnect_waitting_finish", e9.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection", e9.ON_BINARY_DATA = "on_binary_data", e9.REQUEST_RECOVER = "request_recover", e9.REQUEST_JOIN_INFO = "request_join_info", e9.REQUEST_REJOIN_INFO = "req_rejoin_info", e9.IS_P2P_DISCONNECTED = "is_p2p_dis", e9.DISCONNECT_P2P = "dis_p2p", e9.ABORT_P2P_EXECUTION = "abort_p2p_execution", e9.NEED_RENEW_SESSION = "need-sid", e9.REPORT_JOIN_GATEWAY = "report_join_gateway", e9.REQUEST_TIMEOUT = "request_timeout", e9.REQUEST_SUCCESS = "request_success", e9.JOIN_RESPONSE = "join_response", e9.PRE_CONNECT_PC = "pre_connect_pc", e9.P2P_CONNECTION = "p2p_connection", e9.P2P_REMOTE_CANDIDATE_UPDATE = "p2p_remote_candidate_update", e9.P2P_SUBSCRIBE = "p2p_subscribe", e9.P2P_UNSUBSCRIBE = "p2p_unsubscribe", e9.P2P_EXCHANGE_SDP = "p2p_exchange_sdp", e9.P2P_ON_ADD_VIDEO_STREAM = "p2p_on_add_video_stream", e9.P2P_ON_ADD_AUDIO_STREAM = "p2p_on_add_audio_stream", e9.RECOVER_NOTIFICATION = "recover_notification", e9;
}({});
var Pw = function(e9) {
  return e9.PING = "ping", e9.PING_BACK = "ping_back", e9.JOIN = "join_v3", e9.REJOIN = "rejoin_v3", e9.LEAVE = "leave", e9.SET_CLIENT_ROLE = "set_client_role", e9.PUBLISH = "publish", e9.PUBLISH_DATASTREAM = "publish_datastream", e9.UNPUBLISH = "unpublish", e9.UNPUBLISH_DATASTREAM = "unpublish_datastream", e9.SUBSCRIBE = "subscribe", e9.PRE_SUBSCRIBE = "pre_subscribe", e9.SUBSCRIBE_DATASTREAM = "subscribe_datastream", e9.SUBSCRIBE_STREAMS = "subscribe_streams", e9.UNSUBSCRIBE = "unsubscribe", e9.UNSUBSCRIBE_DATASTREAM = "unsubscribe_datastream", e9.UNSUBSCRIBE_STREAMS = "unsubscribe_streams", e9.SUBSCRIBE_CHANGE = "subscribe_change", e9.TRAFFIC_STATS = "traffic_stats", e9.RENEW_TOKEN = "renew_token", e9.SWITCH_VIDEO_STREAM = "switch_video_stream", e9.DEFAULT_VIDEO_STREAM = "default_video_stream", e9.SET_FALLBACK_OPTION = "set_fallback_option", e9.GATEWAY_INFO = "gateway_info", e9.CONTROL = "control", e9.SEND_METADATA = "send_metadata", e9.DATA_STREAM = "data_stream", e9.PICK_SVC_LAYER = "pick_svc_layer", e9.RESTART_ICE = "restart_ice", e9.CONNECT_PC = "connect_pc", e9.SET_VIDEO_PROFILE = "set_video_profile", e9.SET_PARAMETER = "set_parameter", e9.SET_RTM2_FLAG = "set_rtm2_flag", e9;
}({});
var Lw = function(e9) {
  return e9.WRTC_STATS = "wrtc_stats", e9.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length", e9.DENOISER_STATS = "denoiser_stats", e9.EXTENSION_USAGE_STATS = "extension_usage_stats", e9;
}({});
var kw = function(e9) {
  return e9.ON_USER_ONLINE = "on_user_online", e9.ON_USER_OFFLINE = "on_user_offline", e9.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update", e9.ON_PUBLISH_STREAM = "on_publish_stream", e9.ON_UPLINK_STATS = "on_uplink_stats", e9.ON_P2P_LOST = "on_p2p_lost", e9.ON_REMOVE_STREAM = "on_remove_stream", e9.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e9.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e9.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire", e9.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire", e9.ON_USER_BANNED = "on_user_banned", e9.ON_USER_LICENSE_BANNED = "on_user_license_banned", e9.ON_NOTIFICATION = "on_notification", e9.ON_CRYPT_ERROR = "on_crypt_error", e9.MUTE_AUDIO = "mute_audio", e9.MUTE_VIDEO = "mute_video", e9.UNMUTE_AUDIO = "unmute_audio", e9.UNMUTE_VIDEO = "unmute_video", e9.ON_P2P_OK = "on_p2p_ok", e9.RECEIVE_METADATA = "receive_metadata", e9.ON_DATA_STREAM = "on_data_stream", e9.ON_RTP_CAPABILITY_CHANGE = "on_rtp_capability_change", e9.ON_REMOTE_DATASTREAM_UPDATE = "on_remote_datastream_update", e9.ON_REMOTE_FULL_DATASTREAM_INFO = "on_remote_full_datastream_info", e9.ENABLE_LOCAL_VIDEO = "enable_local_video", e9.DISABLE_LOCAL_VIDEO = "disable_local_video", e9.ENABLE_LOCAL_AUDIO = "enable_local_audio", e9.DISABLE_LOCAL_AUDIO = "disable_local_audio", e9.ON_PUBLISHED_USER_LIST = "on_published_user_list", e9;
}({});
var Mw = function(e9) {
  return e9.SEND_ONLY = "SEND_ONLY", e9.RECEIVE_ONLY = "RECEIVE_ONLY", e9;
}({});
var Uw = function(e9) {
  return e9.CONNECTED = "websocket:connected", e9.RECONNECTING = "websocket:reconnecting", e9.WILL_RECONNECT = "websocket:will_reconnect", e9.CLOSED = "websocket:closed", e9.FAILED = "websocket:failed", e9.ON_MESSAGE = "websocket:on_message", e9.REQUEST_NEW_URLS = "websocket:request_new_urls", e9.RECONNECT_WAITTING_FINISH = "websocket:reconnect_waitting_finish", e9.RECONNECT_CREATE_CONNECTION = "websocket:reconnect_create_connection", e9.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "websocket:on_token_privilege_did_expire", e9;
}({});
function xw(e9) {
  if ("string" != typeof e9 || !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e9)) throw fb.error("Invalid Channel Name ".concat(e9)), new yb(Ry.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,");
}
function Vw(e9) {
  if (!function(e10) {
    return "number" == typeof e10 && Math.floor(e10) === e10 && 0 <= e10 && e10 <= 4294967295;
  }(e9) && !Ny(e9, 1, 255)) throw new yb(Ry.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
  "string" == typeof e9 && fb.warn("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.");
}
var Fw = function(e9) {
  return e9.TRANSCODE = "mix_streaming", e9.RAW = "raw_streaming", e9;
}({});
var Bw = { alpha: 1, height: 640, width: 360, x: 0, y: 0, zOrder: 0, audioChannel: 0 };
var jw = { x: 0, y: 0, width: 160, height: 160, zOrder: 255, alpha: 1 };
function Gw(e9, t2) {
  by(e9.url, "".concat(t2, ".url"), 1, 1e3, false), Oy(e9.x) || yy(e9.x, "".concat(t2, ".x"), 0, 1e4), Oy(e9.y) || yy(e9.y, "".concat(t2, ".y"), 0, 1e4), Oy(e9.width) || yy(e9.width, "".concat(t2, ".width"), 0, 1e4), Oy(e9.height) || yy(e9.height, "".concat(t2, ".height"), 0, 1e4), Oy(e9.zOrder) || yy(e9.zOrder, "".concat(t2, ".zOrder"), 0, 255), Oy(e9.alpha) || yy(e9.alpha, "".concat(t2, ".alpha"), 0, 1, false);
}
var Ww = { audioBitrate: 48, audioChannels: 1, audioSampleRate: 48e3, backgroundColor: 0, height: 360, lowLatency: false, videoBitrate: 400, videoCodecProfile: 100, videoCodecType: 1, videoFrameRate: 15, videoGop: 30, width: 640, images: [], userConfigs: [], userConfigExtraInfo: "" };
var Hw = function(e9) {
  return e9.WARNING = "@live_uap-warning", e9.ERROR = "@line_uap-error", e9.PUBLISH_STREAM_STATUS = "@live_uap-publish-status", e9.WORKER_STATUS = "@live_uap-worker-status", e9.REQUEST_NEW_ADDRESS = "@live_uap-request-address", e9;
}({});
var Kw = function(e9) {
  return e9.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager", e9;
}({});
var Yw = function(e9) {
  return e9[e9.LIVE_STREAM_RESPONSE_SUCCEED = 200] = "LIVE_STREAM_RESPONSE_SUCCEED", e9[e9.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM", e9[e9.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR", e9[e9.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM", e9[e9.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR", e9[e9.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST", e9[e9.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED", e9[e9.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE", e9[e9.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN", e9[e9.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH", e9[e9.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED", e9[e9.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM", e9[e9.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR", e9[e9.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST", e9[e9.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT", e9[e9.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT", e9[e9.ERROR_FAIL_SEND_MESSAGE = 504] = "ERROR_FAIL_SEND_MESSAGE", e9[e9.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE", e9[e9.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT", e9[e9.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH", e9[e9.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN", e9;
}({});
function qw(e9) {
  if (!e9.channelName) throw new yb(Ry.INVALID_PARAMS, "invalid channelName in info");
  if ("number" != typeof e9.uid) throw new yb(Ry.INVALID_PARAMS, "invalid uid in info, uid must be a number");
  return e9.token && by(e9.token, "info.token", 1, 2047), Vw(e9.uid), xw(e9.channelName), true;
}
var zw = function(e9) {
  return e9[e9.SetSdkProfile = 0] = "SetSdkProfile", e9[e9.SetSourceChannel = 1] = "SetSourceChannel", e9[e9.SetSourceUserId = 2] = "SetSourceUserId", e9[e9.SetDestChannel = 3] = "SetDestChannel", e9[e9.StartPacketTransfer = 4] = "StartPacketTransfer", e9[e9.StopPacketTransfer = 5] = "StopPacketTransfer", e9[e9.UpdateDestChannel = 6] = "UpdateDestChannel", e9[e9.Reconnect = 7] = "Reconnect", e9[e9.SetVideoProfile = 8] = "SetVideoProfile", e9;
}({});
var Jw = function(e9) {
  return e9.NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED", e9.NETWORK_CONNECTED = "NETWORK_CONNECTED", e9.PACKET_JOINED_SRC_CHANNEL = "PACKET_JOINED_SRC_CHANNEL", e9.PACKET_JOINED_DEST_CHANNEL = "PACKET_JOINED_DEST_CHANNEL", e9.PACKET_SENT_TO_DEST_CHANNEL = "PACKET_SENT_TO_DEST_CHANNEL", e9.PACKET_RECEIVED_VIDEO_FROM_SRC = "PACKET_RECEIVED_VIDEO_FROM_SRC", e9.PACKET_RECEIVED_AUDIO_FROM_SRC = "PACKET_RECEIVED_AUDIO_FROM_SRC", e9.PACKET_UPDATE_DEST_CHANNEL = "PACKET_UPDATE_DEST_CHANNEL", e9.PACKET_UPDATE_DEST_CHANNEL_REFUSED = "PACKET_UPDATE_DEST_CHANNEL_REFUSED", e9.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = "PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE", e9;
}({});
var Xw = function(e9) {
  return e9.RELAY_STATE_IDLE = "RELAY_STATE_IDLE", e9.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING", e9.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING", e9.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE", e9;
}({});
var Qw = function(e9) {
  return e9.RELAY_OK = "RELAY_OK", e9.SERVER_CONNECTION_LOST = "SERVER_CONNECTION_LOST", e9.SRC_TOKEN_EXPIRED = "SRC_TOKEN_EXPIRED", e9.DEST_TOKEN_EXPIRED = "DEST_TOKEN_EXPIRED", e9;
}({});
var Zw = function(e9) {
  return e9.High = "high", e9.Low = "low", e9.Audio = "audio", e9.Screen = "screen", e9.ScreenLow = "screen_low", e9;
}({});
var $w = function(e9) {
  return e9.DISCONNECT = "disconnect", e9.CONNECTION_STATE_CHANGE = "connection-state-change", e9.NETWORK_QUALITY = "network-quality", e9.STREAM_TYPE_CHANGE = "stream-type-change", e9.IS_P2P_DISCONNECTED = "is-p2p-dis", e9.DISCONNECT_P2P = "dis-p2p", e9.REQUEST_NEW_GATEWAY_LIST = "req-gate-url", e9.NEED_RENEW_SESSION = "need-sid", e9.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params", e9.JOIN_RESPONSE = "join-response", e9.RESET_CONNECTION_EVENTS = "reset-connection-events", e9.PRE_CONNECT_PC = "pre-connect_pc", e9;
}({});
var eO = function(e9) {
  return e9.P2P_DISCONNECTED = "P2P_DISCONNECTED", e9.A_ROUND_WS_FAILED = "A_ROUND_WS_FAILED", e9.TIMEOUT = "TIMEOUT", e9.UNKNOWN_REASON = "UNKNOWN_REASON", e9;
}({});
var tO = function(e9) {
  return e9[e9.Nothing = 0] = "Nothing", e9[e9.Audio = 1] = "Audio", e9[e9.LwoVideo = 2] = "LwoVideo", e9[e9.Video = 4] = "Video", e9[e9.Data = 8] = "Data", e9[e9.DataStream0 = 256] = "DataStream0", e9[e9.DataStream1 = 512] = "DataStream1", e9[e9.DataStream2 = 1024] = "DataStream2", e9[e9.DataStream3 = 2048] = "DataStream3", e9[e9.DataStream4 = 4096] = "DataStream4", e9[e9.DataStream5 = 8192] = "DataStream5", e9[e9.DataStream6 = 16384] = "DataStream6", e9[e9.DataStream7 = 32768] = "DataStream7", e9;
}({});
var iO = function(e9) {
  return e9.CHINA = "CHINA", e9.ASIA = "ASIA", e9.NORTH_AMERICA = "NORTH_AMERICA", e9.EUROPE = "EUROPE", e9.JAPAN = "JAPAN", e9.INDIA = "INDIA", e9.KOREA = "KOREA", e9.HKMC = "HKMC", e9.US = "US", e9.OCEANIA = "OCEANIA", e9.SOUTH_AMERICA = "SOUTH_AMERICA", e9.AFRICA = "AFRICA", e9.OVERSEA = "OVERSEA", e9.GLOBAL = "GLOBAL", e9.EXTENSIONS = "EXTENSIONS", e9;
}({});
var nO = [iO.AFRICA, iO.ASIA, iO.CHINA, iO.EUROPE, iO.GLOBAL, iO.INDIA, iO.JAPAN, iO.NORTH_AMERICA, iO.OCEANIA, iO.OVERSEA, iO.SOUTH_AMERICA];
var rO = function(e9) {
  return e9.CHINA = "CN", e9.ASIA = "AS", e9.NORTH_AMERICA = "NA", e9.EUROPE = "EU", e9.JAPAN = "JP", e9.INDIA = "IN", e9.KOREA = "KR", e9.HKMC = "HK", e9.US = "US", e9.OCEANIA = "OC", e9.SOUTH_AMERICA = "SA", e9.AFRICA = "AF", e9.OVERSEA = "OVERSEA", e9.GLOBAL = "GLOBAL", e9.EXTENSIONS = "GLOBAL", e9;
}({});
var oO = { CHINA: {}, ASIA: { CODE: rO.ASIA, WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"], PROXY_CS: ["proxy-ap-web-asia.agora.io"], CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"], UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }, NORTH_AMERICA: { CODE: rO.NORTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"], PROXY_CS: ["proxy-ap-web-america.agora.io"], CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }, EUROPE: { CODE: rO.EUROPE, WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"], PROXY_CS: ["proxy-ap-web-europe.agora.io"], CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"], UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }, JAPAN: { CODE: rO.JAPAN, WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"], PROXY_CS: ["proxy-ap-web-japan.agora.io"], CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"], UAP_AP: ["uap-ap-web-japan.agora.io", "uap-ap-web-japan2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }, INDIA: { CODE: rO.INDIA, WEBCS_DOMAIN: ["ap-web-1-india.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"], PROXY_CS: ["proxy-ap-web-india.agora.io"], CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"], UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"] }, KOREA: { CODE: rO.KOREA, WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"], PROXY_CS: ["proxy-ap-web-korea.agora.io"], CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-korea.agora.io", "sua-ap-web-korea2.agora.io"], UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"], PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"] }, HKMC: { CODE: rO.HKMC, WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"], PROXY_CS: ["proxy-ap-web-hkmc.agora.io"], CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-hkmc.agora.io", "sua-ap-web-hkmc2.agora.io"], UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"], LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"], PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"] }, US: { CODE: rO.US, WEBCS_DOMAIN: ["ap-web-1-us.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"], PROXY_CS: ["proxy-ap-web-us.agora.io"], CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"], UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"], LOG_UPLOAD_SERVER: ["logservice-us.agora.io"], PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"] }, OVERSEA: { CODE: rO.OVERSEA, WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"], PROXY_CS: ["proxy-ap-web-oversea.agora.io"], CDS_AP: ["cds-ap-web-oversea.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"], UAP_AP: ["uap-ap-web-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"] }, GLOBAL: { CODE: rO.GLOBAL, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"], LOG_UPLOAD_SERVER: ["logservice.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"] }, OCEANIA: { CODE: rO.OCEANIA, WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"], PROXY_CS: ["proxy-ap-web-oceania.agora.io"], CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"], UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }, SOUTH_AMERICA: { CODE: rO.SOUTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"], PROXY_CS: ["proxy-ap-web-south-america.agora.io"], CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"], UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }, AFRICA: { CODE: rO.AFRICA, WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"], PROXY_CS: ["proxy-ap-web-africa.agora.io"], CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"], UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"] }, EXTENSIONS: {} };
WA && (oO.CHINA = { CODE: rO.CHINA, WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["proxy-web.ap.sd-rtn.com"], CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"], EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] });
var sO = function(e9) {
  return e9.UPDATE_BITRATE_LIMIT = "update_bitrate_limit", e9;
}({});
var aO = class extends xy {
  constructor(e9, t2) {
    super(), Fg(this, "onICEConnectionStateChange", void 0), Fg(this, "onConnectionStateChange", void 0), Fg(this, "onDTLSTransportStateChange", void 0), Fg(this, "onDTLSTransportError", void 0), Fg(this, "onICETransportStateChange", void 0), Fg(this, "onFirstAudioReceived", void 0), Fg(this, "onFirstVideoReceived", void 0), Fg(this, "onFirstAudioDecoded", void 0), Fg(this, "onFirstVideoDecoded", void 0), Fg(this, "onFirstVideoDecodedTimeout", void 0), Fg(this, "onSelectedLocalCandidateChanged", void 0), Fg(this, "onSelectedRemoteCandidateChanged", void 0), Fg(this, "getLocalVideoStats", void 0);
  }
};
var cO = class extends aO {
  constructor(e9, t2) {
    super(e9, t2), Fg(this, "establishPromise", void 0);
  }
};
var dO = function(e9) {
  return e9.VIDEO = "video", e9.AUDIO = "audio", e9;
}({});
var lO = function(e9) {
  return e9[e9.UDP = 0] = "UDP", e9[e9.TCP = 1] = "TCP", e9[e9.RELAY = 2] = "RELAY", e9;
}({});
var uO = function(e9) {
  return e9[e9.FIRST_CONNECTION = 0] = "FIRST_CONNECTION", e9[e9.TCP_RESTART = 1] = "TCP_RESTART", e9[e9.RELAY_RESTART = 2] = "RELAY_RESTART", e9[e9.OLD_FIRST_CONNECTION = 10] = "OLD_FIRST_CONNECTION", e9[e9.OLD_RESTART = 11] = "OLD_RESTART", e9[e9.DISCONNECTED_OR_FAILED = 20] = "DISCONNECTED_OR_FAILED", e9;
}({});
var hO = function(e9) {
  return e9.LocalVideoTrack = "videoTrack", e9.LocalAudioTrack = "audioTrack", e9.LocalVideoLowTrack = "videoLowTrack", e9;
}({});
var pO = function(e9) {
  return e9.New = "new", e9.Connected = "connected", e9.Reconnecting = "reconnecting", e9.Disconnected = "disconnected", e9;
}({});
var _O = function(e9) {
  return e9.StateChange = "stateChange", e9.IceConnectionStateChange = "iceConnectionStateChange", e9.RequestMuteLocal = "requestMuteLocal", e9.RequestUnmuteLocal = "requestUnmuteLocal", e9.RequestRePublish = "requestRePublish", e9.RequestRePublishDataChannel = "requestRePublishDataChannel", e9.RequestReSubscribe = "requestReSubscribe", e9.RequestUploadStats = "requestUploadStats", e9.RequestUpload = "requestUpload", e9.MediaReconnectStart = "MediaReconnectStart", e9.MediaReconnectEnd = "MediaReconnectEnd", e9.NeedSignalRTT = "NeedSignalRTT", e9.RequestRestartICE = "RequestRestartIce", e9.PeerConnectionStateChange = "PeerConnectionStateChange", e9.RequestReconnect = "RequestReconnect", e9.RequestReconnectPC = "RequestReconnectPC", e9.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC", e9.P2PLost = "P2PLost", e9.UpdateVideoEncoder = "UpdateVideoEncoder", e9.ConnectionTypeChange = "ConnectionTypeChange", e9.RequestLowStreamParameter = "RequestLowStreamParameter", e9.QueryClientConnectionState = "QueryClientConnectionState", e9.LocalCandidate = "LocalCandidate", e9.RequestP2PMuteLocal = "requestP2PMuteLocal", e9.RequestP2PUnPublish = "RequestP2PUnPublish", e9.RequestP2PUnmuteRemote = "RequestP2PUnmuteRemote", e9.RequestP2PMuteRemote = "RequestP2PMuteRemote", e9.RequestP2PRestartICE = "RequestP2PRestartICE", e9;
}({});
var EO = function(e9) {
  return e9.CONNECTING = "CONNECTING", e9.RECONNECTING = "RECONNECTING", e9.CONNECTED = "CONNECTED", e9.CLOSED = "CLOSED", e9;
}({});
var fO = function(e9) {
  return e9[e9.CONNECT_AP = 0] = "CONNECT_AP", e9[e9.AP_CONNECTED = 1] = "AP_CONNECTED", e9[e9.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e9[e9.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e9[e9.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e9[e9.CONNECT_WORKER = 5] = "CONNECT_WORKER", e9[e9.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e9[e9.CLOSED = 7] = "CLOSED", e9;
}({});
var mO = function(e9) {
  return e9.CONNECTION_STATE_CHANGE = "connection-state-change", e9.STATE_CHANGE = "state-change", e9.INSPECT_RESULT = "inspect-result", e9.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e9.REQUEST_NEW_WORKER_URL = "request-new-worker-url", e9;
}({});
var TO = function(e9) {
  return e9.CONNECTED = "transmitter:connected", e9.RECONNECTING = "transmitter:reconnecting", e9.WILL_RECONNECT = "transmitter:will_reconnect", e9.CLOSED = "transmitter:closed", e9.FAILED = "transmitter:failed", e9.ON_MESSAGE = "transmitter:on_message", e9.REQUEST_NEW_URLS = "transmitter:request_new_urls", e9.RECONNECT_WAITTING_FINISH = "transmitter:reconnect_waitting_finish", e9.RECONNECT_CREATE_CONNECTION = "transmitter:reconnect_create_connection", e9.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "transmitter:on_token_privilege_did_expire", e9.TO_CONNECT_DATACHANNEL = "transmitter:to_connect_datachannel", e9.FAILBACK = "transmitter:failback", e9.PRE_CONNECT_PC = "transmitter:pre_connect_pc", e9;
}({});
var SO = function(e9) {
  return e9.CAMERA_CHANGED = "camera-changed", e9.MICROPHONE_CHANGED = "microphone-changed", e9.PLAYBACK_DEVICE_CHANGED = "playback-device-changed", e9.AUDIO_AUTOPLAY_FAILED = "audio-autoplay-failed", e9.AUTOPLAY_FAILED = "autoplay-failed", e9.AUDIO_CONTEXT_STATE_CHANGED = "audio-context-state-changed", e9.SECURITY_POLICY_VIOLATION = "security-policy-violation", e9;
}({});
var gO = function(e9) {
  return e9.CONNECTING = "CONNECTING", e9.RECONNECTING = "RECONNECTING", e9.CONNECTED = "CONNECTED", e9.CLOSED = "CLOSED", e9;
}({});
var RO = function(e9) {
  return e9.CONNECTION_STATE_CHANGE = "connection-state-change", e9.STATE_CHANGE = "state-change", e9.INSPECT_RESULT = "inspect-result", e9.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e9.REQUEST_NEW_WORKER_URL = "request-new-worker-url", e9;
}({});
var CO = function(e9) {
  return e9[e9.CONNECT_AP = 0] = "CONNECT_AP", e9[e9.AP_CONNECTED = 1] = "AP_CONNECTED", e9[e9.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e9[e9.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e9[e9.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e9[e9.CONNECT_WORKER = 5] = "CONNECT_WORKER", e9[e9.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e9[e9.CLOSED = 7] = "CLOSED", e9;
}({});
var IO = function(e9) {
  return e9.CALL = "call", e9.CANDIDATE = "candidate", e9.PUBLISH = "publish", e9.UNPUBLISH = "unpublish", e9.CONTROL = "control", e9.RESTART_ICE = "restart_ice", e9.ACK = "ack", e9.RESPONSE = "response", e9.JOIN = "join", e9.CHECK = "check", e9;
}({});
var vO = function(e9) {
  return e9.ABORT = "abort", e9;
}({});
var yO = function(e9) {
  return e9.MUTE_LOCAL_AUDIO = "mute_local_audio", e9.MUTE_LOCAL_VIDEO = "mute_local_video", e9.UNMUTE_LOCAL_AUDIO = "unmute_local_audio", e9.UNMUTE_LOCAL_VIDEO = "unmute_local_video", e9;
}({});
var AO = function(e9) {
  return e9.P2P_TOKEN_TIMEOUT = "p2p_token_timeout", e9.P2P_TOKEN_CHANGED = "p2p_token_changed", e9;
}({});
var bO = { [yw.ACCESS_POINT]: { [ww.NO_FLAG_SET]: { desc: "flag is zero", retry: false }, [ww.FLAG_SET_BUT_EMPTY]: { desc: "flag is empty", retry: false }, [ww.INVALID_FALG_SET]: { desc: "invalid flag", retry: false }, [ww.FLAG_SET_BUT_NO_RE]: { desc: "flag set unilbs but no request", retry: false }, [ww.INVALID_SERVICE_ID]: { desc: "invalid service id", retry: false }, [ww.NO_SERVICE_AVAILABLE]: { desc: "no service available", retry: true }, [ww.NO_SERVICE_AVAILABLE_P2P]: { desc: "no unilbs p2p service available", retry: true }, [ww.NO_SERVICE_AVAILABLE_VOICE]: { desc: "no unilbs voice service available", retry: true }, [ww.NO_SERVICE_AVAILABLE_WEBRTC]: { desc: "no unilbs webrtc service available", retry: true }, [ww.NO_SERVICE_AVAILABLE_CDS]: { desc: "no cds service available", retry: true }, [ww.NO_SERVICE_AVAILABLE_CDN]: { desc: "no cdn dispatcher service available", retry: true }, [ww.NO_SERVICE_AVAILABLE_TDS]: { desc: "no tds service available", retry: true }, [ww.NO_SERVICE_AVAILABLE_REPORT]: { desc: "no unilbs report service available", retry: true }, [ww.NO_SERVICE_AVAILABLE_APP_CENTER]: { desc: "no app center service available", retry: true }, [ww.NO_SERVICE_AVAILABLE_ENV0]: { desc: "no unilbs sig env0 service available", retry: true }, [ww.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voet service available", retry: true }, [ww.NO_SERVICE_AVAILABLE_STRING_UID]: { desc: "no string uid service available", retry: true }, [ww.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: { desc: "no webrtc unilbs service available", retry: true } }, [yw.UNILBS]: { [bw.INVALID_VENDOR_KEY]: { desc: "invalid vendor key, can not find appid", retry: false }, [bw.INVALID_CHANNEL_NAME]: { desc: "invalid channel name", retry: false }, [bw.INTERNAL_ERROR]: { desc: "unilbs internal error", retry: false }, [bw.NO_AUTHORIZED]: { desc: "invalid token, authorized failed", retry: false }, [bw.DYNAMIC_KEY_TIMEOUT]: { desc: "dynamic key or token timeout", retry: false }, [bw.NO_ACTIVE_STATUS]: { desc: "no active status", retry: false }, [bw.DYNAMIC_KEY_EXPIRED]: { desc: "dynamic key expired", retry: false }, [bw.STATIC_USE_DYNAMIC_KEY]: { desc: "static use dynamic key", retry: false }, [bw.DYNAMIC_USE_STATIC_KEY]: { desc: "dynamic use static key", retry: false }, [bw.USER_OVERLOAD]: { desc: "amount of users over load", retry: false }, [bw.FORBIDDEN_REGION]: { desc: "the request is forbidden in this area", retry: false }, [bw.CANNOT_MEET_AREA_DEMAND]: { desc: "unable to allocate services in this area", retry: false } }, [yw.STRING_UID_ALLOCATOR]: { [Aw.IIIEGAL_APPID]: { desc: "invalid appid", retry: false }, [Aw.IIIEGAL_UID]: { desc: "invalid string uid", retry: false }, [Aw.INTERNAL_ERROR]: { desc: "string uid allocator internal error", retry: true } } };
function wO(e9) {
  const t2 = bO[Math.floor(e9 / 1e4)];
  if (!t2) return { desc: "unknown error", retry: false };
  const i2 = t2[e9 % 1e4];
  if (!i2) {
    if (Math.floor(e9 / 1e4) === yw.ACCESS_POINT) {
      const t3 = e9 % 1e4;
      if ("1" === t3.toString()[0]) return { desc: e9.toString(), retry: false };
      if ("2" === t3.toString()[0]) return { desc: e9.toString(), retry: true };
    }
    return { desc: "unknown error", retry: false };
  }
  return i2;
}
var OO = { [Ow.K_TIMESTAMP_EXPIRED]: { desc: "K_TIMESTAMP_EXPIRED", action: "failed" }, [Ow.K_CHANNEL_PERMISSION_INVALID]: { desc: "K_CHANNEL_PERMISSION_INVALID", action: "failed" }, [Ow.K_CERTIFICATE_INVALID]: { desc: "K_CERTIFICATE_INVALID", action: "failed" }, [Ow.K_CHANNEL_NAME_EMPTY]: { desc: "K_CHANNEL_NAME_EMPTY", action: "failed" }, [Ow.K_CHANNEL_NOT_FOUND]: { desc: "K_CHANNEL_NOT_FOUND", action: "failed" }, [Ow.K_TICKET_INVALID]: { desc: "K_TICKET_INVALID", action: "failed" }, [Ow.K_CHANNEL_CONFLICTED]: { desc: "K_CHANNEL_CONFLICTED", action: "failed" }, [Ow.K_SERVICE_NOT_READY]: { desc: "K_SERVICE_NOT_READY", action: "tryNext" }, [Ow.K_SERVICE_TOO_HEAVY]: { desc: "K_SERVICE_TOO_HEAVY", action: "tryNext" }, [Ow.K_UID_BANNED]: { desc: "K_UID_BANNED", action: "failed" }, [Ow.K_IP_BANNED]: { desc: "K_IP_BANNED", action: "failed" }, [Ow.K_AUTO_REBALANCE]: { desc: "k_AUTO_REBALANCE", action: "recover" }, [Ow.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [Ow.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [Ow.WARN_NO_AVAILABLE_CHANNEL]: { desc: "WARN_NO_AVAILABLE_CHANNEL", action: "failed" }, [Ow.WARN_LOOKUP_CHANNEL_TIMEOUT]: { desc: "WARN_LOOKUP_CHANNEL_TIMEOUT", action: "tryNext" }, [Ow.WARN_LOOKUP_CHANNEL_REJECTED]: { desc: "WARN_LOOKUP_CHANNEL_REJECTED", action: "failed" }, [Ow.WARN_OPEN_CHANNEL_TIMEOUT]: { desc: "WARN_OPEN_CHANNEL_TIMEOUT", action: "tryNext" }, [Ow.WARN_OPEN_CHANNEL_REJECTED]: { desc: "WARN_OPEN_CHANNEL_REJECTED", action: "failed" }, [Ow.WARN_REQUEST_DEFERRED]: { desc: "WARN_REQUEST_DEFERRED", action: "failed" }, [Ow.ERR_DYNAMIC_KEY_TIMEOUT]: { desc: "ERR_DYNAMIC_KEY_TIMEOUT", action: "failed" }, [Ow.ERR_NO_AUTHORIZED]: { desc: "ERR_NO_AUTHORIZED", action: "failed" }, [Ow.ERR_VOM_SERVICE_UNAVAILABLE]: { desc: "ERR_VOM_SERVICE_UNAVAILABLE", action: "tryNext" }, [Ow.ERR_NO_CHANNEL_AVAILABLE_CODE]: { desc: "ERR_NO_CHANNEL_AVAILABLE_CODE", action: "failed" }, [Ow.ERR_MASTER_VOCS_UNAVAILABLE]: { desc: "ERR_MASTER_VOCS_UNAVAILABLE", action: "tryNext" }, [Ow.ERR_INTERNAL_ERROR]: { desc: "ERR_INTERNAL_ERROR", action: "tryNext" }, [Ow.ERR_NO_ACTIVE_STATUS]: { desc: "ERR_NO_ACTIVE_STATUS", action: "failed" }, [Ow.ERR_INVALID_UID]: { desc: "ERR_INVALID_UID", action: "failed" }, [Ow.ERR_DYNAMIC_KEY_EXPIRED]: { desc: "ERR_DYNAMIC_KEY_EXPIRED", action: "failed" }, [Ow.ERR_STATIC_USE_DYANMIC_KE]: { desc: "ERR_STATIC_USE_DYANMIC_KE", action: "failed" }, [Ow.ERR_DYNAMIC_USE_STATIC_KE]: { desc: "ERR_DYNAMIC_USE_STATIC_KE", action: "failed" }, [Ow.ERR_NO_VOCS_AVAILABLE]: { desc: "ERR_NO_VOCS_AVAILABLE", action: "tryNext" }, [Ow.ERR_NO_VOS_AVAILABLE]: { desc: "ERR_NO_VOS_AVAILABLE", action: "tryNext" }, [Ow.ERR_JOIN_CHANNEL_TIMEOUT]: { desc: "ERR_JOIN_CHANNEL_TIMEOUT", action: "tryNext" }, [Ow.ERR_JOIN_BY_MULTI_IP]: { desc: "ERR_JOIN_BY_MULTI_IP", action: "recover" }, [Ow.ERR_NOT_JOINED]: { desc: "ERR_NOT_JOINED", action: "failed" }, [Ow.ERR_REPEAT_JOIN_REQUEST]: { desc: "ERR_REPEAT_JOIN_REQUEST", action: "quit" }, [Ow.ERR_REPEAT_JOIN_CHANNEL]: { desc: "ERR_REPEAT_JOIN_CHANNEL", action: "quit" }, [Ow.ERR_INVALID_STRINGUID]: { desc: "ERR_INVALID_STRINGUID", action: "failed" }, [Ow.ERR_TOO_MANY_USERS]: { desc: "ERR_TOO_MANY_USERS", action: "tryNext" }, [Ow.ERR_SET_CLIENT_ROLE_TIMEOUT]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [Ow.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [Ow.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: { desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", action: "success" }, [Ow.ERR_PUBLISH_REQUEST_INVALID]: { desc: "ERR_PUBLISH_REQUEST_INVALID", action: "failed" }, [Ow.ERR_SUBSCRIBE_REQUEST_INVALID]: { desc: "ERR_SUBSCRIBE_REQUEST_INVALID", action: "failed" }, [Ow.ERR_NOT_SUPPORTED_MESSAGE]: { desc: "ERR_NOT_SUPPORTED_MESSAGE", action: "failed" }, [Ow.ERR_ILLEAGAL_PLUGIN]: { desc: "ERR_ILLEAGAL_PLUGIN", action: "failed" }, [Ow.ILLEGAL_CLIENT_ROLE_LEVEL]: { desc: "ILLEGAL_CLIENT_ROLE_LEVEL", action: "failed" }, [Ow.ERR_REJOIN_TOKEN_INVALID]: { desc: "ERR_REJOIN_TOKEN_INVALID", action: "failed" }, [Ow.ERR_REJOIN_USER_NOT_JOINED]: { desc: "ERR_REJOIN_NOT_JOINED", action: "failed" }, [Ow.ERR_INVALID_OPTIONAL_INFO]: { desc: "ERR_INVALID_OPTIONAL_INFO", action: "quit" }, [Ow.ERR_TEST_RECOVER]: { desc: "ERR_TEST_RECOVER", action: "recover" }, [Ow.ERR_TEST_TRYNEXT]: { desc: "ERR_TEST_TRYNEXT", action: "recover" }, [Ow.ERR_TEST_RETRY]: { desc: "ERR_TEST_RETRY", action: "recover" }, [Ow.ILLEGAL_AES_PASSWORD]: { desc: "ERR_TEST_RETRY", action: "failed" }, [Ow.ERR_TOO_MANY_BROADCASTERS]: { desc: "ERR_TOO_MANY_BROADCASTERS", action: "failed" }, [Ow.ERR_TOO_MANY_SUBSCRIBERS]: { desc: "ERR_TOO_MANY_SUBSCRIBERS", action: "failed" }, [Ow.ERR_LICENSE_ILLEGAL]: { desc: "ERR_LICENSE_ILLEGAL", action: "quit" }, [Ow.ERR_LICENSE_MISSING]: { desc: "ERR_LICENSE_MISSING", action: "quit" }, [Ow.ERR_LICENSE_EXPIRED]: { desc: "ERR_LICENSE_EXPIRED", action: "quit" }, [Ow.ERR_LICENSE_MINUTES_EXCEEDED]: { desc: "ERR_LICENSE_MINUTES_EXCEEDED", action: "quit" }, [Ow.ERR_LICENSE_PERIOD_INVALID]: { desc: "ERR_LICENSE_PERIOD_INVALID", action: "quit" }, [Ow.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: { desc: "ERR_LICENSE_MULTIPLE_SDK_SERVICE", action: "quit" } };
function NO(e9) {
  const t2 = OO[e9];
  return t2 || { desc: "UNKNOWN_ERROR_".concat(e9), action: "failed" };
}
function DO(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function PO(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? DO(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : DO(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
function LO(e9) {
  return e9.every((e10) => e10.readyState === WebSocket.CLOSED || e10.readyState === WebSocket.CLOSING);
}
function kO(e9, t2) {
  if ("string" == typeof e9) return e9;
  const { proxy: i2, host: n2, port: r2 } = e9;
  if (t2) {
    const e10 = XA("JOIN_GATEWAY_FALLBACK_PORT") || 443;
    return 443 === e10 ? "wss://".concat(n2, "/ws/?p=").concat(Number(r2) + 150) : "wss://".concat(n2, ":").concat(e10, "/ws/?p=").concat(Number(r2) + 150);
  }
  return i2 ? "wss://".concat(i2, "/ws/?h=").concat(n2, "&p=").concat(r2) : "wss://".concat(n2, ":").concat(r2);
}
var MO = /wss:\/\/(.+)\/ws\/\?h=(.+)&p=([0-9]+)\/?/;
var UO = /wss:\/\/(.+)\/ws\/\?p=([0-9]+)\/?/;
var xO = /wss:\/\/(.+):([0-9]+)\/?/;
var VO = /wss:\/\/(.[^\/]+)\/?/;
var FO = 0;
var BO = class {
  constructor(e9, t2) {
    Fg(this, "id", 0), Fg(this, "store", void 0), Fg(this, "recordIndex", void 0), Fg(this, "websockets", []), Fg(this, "try443PortDuration", 2e3), Fg(this, "forceCloseWSDuration", 5e3), Fg(this, "try443PortTimeout", null), Fg(this, "forceCloseTimeout", null), Fg(this, "isTry443PortFailed", false), Fg(this, "isNormalPortFailed", false), Fg(this, "useDoubleDomain", false), Fg(this, "useProxy", false), Fg(this, "startTime", Date.now()), this.id = ++FO, this.try443PortDuration = XA("JOIN_GATEWAY_TRY_443PORT_DURATION") || 2e3, this.forceCloseWSDuration = e9 || 5e3, this.store = t2;
  }
  closeAllWebsockets() {
    this.websockets.forEach((e9) => {
      e9.onopen = null, e9.onclose = null, e9.onmessage = null, e9.close();
    }), this.websockets.length = 0;
  }
  clearTimeout() {
    this.forceCloseTimeout && clearTimeout(this.forceCloseTimeout), this.try443PortTimeout && clearTimeout(this.try443PortTimeout);
  }
  logger() {
    var e9;
    const t2 = Date.now() - this.startTime;
    for (var i2 = arguments.length, n2 = new Array(i2), r2 = 0; r2 < i2; r2++) n2[r2] = arguments[r2];
    fb.debug("[choose-best-ws ".concat(null === (e9 = this.store) || void 0 === e9 ? void 0 : e9.clientId, " ").concat(this.id, "] ").concat(t2, "ms:"), ...n2);
  }
  createWebSocket(e9, t2, i2) {
    this.logger("createWebSocket:", e9, { isTry443Port: t2, hasTimeoutDetection: i2 });
    const n2 = XA("GATEWAY_DOMAINS"), r2 = Date.now(), o2 = [], s2 = n2.find((t3) => {
      var i3;
      return Dn(i3 = e9.host).call(i3, t3);
    });
    s2 || (this.useDoubleDomain = false);
    const a2 = [];
    if (this.useDoubleDomain) n2.forEach((i3) => {
      a2.push(kO(PO(PO({}, e9), {}, { host: e9.host.replace(s2, i3) }), t2));
    });
    else {
      const i3 = PO({}, e9);
      if (t2 && s2) {
        const e10 = n2.find((e11) => e11 !== s2);
        e10 && (i3.host = i3.host.replace(s2, e10));
      }
      a2.push(kO(i3, t2));
    }
    try {
      a2.forEach((e10) => {
        const t3 = new WebSocket(e10);
        t3.binaryType = "arraybuffer", o2.push(t3), this.logger("ws is connecting:", t3.url);
      });
    } catch (n3) {
      if (this.logger("ws create failed"), o2.forEach((e10) => e10.close()), o2.length = 0, this.useDoubleDomain) return this.useDoubleDomain = false, this.createWebSocket(e9, t2, i2);
      if (!t2 && 443 !== Number(e9.port)) return this.createWebSocket(e9, true, i2);
      throw new yb(Ry.WS_ERR, "init websocket failed! Error: ".concat(n3.toString()));
    }
    const c2 = Mv();
    this.store && this.store.recordJoinChannelService({ urls: o2.map((e10) => e10.url), service: "gateway" }, this.recordIndex), o2.forEach((e10) => {
      e10.onopen = () => {
        this.logger("onopen: ws ".concat(e10.url, " open cost ").concat(Date.now() - r2, "ms")), this.websockets.forEach((t3) => {
          t3 !== e10 && (t3.onopen = null, t3.onclose = null, t3.onmessage = null, t3.close(), this.logger("close backup websocket: ".concat(t3.url)));
        }), this.websockets.length = 0, c2.resolve(e10);
      }, e10.onclose = (i3) => {
        this.logger("onclose: ws ".concat(e10.url, " closed cost ").concat(Date.now() - r2, "ms state: ").concat(e10.readyState)), t2 ? this.isTry443PortFailed = LO(o2) : this.isNormalPortFailed = LO(o2), this.logger("443: ".concat(this.useProxy ? "not try" : this.isTry443PortFailed ? "failed" : "trying", " 47xx: ").concat(this.isNormalPortFailed ? "failed" : "trying")), (t2 && this.isTry443PortFailed || !t2 && (this.isTry443PortFailed || this.useProxy) && this.isNormalPortFailed) && (this.logger("onclose: all websocket is closed, ".concat(i3.reason)), c2.reject({ code: i3.code, reason: eO.A_ROUND_WS_FAILED }));
      }, e10.onmessage = (t3) => this.logger("".concat(e10.url, " onmessage: ").concat(t3.data));
    }), this.websockets.push(...o2);
    return i2 || (() => {
      const i3 = () => {
        this.logger("5s timeout close un-opens, isWebsocket created: ", c2.isResolved), this.websockets.forEach((e10) => e10.readyState !== WebSocket.OPEN && e10.close());
      };
      if (t2 || this.useProxy) return this.logger("add 5s timeout at ".concat(t2 ? "try-443" : "proxy", " condition")), this.forceCloseTimeout = window.setTimeout(i3, this.forceCloseWSDuration);
      this.try443PortTimeout = window.setTimeout(() => {
        if (this.logger("2s timeout, isWebsocket created: ", c2.isResolved), c2.isResolved) return i3();
        Hv().os === Fv.MAC_OS && Zv() && i3(), this.createWebSocket(e9, true, true).then((e10) => c2.resolve(e10)).catch((e10) => {
          this.isNormalPortFailed && c2.reject(e10), this.logger("try 443 port to create ws failed");
        }), this.forceCloseTimeout = window.setTimeout(i3, this.forceCloseWSDuration);
      }, this.try443PortDuration);
    })(), c2.promise;
  }
  chooseBestWebsocket(e9, t2, i2, n2) {
    return this.useDoubleDomain = !!t2, "string" == typeof e9 && (e9 = function(e10) {
      let t3, i3, n3;
      return [, t3, i3, n3] = e10.match(MO) || [], t3 || ([, i3, n3] = e10.match(UO) || []), i3 && n3 || ([, i3, n3] = e10.match(xO) || []), i3 && n3 || ([, i3] = e10.match(VO) || []), i3 || fb.warning("un-destructible url: ", e10), { proxy: t3, host: i3, port: n3 || "443" };
    }(e9)), this.recordIndex = n2, this.useProxy = !!e9.proxy, i2 && this.useProxy && (fb.warn("cannot use 443 only when use proxy"), i2 = false), this.createWebSocket(e9, !!i2, false).finally(() => this.clearTimeout());
  }
};
function jO(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
var GO = class extends xy {
  get url() {
    return this.websocket && this.websocket.url || null;
  }
  get reconnectMode() {
    return this._reconnectMode;
  }
  set reconnectMode(e9) {
    var t2;
    Dn(t2 = ["tryNext", "recover"]).call(t2, e9) && this.resetReconnectCount(e9), this._reconnectMode = e9;
  }
  get state() {
    return this._state;
  }
  set state(e9) {
    e9 !== this._state && (this._state = e9, "reconnecting" === this._state ? this.emit(Uw.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(Uw.CONNECTED) : "closed" === this._state ? this.emit(Uw.CLOSED) : "failed" === this._state && this.emit(Uw.FAILED));
  }
  resetReconnectCount(e9) {
    fb.debug("websocket reset reconnect count, reason: " + e9), this.reconnectCount = 0;
  }
  constructor(e9, t2) {
    let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o2 = arguments.length > 5 ? arguments[5] : void 0;
    super(), Fg(this, "connectionID", 0), Fg(this, "currentURLIndex", 0), Fg(this, "urls", []), Fg(this, "_reconnectMode", "tryNext"), Fg(this, "reconnectReason", void 0), Fg(this, "_initMutex", new NA("websocket")), Fg(this, "name", void 0), Fg(this, "_state", "closed"), Fg(this, "reconnectInterrupter", void 0), Fg(this, "websocket", void 0), Fg(this, "retryConfig", void 0), Fg(this, "reconnectCount", 0), Fg(this, "forceCloseTimeout", 5e3), Fg(this, "onlineReconnectListener", void 0), Fg(this, "useCompress", void 0), Fg(this, "tryDoubleDomain", false), Fg(this, "use443PortOnly", false), Fg(this, "wsInflateLength", 0), Fg(this, "wsDeflateLength", 0), Fg(this, "closeEstablishingWs", () => {
    }), Fg(this, "store", void 0), Fg(this, "joinGatewayRecordIndex", void 0), this.store = o2, this.name = e9, this.retryConfig = function(e10) {
      for (var t3 = 1; t3 < arguments.length; t3++) {
        var i3 = null != arguments[t3] ? arguments[t3] : {};
        t3 % 2 ? jO(Object(i3), true).forEach(function(t4) {
          Fg(e10, t4, i3[t4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e10, Object.getOwnPropertyDescriptors(i3)) : jO(Object(i3)).forEach(function(t4) {
          Object.defineProperty(e10, t4, Object.getOwnPropertyDescriptor(i3, t4));
        });
      }
      return e10;
    }({}, t2), this.useCompress = i2, this.tryDoubleDomain = n2, this.use443PortOnly = r2;
    const { timeout: s2, timeoutFactor: a2 } = t2, c2 = Math.max(300, Math.floor(3 * s2 / 5)), d2 = Math.max(1.2, Math.floor(8 * a2) / 10);
    Xy.ONLINE && (this.retryConfig.timeout = c2, this.retryConfig.timeoutFactor = d2), iA.on(Qy.NETWORK_STATE_CHANGE, (e10, t3) => {
      e10 !== t3 && (this.resetReconnectCount("network state change: ".concat(t3, " -> ").concat(e10)), e10 === Xy.ONLINE ? (this.retryConfig.timeout = c2, this.retryConfig.timeoutFactor = d2) : (this.retryConfig.timeout = s2, this.retryConfig.timeoutFactor = a2));
    });
  }
  getConnection() {
    return this.websocket || void 0;
  }
  async init(e9) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
    const i2 = await this._initMutex.lock();
    this.forceCloseTimeout = t2, this.urls = e9, this.state = "connecting";
    try {
      const e10 = Mv(), t3 = this.urls[this.currentURLIndex];
      XA("ENABLE_PREALLOC_PC") && this.emit(TO.PRE_CONNECT_PC), this.createWebSocketConnection(t3).then(e10.resolve).catch(e10.reject), this.once(Uw.CLOSED, () => {
        e10.reject(new Cy(Ry.WS_DISCONNECT));
      }), this.once(Uw.CONNECTED, e10.resolve), await e10.promise;
    } catch (e10) {
    } finally {
      i2();
    }
  }
  close(e9, t2) {
    if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {
      this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;
      const e10 = this.websocket;
      t2 ? setTimeout(() => e10.close(), 500) : e10.close(), this.websocket = void 0;
    }
    this.state = e9 ? "failed" : "closed", this.closeEstablishingWs && this.closeEstablishingWs();
  }
  reconnect(e9, t2) {
    if (!this.websocket) return void fb.warning("[".concat(this.name, "] can not reconnect, no websocket"));
    void 0 !== e9 && (this.reconnectMode = e9), fb.debug("[".concat(this.name, "] reconnect is triggered initiative")), "number" == typeof this.joinGatewayRecordIndex && this.store && this.store.recordJoinChannelService({ status: "error", errors: [new Error(t2)] }, this.joinGatewayRecordIndex);
    const i2 = this.websocket.onclose;
    this.websocket.onclose = null, this.websocket.close(), i2 && i2.bind(this.websocket)({ code: 9999, reason: t2 });
  }
  sendMessage(e9) {
    let t2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) throw new Cy(Ry.WS_ABORT, "websocket is not ready");
    try {
      t2 || (e9 = JSON.stringify(e9)), this.websocket.send(e9);
    } catch (e10) {
      throw new Cy(Ry.WS_ERR, "send websocket message error" + e10.toString());
    }
  }
  setWsInflateData(e9) {
    this.wsDeflateLength = this.wsDeflateLength + e9.originLength, this.wsInflateLength = this.wsInflateLength + e9.compressedLength;
  }
  getWsInflateData() {
    const e9 = this.wsInflateLength, t2 = this.wsDeflateLength;
    return this.clearWsInflateData(), { wsInflateLength: e9, wsDeflateLength: t2 };
  }
  clearWsInflateData() {
    this.wsInflateLength = 0, this.wsDeflateLength = 0;
  }
  async createWebSocketConnection(e9) {
    var t2;
    const i2 = Mv();
    this.connectionID += 1, this.joinGatewayRecordIndex = void 0;
    const n2 = (e10) => {
      var t3;
      null === (t3 = this.store) || void 0 === t3 || t3.signalChannelOpen(), fb.debug("[".concat(this.name, "] websocket opened:"), e10), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), i2.resolve();
    }, r2 = async (e10) => {
      var t3;
      if (fb.debug("[".concat(this.name, "] websocket close ").concat(null === (t3 = this.websocket) || void 0 === t3 ? void 0 : t3.url, ", code: ").concat(e10.code, ", reason: ").concat(e10.reason, ", current mode: ").concat(this.reconnectMode)), this.reconnectCount >= this.retryConfig.maxRetryCount) i2.reject(new Cy(Ry.WS_DISCONNECT, "websocket close: ".concat(e10.code))), this.close();
      else {
        "connected" === this.state && (this.reconnectReason = e10.reason, this.state = "reconnecting");
        const t4 = eA(this, Uw.WILL_RECONNECT, this.reconnectMode, e10.reason) || this.reconnectMode, n3 = await this.reconnectWithAction(t4);
        if ("closed" === this.state) return void fb.debug("[".concat(this.connectionID, "] ws is closed, no need to reconnect"));
        if (!n3) return i2.reject(new Cy(Ry.WS_DISCONNECT, "websocket reconnect failed: ".concat(e10.code))), this.close(true);
        i2.resolve();
      }
    }, o2 = (e10) => {
      this.emit(Uw.ON_MESSAGE, e10);
    }, s2 = (e10) => {
      fb.warn("[".concat(this.connectionID, "] ws open error ").concat(e10));
    };
    this.websocket && (this.websocket.onclose = null, this.websocket.close()), XA("GATEWAY_WSS_ADDRESS") && this.name.startsWith("gateway") && (e9 = XA("GATEWAY_WSS_ADDRESS")), fb.debug("[".concat(this.name, "] start connect, url:"), e9);
    const a2 = null === (t2 = this.store) || void 0 === t2 ? void 0 : t2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" });
    try {
      var c2;
      const t3 = await this.chooseBestWebsocketConnection(e9);
      this.websocket = t3, n2 && n2(this.websocket.url), this.websocket.onclose = r2, this.websocket.onmessage = o2, this.websocket.onerror = s2, null === (c2 = this.store) || void 0 === c2 || c2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a2), this.joinGatewayRecordIndex = a2;
    } catch (e10) {
      const t3 = "closed" === this.state, n3 = e10 instanceof Cy, o3 = n3 && e10.code === Ry.WS_ABORT, s3 = n3 && e10.code === Ry.WS_ERR, c3 = n3 ? e10.message : e10 && (e10.reason || e10.toString());
      fb.warning("[choose-best-ws] chooseBestWebsocket error: ".concat(c3)), this.store && this.store.recordJoinChannelService({ endTs: Date.now(), status: o3 ? "aborted" : "error", errors: [e10] }, a2), t3 || s3 ? (i2.reject(t3 ? new Cy(Ry.WS_DISCONNECT, "websocket is closed: ".concat(c3)) : new Cy(Ry.WS_ERR, "init websocket failed: ".concat(c3))), s3 && fb.error("[".concat(this.name, "] init websocket failed: ").concat(c3))) : r2 && r2(e10);
    }
    return i2.promise;
  }
  async reconnectWithAction(e9) {
    let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if (this.reconnectCount >= this.retryConfig.maxRetryCount) return false;
    if (0 === this.urls.length) return false;
    if ("closed" === this.state) return false;
    fb.warning("[choose-best-ws] action: =>", e9), this.onlineReconnectListener || iA.isOnline || !iA.onlineWaiter || (this.onlineReconnectListener = iA.onlineWaiter.then(() => {
      this.onlineReconnectListener = void 0;
    }));
    let i2 = true;
    if (this.reconnectInterrupter = () => i2 = false, t2) {
      const t3 = LA(this.reconnectCount, this.retryConfig);
      fb.debug("[".concat(this.name, "] wait ").concat(t3, "ms to reconnect websocket, mode: ").concat(e9)), await Gh.race([mA(t3), this.onlineReconnectListener || new Gh(() => {
      })]);
    }
    if ("closed" === this._state || !i2) return false;
    this.reconnectCount += 1;
    const n2 = async (e10, t3) => {
      this.emit(Uw.RECONNECT_CREATE_CONNECTION, t3), await this.createWebSocketConnection(e10);
    };
    try {
      if ("retry" === e9) this.emit(Uw.RECONNECT_WAITTING_FINISH, e9), await n2(this.urls[this.currentURLIndex], e9);
      else if ("tryNext" === e9) {
        if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length) return this.reconnectWithAction("recover", false);
        fb.debug("[".concat(this.name, "] websocket url length: ").concat(this.urls.length, " current index: ").concat(this.currentURLIndex)), this.emit(Uw.RECONNECT_WAITTING_FINISH, e9), await n2(this.urls[this.currentURLIndex], e9);
      } else "recover" === e9 && (fb.debug("[".concat(this.name, "] request new urls")), this.resetReconnectCount("recover mode"), this.emit(Uw.RECONNECT_WAITTING_FINISH, e9), this.urls = await Zy(this, Uw.REQUEST_NEW_URLS), this.currentURLIndex = 0, await n2(this.urls[this.currentURLIndex], e9));
    } catch (i3) {
      var r2;
      fb.error("[".concat(this.name, "] reconnect failed ").concat(i3 && i3.toString()));
      const n3 = null == i3 || null === (r2 = i3.data) || void 0 === r2 ? void 0 : r2.desc;
      return Array.isArray(n3) && Dn(n3).call(n3, "dynamic key expired") ? (this.emit(Uw.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : this.reconnectWithAction(e9, t2);
    }
    return true;
  }
};
var WO = class extends GO {
  constructor(e9, t2) {
    super(e9, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
  }
  async chooseBestWebsocketConnection(e9, t2) {
    const i2 = Mv(), n2 = function(e10, t3) {
      return new BO(e10, t3);
    }(this.forceCloseTimeout, this.store);
    this.closeEstablishingWs = () => {
      fb.debug("[choose-best-ws] close establishing websockets"), n2.closeAllWebsockets(), i2.reject(new Cy(Ry.WS_ABORT, "choose best websocket aborted"));
    };
    const r2 = XA("GATEWAY_DOMAINS");
    return fb.debug("[choose-best-ws] currentDomain: ", e9, ", domains: ", r2, "total: ".concat(this.urls.length), "current: ".concat(this.currentURLIndex + 1)), n2.chooseBestWebsocket(e9, this.tryDoubleDomain, this.use443PortOnly, t2).then(i2.resolve).catch(i2.reject), i2.promise.finally(() => {
      this.closeEstablishingWs = void 0;
    });
  }
};
var HO = class extends GO {
  constructor(e9, t2) {
    super(e9, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
  }
  async chooseBestWebsocketConnection(e9, t2) {
    return new Gh((i2, n2) => {
      let r2 = false;
      const o2 = [];
      this.closeEstablishingWs = () => {
        fb.debug("[choose-best-ws] close establishing websockets"), o2.forEach((e10) => {
          e10.onclose = null, e10.onopen = null, e10.onmessage = null, e10.close();
        }), n2(new Cy(Ry.WS_ABORT, "choose best websocket aborted"));
      };
      const s2 = XA("GATEWAY_DOMAINS");
      let a2;
      const c2 = e9.indexOf("?h="), d2 = s2.find((t3) => -1 !== c2 ? Dn(e9).call(e9, t3, c2) : Dn(e9).call(e9, t3));
      fb.debug("[choose-best-ws] currentDomain: ", d2, ", domains: ", s2);
      let l2 = !this.tryDoubleDomain || !d2;
      if (!l2 && d2) {
        var u2;
        const h3 = Date.now();
        try {
          s2.forEach((t3) => {
            const i3 = -1 === c2 ? e9.replace(d2, t3) : e9.substr(0, c2) + e9.substr(c2).replace(d2, t3), n3 = new WebSocket(i3);
            n3.binaryType = "arraybuffer", o2.push(n3), fb.debug("[choose-best-ws] ws is connecting:", n3.url);
          });
        } catch (e10) {
          for (fb.debug("[choose-best-ws] ws create failed, fallback to single url"), o2.forEach((e11) => e11.close()); o2.length; ) o2.pop();
          l2 = true;
        }
        null === (u2 = this.store) || void 0 === u2 || u2.recordJoinChannelService({ urls: o2.map((e10) => e10.url), service: "gateway" }, t2), o2.forEach((e10) => {
          e10.onopen = () => {
            if (r2) return;
            const t3 = Date.now() - h3;
            fb.debug("[choose-best-ws] ws open cost ".concat(t3, "ms")), o2.filter((t4) => t4 !== e10).forEach((e11) => {
              fb.debug("[choose-best-ws]close backup websocket: ".concat(e11.url)), e11.close();
            }), r2 = true, i2(e10);
          }, e10.onclose = (e11) => {
            if (a2 = e11, r2) return;
            o2.find((e12) => !(e12.readyState === WebSocket.CLOSED || e12.readyState === WebSocket.CLOSING)) || (fb.debug("[choose-best-ws] all websocket is closed"), r2 = true, n2(a2));
          }, e10.onmessage = (t3) => {
            fb.debug("[choose-best-ws]".concat(e10.url, " onmessage: ").concat(t3.data));
          };
        }), mA(this.forceCloseTimeout).then(() => {
          o2.forEach((e10) => {
            e10.readyState !== WebSocket.OPEN && e10.close();
          });
        });
      }
      if (l2) {
        var h2;
        let r3;
        fb.debug("[choose-best-ws] use single url: ", e9), null === (h2 = this.store) || void 0 === h2 || h2.recordJoinChannelService({ urls: [e9], service: "gateway" }, t2);
        try {
          r3 = new WebSocket(e9), o2.push(r3), r3.binaryType = "arraybuffer";
        } catch (e10) {
          const t3 = new Cy(Ry.WS_ERR, "init websocket failed! Error: ".concat(e10.toString()));
          return fb.error("[".concat(this.name, "]").concat(t3)), void n2(t3);
        }
        r3.onopen = () => {
          i2(r3);
        }, r3.onclose = (e10) => {
          n2(e10);
        }, r3.onmessage = (e10) => {
          fb.debug("[choose-best-ws]".concat(r3.url, " onmessage: ").concat(e10.data));
        }, mA(this.forceCloseTimeout).then(() => {
          r3 && r3.readyState !== WebSocket.OPEN && r3.close();
        });
      }
    }).then((e10) => (this.closeEstablishingWs = void 0, e10)).catch((e10) => {
      throw this.closeEstablishingWs = void 0, e10;
    });
  }
};
var KO = class extends xy {
  get connectionState() {
    return this._connectionState;
  }
  set connectionState(e9) {
    e9 !== this._connectionState && (this._connectionState = e9, e9 === Nw.CONNECTED ? this.emit(Dw.WS_CONNECTED) : e9 === Nw.RECONNECTING ? this.emit(Dw.WS_RECONNECTING, this._websocketReconnectReason) : e9 === Nw.CLOSED && this.emit(Dw.WS_CLOSED, this._disconnectedReason));
  }
  get currentURLIndex() {
    return this.websocket.currentURLIndex;
  }
  get url() {
    return this.websocket && this.websocket.url || null;
  }
  get rtt() {
    return this.rttRolling.mean();
  }
  constructor(e9, t2) {
    super(), Fg(this, "_disconnectedReason", void 0), Fg(this, "_websocketReconnectReason", void 0), Fg(this, "_connectionState", Nw.CLOSED), Fg(this, "reconnectToken", void 0), Fg(this, "websocket", void 0), Fg(this, "openConnectionTime", void 0), Fg(this, "clientId", void 0), Fg(this, "lastMsgTime", Date.now()), Fg(this, "uploadCache", []), Fg(this, "uploadCacheInterval", void 0), Fg(this, "rttRolling", new MA(5)), Fg(this, "pingpongTimer", void 0), Fg(this, "wsInflateDataTimer", void 0), Fg(this, "pingpongTimeoutCount", 0), Fg(this, "joinResponse", void 0), Fg(this, "multiIpOption", void 0), Fg(this, "initError", void 0), Fg(this, "spec", void 0), Fg(this, "store", void 0), Fg(this, "onWebsocketMessage", (e10) => {
      if (e10.data instanceof ArrayBuffer) return void this.emit(Dw.ON_BINARY_DATA, e10.data);
      const t3 = JSON.parse(e10.data);
      if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
        const e11 = "res-@".concat(t3._id);
        this.emit(e11, t3._result, t3._message);
      } else if (Object.prototype.hasOwnProperty.call(t3, "_type")) {
        if (this.emit(t3._type, t3._message), t3._type === kw.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === kw.ON_USER_BANNED) switch (t3._message.error_code) {
          case 14:
            this.close(Hy.UID_BANNED);
            break;
          case 15:
            this.close(Hy.IP_BANNED);
            break;
          case 16:
            this.close(Hy.CHANNEL_BANNED);
        }
        if (t3._type === kw.ON_USER_LICENSE_BANNED) switch (t3._message.error_code) {
          case Ow.ERR_LICENSE_MISSING:
            this.close(Hy.LICENSE_MISSING);
            break;
          case Ow.ERR_LICENSE_EXPIRED:
            this.close(Hy.LICENSE_EXPIRED);
            break;
          case Ow.ERR_LICENSE_MINUTES_EXCEEDED:
            this.close(Hy.LICENSE_MINUTES_EXCEEDED);
            break;
          case Ow.ERR_LICENSE_PERIOD_INVALID:
            this.close(Hy.LICENSE_PERIOD_INVALID);
            break;
          case Ow.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
            this.close(Hy.LICENSE_MULTIPLE_SDK_SERVICE);
            break;
          case Ow.ERR_LICENSE_ILLEGAL:
            this.close(Hy.LICENSE_ILLEGAL);
            break;
          default:
            this.close();
        }
      }
    }), this.clientId = e9.clientId, this.spec = e9, this.store = t2, this.websocket = new WO("gateway-".concat(this.clientId), this.spec.retryConfig, true, XA("JOIN_GATEWAY_USE_DUAL_DOMAIN"), XA("JOIN_GATEWAY_USE_443PORT_ONLY"), t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
      this.connectionState === Nw.CONNECTED && this.reconnect("retry", Jy.OFFLINE);
    });
  }
  async request(e9, t2, i2, n2) {
    const r2 = TA(6, ""), o2 = { _id: r2, _type: e9, _message: t2 }, s2 = this.websocket.connectionID, a2 = () => new Gh((t3, i3) => {
      if (this.connectionState === Nw.CONNECTED) return t3();
      const n3 = () => {
        this.off(Dw.WS_CLOSED, r3), t3();
      }, r3 = () => {
        this.off(Dw.WS_CONNECTED, n3), i3(new yb(Ry.WS_ABORT));
      };
      this.once(Dw.WS_CONNECTED, n3), this.once(Dw.WS_CLOSED, r3), e9 !== Pw.PUBLISH && e9 !== Pw.PUBLISH_DATASTREAM && e9 !== Pw.SUBSCRIBE && e9 !== Pw.SUBSCRIBE_DATASTREAM && e9 !== Pw.UNSUBSCRIBE && e9 !== Pw.UNSUBSCRIBE_DATASTREAM && e9 !== Pw.UNPUBLISH && e9 !== Pw.UNPUBLISH_DATASTREAM && e9 !== Pw.CONTROL && e9 !== Pw.RESTART_ICE || this.once(Dw.DISCONNECT_P2P, () => {
        i3(new yb(Ry.DISCONNECT_P2P));
      }), e9 !== Pw.PUBLISH && e9 !== Pw.RESTART_ICE || this.once(Dw.ABORT_P2P_EXECUTION, () => {
        i3(new yb(Ry.DISCONNECT_P2P));
      });
    });
    if (this.connectionState !== Nw.CONNECTING && this.connectionState !== Nw.RECONNECTING || e9 === Pw.JOIN || e9 === Pw.REJOIN || await a2(), this.websocket.sendMessage(o2, true), n2) return;
    const c2 = new Gh((i3, n3) => {
      let o3 = false;
      const a3 = (n4, r3) => {
        o3 = true, i3({ isSuccess: "success" === n4, message: r3 || {} }), this.off(Dw.WS_CLOSED, c3), this.off(Dw.WS_RECONNECTING, c3), this.emit(Dw.REQUEST_SUCCESS, e9, t2);
      };
      this.once("res-@".concat(r2), a3);
      const c3 = () => {
        n3(new yb(Ry.WS_ABORT, "type: ".concat(e9))), this.off(Dw.WS_CLOSED, c3), this.off(Dw.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
      };
      this.once(Dw.WS_CLOSED, c3), this.once(Dw.WS_RECONNECTING, c3), mA(XA("SIGNAL_REQUEST_TIMEOUT")).then(() => {
        this.websocket.connectionID !== s2 || o3 || (fb.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e9)), this.emit(Dw.REQUEST_TIMEOUT, e9, t2));
      });
    });
    let d2 = null;
    try {
      d2 = await c2;
    } catch (n3) {
      if (this.connectionState === Nw.CLOSED || e9 === Pw.LEAVE) throw new yb(Ry.WS_ABORT);
      return !this.spec.forceWaitGatewayResponse || i2 ? n3.throw() : e9 === Pw.JOIN || e9 === Pw.REJOIN ? null : (await a2(), await this.request(e9, t2));
    }
    if (d2.isSuccess) return d2.message;
    const l2 = Number(d2.message.error_code || d2.message.code), u2 = NO(l2), h2 = new yb(Ry.UNEXPECTED_RESPONSE, "".concat(u2.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message, desc: u2.desc });
    return "success" === u2.action ? d2.message : (fb.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e9, ", error_code: ").concat(l2, ", message: ").concat(u2.desc, ", action: ").concat(u2.action)), l2 === Ow.ERR_TOO_MANY_BROADCASTERS ? e9 === Pw.JOIN || e9 === Pw.REJOIN ? (this.initError = h2, this.close(), h2.throw()) : h2.throw() : "failed" === u2.action ? h2.throw() : "quit" === u2.action ? (this.initError = h2, this.close(), h2.throw()) : (l2 === Ow.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, fb.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", Jy.MULTI_IP)) : this.reconnect(u2.action, Jy.SERVER_ERROR), e9 === Pw.JOIN || e9 === Pw.REJOIN ? null : await this.request(e9, t2)));
  }
  waitMessage(e9, t2) {
    return new Gh((i2) => {
      const n2 = (r2) => {
        (!t2 || t2(r2)) && (this.off(e9, n2), i2(r2));
      };
      this.on(e9, n2);
    });
  }
  uploadWRTCStats(e9) {
    if (!this.store.sessionId) return void fb.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
    const t2 = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e9 };
    this.upload(Lw.WRTC_STATS, t2);
  }
  upload(e9, t2) {
    const i2 = { _type: e9, _message: t2 };
    try {
      this.websocket.sendMessage(i2);
    } catch (e10) {
      const t3 = XA("MAX_UPLOAD_CACHE") || 50;
      this.uploadCache.push(i2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
        if (this.connectionState !== Nw.CONNECTED) return;
        const e11 = this.uploadCache.splice(0, 1)[0];
        0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e11._type, e11._message);
      }, XA("UPLOAD_CACHE_INTERVAL") || 2e3));
    }
  }
  send(e9, t2) {
    const i2 = { _type: e9, _message: t2 };
    this.websocket.sendMessage(i2);
  }
  init(e9, t2) {
    return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Gh((t3, i2) => {
      this.once(Dw.WS_CONNECTED, () => t3(this.joinResponse)), this.once(Dw.WS_CLOSED, () => i2(this.initError || new yb(Ry.WS_ABORT))), this.connectionState = Nw.CONNECTING, this.websocket.init(e9).catch(i2), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {
        this.handleWsInflateData();
      }, 2e4);
    });
  }
  close(e9) {
    this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e9 || Hy.LEAVE, this.connectionState = Nw.CLOSED, fb.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close();
  }
  async join() {
    if (!this.joinResponse) {
      this.emit(Dw.ABORT_P2P_EXECUTION);
      const e9 = await Zy(this, Dw.REQUEST_JOIN_INFO), t2 = await this.request(Pw.JOIN, e9);
      if (!t2) return this.emit(Dw.REPORT_JOIN_GATEWAY, eO.TIMEOUT, this.url || ""), false;
      this.joinResponse = t2, this.emit(Dw.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
    }
    return this.connectionState = Nw.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
  }
  async rejoin() {
    if (!this.reconnectToken) throw new yb(Ry.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
    const e9 = tA(this, Dw.REQUEST_REJOIN_INFO);
    e9.token = this.reconnectToken;
    const t2 = await this.request(Pw.REJOIN, e9);
    return !!t2 && (this.connectionState = Nw.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t2.peers && t2.peers.forEach((e10) => {
      this.emit(kw.ON_USER_ONLINE, { uid: e10.uid }), e10.audio && this.emit(kw.ON_ADD_AUDIO_STREAM, { uid: e10.uid, uint_id: e10.uint_id, audio: true, ssrcId: e10.audio_ssrc }), e10.video && this.emit(kw.ON_ADD_VIDEO_STREAM, { uid: e10.uid, uint_id: e10.uint_id, video: true, ssrcId: e10.video_ssrc }), e10.audio_mute ? this.emit(kw.MUTE_AUDIO, { uid: e10.uid }) : this.emit(kw.UNMUTE_AUDIO, { uid: e10.uid }), e10.video_mute ? this.emit(kw.MUTE_VIDEO, { uid: e10.uid }) : this.emit(kw.UNMUTE_VIDEO, { uid: e10.uid }), e10.audio_enable_local ? this.emit(kw.ENABLE_LOCAL_AUDIO, { uid: e10.uid }) : this.emit(kw.DISABLE_LOCAL_AUDIO, { uid: e10.uid }), e10.video_enable_local ? this.emit(kw.ENABLE_LOCAL_VIDEO, { uid: e10.uid }) : this.emit(kw.DISABLE_LOCAL_VIDEO, { uid: e10.uid }), e10.audio || e10.video || this.emit(kw.ON_REMOVE_STREAM, { uid: e10.uid, uint_id: e10.uint_id });
    }), true);
  }
  reconnect(e9, t2) {
    this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e9, t2);
  }
  handleNotification(e9) {
    fb.debug("[".concat(this.clientId, "] receive notification: "), e9);
    const t2 = NO(e9.code);
    if (28 === e9.code && "detail" in e9 && (fb.info("[".concat(this.clientId, "] receive recover notification: "), e9.detail), this.emit(Dw.RECOVER_NOTIFICATION, e9.detail)), "success" !== t2.action) {
      if ("failed" !== t2.action) return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(Hy.UID_BANNED), void this.close()) : void this.reconnect(t2.action, Jy.SERVER_ERROR);
      fb.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
    }
  }
  handlePingPong() {
    if (!this.websocket || "connected" !== this.websocket.state) return;
    this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
    const e9 = XA("PING_PONG_TIME_OUT"), t2 = Date.now();
    this.pingpongTimeoutCount >= e9 && (fb.warning("[".concat(this.clientId, "] PING-PONG Timeout. Last Socket Message: ").concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > XA("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", Jy.TIMEOUT) : this.request(Pw.PING, void 0, true).then(() => {
      this.pingpongTimeoutCount = 0;
      const e10 = Date.now() - t2;
      this.rttRolling.add(e10), XA("REPORT_STATS") && this.send(Pw.PING_BACK, { pingpongElapse: e10 });
    }).catch((e10) => {
    });
  }
  handleWsInflateData() {
    const { wsInflateLength: e9, wsDeflateLength: t2 } = this.websocket.getWsInflateData();
    0 !== e9 && 0 !== t2 && this.upload(Lw.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e9 });
  }
  handleWebsocketEvents() {
    this.websocket.on(Uw.RECONNECT_WAITTING_FINISH, (e9) => {
      this.emit(Dw.WS_RECONNECT_WAITTING_FINISH, e9);
    }), this.websocket.on(Uw.RECONNECT_CREATE_CONNECTION, (e9) => {
      this.emit(Dw.WS_RECONNECT_CREATE_CONNECTION, e9);
    }), this.websocket.on(Uw.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(Uw.CLOSED, () => {
      this.connectionState = Nw.CLOSED;
    }), this.websocket.on(Uw.FAILED, () => {
      this._disconnectedReason = Hy.NETWORK_ERROR, this.connectionState = Nw.CLOSED;
    }), this.websocket.on(Uw.RECONNECTING, (e9) => {
      this._websocketReconnectReason = e9, this.joinResponse = void 0, this.connectionState === Nw.CONNECTED ? this.connectionState = Nw.RECONNECTING : this.connectionState = Nw.CONNECTING;
    }), this.websocket.on(Uw.WILL_RECONNECT, (e9, t2, i2) => {
      const n2 = tA(this, Dw.IS_P2P_DISCONNECTED), r2 = n2 || "retry" !== e9;
      n2 && "retry" === e9 && (fb.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), e9 = "tryNext", t2 = eO.P2P_DISCONNECTED), r2 && (fb.debug("".concat(this.clientId, " will renewSession, reconnect mode: ").concat(e9)), this.emit(Dw.REPORT_JOIN_GATEWAY, t2 || eO.UNKNOWN_REASON, this.url || ""), this.reconnectToken = void 0, this.emit(Dw.DISCONNECT_P2P)), i2(e9);
    }), this.websocket.on(Uw.CONNECTED, () => {
      this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e9) => {
        fb.warning("[".concat(this.clientId, "] rejoin failed ").concat(e9)), this.reconnect("tryNext", Jy.SERVER_ERROR);
      }) : this.join().catch((e9) => {
        if (this.emit(Dw.REPORT_JOIN_GATEWAY, e9, this.url || ""), e9 instanceof yb) {
          if (e9.code === Ry.UNEXPECTED_RESPONSE && e9.data.code === Ow.ERR_NO_AUTHORIZED) return this.initError = new yb(Ry.CAN_NOT_GET_GATEWAY_SERVER, "AgoraRTCError CAN_NOT_GET_GATEWAY_SERVER: dynamic key expired"), fb.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", Jy.SERVER_ERROR);
          fb.error("[".concat(this.clientId, "] join gateway request failed"), e9.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", Jy.SERVER_ERROR) : (this.initError = e9, this.close());
        }
      });
    }), this.websocket.on(Uw.REQUEST_NEW_URLS, (e9, t2) => {
      Zy(this, Dw.REQUEST_RECOVER, this.multiIpOption).then(e9).catch(t2);
    }), this.websocket.on(Uw.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
      this.emit(kw.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
    }), this.websocket.on(TO.PRE_CONNECT_PC, () => {
      this.emit(Dw.PRE_CONNECT_PC);
    });
  }
};
var YO = function(e9) {
  return e9[e9.CHOOSE_SERVER = 11] = "CHOOSE_SERVER", e9[e9.CLOUD_PROXY = 18] = "CLOUD_PROXY", e9[e9.CLOUD_PROXY_5 = 20] = "CLOUD_PROXY_5", e9[e9.CLOUD_PROXY_FALLBACK = 26] = "CLOUD_PROXY_FALLBACK", e9;
}({});
function qO(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function zO(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? qO(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : qO(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
function JO(e9) {
  return e9.match(/^[\.\:\d]+$/) ? "".concat(e9.replace(/[^\d]/g, "-"), ".").concat(XA("TURN_DOMAIN")) : (fb.info("Unidentified as ip: ".concat(e9, ", use as host")), e9);
}
function XO(e9, t2) {
  e9.addresses || (e9.addresses = []);
  const i2 = function(e10, t3) {
    if (XA("CONNECT_GATEWAY_WITHOUT_DOMAIN")) return e10.map((e11) => {
      let { ip: t4, port: i4 } = e11;
      return { address: "".concat(t4, ":").concat(i4) };
    });
    const i3 = XA("GATEWAY_DOMAINS");
    let n3 = i3[1] && Dn(t3).call(t3, i3[1]) ? 1 : 0;
    return e10.map((e11) => {
      let { domain_prefix: t4, port: r3, ip: o3 } = e11;
      if (t4) return { address: "".concat(t4, ".").concat(i3[n3++ % i3.length], ":").concat(r3) };
      const s3 = /^[\.\:\d]+$/.test(o3), a2 = s3 ? "".concat(o3.replace(/[^\d]/g, "-"), ".").concat(i3[n3++ % i3.length], ":").concat(r3) : "".concat(o3, ":").concat(r3);
      return s3 || fb.info("Unidentified as ip: ".concat(o3, ", use as host")), { ip: o3, port: r3, address: a2 };
    });
  }(e9.addresses, t2), n2 = Array.isArray(e9.detail) && e9.detail[18];
  if (n2 && "string" == typeof n2) {
    const e10 = n2.split(";");
    for (let t3 = 0; t3 < e10.length; t3++) {
      var r2;
      const n3 = jp(r2 = e10[t3]).call(r2);
      i2[t3] && n3 && (i2[t3].ip6 = n3);
    }
  }
  const o2 = e9.detail && e9.detail.candidate;
  let s2;
  if (o2) {
    const [e10, t3] = o2.split(":");
    e10 && t3 && (s2 = { port: Number(t3), ip: e10, address: "".concat(e10, ":").concat(t3) });
  }
  return { gatewayAddrs: i2, apGatewayAddress: s2, uid: e9.uid, cid: e9.cid, cert: e9.cert, vid: e9.detail && e9.detail[8], uni_lbs_ip: e9.detail && e9.detail[1], res: e9, csIp: e9.detail && e9.detail[502] };
}
function QO(e9) {
  return "number" == typeof e9 ? e9 : e9.exact || e9.ideal || e9.max || e9.min || 0;
}
function ZO(e9) {
  const t2 = e9._encoderConfig;
  if (!t2) return {};
  const i2 = { resolution: t2.width && t2.height ? "".concat(QO(t2.width), "x").concat(QO(t2.height)) : void 0, maxVideoBW: t2.bitrateMax, minVideoBW: t2.bitrateMin };
  return "number" == typeof t2.frameRate ? (i2.maxFrameRate = t2.frameRate, i2.minFrameRate = t2.frameRate) : t2.frameRate && (i2.maxFrameRate = t2.frameRate.max || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.min, i2.minFrameRate = t2.frameRate.min || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.max), i2;
}
function $O(e9) {
  return e9 >= 0 && e9 < 0.17 ? 1 : e9 >= 0.17 && e9 < 0.36 ? 2 : e9 >= 0.36 && e9 < 0.59 ? 3 : e9 >= 0.59 && e9 <= 1 ? 4 : e9 > 1 ? 5 : 0;
}
function eN(e9, t2) {
  let i2, n2, r2;
  switch (t2) {
    case YO.CHOOSE_SERVER:
      n2 = 4096, r2 = "choose server";
      break;
    case YO.CLOUD_PROXY:
      n2 = 1048576, r2 = "proxy";
      break;
    case YO.CLOUD_PROXY_5:
      n2 = 4194304, r2 = "proxy5";
      break;
    case YO.CLOUD_PROXY_FALLBACK:
      n2 = 4194310, r2 = "proxy fallback";
      break;
    default:
      throw new yb(Ry.UNEXPECTED_ERROR, "multi unlibs response transformer get unknown service id", { csIp: e9.detail && e9.detail[502], retry: false });
  }
  if (e9.response_body.forEach((t3) => {
    t3.buffer && t3.buffer.flag === n2 && (i2 = { code: t3.buffer.code, addresses: (t3.buffer.edges_services || []).map((e10) => zO(zO({}, e10), {}, { ticket: t3.buffer.cert })), server_ts: e9.enter_ts, uid: t3.buffer.uid, cid: t3.buffer.cid, cname: t3.buffer.cname, detail: zO(zO({}, t3.buffer.detail), e9.detail), flag: t3.buffer.flag, opid: e9.opid, cert: t3.buffer.cert });
  }), !i2) throw new yb(Ry.MULTI_UNILBS_RESPONSE_ERROR, "cannot parse response ".concat(r2, " from multi unilbs response"), { csIp: e9.detail && e9.detail[502] });
  return i2;
}
async function tN(e9, t2) {
  return await Gh.all(e9.addresses.map(async (e10) => ({ address: JO(e10.ip), tcpport: e10.port, udpport: e10.port, username: t2 && XA("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? t2.toString() : KA.username, password: t2 && XA("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? await Uy(t2.toString()) : KA.password })));
}
function iN(e9, t2) {
  const i2 = t2.getMediaStreamTrack(true).getSettings(), n2 = t2.videoHeight || i2.height, r2 = t2.videoWidth || i2.width;
  return n2 && r2 ? Math.max(Math.min(n2, r2) / Math.min(QO(e9.height), QO(e9.width)), 1) : (fb.warning("can't get ori-track's height, default scale down 4 times for low stream"), 4);
}
function nN(e9) {
  let { candidateType: t2, relayProtocol: i2, type: n2, address: r2, port: o2, protocol: s2 } = e9;
  return "local-candidate" === n2 ? { candidateType: t2, relayProtocol: i2, protocol: s2 } : { candidateType: t2, relayProtocol: i2, address: r2, port: o2, protocol: s2 };
}
var rN;
var oN = i(ew);
var sN = Xi("Array").values;
var aN = pn;
var cN = Ze;
var dN = l;
var lN = sN;
var uN = Array.prototype;
var hN = { DOMTokenList: true, NodeList: true };
var pN = function(e9) {
  var t2 = e9.values;
  return e9 === uN || dN(uN, e9) && t2 === uN.values || cN(hN, aN(e9)) ? lN : t2;
};
var _N = i(pN);
var EN = N;
var fN = d;
var mN = L;
var TN = n;
var SN = eo;
var gN = Br;
var RN = k;
var CN = Je;
var IN = K;
var vN = Object.assign;
var yN = Object.defineProperty;
var AN = fN([].concat);
var bN = !vN || TN(function() {
  if (EN && 1 !== vN({ b: 1 }, vN(yN({}, "a", { enumerable: true, get: function() {
    yN(this, "b", { value: 3, enumerable: false });
  } }), { b: 2 })).b) return true;
  var e9 = {}, t2 = {}, i2 = Symbol(), n2 = "abcdefghijklmnopqrst";
  return e9[i2] = 7, n2.split("").forEach(function(e10) {
    t2[e10] = e10;
  }), 7 != vN({}, e9)[i2] || SN(vN({}, t2)).join("") != n2;
}) ? function(e9, t2) {
  for (var i2 = CN(e9), n2 = arguments.length, r2 = 1, o2 = gN.f, s2 = RN.f; n2 > r2; ) for (var a2, c2 = IN(arguments[r2++]), d2 = o2 ? AN(SN(c2), o2(c2)) : SN(c2), l2 = d2.length, u2 = 0; l2 > u2; ) a2 = d2[u2++], EN && !mN(s2, c2, a2) || (i2[a2] = c2[a2]);
  return i2;
} : vN;
var wN = ii;
var ON = rs;
var NN = Xt;
var DN = L;
var PN = Je;
var LN = function(e9, t2, i2, n2) {
  try {
    return n2 ? t2(wN(i2)[0], i2[1]) : t2(i2);
  } catch (t3) {
    ON(e9, "throw", t3);
  }
};
var kN = jo;
var MN = jc;
var UN = Gi;
var xN = E_;
var VN = es;
var FN = qo;
var BN = Array;
var jN = d;
var GN = 2147483647;
var WN = /[^\0-\u007E]/;
var HN = /[.\u3002\uFF0E\uFF61]/g;
var KN = "Overflow: input needs wider integers to process";
var YN = RangeError;
var qN = jN(HN.exec);
var zN = Math.floor;
var JN = String.fromCharCode;
var XN = jN("".charCodeAt);
var QN = jN([].join);
var ZN = jN([].push);
var $N = jN("".replace);
var eD = jN("".split);
var tD = jN("".toLowerCase);
var iD = function(e9) {
  return e9 + 22 + 75 * (e9 < 26);
};
var nD = function(e9, t2, i2) {
  var n2 = 0;
  for (e9 = i2 ? zN(e9 / 700) : e9 >> 1, e9 += zN(e9 / t2); e9 > 455; ) e9 = zN(e9 / 35), n2 += 36;
  return zN(n2 + 36 * e9 / (e9 + 38));
};
var rD = function(e9) {
  var t2 = [];
  e9 = function(e10) {
    for (var t3 = [], i3 = 0, n3 = e10.length; i3 < n3; ) {
      var r3 = XN(e10, i3++);
      if (r3 >= 55296 && r3 <= 56319 && i3 < n3) {
        var o3 = XN(e10, i3++);
        56320 == (64512 & o3) ? ZN(t3, ((1023 & r3) << 10) + (1023 & o3) + 65536) : (ZN(t3, r3), i3--);
      } else ZN(t3, r3);
    }
    return t3;
  }(e9);
  var i2, n2, r2 = e9.length, o2 = 128, s2 = 0, a2 = 72;
  for (i2 = 0; i2 < e9.length; i2++) (n2 = e9[i2]) < 128 && ZN(t2, JN(n2));
  var c2 = t2.length, d2 = c2;
  for (c2 && ZN(t2, "-"); d2 < r2; ) {
    var l2 = GN;
    for (i2 = 0; i2 < e9.length; i2++) (n2 = e9[i2]) >= o2 && n2 < l2 && (l2 = n2);
    var u2 = d2 + 1;
    if (l2 - o2 > zN((GN - s2) / u2)) throw YN(KN);
    for (s2 += (l2 - o2) * u2, o2 = l2, i2 = 0; i2 < e9.length; i2++) {
      if ((n2 = e9[i2]) < o2 && ++s2 > GN) throw YN(KN);
      if (n2 == o2) {
        for (var h2 = s2, p2 = 36; ; ) {
          var _2 = p2 <= a2 ? 1 : p2 >= a2 + 26 ? 26 : p2 - a2;
          if (h2 < _2) break;
          var E2 = h2 - _2, f2 = 36 - _2;
          ZN(t2, JN(iD(_2 + E2 % f2))), h2 = zN(E2 / f2), p2 += 36;
        }
        ZN(t2, JN(iD(h2))), a2 = nD(s2, u2, d2 == c2), s2 = 0, d2++;
      }
    }
    s2++, o2++;
  }
  return QN(t2, "");
};
var oD = wi;
var sD = N;
var aD = Gg;
var cD = h;
var dD = Xt;
var lD = d;
var uD = ha;
var hD = hc;
var pD = Sc;
var _D = Ze;
var ED = bN;
var fD = function(e9) {
  var t2 = PN(e9), i2 = MN(this), n2 = arguments.length, r2 = n2 > 1 ? arguments[1] : void 0, o2 = void 0 !== r2;
  o2 && (r2 = NN(r2, n2 > 2 ? arguments[2] : void 0));
  var s2, a2, c2, d2, l2, u2, h2 = FN(t2), p2 = 0;
  if (!h2 || this === BN && kN(h2)) for (s2 = UN(t2), a2 = i2 ? new this(s2) : BN(s2); s2 > p2; p2++) u2 = o2 ? r2(t2[p2], p2) : t2[p2], xN(a2, p2, u2);
  else for (l2 = (d2 = VN(t2, h2)).next, a2 = i2 ? new this() : []; !(c2 = DN(l2, d2)).done; p2++) u2 = o2 ? LN(d2, r2, [c2.value, p2], true) : c2.value, xN(a2, p2, u2);
  return a2.length = p2, a2;
};
var mD = R_;
var TD = Ch.codeAt;
var SD = function(e9) {
  var t2, i2, n2 = [], r2 = eD($N(tD(e9), HN, "."), ".");
  for (t2 = 0; t2 < r2.length; t2++) i2 = r2[t2], ZN(n2, qN(WN, i2) ? "xn--" + rD(i2) : i2);
  return QN(n2, ".");
};
var gD = fn;
var RD = Da;
var CD = Zc;
var ID = rC;
var vD = ra;
var yD = vD.set;
var AD = vD.getterFor("URL");
var bD = ID.URLSearchParams;
var wD = ID.getState;
var OD = cD.URL;
var ND = cD.TypeError;
var DD = cD.parseInt;
var PD = Math.floor;
var LD = Math.pow;
var kD = lD("".charAt);
var MD = lD(/./.exec);
var UD = lD([].join);
var xD = lD(1 .toString);
var VD = lD([].pop);
var FD = lD([].push);
var BD = lD("".replace);
var jD = lD([].shift);
var GD = lD("".split);
var WD = lD("".slice);
var HD = lD("".toLowerCase);
var KD = lD([].unshift);
var YD = "Invalid scheme";
var qD = "Invalid host";
var zD = "Invalid port";
var JD = /[a-z]/i;
var XD = /[\d+-.a-z]/i;
var QD = /\d/;
var ZD = /^0x/i;
var $D = /^[0-7]+$/;
var eP = /^\d+$/;
var tP = /^[\da-f]+$/i;
var iP = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
var nP = /[\0\t\n\r #/:<>?@[\\\]^|]/;
var rP = /^[\u0000-\u0020]+/;
var oP = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
var sP = /[\t\n\r]/g;
var aP = function(e9) {
  var t2, i2, n2, r2;
  if ("number" == typeof e9) {
    for (t2 = [], i2 = 0; i2 < 4; i2++) KD(t2, e9 % 256), e9 = PD(e9 / 256);
    return UD(t2, ".");
  }
  if ("object" == typeof e9) {
    for (t2 = "", n2 = function(e10) {
      for (var t3 = null, i3 = 1, n3 = null, r3 = 0, o2 = 0; o2 < 8; o2++) 0 !== e10[o2] ? (r3 > i3 && (t3 = n3, i3 = r3), n3 = null, r3 = 0) : (null === n3 && (n3 = o2), ++r3);
      return r3 > i3 && (t3 = n3, i3 = r3), t3;
    }(e9), i2 = 0; i2 < 8; i2++) r2 && 0 === e9[i2] || (r2 && (r2 = false), n2 === i2 ? (t2 += i2 ? ":" : "::", r2 = true) : (t2 += xD(e9[i2], 16), i2 < 7 && (t2 += ":")));
    return "[" + t2 + "]";
  }
  return e9;
};
var cP = {};
var dP = ED({}, cP, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 });
var lP = ED({}, dP, { "#": 1, "?": 1, "{": 1, "}": 1 });
var uP = ED({}, lP, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 });
var hP = function(e9, t2) {
  var i2 = TD(e9, 0);
  return i2 > 32 && i2 < 127 && !_D(t2, e9) ? e9 : encodeURIComponent(e9);
};
var pP = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 };
var _P = function(e9, t2) {
  var i2;
  return 2 == e9.length && MD(JD, kD(e9, 0)) && (":" == (i2 = kD(e9, 1)) || !t2 && "|" == i2);
};
var EP = function(e9) {
  var t2;
  return e9.length > 1 && _P(WD(e9, 0, 2)) && (2 == e9.length || "/" === (t2 = kD(e9, 2)) || "\\" === t2 || "?" === t2 || "#" === t2);
};
var fP = function(e9) {
  return "." === e9 || "%2e" === HD(e9);
};
var mP = {};
var TP = {};
var SP = {};
var gP = {};
var RP = {};
var CP = {};
var IP = {};
var vP = {};
var yP = {};
var AP = {};
var bP = {};
var wP = {};
var OP = {};
var NP = {};
var DP = {};
var PP = {};
var LP = {};
var kP = {};
var MP = {};
var UP = {};
var xP = {};
var VP = function(e9, t2, i2) {
  var n2, r2, o2, s2 = gD(e9);
  if (t2) {
    if (r2 = this.parse(s2)) throw ND(r2);
    this.searchParams = null;
  } else {
    if (void 0 !== i2 && (n2 = new VP(i2, true)), r2 = this.parse(s2, null, n2)) throw ND(r2);
    (o2 = wD(new bD())).bindURL(this), this.searchParams = o2;
  }
};
VP.prototype = { type: "URL", parse: function(e9, t2, i2) {
  var n2, r2, o2, s2, a2, c2 = this, d2 = t2 || mP, l2 = 0, u2 = "", h2 = false, p2 = false, _2 = false;
  for (e9 = gD(e9), t2 || (c2.scheme = "", c2.username = "", c2.password = "", c2.host = null, c2.port = null, c2.path = [], c2.query = null, c2.fragment = null, c2.cannotBeABaseURL = false, e9 = BD(e9, rP, ""), e9 = BD(e9, oP, "$1")), e9 = BD(e9, sP, ""), n2 = fD(e9); l2 <= n2.length; ) {
    switch (r2 = n2[l2], d2) {
      case mP:
        if (!r2 || !MD(JD, r2)) {
          if (t2) return YD;
          d2 = SP;
          continue;
        }
        u2 += HD(r2), d2 = TP;
        break;
      case TP:
        if (r2 && (MD(XD, r2) || "+" == r2 || "-" == r2 || "." == r2)) u2 += HD(r2);
        else {
          if (":" != r2) {
            if (t2) return YD;
            u2 = "", d2 = SP, l2 = 0;
            continue;
          }
          if (t2 && (c2.isSpecial() != _D(pP, u2) || "file" == u2 && (c2.includesCredentials() || null !== c2.port) || "file" == c2.scheme && !c2.host)) return;
          if (c2.scheme = u2, t2) return void (c2.isSpecial() && pP[c2.scheme] == c2.port && (c2.port = null));
          u2 = "", "file" == c2.scheme ? d2 = NP : c2.isSpecial() && i2 && i2.scheme == c2.scheme ? d2 = gP : c2.isSpecial() ? d2 = vP : "/" == n2[l2 + 1] ? (d2 = RP, l2++) : (c2.cannotBeABaseURL = true, FD(c2.path, ""), d2 = MP);
        }
        break;
      case SP:
        if (!i2 || i2.cannotBeABaseURL && "#" != r2) return YD;
        if (i2.cannotBeABaseURL && "#" == r2) {
          c2.scheme = i2.scheme, c2.path = mD(i2.path), c2.query = i2.query, c2.fragment = "", c2.cannotBeABaseURL = true, d2 = xP;
          break;
        }
        d2 = "file" == i2.scheme ? NP : CP;
        continue;
      case gP:
        if ("/" != r2 || "/" != n2[l2 + 1]) {
          d2 = CP;
          continue;
        }
        d2 = yP, l2++;
        break;
      case RP:
        if ("/" == r2) {
          d2 = AP;
          break;
        }
        d2 = kP;
        continue;
      case CP:
        if (c2.scheme = i2.scheme, r2 == rN) c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = mD(i2.path), c2.query = i2.query;
        else if ("/" == r2 || "\\" == r2 && c2.isSpecial()) d2 = IP;
        else if ("?" == r2) c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = mD(i2.path), c2.query = "", d2 = UP;
        else {
          if ("#" != r2) {
            c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = mD(i2.path), c2.path.length--, d2 = kP;
            continue;
          }
          c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = mD(i2.path), c2.query = i2.query, c2.fragment = "", d2 = xP;
        }
        break;
      case IP:
        if (!c2.isSpecial() || "/" != r2 && "\\" != r2) {
          if ("/" != r2) {
            c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, d2 = kP;
            continue;
          }
          d2 = AP;
        } else d2 = yP;
        break;
      case vP:
        if (d2 = yP, "/" != r2 || "/" != kD(u2, l2 + 1)) continue;
        l2++;
        break;
      case yP:
        if ("/" != r2 && "\\" != r2) {
          d2 = AP;
          continue;
        }
        break;
      case AP:
        if ("@" == r2) {
          h2 && (u2 = "%40" + u2), h2 = true, o2 = fD(u2);
          for (var E2 = 0; E2 < o2.length; E2++) {
            var f2 = o2[E2];
            if (":" != f2 || _2) {
              var m2 = hP(f2, uP);
              _2 ? c2.password += m2 : c2.username += m2;
            } else _2 = true;
          }
          u2 = "";
        } else if (r2 == rN || "/" == r2 || "?" == r2 || "#" == r2 || "\\" == r2 && c2.isSpecial()) {
          if (h2 && "" == u2) return "Invalid authority";
          l2 -= fD(u2).length + 1, u2 = "", d2 = bP;
        } else u2 += r2;
        break;
      case bP:
      case wP:
        if (t2 && "file" == c2.scheme) {
          d2 = PP;
          continue;
        }
        if (":" != r2 || p2) {
          if (r2 == rN || "/" == r2 || "?" == r2 || "#" == r2 || "\\" == r2 && c2.isSpecial()) {
            if (c2.isSpecial() && "" == u2) return qD;
            if (t2 && "" == u2 && (c2.includesCredentials() || null !== c2.port)) return;
            if (s2 = c2.parseHost(u2)) return s2;
            if (u2 = "", d2 = LP, t2) return;
            continue;
          }
          "[" == r2 ? p2 = true : "]" == r2 && (p2 = false), u2 += r2;
        } else {
          if ("" == u2) return qD;
          if (s2 = c2.parseHost(u2)) return s2;
          if (u2 = "", d2 = OP, t2 == wP) return;
        }
        break;
      case OP:
        if (!MD(QD, r2)) {
          if (r2 == rN || "/" == r2 || "?" == r2 || "#" == r2 || "\\" == r2 && c2.isSpecial() || t2) {
            if ("" != u2) {
              var T2 = DD(u2, 10);
              if (T2 > 65535) return zD;
              c2.port = c2.isSpecial() && T2 === pP[c2.scheme] ? null : T2, u2 = "";
            }
            if (t2) return;
            d2 = LP;
            continue;
          }
          return zD;
        }
        u2 += r2;
        break;
      case NP:
        if (c2.scheme = "file", "/" == r2 || "\\" == r2) d2 = DP;
        else {
          if (!i2 || "file" != i2.scheme) {
            d2 = kP;
            continue;
          }
          if (r2 == rN) c2.host = i2.host, c2.path = mD(i2.path), c2.query = i2.query;
          else if ("?" == r2) c2.host = i2.host, c2.path = mD(i2.path), c2.query = "", d2 = UP;
          else {
            if ("#" != r2) {
              EP(UD(mD(n2, l2), "")) || (c2.host = i2.host, c2.path = mD(i2.path), c2.shortenPath()), d2 = kP;
              continue;
            }
            c2.host = i2.host, c2.path = mD(i2.path), c2.query = i2.query, c2.fragment = "", d2 = xP;
          }
        }
        break;
      case DP:
        if ("/" == r2 || "\\" == r2) {
          d2 = PP;
          break;
        }
        i2 && "file" == i2.scheme && !EP(UD(mD(n2, l2), "")) && (_P(i2.path[0], true) ? FD(c2.path, i2.path[0]) : c2.host = i2.host), d2 = kP;
        continue;
      case PP:
        if (r2 == rN || "/" == r2 || "\\" == r2 || "?" == r2 || "#" == r2) {
          if (!t2 && _P(u2)) d2 = kP;
          else if ("" == u2) {
            if (c2.host = "", t2) return;
            d2 = LP;
          } else {
            if (s2 = c2.parseHost(u2)) return s2;
            if ("localhost" == c2.host && (c2.host = ""), t2) return;
            u2 = "", d2 = LP;
          }
          continue;
        }
        u2 += r2;
        break;
      case LP:
        if (c2.isSpecial()) {
          if (d2 = kP, "/" != r2 && "\\" != r2) continue;
        } else if (t2 || "?" != r2) if (t2 || "#" != r2) {
          if (r2 != rN && (d2 = kP, "/" != r2)) continue;
        } else c2.fragment = "", d2 = xP;
        else c2.query = "", d2 = UP;
        break;
      case kP:
        if (r2 == rN || "/" == r2 || "\\" == r2 && c2.isSpecial() || !t2 && ("?" == r2 || "#" == r2)) {
          if (".." === (a2 = HD(a2 = u2)) || "%2e." === a2 || ".%2e" === a2 || "%2e%2e" === a2 ? (c2.shortenPath(), "/" == r2 || "\\" == r2 && c2.isSpecial() || FD(c2.path, "")) : fP(u2) ? "/" == r2 || "\\" == r2 && c2.isSpecial() || FD(c2.path, "") : ("file" == c2.scheme && !c2.path.length && _P(u2) && (c2.host && (c2.host = ""), u2 = kD(u2, 0) + ":"), FD(c2.path, u2)), u2 = "", "file" == c2.scheme && (r2 == rN || "?" == r2 || "#" == r2)) for (; c2.path.length > 1 && "" === c2.path[0]; ) jD(c2.path);
          "?" == r2 ? (c2.query = "", d2 = UP) : "#" == r2 && (c2.fragment = "", d2 = xP);
        } else u2 += hP(r2, lP);
        break;
      case MP:
        "?" == r2 ? (c2.query = "", d2 = UP) : "#" == r2 ? (c2.fragment = "", d2 = xP) : r2 != rN && (c2.path[0] += hP(r2, cP));
        break;
      case UP:
        t2 || "#" != r2 ? r2 != rN && ("'" == r2 && c2.isSpecial() ? c2.query += "%27" : c2.query += "#" == r2 ? "%23" : hP(r2, cP)) : (c2.fragment = "", d2 = xP);
        break;
      case xP:
        r2 != rN && (c2.fragment += hP(r2, dP));
    }
    l2++;
  }
}, parseHost: function(e9) {
  var t2, i2, n2;
  if ("[" == kD(e9, 0)) {
    if ("]" != kD(e9, e9.length - 1)) return qD;
    if (t2 = function(e10) {
      var t3, i3, n3, r2, o2, s2, a2, c2 = [0, 0, 0, 0, 0, 0, 0, 0], d2 = 0, l2 = null, u2 = 0, h2 = function() {
        return kD(e10, u2);
      };
      if (":" == h2()) {
        if (":" != kD(e10, 1)) return;
        u2 += 2, l2 = ++d2;
      }
      for (; h2(); ) {
        if (8 == d2) return;
        if (":" != h2()) {
          for (t3 = i3 = 0; i3 < 4 && MD(tP, h2()); ) t3 = 16 * t3 + DD(h2(), 16), u2++, i3++;
          if ("." == h2()) {
            if (0 == i3) return;
            if (u2 -= i3, d2 > 6) return;
            for (n3 = 0; h2(); ) {
              if (r2 = null, n3 > 0) {
                if (!("." == h2() && n3 < 4)) return;
                u2++;
              }
              if (!MD(QD, h2())) return;
              for (; MD(QD, h2()); ) {
                if (o2 = DD(h2(), 10), null === r2) r2 = o2;
                else {
                  if (0 == r2) return;
                  r2 = 10 * r2 + o2;
                }
                if (r2 > 255) return;
                u2++;
              }
              c2[d2] = 256 * c2[d2] + r2, 2 != ++n3 && 4 != n3 || d2++;
            }
            if (4 != n3) return;
            break;
          }
          if (":" == h2()) {
            if (u2++, !h2()) return;
          } else if (h2()) return;
          c2[d2++] = t3;
        } else {
          if (null !== l2) return;
          u2++, l2 = ++d2;
        }
      }
      if (null !== l2) for (s2 = d2 - l2, d2 = 7; 0 != d2 && s2 > 0; ) a2 = c2[d2], c2[d2--] = c2[l2 + s2 - 1], c2[l2 + --s2] = a2;
      else if (8 != d2) return;
      return c2;
    }(WD(e9, 1, -1)), !t2) return qD;
    this.host = t2;
  } else if (this.isSpecial()) {
    if (e9 = SD(e9), MD(iP, e9)) return qD;
    if (t2 = function(e10) {
      var t3, i3, n3, r2, o2, s2, a2, c2 = GD(e10, ".");
      if (c2.length && "" == c2[c2.length - 1] && c2.length--, (t3 = c2.length) > 4) return e10;
      for (i3 = [], n3 = 0; n3 < t3; n3++) {
        if ("" == (r2 = c2[n3])) return e10;
        if (o2 = 10, r2.length > 1 && "0" == kD(r2, 0) && (o2 = MD(ZD, r2) ? 16 : 8, r2 = WD(r2, 8 == o2 ? 1 : 2)), "" === r2) s2 = 0;
        else {
          if (!MD(10 == o2 ? eP : 8 == o2 ? $D : tP, r2)) return e10;
          s2 = DD(r2, o2);
        }
        FD(i3, s2);
      }
      for (n3 = 0; n3 < t3; n3++) if (s2 = i3[n3], n3 == t3 - 1) {
        if (s2 >= LD(256, 5 - t3)) return null;
      } else if (s2 > 255) return null;
      for (a2 = VD(i3), n3 = 0; n3 < i3.length; n3++) a2 += i3[n3] * LD(256, 3 - n3);
      return a2;
    }(e9), null === t2) return qD;
    this.host = t2;
  } else {
    if (MD(nP, e9)) return qD;
    for (t2 = "", i2 = fD(e9), n2 = 0; n2 < i2.length; n2++) t2 += hP(i2[n2], cP);
    this.host = t2;
  }
}, cannotHaveUsernamePasswordPort: function() {
  return !this.host || this.cannotBeABaseURL || "file" == this.scheme;
}, includesCredentials: function() {
  return "" != this.username || "" != this.password;
}, isSpecial: function() {
  return _D(pP, this.scheme);
}, shortenPath: function() {
  var e9 = this.path, t2 = e9.length;
  !t2 || "file" == this.scheme && 1 == t2 && _P(e9[0], true) || e9.length--;
}, serialize: function() {
  var e9 = this, t2 = e9.scheme, i2 = e9.username, n2 = e9.password, r2 = e9.host, o2 = e9.port, s2 = e9.path, a2 = e9.query, c2 = e9.fragment, d2 = t2 + ":";
  return null !== r2 ? (d2 += "//", e9.includesCredentials() && (d2 += i2 + (n2 ? ":" + n2 : "") + "@"), d2 += aP(r2), null !== o2 && (d2 += ":" + o2)) : "file" == t2 && (d2 += "//"), d2 += e9.cannotBeABaseURL ? s2[0] : s2.length ? "/" + UD(s2, "/") : "", null !== a2 && (d2 += "?" + a2), null !== c2 && (d2 += "#" + c2), d2;
}, setHref: function(e9) {
  var t2 = this.parse(e9);
  if (t2) throw ND(t2);
  this.searchParams.update();
}, getOrigin: function() {
  var e9 = this.scheme, t2 = this.port;
  if ("blob" == e9) try {
    return new FP(e9.path[0]).origin;
  } catch (e10) {
    return "null";
  }
  return "file" != e9 && this.isSpecial() ? e9 + "://" + aP(this.host) + (null !== t2 ? ":" + t2 : "") : "null";
}, getProtocol: function() {
  return this.scheme + ":";
}, setProtocol: function(e9) {
  this.parse(gD(e9) + ":", mP);
}, getUsername: function() {
  return this.username;
}, setUsername: function(e9) {
  var t2 = fD(gD(e9));
  if (!this.cannotHaveUsernamePasswordPort()) {
    this.username = "";
    for (var i2 = 0; i2 < t2.length; i2++) this.username += hP(t2[i2], uP);
  }
}, getPassword: function() {
  return this.password;
}, setPassword: function(e9) {
  var t2 = fD(gD(e9));
  if (!this.cannotHaveUsernamePasswordPort()) {
    this.password = "";
    for (var i2 = 0; i2 < t2.length; i2++) this.password += hP(t2[i2], uP);
  }
}, getHost: function() {
  var e9 = this.host, t2 = this.port;
  return null === e9 ? "" : null === t2 ? aP(e9) : aP(e9) + ":" + t2;
}, setHost: function(e9) {
  this.cannotBeABaseURL || this.parse(e9, bP);
}, getHostname: function() {
  var e9 = this.host;
  return null === e9 ? "" : aP(e9);
}, setHostname: function(e9) {
  this.cannotBeABaseURL || this.parse(e9, wP);
}, getPort: function() {
  var e9 = this.port;
  return null === e9 ? "" : gD(e9);
}, setPort: function(e9) {
  this.cannotHaveUsernamePasswordPort() || ("" == (e9 = gD(e9)) ? this.port = null : this.parse(e9, OP));
}, getPathname: function() {
  var e9 = this.path;
  return this.cannotBeABaseURL ? e9[0] : e9.length ? "/" + UD(e9, "/") : "";
}, setPathname: function(e9) {
  this.cannotBeABaseURL || (this.path = [], this.parse(e9, LP));
}, getSearch: function() {
  var e9 = this.query;
  return e9 ? "?" + e9 : "";
}, setSearch: function(e9) {
  "" == (e9 = gD(e9)) ? this.query = null : ("?" == kD(e9, 0) && (e9 = WD(e9, 1)), this.query = "", this.parse(e9, UP)), this.searchParams.update();
}, getSearchParams: function() {
  return this.searchParams.facade;
}, getHash: function() {
  var e9 = this.fragment;
  return e9 ? "#" + e9 : "";
}, setHash: function(e9) {
  "" != (e9 = gD(e9)) ? ("#" == kD(e9, 0) && (e9 = WD(e9, 1)), this.fragment = "", this.parse(e9, xP)) : this.fragment = null;
}, update: function() {
  this.query = this.searchParams.serialize() || null;
} };
var FP = function(e9) {
  var t2 = pD(this, BP), i2 = CD(arguments.length, 1) > 1 ? arguments[1] : void 0, n2 = yD(t2, new VP(e9, false, i2));
  sD || (t2.href = n2.serialize(), t2.origin = n2.getOrigin(), t2.protocol = n2.getProtocol(), t2.username = n2.getUsername(), t2.password = n2.getPassword(), t2.host = n2.getHost(), t2.hostname = n2.getHostname(), t2.port = n2.getPort(), t2.pathname = n2.getPathname(), t2.search = n2.getSearch(), t2.searchParams = n2.getSearchParams(), t2.hash = n2.getHash());
};
var BP = FP.prototype;
var jP = function(e9, t2) {
  return { get: function() {
    return AD(this)[e9]();
  }, set: t2 && function(e10) {
    return AD(this)[t2](e10);
  }, configurable: true, enumerable: true };
};
if (sD && (hD(BP, "href", jP("serialize", "setHref")), hD(BP, "origin", jP("getOrigin")), hD(BP, "protocol", jP("getProtocol", "setProtocol")), hD(BP, "username", jP("getUsername", "setUsername")), hD(BP, "password", jP("getPassword", "setPassword")), hD(BP, "host", jP("getHost", "setHost")), hD(BP, "hostname", jP("getHostname", "setHostname")), hD(BP, "port", jP("getPort", "setPort")), hD(BP, "pathname", jP("getPathname", "setPathname")), hD(BP, "search", jP("getSearch", "setSearch")), hD(BP, "searchParams", jP("getSearchParams")), hD(BP, "hash", jP("getHash", "setHash"))), uD(BP, "toJSON", function() {
  return AD(this).serialize();
}, { enumerable: true }), uD(BP, "toString", function() {
  return AD(this).serialize();
}, { enumerable: true }), OD) {
  GP = OD.createObjectURL, WP = OD.revokeObjectURL;
  GP && uD(FP, "createObjectURL", dD(GP, OD)), WP && uD(FP, "revokeObjectURL", dD(WP, OD));
}
var GP;
var WP;
RD(FP, "URL"), oD({ global: true, constructor: true, forced: !aD, sham: !sD }, { URL: FP });
var HP = wi;
var KP = n;
var YP = Zc;
var qP = fn;
var zP = Gg;
var JP = ae("URL");
HP({ target: "URL", stat: true, forced: !(zP && KP(function() {
  JP.canParse();
})) }, { canParse: function(e9) {
  var t2 = YP(arguments.length, 1), i2 = qP(e9), n2 = t2 < 2 || void 0 === arguments[1] ? void 0 : qP(arguments[1]);
  try {
    return !!new JP(i2, n2);
  } catch (e10) {
    return false;
  }
} });
var XP = i(ie.URL);
var QP = { getDisplayMedia: false, getStreamFromExtension: false, supportUnifiedPlan: false, supportMinBitrate: false, supportSetRtpSenderParameters: false, supportDualStream: true, webAudioMediaStreamDest: false, supportReplaceTrack: false, supportWebGL: false, webAudioWithAEC: false, supportRequestFrame: false, supportShareAudio: false, supportDualStreamEncoding: false, supportDataChannel: false, supportPCSetConfiguration: false, supportWebRTCEncodedTransform: false, supportWebRTCInsertableStream: false, supportRequestVideoFrameCallback: false, supportWebCrypto: false };
function ZP() {
  return QP;
}
function $P() {
  return "setSinkId" in HTMLAudioElement.prototype && (!XA("RESTRICTION_SET_PLAYBACK_DEVICE") || (Jv() || Qv()) && !_y());
}
function eL() {
  return !QP.supportUnifiedPlan || XA("CHROME_FORCE_PLAN_B") && Ey();
}
var tL = function(e9) {
  return e9.IOS_15_16_INTERRUPTION_START = "ios15_16-interruption-start", e9.IOS_15_16_INTERRUPTION_END = "ios15_16-interruption-end", e9.IOS_INTERRUPTION_START = "ios-interruption-start", e9.IOS_INTERRUPTION_END = "ios-interruption-end", e9.STATE_CHANGE = "state-change", e9;
}({});
function iL(e9, t2, i2) {
  return { sampleRate: e9, stereo: t2, bitrate: i2 };
}
function nL(e9, t2, i2, n2, r2) {
  return { width: e9, height: t2, frameRate: i2, bitrateMin: n2, bitrateMax: r2 };
}
function rL(e9, t2, i2, n2, r2) {
  return { width: { max: e9 }, height: { max: t2 }, frameRate: i2, bitrateMin: n2, bitrateMax: r2 };
}
function oL(e9, t2) {
  return { numSpatialLayers: e9, numTemporalLayers: t2 };
}
var sL = { "90p": nL(160, 90), "90p_1": nL(160, 90), "120p": nL(160, 120, 15, 30, 65), "120p_1": nL(160, 120, 15, 30, 65), "120p_3": nL(120, 120, 15, 30, 50), "120p_4": nL(212, 120), "180p": nL(320, 180, 15, 30, 140), "180p_1": nL(320, 180, 15, 30, 140), "180p_3": nL(180, 180, 15, 30, 100), "180p_4": nL(240, 180, 15, 30, 120), "240p": nL(320, 240, 15, 40, 200), "240p_1": nL(320, 240, 15, 40, 200), "240p_3": nL(240, 240, 15, 40, 140), "240p_4": nL(424, 240, 15, 40, 220), "360p": nL(640, 360, 15, 80, 400), "360p_1": nL(640, 360, 15, 80, 400), "360p_3": nL(360, 360, 15, 80, 260), "360p_4": nL(640, 360, 30, 80, 600), "360p_6": nL(360, 360, 30, 80, 400), "360p_7": nL(480, 360, 15, 80, 320), "360p_8": nL(480, 360, 30, 80, 490), "360p_9": nL(640, 360, 15, 80, 800), "360p_10": nL(640, 360, 24, 80, 800), "360p_11": nL(640, 360, 24, 80, 1e3), "480p": nL(640, 480, 15, 100, 500), "480p_1": nL(640, 480, 15, 100, 500), "480p_2": nL(640, 480, 30, 100, 1e3), "480p_3": nL(480, 480, 15, 100, 400), "480p_4": nL(640, 480, 30, 100, 750), "480p_6": nL(480, 480, 30, 100, 600), "480p_8": nL(848, 480, 15, 100, 610), "480p_9": nL(848, 480, 30, 100, 930), "480p_10": nL(640, 480, 10, 100, 400), "720p": nL(1280, 720, 15, 120, 1130), "720p_auto": nL(1280, 720, 30, 900, 3e3), "720p_1": nL(1280, 720, 15, 120, 1130), "720p_2": nL(1280, 720, 30, 120, 2e3), "720p_3": nL(1280, 720, 30, 120, 1710), "720p_5": nL(960, 720, 15, 120, 910), "720p_6": nL(960, 720, 30, 120, 1380), "1080p": nL(1920, 1080, 15, 120, 2080), "1080p_1": nL(1920, 1080, 15, 120, 2080), "1080p_2": nL(1920, 1080, 30, 120, 3e3), "1080p_3": nL(1920, 1080, 30, 120, 3150), "1080p_5": nL(1920, 1080, 60, 120, 4780), "1440p": nL(2560, 1440, 30, 120, 4850), "1440p_1": nL(2560, 1440, 30, 120, 4850), "1440p_2": nL(2560, 1440, 60, 120, 7350), "4k": nL(3840, 2160, 30, 120, 8910), "4k_1": nL(3840, 2160, 30, 120, 8910), "4k_3": nL(3840, 2160, 60, 120, 13500) };
var aL = { "480p": rL(640, 480, 5), "480p_1": rL(640, 480, 5), "480p_2": rL(640, 480, 30), "480p_3": rL(640, 480, 15), "720p": rL(1280, 720, 5), "720p_auto": nL(1280, 720, 30, 900, 3e3), "720p_1": rL(1280, 720, 5), "720p_2": rL(1280, 720, 30), "720p_3": rL(1280, 720, 15), "1080p": rL(1920, 1080, 5), "1080p_1": rL(1920, 1080, 5), "1080p_2": rL(1920, 1080, 30), "1080p_3": rL(1920, 1080, 15) };
var cL = { "1SL1TL": oL(1, 1), "3SL3TL": oL(3, 3), "2SL3TL": oL(2, 3) };
function dL(e9) {
  return e9 || (e9 = "480p_1"), "string" == typeof e9 ? Object.assign({}, sL[e9]) : e9;
}
function lL(e9) {
  return "string" == typeof e9 ? Object.assign({}, aL[e9]) : e9;
}
function uL(e9) {
  return "string" == typeof e9 ? Object.assign({}, cL[e9]) : e9;
}
var hL = { speech_low_quality: iL(16e3, false), speech_standard: iL(32e3, false, 18), music_standard: iL(48e3, false), standard_stereo: iL(48e3, true, 56), high_quality: iL(48e3, false, 128), high_quality_stereo: iL(48e3, true, 192) };
function pL(e9) {
  return "string" == typeof e9 ? Object.assign({}, hL[e9]) : e9;
}
var _L = [];
function EL(e9) {
  return vy(e9, "mediaSource", ["screen", "window", "application"]), true;
}
var fL = function(e9) {
  return e9.NEED_RENEGOTIATE = "@need_renegotiate", e9.NEED_REPLACE_TRACK = "@need_replace_track", e9.NEED_REPLACE_MIXING_TRACK = "@need_replace_mixing_track", e9.NEED_CLOSE = "@need_close", e9.NEED_ENABLE_TRACK = "@need_enable_track", e9.NEED_DISABLE_TRACK = "@need_disable_track", e9.NEED_SESSION_ID = "@need_sid", e9.SET_OPTIMIZATION_MODE = "@set_optimization_mode", e9.GET_STATS = "@get_stats", e9.GET_RTC_STATS = "@get_rtc_stats", e9.GET_LOW_VIDEO_TRACK = "@get_low_video_track", e9.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp", e9.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder", e9.NEED_UPDATE_VIDEO_SEND_PARAMETERS = "@need_update_video_send_parameters", e9.NEED_MUTE_TRACK = "@need_mute_track", e9.NEED_UNMUTE_TRACK = "@need_unmute_track", e9;
}({});
var mL = function(e9) {
  return e9.SCREEN_TRACK = "screen_track", e9.CUSTOM_TRACK = "custome_track", e9.LOW_STREAM = "low_stream", e9.SCREEN_LOW_TRACK = "screen_low_track", e9;
}({});
var TL = function(e9) {
  return e9[e9.HIGH_STREAM = 0] = "HIGH_STREAM", e9[e9.LOW_STREAM = 1] = "LOW_STREAM", e9;
}({});
var SL = function(e9) {
  return e9[e9.HIGH_STREAM = 0] = "HIGH_STREAM", e9[e9.LOW_STREAM = 1] = "LOW_STREAM", e9[e9.HIGH_STREAM_LAYER1 = 4] = "HIGH_STREAM_LAYER1", e9[e9.HIGH_STREAM_LAYER2 = 5] = "HIGH_STREAM_LAYER2", e9[e9.HIGH_STREAM_LAYER3 = 6] = "HIGH_STREAM_LAYER3", e9[e9.HIGH_STREAM_LAYER4 = 7] = "HIGH_STREAM_LAYER4", e9[e9.HIGH_STREAM_LAYER5 = 8] = "HIGH_STREAM_LAYER5", e9[e9.HIGH_STREAM_LAYER6 = 9] = "HIGH_STREAM_LAYER6", e9;
}({});
var gL = function(e9) {
  return e9[e9.DISABLE = 0] = "DISABLE", e9[e9.LOW_STREAM = 1] = "LOW_STREAM", e9[e9.AUDIO_ONLY = 2] = "AUDIO_ONLY", e9[e9.HIGH_STREAM_LAYER1 = 3] = "HIGH_STREAM_LAYER1", e9[e9.HIGH_STREAM_LAYER2 = 4] = "HIGH_STREAM_LAYER2", e9[e9.HIGH_STREAM_LAYER3 = 5] = "HIGH_STREAM_LAYER3", e9[e9.HIGH_STREAM_LAYER4 = 6] = "HIGH_STREAM_LAYER4", e9[e9.HIGH_STREAM_LAYER5 = 7] = "HIGH_STREAM_LAYER5", e9[e9.HIGH_STREAM_LAYER6 = 8] = "HIGH_STREAM_LAYER6", e9;
}({});
var RL = function(e9) {
  return e9.TRANSCEIVER_UPDATED = "transceiver-updated", e9.SEI_TO_SEND = "sei-to-send", e9.SEI_RECEIVED = "sei-received", e9.TRACK_UPDATED = "track-updated", e9;
}({});
var CL = function(e9) {
  return e9.SOURCE_STATE_CHANGE = "source-state-change", e9.TRACK_ENDED = "track-ended", e9.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload", e9.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e9.CLOSED = "closed", e9;
}({});
var IL = function(e9) {
  return e9.FIRST_FRAME_DECODED = "first-frame-decoded", e9.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e9.VIDEO_STATE_CHANGED = "video-state-changed", e9;
}({});
var vL = function(e9) {
  return e9.AUDIO = "audio", e9.VIDEO = "video", e9.DATA = "data", e9;
}({});
var yL = function(e9) {
  return e9.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change", e9.RECEIVE_TRACK_BUFFER = "receive_track_buffer", e9.ON_AUDIO_BUFFER = "on_audio_buffer", e9.UPDATE_SOURCE = "update_source", e9;
}({});
!function(e9) {
  e9.UPDATE_TRACK_SOURCE = "update-track-source";
}({});
var AL = { sendVolumeLevel: 0, sendBitrate: 0, sendBytes: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, currentPacketLossRate: 0 };
var bL = { sendBytes: 0, sendBitrate: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, sendResolutionHeight: 0, sendResolutionWidth: 0, captureResolutionHeight: 0, captureResolutionWidth: 0, targetSendBitrate: 0, totalDuration: 0, totalFreezeTime: 0, currentPacketLossRate: 0 };
var wL = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveLevel: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receivePacketsDiscarded: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 };
var OL = { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 };
var NL = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receiveResolutionHeight: 0, receiveResolutionWidth: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 };
var DL = function(e9) {
  return e9.ON_TRACK = "on_track", e9.ON_NODE = "on_node", e9;
}({});
var PL = function(e9) {
  return e9.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints", e9.REQUEST_CONSTRAINTS = "request_constraints", e9;
}({});
var LL = function(e9) {
  return e9.IDLE = "IDLE", e9.INITING = "INITING", e9.INITEND = "INITEND", e9;
}({});
var kL = function(e9) {
  return e9.STATE_CHANGE = "state_change", e9.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged", e9.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged", e9.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged", e9;
}({});
var ML = function(e9) {
  return e9.NONE = "none", e9.INIT = "init", e9.CANPLAY = "canplay", e9.PLAYING = "playing", e9.PAUSED = "paused", e9.SUSPEND = "suspend", e9.STALLED = "stalled", e9.WAITING = "waiting", e9.ERROR = "error", e9.DESTROYED = "destroyed", e9.ABORT = "abort", e9.ENDED = "ended", e9.EMPTIED = "emptied", e9.LOADEDDATA = "loadeddata", e9;
}({});
var UL = function(e9) {
  return e9[e9.VideoStateStopped = 0] = "VideoStateStopped", e9[e9.VideoStateStarting = 1] = "VideoStateStarting", e9[e9.VideoStateDecoding = 2] = "VideoStateDecoding", e9[e9.VideoStateFrozen = 3] = "VideoStateFrozen", e9;
}({});
var xL = { uninit: 100, none: 110, init: 120, loadeddata: 130, canplay: 200, playing: 210, paused: 220, suspend: 300, stalled: 310, waiting: 320, error: 330, destroyed: 340, abort: 350, ended: 360, emptied: 370 };
var VL = function(e9) {
  return e9.OPEN = "open", e9.MESSAGE = "message", e9.CLOSE = "close", e9.CLOSING = "closing", e9.ERROR = "error", e9;
}({});
function FL(e9, t2, i2, n2, r2) {
  var o2, s2, a2 = {};
  return Object.keys(n2).forEach(function(e10) {
    a2[e10] = n2[e10];
  }), a2.enumerable = !!a2.enumerable, a2.configurable = !!a2.configurable, ("value" in a2 || a2.initializer) && (a2.writable = true), a2 = Jn(o2 = oN(s2 = i2.slice()).call(s2)).call(o2, function(i3, n3) {
    return n3(e9, t2, i3) || i3;
  }, a2), r2 && void 0 !== a2.initializer && (a2.value = a2.initializer ? a2.initializer.call(r2) : void 0, a2.initializer = void 0), void 0 === a2.initializer && (Object.defineProperty(e9, t2, a2), a2 = null), a2;
}
function BL(e9, t2, i2) {
  return (t2 = function(e10) {
    var t3 = function(e11, t4) {
      if ("object" != typeof e11 || !e11) return e11;
      var i3 = e11[Symbol.toPrimitive];
      if (void 0 !== i3) {
        var n2 = i3.call(e11, "string");
        if ("object" != typeof n2) return n2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(e11);
    }(e10);
    return "symbol" == typeof t3 ? t3 : t3 + "";
  }(t2)) in e9 ? Object.defineProperty(e9, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e9[t2] = i2, e9;
}
function jL(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function GL(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? jL(Object(i2), true).forEach(function(t3) {
      BL(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : jL(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var WL = class extends xy {
  set _mediaStreamTrack(e9) {
    e9 !== this.mediaStreamTrack && (this.safeEmit(RL.TRACK_UPDATED, e9), this.mediaStreamTrack = e9);
  }
  get _mediaStreamTrack() {
    return this.mediaStreamTrack;
  }
  constructor(e9, t2) {
    super(), BL(this, "trackMediaType", void 0), BL(this, "_ID", void 0), BL(this, "_rtpTransceiver", void 0), BL(this, "_lowRtpTransceiver", void 0), BL(this, "_hints", []), BL(this, "_isClosed", false), BL(this, "_originMediaStreamTrack", void 0), BL(this, "mediaStreamTrack", void 0), BL(this, "_external", {}), this._ID = t2 || TA(8, "track-"), this._originMediaStreamTrack = e9, this.mediaStreamTrack = e9, function(e10) {
      Dn(_L).call(_L, e10) || _L.push(e10);
    }(this);
  }
  toString() {
    return this._ID;
  }
  getTrackId() {
    return this._ID;
  }
  getMediaStreamTrack(e9) {
    return e9 || dA(() => {
      var e10;
      vb.reportApiInvoke(null, { name: By.GET_MEDIA_STREAM_TRACK, options: [], tag: jy.TRACER }).onSuccess((null === (e10 = this._mediaStreamTrack) || void 0 === e10 ? void 0 : e10.label) || "");
    }, this.mediaStreamTrack.id || this.getTrackId()), this._mediaStreamTrack;
  }
  getRTCRtpTransceiver(e9) {
    return e9 === TL.LOW_STREAM ? this._lowRtpTransceiver : this._rtpTransceiver;
  }
  getMediaStreamTrackSettings() {
    return this.getMediaStreamTrack(true).getSettings();
  }
  close() {
    this._isClosed = true, this._lowRtpTransceiver = void 0, this._rtpTransceiver = void 0, function(e9) {
      const t2 = _L.indexOf(e9);
      -1 !== t2 && _L.splice(t2, 1);
    }(this), this.emit(CL.CLOSED), this.removeAllListeners(RL.SEI_RECEIVED);
  }
  _updateRtpTransceiver(e9, t2) {
    if (t2 === TL.LOW_STREAM) {
      if (this._lowRtpTransceiver === e9) return;
      this._lowRtpTransceiver = e9;
    } else {
      if (this._rtpTransceiver === e9) return;
      this._rtpTransceiver = e9;
    }
    this.emit(RL.TRANSCEIVER_UPDATED, e9, t2);
  }
};
var HL = class extends WL {
  get isExternalTrack() {
    return this._isExternalTrack;
  }
  get muted() {
    return this._muted;
  }
  get enabled() {
    return this._enabled;
  }
  get processorContext() {
    return this._processorContext;
  }
  constructor(e9, t2) {
    super(e9, t2), BL(this, "_enabled", true), BL(this, "_muted", false), BL(this, "_isExternalTrack", false), BL(this, "_isClosed", false), BL(this, "_enabledMutex", void 0), BL(this, "processor", void 0), BL(this, "_processorContext", void 0), BL(this, "_handleTrackEnded", () => {
      this.onTrackEnded();
    }), this._enabledMutex = new NA("".concat(this.getTrackId())), e9.addEventListener("ended", this._handleTrackEnded);
  }
  getTrackLabel() {
    var e9, t2;
    return null !== (e9 = null === (t2 = this._originMediaStreamTrack) || void 0 === t2 ? void 0 : t2.label) && void 0 !== e9 ? e9 : "";
  }
  close() {
    this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, fb.debug("[".concat(this.getTrackId(), "] close")), this.emit(fL.NEED_CLOSE), super.close());
  }
  async _updateOriginMediaStreamTrack(e9, t2) {
    let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    this._isExternalTrack = i2, e9 !== this._originMediaStreamTrack && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop()), e9.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e9, this._muted && (this._originMediaStreamTrack.enabled = false), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await $y(this, fL.NEED_REPLACE_TRACK, this), this.processor && this._processorContext && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this._processorContext }));
  }
  _getDefaultPlayerConfig() {
    return {};
  }
  onTrackEnded() {
    fb.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(CL.TRACK_ENDED);
  }
  stateCheck(e9, t2) {
    if (fb.debug("check track state, [muted: ".concat(this._muted, ", enabled: ").concat(this._enabled, "] to [").concat(e9, ": ").concat(t2, "]")), Iy(t2, e9), this._enabled && this._muted && "enabled" === e9 && false === t2) throw new Cy(Ry.TRACK_STATE_UNREACHABLE, "cannot set enabled while the track is muted").print("error", fb);
    if (!this._enabled && !this._muted && "muted" === e9 && true === t2) throw new Cy(Ry.TRACK_STATE_UNREACHABLE, "cannot set muted while the track is disabled").print("error", fb);
  }
  getProcessorStats() {
    return this._processorContext && this._processorContext.gatherStats() || [];
  }
  getProcessorUsage() {
    return this._processorContext ? this._processorContext.gatherUsage() : Gh.resolve([]);
  }
};
var KL = window.AudioContext || window.webkitAudioContext;
var YL = null;
var qL = new class extends xy {
  constructor() {
    super(...arguments), BL(this, "prevState", void 0), BL(this, "curState", void 0), BL(this, "currentTime", void 0), BL(this, "currentTimeStuckAt", void 0), BL(this, "interruptDetectorTrack", void 0), BL(this, "onLocalAudioTrackMute", () => {
      fb.info("ios15-interruption-start"), this.emit(tL.IOS_15_16_INTERRUPTION_START);
    }), BL(this, "onLocalAudioTrackUnmute", async () => {
      fb.info("ios15-interruption-end"), "running" !== this.curState || this.duringInterruption ? fb.info("ios15-interruption-end-canceled") : (YL && await YL.suspend(), this.emit(tL.IOS_15_16_INTERRUPTION_END));
    });
  }
  get duringInterruption() {
    return "running" === this.prevState && "interrupted" === this.curState;
  }
  bindInterruptDetectorTrack(e9) {
    fb.debug("webaudio bindInterruptDetectorTrack ".concat(e9.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = e9, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);
  }
  unbindInterruptDetectorTrack(e9) {
    fb.debug("webaudio unbindInterruptDetectorTrack ".concat(e9.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === e9 && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);
  }
}();
function zL() {
  if (!YL) {
    if (function() {
      if (!KL) return void fb.error("your browser is not support web audio");
      fb.info("create audio context");
      const e9 = GL({}, XA("WEBAUDIO_INIT_OPTIONS"));
      fb.debug("audio context init option:", JSON.stringify(e9)), YL = new KL(e9), qL.curState = YL.state, YL.onstatechange = () => {
        qL.prevState = qL.curState, qL.curState = YL ? YL.state : void 0;
        const { prevState: e10, curState: t2 } = qL, i2 = "running" === t2, n2 = "interrupted" === t2, r2 = "running" === e10, o2 = "suspended" === e10, s2 = "interrupted" === e10, a2 = Hv().osVersion;
        ($v() || uy()) && r2 && n2 && (fb.info("ios".concat(a2, "-interruption-start")), qL.emit(tL.IOS_INTERRUPTION_START)), ($v() || uy()) && (o2 || s2) && i2 && (fb.info("ios".concat(a2, "-interruption-end")), qL.emit(tL.IOS_INTERRUPTION_END)), e10 !== t2 && qL.emit(tL.STATE_CHANGE, t2, e10);
      }, setInterval(() => {
        var e10;
        const t2 = null === (e10 = YL) || void 0 === e10 ? void 0 : e10.currentTime;
        qL.currentTime !== t2 ? (qL.currentTimeStuckAt && (fb.debug("AudioContext current time resume at ".concat(t2)), qL.currentTimeStuckAt = void 0), qL.currentTime = t2) : (t2 !== qL.currentTimeStuckAt && (vb.reportApiInvoke(null, { name: "WEB_AUDIO_CURRENT_TIME_STUCK", options: { currentTime: t2 }, tag: jy.TRACER }).onSuccess(), fb.warning("AudioContext current time stuck at ".concat(t2))), qL.currentTimeStuckAt = t2);
      }, 5e3), async function(e10) {
        const t2 = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"];
        let i2, n2 = false, r2 = false, o2 = false;
        function s2(t3) {
          "running" === e10.state ? a2(false) : $v() || uy() ? "suspended" === e10.state && (a2(true), t3 && e10.resume().then(c2, c2)) : "closed" !== e10.state && (a2(true), t3 && e10.resume().then(c2, c2));
        }
        function a2(e11) {
          if (n2 !== e11) {
            n2 = e11;
            for (let i3 = 0, n3 = t2; i3 < n3.length; i3 += 1) {
              const t3 = n3[i3];
              e11 ? window.addEventListener(t3, d2, { capture: true, passive: true }) : window.removeEventListener(t3, d2, { capture: true, passive: true });
            }
          }
        }
        function c2() {
          s2(false);
        }
        function d2() {
          s2(true);
        }
        function l2(e11) {
          if (!o2) if (i2.paused) if (e11) {
            let t3;
            u2(false), o2 = true;
            try {
              t3 = i2.play(), t3 ? t3.then(h2, h2) : (i2.addEventListener("playing", h2), i2.addEventListener("abort", h2), i2.addEventListener("error", h2));
            } catch (e12) {
              h2();
            }
          } else u2(true);
          else u2(false);
        }
        function u2(e11) {
          if (r2 !== e11) {
            r2 = e11;
            for (let i3 = 0, n3 = t2; i3 < n3.length; i3++) {
              const t3 = n3[i3];
              e11 ? window.addEventListener(t3, p2, { capture: true, passive: true }) : window.removeEventListener(t3, p2, { capture: true, passive: true });
            }
          }
        }
        function h2() {
          i2.removeEventListener("playing", h2), i2.removeEventListener("abort", h2), i2.removeEventListener("error", h2), o2 = false, l2(false);
        }
        function p2() {
          l2(true);
        }
        if ($v()) {
          const t3 = e10.createMediaStreamDestination(), n3 = document.createElement("div");
          n3.innerHTML = "<audio x-webkit-airplay='deny'></audio>", i2 = n3.children.item(0), i2.controls = false, i2.disableRemotePlayback = true, i2.preload = "auto", i2.srcObject = t3.stream, l2(true);
        }
        qL.on(tL.STATE_CHANGE, function() {
          s2(true);
        }), s2(false);
      }(YL);
    }(), !YL) throw new Cy(Ry.NOT_SUPPORTED, "can not create audio context");
    return YL;
  }
  return YL;
}
function JL(e9) {
  if (function() {
    if (null !== XL) return XL;
    const e10 = zL(), t3 = e10.createBufferSource(), i3 = e10.createGain(), n2 = e10.createGain();
    t3.connect(i3), t3.connect(n2), t3.disconnect(i3);
    let r2 = false;
    try {
      t3.disconnect(i3);
    } catch (e11) {
      r2 = true;
    }
    return t3.disconnect(), XL = r2, r2;
  }()) return;
  const t2 = e9.connect, i2 = e9.disconnect;
  e9.connect = (i3, n2, r2) => {
    var o2;
    return e9._inputNodes || (e9._inputNodes = []), Dn(o2 = e9._inputNodes).call(o2, i3) || (i3 instanceof AudioNode ? (e9._inputNodes.push(i3), t2.call(e9, i3, n2, r2)) : t2.call(e9, i3, n2)), e9;
  }, e9.disconnect = (n2, r2, o2) => {
    i2.call(e9), n2 ? nA(e9._inputNodes, n2) : e9._inputNodes = [];
    for (const i3 of e9._inputNodes) t2.call(e9, i3);
  };
}
var XL = null;
function QL(e9, t2) {
  let i2 = false;
  const n2 = 1 / t2;
  if (XA("DISABLE_WEBAUDIO")) {
    const t3 = window.setInterval(() => {
      i2 ? window.clearInterval(t3) : e9(performance.now() / 1e3);
    }, 1e3 * n2);
  } else {
    const t3 = zL();
    let r2 = t3.createGain();
    r2.gain.value = 0, r2.connect(t3.destination);
    const o2 = () => {
      if (i2) return void (r2 = null);
      const s2 = t3.createOscillator();
      s2.onended = o2, s2.connect(r2), s2.start(0), s2.stop(t3.currentTime + n2), e9(t3.currentTime);
    };
    o2();
  }
  return () => {
    i2 = true;
  };
}
var ZL = class {
  constructor() {
    BL(this, "context", void 0), BL(this, "analyserNode", void 0), BL(this, "sourceNode", void 0), this.context = zL(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4;
  }
  updateSource(e9) {
    if (e9 !== this.sourceNode) {
      if (this.sourceNode) try {
        this.sourceNode.disconnect(this.analyserNode);
      } catch (e10) {
      }
      this.sourceNode = e9, null == e9 || e9.connect(this.analyserNode);
    }
  }
  getVolumeLevel() {
    if (!this.sourceNode) return 0;
    if (!this.context || $v() || uy() || "running" !== this.context.state && this.context.resume(), !this.analyserNode) return 0;
    const e9 = new Float32Array(this.analyserNode.fftSize);
    if (this.analyserNode.getFloatTimeDomainData) this.analyserNode.getFloatTimeDomainData(e9);
    else {
      const t3 = new Uint8Array(this.analyserNode.fftSize);
      this.analyserNode.getByteTimeDomainData(t3);
      for (let i2 = 0; i2 < e9.length; ++i2) e9[i2] = t3[i2] / 128 - 1;
    }
    const t2 = Jn(e9).call(e9, (e10, t3) => e10 + t3 * t3, 0) / e9.length;
    return Math.max(10 * Math.log10(t2) + 100, 0) / 100;
  }
  getAnalyserNode() {
    return this.analyserNode;
  }
  rebuildAnalyser() {
    try {
      var e9, t2;
      null === (e9 = this.sourceNode) || void 0 === e9 || e9.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4, null === (t2 = this.sourceNode) || void 0 === t2 || t2.connect(this.analyserNode);
    } catch (e10) {
      fb.warning("rebuild analyser node failed.");
    }
  }
  destroy() {
    this.updateSource(void 0);
  }
};
var $L = class extends xy {
  get processSourceNode() {
    return this.sourceNode;
  }
  set processedNode(e9) {
    var t2;
    if (!this.isDestroyed && this._processedNode !== e9) {
      try {
        var i2;
        null === (i2 = this.sourceNode) || void 0 === i2 || i2.disconnect(this.outputNode);
      } catch (e10) {
      }
      null === (t2 = this._processedNode) || void 0 === t2 || t2.disconnect(), this._processedNode = e9, this.connect();
    }
  }
  get processedNode() {
    return this._processedNode;
  }
  constructor() {
    super(), BL(this, "outputNode", void 0), BL(this, "outputTrack", void 0), BL(this, "isPlayed", false), BL(this, "sourceNode", void 0), BL(this, "context", void 0), BL(this, "audioBufferNode", void 0), BL(this, "destNode", void 0), BL(this, "audioOutputLevel", 0), BL(this, "volumeLevelAnalyser", void 0), BL(this, "_processedNode", void 0), BL(this, "playNode", void 0), BL(this, "isDestroyed", false), BL(this, "onNoAudioInput", void 0), BL(this, "isNoAudioInput", false), BL(this, "_noAudioInputCount", 0), this.context = zL(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), JL(this.outputNode), this.volumeLevelAnalyser = new ZL();
  }
  startGetAudioBuffer(e9) {
    this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e9), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = (e10) => {
      this.emit(yL.ON_AUDIO_BUFFER, function(e11) {
        for (let t2 = 0; t2 < e11.outputBuffer.numberOfChannels; t2 += 1) {
          const i2 = e11.outputBuffer.getChannelData(t2);
          for (let e12 = 0; e12 < i2.length; e12 += 1) i2[e12] = 0;
        }
        return e11.inputBuffer;
      }(e10));
    });
  }
  stopGetAudioBuffer() {
    this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);
  }
  createOutputTrack() {
    if (!ZP().webAudioMediaStreamDest) throw new Cy(Ry.NOT_SUPPORTED, "your browser is not support audio processor");
    return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;
  }
  play(e9) {
    "running" !== this.context.state && oA(() => {
      qL.emit("autoplay-failed");
    }), this.isPlayed = true, this.playNode = e9 || this.context.destination, this.outputNode.connect(this.playNode);
  }
  stop() {
    if (this.isPlayed) try {
      this.outputNode.disconnect(this.playNode);
    } catch (e9) {
    }
    this.isPlayed = false;
  }
  getAccurateVolumeLevel() {
    return this.volumeLevelAnalyser.getVolumeLevel();
  }
  async checkHasAudioInput() {
    let e9 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    if (e9 > 5) return this.isNoAudioInput = true, this.onNoAudioInput && this.onNoAudioInput(), false;
    $v() || uy() ? "suspended" === this.context.state && this.context.resume() : "running" !== this.context.state && this.context.resume();
    const t2 = this.volumeLevelAnalyser.getAnalyserNode();
    let i2;
    t2.getFloatTimeDomainData ? (i2 = new Float32Array(t2.fftSize), t2.getFloatTimeDomainData(i2)) : (i2 = new Uint8Array(t2.fftSize), t2.getByteTimeDomainData(i2));
    let n2 = false;
    for (let e10 = 0; e10 < i2.length; e10++) 0 !== i2[e10] && (n2 = true);
    return n2 ? (this.isNoAudioInput = false, true) : (await mA(200), await this.checkHasAudioInput(e9 ? e9 + 1 : 1) && n2);
  }
  getAudioVolume() {
    return this.outputNode.gain.value;
  }
  setVolume(e9) {
    this.outputNode.gain.setValueAtTime(e9, this.context.currentTime);
  }
  destroy() {
    this.disconnect(), this.stop(), this.isDestroyed = true, this.onNoAudioInput = void 0;
  }
  disconnect() {
    var e9, t2;
    null === (e9 = this.processedNode) || void 0 === e9 || e9.disconnect(), null === (t2 = this.sourceNode) || void 0 === t2 || t2.disconnect(), this.outputNode && this.outputNode.disconnect();
  }
  connect() {
    var e9;
    this.processedNode ? null === (e9 = this.processedNode) || void 0 === e9 || e9.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode), this.volumeLevelAnalyser.updateSource(this.outputNode);
  }
};
var ek = class extends $L {
  get isFreeze() {
    return false;
  }
  constructor(e9, t2, i2) {
    var n2;
    if (super(), BL(this, "sourceNode", void 0), BL(this, "track", void 0), BL(this, "clonedTrack", void 0), BL(this, "audioElement", void 0), BL(this, "isCurrentTrackCloned", false), BL(this, "isRemoteTrack", false), BL(this, "originVolumeLevelAnalyser", void 0), BL(this, "rebuildWebAudio", async () => {
      if (fb.debug("ready to rebuild web audio, state:", this.context.state), this.isNoAudioInput && await this.checkHasAudioInput(), !this.isNoAudioInput || this.isDestroyed) return document.body.removeEventListener("click", this.rebuildWebAudio, true), void fb.debug("rebuild web audio success, current volume status", this.getAccurateVolumeLevel());
      this.context.resume().then(() => fb.info("resume success")), fb.debug("rebuild web audio because of ios 12 bugs"), this.disconnect();
      const e10 = this.track;
      this.track = this.track.clone(), this.isCurrentTrackCloned ? e10.stop() : this.isCurrentTrackCloned = true;
      const t3 = new MediaStream([this.track]);
      this.sourceNode = this.context.createMediaStreamSource(t3), JL(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();
      const i3 = this.outputNode.gain.value;
      this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(i3, this.context.currentTime), JL(this.outputNode), this.emit(yL.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t3, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();
    }), "audio" !== e9.kind) throw new Cy(Ry.UNEXPECTED_ERROR);
    this.track = e9;
    const r2 = new MediaStream([this.track]);
    if (this.isRemoteTrack = !!t2, this.sourceNode = this.context.createMediaStreamSource(r2), JL(this.sourceNode), i2) {
      const e10 = i2.clone();
      e10.enabled = true, this.clonedTrack = e10, fb.debug("create an unmuted track ".concat(e10.id, " from the original track ").concat(i2.id, " to get the volume"));
      const t3 = this.context.createMediaStreamSource(new MediaStream([e10]));
      JL(t3), this.originVolumeLevelAnalyser = new ZL(), this.originVolumeLevelAnalyser.updateSource(t3);
    }
    this.connect(), this.audioElement = document.createElement("audio"), this.audioElement.srcObject = r2;
    const o2 = Hv();
    t2 && o2.os === Fv.IOS && Number(null === (n2 = o2.osVersion) || void 0 === n2 ? void 0 : n2.split(".")[0]) < 15 && (qL.on(tL.STATE_CHANGE, () => {
      "suspended" === this.context.state ? document.body.addEventListener("click", this.rebuildWebAudio, true) : "running" === this.context.state && this.rebuildWebAudio();
    }), this.checkHasAudioInput().then((e10) => {
      e10 || document.body.addEventListener("click", this.rebuildWebAudio, true);
    }));
  }
  updateTrack(e9) {
    this.sourceNode.disconnect(), this.track = e9, this.isCurrentTrackCloned = false;
    const t2 = new MediaStream([e9]);
    this.sourceNode = this.context.createMediaStreamSource(t2), JL(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(yL.UPDATE_SOURCE), this.audioElement.srcObject = t2;
  }
  destroy() {
    var e9;
    this.audioElement.srcObject = null, this.audioElement.remove(), qL.off("state-change", this.rebuildWebAudio), null === (e9 = this.originVolumeLevelAnalyser) || void 0 === e9 || e9.destroy(), this.clonedTrack = void 0, super.destroy();
  }
  createMediaStreamSourceNode(e9) {
    return this.context.createMediaStreamSource(new MediaStream([e9]));
  }
  updateOriginTrack(e9) {
    const t2 = e9.clone();
    t2.enabled = true, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t2), fb.debug("create an unmuted track ".concat(t2.id, " from the original track ").concat(e9.id, " to get the volume"));
    const i2 = this.context.createMediaStreamSource(new MediaStream([t2]));
    JL(i2), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(i2);
  }
  getOriginVolumeLevel() {
    return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel();
  }
};
async function tk(e9, t2, i2) {
  const n2 = (e10, t3) => e10 ? "number" != typeof e10 ? e10.max || e10.exact || e10.ideal || e10.min || t3 : e10 : t3, r2 = { audio: !!i2 && { mandatory: { chromeMediaSource: "desktop" } }, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: e9, maxHeight: n2(t2.height, 1080), maxWidth: n2(t2.width, 1920) } } };
  return t2.frameRate && "number" != typeof t2.frameRate ? (r2.video.mandatory.maxFrameRate = t2.frameRate.max, r2.video.mandatory.minFrameRate = t2.frameRate.min) : "number" == typeof t2.frameRate && (r2.video.mandatory.maxFrameRate = t2.frameRate), await navigator.mediaDevices.getUserMedia(r2);
}
async function ik(e9, t2) {
  const i2 = await nk(e9.mediaSource), { sourceId: n2, audio: r2 } = await function(e10) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return new Gh((i3, n3) => {
      const r3 = document.createElement("div");
      r3.innerText = "share screen", r3.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
      const o2 = document.createElement("div");
      o2.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
      const s2 = document.createElement("div");
      s2.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", s2.setAttribute("style", "height: 12%;");
      const a2 = document.createElement("div");
      a2.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
      const c2 = document.createElement("div");
      c2.setAttribute("style", "display: flex; justify-content: space-between; padding: 16px 0;");
      const d2 = document.createElement("button");
      d2.innerHTML = "cancel", d2.setAttribute("style", "width: 85px;"), d2.onclick = () => {
        document.body.removeChild(h2);
        const e11 = new Error("NotAllowedError");
        e11.name = "NotAllowedError", n3(e11);
      };
      let l2 = t3;
      const u2 = document.createElement("div");
      if (t3) {
        const e11 = document.createElement("input");
        e11.setAttribute("type", "checkbox");
        const t4 = document.createElement("span");
        e11.setAttribute("style", "margin-right: 6px;"), t4.innerText = "Share audio", e11.checked = l2, e11.onchange = () => {
          l2 = e11.checked;
        }, u2.appendChild(e11), u2.appendChild(t4);
      }
      c2.appendChild(u2), c2.appendChild(d2), o2.appendChild(s2), o2.appendChild(a2), o2.appendChild(c2);
      const h2 = document.createElement("div");
      h2.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), h2.appendChild(r3), h2.appendChild(o2), document.body.appendChild(h2), e10.map((e11) => {
        if (e11.id) {
          const t4 = document.createElement("div");
          t4.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");
          let n4 = e11.thumbnail;
          try {
            const { width: e12 } = n4.getSize();
            e12 > 1920 && (n4 = n4.resize({ width: 1920 }));
          } catch (e12) {
            throw e12 && e12.message.startsWith("Illegal invocation") && console.error("Operate thumbnail error, please try to set contextIsolation: false. (https://github.com/electron/electron/issues/34953)"), e12;
          }
          t4.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + n4.toDataURL() + ' /></div><span style="	height: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + e11.name.replace(/[\u00A0-\u9999<>\&]/g, function(e12) {
            return "&#" + e12.charCodeAt(0) + ";";
          }) + "</span>", t4.onclick = () => {
            document.body.removeChild(h2), i3({ sourceId: e11.id, audio: l2 });
          }, a2.appendChild(t4);
        }
      });
    });
  }(i2, t2);
  return await tk(n2, e9, r2);
}
async function nk(e9) {
  let t2 = ["window", "screen"];
  "application" !== e9 && "window" !== e9 || (t2 = ["window"]), "screen" === e9 && (t2 = ["screen"]);
  const i2 = Fy();
  if (!i2) throw console.error("failed to fetch electron, please mount it to window"), new Cy(Ry.ELECTRON_IS_NULL);
  let n2 = null;
  try {
    var r2;
    n2 = (null === (r2 = i2.desktopCapturer) || void 0 === r2 ? void 0 : r2.getSources({ types: t2 })) || i2.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES", { types: t2 });
  } catch (e10) {
    n2 = null;
  }
  n2 && n2.then || (n2 = new Gh((e10, n3) => {
    i2.desktopCapturer.getSources({ types: t2 }, (t3, i3) => {
      t3 ? n3(t3) : e10(i3);
    });
  }));
  try {
    return await n2;
  } catch (e10) {
    throw new Cy(Ry.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e10.toString());
  }
}
var rk = new NA("safari");
var ok = false;
var sk = false;
async function ak(e9, t2) {
  let i2 = 0, n2 = null;
  for (; i2 < 2; ) try {
    n2 = await ck(e9, t2, i2 > 0);
    break;
  } catch (e10) {
    if (e10 instanceof Cy) throw fb.error("[".concat(t2, "] ").concat(e10.toString())), e10;
    const n3 = dk(e10.name || e10.code || e10, e10.message);
    if (n3.code === Ry.MEDIA_OPTION_INVALID) {
      fb.debug("[".concat(t2, "] detect media option invalid, retry")), i2 += 1, await mA(500);
      continue;
    }
    throw fb.error("[".concat(t2, "] ").concat(n3.toString())), n3;
  }
  if (!n2) throw new Cy(Ry.UNEXPECTED_ERROR, "can not find stream after getUserMedia");
  return n2;
}
async function ck(e9, t2, i2) {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Cy(Ry.NOT_SUPPORTED, "can not find getUserMedia");
  i2 && (e9.video && (delete e9.video.width, delete e9.video.height), e9.screen && (delete e9.screen.width, delete e9.screen.height));
  const n2 = ZP(), r2 = new MediaStream();
  if (e9.audioSource && r2.addTrack(e9.audioSource), e9.videoSource && r2.addTrack(e9.videoSource), !e9.audio && !e9.video && !e9.screen) return fb.debug("Using Video Source/ Audio Source"), r2;
  if (e9.screen) if (Fy()) e9.screen.sourceId ? lk(r2, await tk(e9.screen.sourceId, e9.screen, e9.screenAudio)) : lk(r2, await ik(e9.screen, e9.screenAudio));
  else if (Jv() && e9.screen.extensionId && e9.screen.mandatory) {
    if (!n2.getStreamFromExtension) throw new Cy(Ry.NOT_SUPPORTED, "This browser does not support screen sharing");
    fb.debug("[".concat(t2, '] Screen access on chrome stable, looking for extension"'));
    const i3 = await (s2 = e9.screen.extensionId, a2 = t2, new Gh((e10, t3) => {
      try {
        chrome.runtime.sendMessage(s2, { getStream: true }, (i4) => {
          if (!i4 || !i4.streamId) return fb.error("[".concat(a2, "] No response from Chrome Plugin. Plugin not installed properly"), i4), void t3(new Cy(Ry.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly"));
          e10(i4.streamId);
        });
      } catch (e11) {
        fb.error("[".concat(a2, "] AgoraRTC screensharing plugin is not accessible(").concat(s2, ")"), e11.toString()), t3(new Cy(Ry.CHROME_PLUGIN_NOT_INSTALL));
      }
    }));
    e9.screen.mandatory.chromeMediaSourceId = i3, lk(r2, await navigator.mediaDevices.getUserMedia({ video: { mandatory: e9.screen.mandatory } }));
  } else if (n2.getDisplayMedia) {
    var o2;
    e9.screen.mediaSource && EL(e9.screen.mediaSource);
    const i3 = { width: e9.screen.width, height: e9.screen.height, frameRate: e9.screen.frameRate, displaySurface: null !== (o2 = e9.screen.displaySurface) && void 0 !== o2 ? o2 : "screen" === e9.screen.mediaSource ? "monitor" : e9.screen.mediaSource }, { selfBrowserSurface: n3, surfaceSwitching: s3, systemAudio: a3 } = e9.screen, c3 = { selfBrowserSurface: n3, surfaceSwitching: s3, systemAudio: a3 };
    !n3 && delete c3.selfBrowserSurface, !s3 && delete c3.surfaceSwitching, !a3 && delete c3.systemAudio, fb.debug("[".concat(t2, "] getDisplayMedia:"), JSON.stringify({ video: i3, audio: !!e9.screenAudio, controls: c3 })), lk(r2, await navigator.mediaDevices.getDisplayMedia(GL({ video: i3, audio: !!e9.screenAudio }, c3)));
  } else {
    if (!Zv()) throw fb.error("[".concat(t2, "] This browser does not support screenSharing")), new Cy(Ry.NOT_SUPPORTED, "This browser does not support screen sharing");
    {
      e9.screen.mediaSource && EL(e9.screen.mediaSource);
      const i3 = { video: { mediaSource: e9.screen.mediaSource, width: e9.screen.width, height: e9.screen.height, frameRate: e9.screen.frameRate } };
      fb.debug("[".concat(t2, "] getUserMedia: ").concat(JSON.stringify(i3))), lk(r2, await navigator.mediaDevices.getUserMedia(i3));
    }
  }
  var s2, a2;
  if (!e9.video && !e9.audio) return r2;
  let c2 = { video: e9.video, audio: e9.audio }, d2 = XA("MEDIA_DEVICE_CONSTRAINTS");
  if (d2) try {
    "string" == typeof d2 && (d2 = JSON.parse(d2)), c2 = vA(c2, d2);
  } catch (e10) {
  }
  fb.debug("[".concat(t2, "] GetUserMedia"), JSON.stringify(c2)), Hv();
  let l2, u2 = null;
  (Xv() || $v() || zv()) && (u2 = await rk.lock());
  try {
    l2 = await navigator.mediaDevices.getUserMedia(c2);
  } catch (e10) {
    throw u2 && u2(), e10;
  }
  return c2.audio && (ok = true), c2.video && (sk = true), lk(r2, l2), u2 && u2(), r2;
}
function dk(e9, t2) {
  switch (e9) {
    case "Starting video failed":
    case "OverconstrainedError":
    case "TrackStartError":
      return new Cy(Ry.MEDIA_OPTION_INVALID, "".concat(e9, ": ").concat(t2));
    case "NotFoundError":
    case "DevicesNotFoundError":
      return new Cy(Ry.DEVICE_NOT_FOUND, "".concat(e9, ": ").concat(t2));
    case "NotSupportedError":
      return new Cy(Ry.NOT_SUPPORTED, "".concat(e9, ": ").concat(t2));
    case "NotReadableError":
      return new Cy(Ry.NOT_READABLE, "".concat(e9, ": ").concat(t2));
    case "InvalidStateError":
    case "NotAllowedError":
    case "PERMISSION_DENIED":
    case "PermissionDeniedError":
      return new Cy(Ry.PERMISSION_DENIED, "".concat(e9, ": ").concat(t2));
    case "ConstraintNotSatisfiedError":
      return new Cy(Ry.CONSTRAINT_NOT_SATISFIED, "".concat(e9, ": ").concat(t2));
    default:
      return fb.error("getUserMedia unexpected error", e9), new Cy(Ry.UNEXPECTED_ERROR, "".concat(e9, ": ").concat(t2));
  }
}
function lk(e9, t2) {
  const i2 = e9.getVideoTracks()[0], n2 = e9.getAudioTracks()[0], r2 = t2.getVideoTracks()[0], o2 = t2.getAudioTracks()[0];
  o2 && (n2 && e9.removeTrack(n2), e9.addTrack(o2)), r2 && (i2 && e9.removeTrack(i2), e9.addTrack(r2));
}
var uk = new class extends xy {
  get state() {
    return this._state;
  }
  set state(e9) {
    e9 !== this._state && (this.emit(kL.STATE_CHANGE, e9), this._state = e9);
  }
  constructor() {
    super(), BL(this, "_state", LL.IDLE), BL(this, "isAccessMicrophonePermission", false), BL(this, "isAccessCameraPermission", false), BL(this, "lastAccessMicrophonePermission", false), BL(this, "lastAccessCameraPermission", false), BL(this, "checkdeviceMatched", false), BL(this, "deviceInfoMap", /* @__PURE__ */ new Map()), this.init().then(() => {
      navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", this.updateDevicesInfo.bind(this)), window.setInterval(() => {
        (XA("ENUMERATE_DEVICES_INTERVAL") || (fy() || Yv() === Fv.HARMONY_OS) && Ey()) && this.updateDevicesInfo();
      }, XA("ENUMERATE_DEVICES_INTERVAL_TIME"));
    }).catch((e9) => fb.error(e9.toString()));
  }
  async enumerateDevices(e9, t2) {
    let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return new Cy(Ry.NOT_SUPPORTED, "enumerateDevices() not supported.").throw();
    const n2 = await navigator.mediaDevices.enumerateDevices(), r2 = this.checkMediaDeviceInfoIsOk(n2);
    let o2 = !this.isAccessMicrophonePermission && e9, s2 = !this.isAccessCameraPermission && t2;
    r2.audio && (o2 = false), r2.video && (s2 = false);
    let a2 = null, c2 = null, d2 = null;
    if (!i2 && (o2 || s2)) {
      if (rk.isLocked && (fb.debug("[device manager] wait GUM lock"), (await rk.lock())(), fb.debug("[device manager] GUM unlock")), ok && (o2 = false, this.isAccessMicrophonePermission = true), sk && (s2 = false, this.isAccessCameraPermission = true), fb.debug("[device manager] check media device permissions", e9, t2, o2, s2), o2 && s2) {
        try {
          d2 = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
        } catch (e10) {
          const t3 = dk(e10.name || e10.code || e10, e10.message);
          if (t3.code === Ry.PERMISSION_DENIED) throw t3;
          fb.warning("getUserMedia failed in getDevices", t3);
        }
        this.isAccessCameraPermission = true, this.isAccessMicrophonePermission = true;
      } else if (o2) {
        try {
          a2 = await navigator.mediaDevices.getUserMedia({ audio: e9 });
        } catch (e10) {
          const t3 = dk(e10.name || e10.code || e10, e10.message);
          if (t3.code === Ry.PERMISSION_DENIED) throw t3;
          fb.warning("getUserMedia failed in getDevices", t3);
        }
        this.isAccessMicrophonePermission = true;
      } else if (s2) {
        try {
          c2 = await navigator.mediaDevices.getUserMedia({ video: t2 });
        } catch (e10) {
          const t3 = dk(e10.name || e10.code || e10, e10.message);
          if (t3.code === Ry.PERMISSION_DENIED) throw t3;
          fb.warning("getUserMedia failed in getDevices", t3);
        }
        this.isAccessCameraPermission = true;
      }
      fb.debug("[device manager] mic permission", e9, "cam permission", t2);
    }
    try {
      const e10 = await navigator.mediaDevices.enumerateDevices();
      return a2 && a2.getTracks().forEach((e11) => e11.stop()), c2 && c2.getTracks().forEach((e11) => e11.stop()), d2 && d2.getTracks().forEach((e11) => e11.stop()), a2 = null, c2 = null, d2 = null, e10;
    } catch (e10) {
      return a2 && a2.getTracks().forEach((e11) => e11.stop()), c2 && c2.getTracks().forEach((e11) => e11.stop()), d2 && d2.getTracks().forEach((e11) => e11.stop()), a2 = null, c2 = null, d2 = null, new Cy(Ry.ENUMERATE_DEVICES_FAILED, e10.toString()).throw();
    }
  }
  async getRecordingDevices() {
    let e9 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    return (await this.enumerateDevices(true, false, e9)).filter((e10) => "audioinput" === e10.kind);
  }
  async getCamerasDevices() {
    let e9 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    return (await this.enumerateDevices(false, true, e9)).filter((e10) => "videoinput" === e10.kind);
  }
  async getSpeakers() {
    let e9 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    return (await this.enumerateDevices(true, false, e9)).filter((e10) => "audiooutput" === e10.kind);
  }
  searchDeviceIdByName(e9) {
    let t2 = null;
    return this.deviceInfoMap.forEach((i2) => {
      i2.device.label === e9 && (t2 = i2.device.deviceId);
    }), t2;
  }
  async getDeviceById(e9) {
    const t2 = (await this.enumerateDevices(true, true, true)).find((t3) => t3.deviceId === e9);
    if (!t2) throw new Cy(Ry.DEVICE_NOT_FOUND, "deviceId: ".concat(e9));
    return t2;
  }
  async init() {
    this.state = LL.INITING;
    try {
      await this.updateDevicesInfo(), this.state = LL.INITEND;
    } catch (e9) {
      throw fb.warning("Device Detection functionality cannot start properly.", e9.toString()), this.state = LL.IDLE, ("boolean" == typeof isSecureContext ? isSecureContext : "https:" === location.protocol || "file:" === location.protocol || "localhost" === location.hostname || "127.0.0.1" === location.hostname || "::1" === location.hostname) || new Cy(Ry.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.").throw(), e9;
    }
  }
  async updateDevicesInfo() {
    const e9 = await this.enumerateDevices(true, true, true), t2 = Date.now(), i2 = [];
    if (e9[0] && e9[0].label && false === this.checkdeviceMatched) {
      this.checkdeviceMatched = true;
      const t3 = e9.find((e10) => "audioinput" === e10.kind && "default" === e10.deviceId), i3 = e9.find((e10) => "audiooutput" === e10.kind && "default" === e10.deviceId);
      t3 && i3 ? i3.groupId === t3.groupId ? fb.debug("[device-check] default input ".concat(t3.label, " and output ").concat(i3.label, " is the same group")) : fb.warning("[device-check] default input ".concat(t3.label, " and output ").concat(i3.label, " is not the same group")) : fb.debug("[device-check] default input or output not found");
    }
    const n2 = this.checkMediaDeviceInfoIsOk(e9);
    if (e9.forEach((e10) => {
      if (!e10.deviceId) return;
      const n3 = this.deviceInfoMap.get("".concat(e10.kind, "_").concat(e10.deviceId));
      if ("ACTIVE" !== (n3 ? n3.state : "INACTIVE")) {
        const n4 = { initAt: t2, updateAt: t2, device: e10, state: "ACTIVE" };
        this.deviceInfoMap.set("".concat(e10.kind, "_").concat(e10.deviceId), n4), i2.push(n4);
      }
      n3 && (n3.updateAt = t2);
    }), this.deviceInfoMap.forEach((e10, n3) => {
      "ACTIVE" === e10.state && e10.updateAt !== t2 && (e10.state = "INACTIVE", i2.push(e10));
    }), this.state !== LL.INITEND) return n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), void (n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true));
    i2.forEach((e10) => {
      switch (e10.device.kind) {
        case "audioinput":
          this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(kL.RECORDING_DEVICE_CHANGED, e10);
          break;
        case "videoinput":
          this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(kL.CAMERA_DEVICE_CHANGED, e10);
          break;
        case "audiooutput":
          this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(kL.PLAYOUT_DEVICE_CHANGED, e10);
      }
    }), n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true);
  }
  checkMediaDeviceInfoIsOk(e9) {
    const t2 = e9.filter((e10) => "audioinput" === e10.kind), i2 = e9.filter((e10) => "videoinput" === e10.kind), n2 = { audio: false, video: false };
    for (const e10 of t2) if (e10.label && e10.deviceId) {
      n2.audio = true;
      break;
    }
    for (const e10 of i2) if (e10.label && e10.deviceId) {
      n2.video = true;
      break;
    }
    return n2;
  }
}();
var hk = false;
var pk = new class extends xy {
  constructor() {
    super(...arguments), BL(this, "onAutoplayFailed", void 0), BL(this, "onAudioAutoplayFailed", void 0);
  }
}();
function _k() {
  if (Hv(), !hk) {
    const e9 = (t2) => {
      t2.preventDefault(), hk = false, my() ? document.body.removeEventListener("click", e9, true) : (document.body.removeEventListener("touchstart", e9, true), document.body.removeEventListener("mousedown", e9, true));
    };
    hk = true, my() ? document.body.addEventListener("click", e9, true) : (document.body.addEventListener("touchstart", e9, true), document.body.addEventListener("mousedown", e9, true)), fb.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"), pk.onAutoplayFailed ? pk.onAutoplayFailed() : pk.onAudioAutoplayFailed ? fb.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .") : fb.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."), pk.emit("autoplay-failed");
  }
}
function Ek(e9, t2, i2, n2) {
  if (!e9) return;
  const r2 = vb.getBaseInfoBySessionId(e9);
  if (!r2) return;
  const o2 = r2.info, s2 = Date.now(), a2 = GL(GL({}, o2), {}, { vid: void 0 === o2.vid ? 0 : Number(o2.vid), lts: s2, elapse: s2 - r2.startTime, cbRegistered: pk.onAutoplayFailed || pk.onAudioAutoplayFailed ? 1 : -1, errorMsg: i2, mediaType: t2, trackId: n2, extend: void 0 });
  vb.send({ type: Rb.AUTOPLAY_FAILED, data: a2 }, true);
}
var fk = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "error"];
var mk = new class {
  constructor() {
    BL(this, "onAutoplayFailed", void 0), BL(this, "elementMap", /* @__PURE__ */ new Map()), BL(this, "elementStateMap", /* @__PURE__ */ new Map()), BL(this, "elementsNeedToResume", []), BL(this, "sinkIdMap", /* @__PURE__ */ new Map()), BL(this, "autoResumeAfterInterruption", (e9) => {
      Array.from(this.elementMap.entries()).forEach((t2) => {
        let [i2, n2] = t2;
        const r2 = this.elementStateMap.get(i2), o2 = n2.srcObject.getAudioTracks()[0], s2 = o2 && o2.readyState;
        if (fb.debug("resume after interrupted, ele: ".concat(r2, " audio: ").concat(s2, " ").concat(e9)), "live" === s2) {
          if (e9) return n2.pause(), void n2.play();
          if ("running" === qL.curState) return cy() ? (n2.pause(), void n2.play()) : void (r2 && "paused" === r2 && n2.play());
        }
      });
    }), BL(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
      Array.from(this.elementMap.entries()).forEach((e9) => {
        let [t2, i2] = e9;
        const n2 = i2.srcObject.getAudioTracks()[0];
        n2 && "live" === n2.readyState && (fb.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"), i2.pause(), i2.play());
      });
    }), this.autoResumeAudioElement(), qL.on(tL.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), qL.on(tL.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), qL.on(tL.STATE_CHANGE, () => {
      $v() && "suspended" === qL.prevState && "running" === qL.curState && this.autoResumeAfterInterruption();
    });
  }
  async setSinkID(e9, t2) {
    const i2 = this.elementMap.get(e9);
    if (this.sinkIdMap.set(e9, t2), i2) try {
      await i2.setSinkId(t2);
    } catch (e10) {
      throw new Cy(Ry.PERMISSION_DENIED, "can not set sink id: " + e10.toString());
    }
  }
  play(e9, t2, i2, n2) {
    if (this.elementMap.has(t2)) return;
    const r2 = document.createElement("audio");
    r2.autoplay = true, r2.srcObject = new MediaStream([e9]), this.bindAudioElementEvents(t2, r2), this.elementMap.set(t2, r2), this.elementStateMap.set(t2, ML.INIT), this.setVolume(t2, i2);
    const o2 = this.sinkIdMap.get(t2);
    if (o2) try {
      r2.setSinkId(o2).catch((e10) => {
        fb.warning("[".concat(t2, "] set sink id failed"), e10.toString());
      });
    } catch (e10) {
      fb.warning("[".concat(t2, "] set sink id failed"), e10.toString());
    }
    const s2 = r2.play();
    s2 && s2.then && s2.catch((e10) => {
      n2 && Ek(n2, "audio", e10.message, t2), fb.warning("audio element play warning", e10.toString()), this.elementMap.has(t2) && "NotAllowedError" === e10.name && (fb.warning("detected audio element autoplay failed"), this.elementsNeedToResume.push(r2), oA(() => {
        this.onAutoplayFailed && this.onAutoplayFailed(), _k();
      }));
    });
  }
  updateTrack(e9, t2) {
    const i2 = this.elementMap.get(e9);
    i2 && (i2.srcObject = new MediaStream([t2]));
  }
  isPlaying(e9) {
    return this.elementMap.has(e9) && "playing" === this.elementStateMap.get(e9);
  }
  setVolume(e9, t2) {
    const i2 = this.elementMap.get(e9);
    i2 && (t2 = Math.max(0, Math.min(100, t2)), i2.volume = t2 / 100);
  }
  stop(e9) {
    const t2 = this.elementMap.get(e9);
    if (this.sinkIdMap.delete(e9), !t2) return;
    const i2 = this.elementsNeedToResume.indexOf(t2);
    this.elementsNeedToResume.splice(i2, 1), t2.srcObject = null, t2.remove(), this.elementMap.delete(e9), this.elementStateMap.delete(e9);
  }
  bindAudioElementEvents(e9, t2) {
    fk.forEach((i2) => {
      t2.addEventListener(i2, (i3) => {
        const n2 = this.elementStateMap.get(e9), r2 = "pause" === i3.type ? "paused" : i3.type;
        if (fb.debug("[".concat(e9, "] audio-element-status change ").concat(n2, " => ").concat(r2)), "error" === i3.type) {
          const i4 = null == t2 ? void 0 : t2.error;
          i4 && fb.error("[".concat(e9, "] media error, code: ").concat(i4.code, ", message: ").concat(i4.message));
        }
        this.elementStateMap.set(e9, r2);
      });
    });
  }
  getPlayerState(e9) {
    return this.elementStateMap.get(e9) || "uninit";
  }
  autoResumeAudioElement() {
    const e9 = () => {
      this.elementsNeedToResume.forEach((e10) => {
        e10.play().then((e11) => {
          fb.debug("Auto resume audio element success");
        }).catch((e11) => {
          fb.warning("Auto resume audio element failed!", e11);
        });
      }), this.elementsNeedToResume = [];
    };
    new Gh((e10) => {
      document.body ? e10() : window.addEventListener("load", () => e10());
    }).then(() => {
      my() ? document.body.addEventListener("click", e9, true) : (document.body.addEventListener("touchstart", e9, true), document.body.addEventListener("mousedown", e9, true));
    });
  }
}();
function Tk() {
  return function(e9, t2, i2) {
    const n2 = i2.value;
    return "function" == typeof n2 && (i2.value = function() {
      this._isClosed && new Cy(Ry.INVALID_OPERATION, "[".concat(this.getTrackId(), "] cannot operate a closed track")).print("warning", fb);
      for (var e10 = arguments.length, t3 = new Array(e10), i3 = 0; i3 < e10; i3++) t3[i3] = arguments[i3];
      const r2 = n2.apply(this, t3);
      return r2 instanceof Gh ? new Gh((e11, t4) => {
        r2.then(e11).catch(t4);
      }) : r2;
    }), i2;
  };
}
var Sk = class extends xy {
  constructor(e9) {
    super(), BL(this, "name", "VideoProcessorDestination"), BL(this, "ID", "0"), BL(this, "_source", void 0), BL(this, "videoContext", void 0), BL(this, "inputTrack", void 0), this.videoContext = e9;
  }
  get kind() {
    return "video";
  }
  get enabled() {
    return true;
  }
  pipe() {
    throw new Cy(Ry.NOT_SUPPORTED, "VideoProcessor cannot pipe to any other Processor");
  }
  unpipe() {
    throw new Cy(Ry.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor");
  }
  enable() {
  }
  disable() {
  }
  updateInput(e9) {
    if (e9.context !== this.videoContext) throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).");
    e9.track && e9.track !== this.inputTrack && (this.videoContext.chained = true, this.inputTrack = e9.track, this.emit(DL.ON_TRACK, e9.track));
  }
  reset() {
    this.inputTrack = void 0, this.videoContext.chained = false, this.emit(DL.ON_TRACK, void 0);
  }
};
var gk = class extends xy {
  set chained(e9) {
    this._chained = e9;
  }
  get chained() {
    return this._chained;
  }
  constructor(e9, t2) {
    super(), BL(this, "constraintsMap", /* @__PURE__ */ new Map()), BL(this, "statsRegistry", []), BL(this, "usageRegistry", []), BL(this, "trackId", void 0), BL(this, "direction", void 0), BL(this, "_chained", false), this.trackId = e9, this.direction = t2;
  }
  async getConstraints() {
    return await Zy(this, PL.REQUEST_CONSTRAINTS);
  }
  async requestApplyConstraints(e9, t2) {
    var i2;
    return fb.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e9 && this.constraintsMap.set(t2, e9), $y(this, PL.REQUEST_UPDATE_CONSTRAINTS, Array.from(_N(i2 = this.constraintsMap).call(i2)));
  }
  async requestRevertConstraints(e9) {
    var t2;
    if (this.constraintsMap.has(e9)) return fb.info("processor ".concat(e9.name, " requestRevertConstraints for ").concat(this.trackId)), this.constraintsMap.delete(e9), $y(this, PL.REQUEST_UPDATE_CONSTRAINTS, Array.from(_N(t2 = this.constraintsMap).call(t2)));
  }
  registerStats(e9, t2, i2) {
    this.statsRegistry.find((i3) => i3.processorID === e9.ID && i3.processorName === e9.name && i3.type === t2) || this.statsRegistry.push({ processorName: e9.name, processorID: e9.ID, type: t2, cb: i2 });
  }
  unregisterStats(e9, t2) {
    const i2 = this.statsRegistry.findIndex((i3) => i3.processorID === e9.ID && i3.processorName === e9.name && i3.type === t2);
    -1 !== i2 && this.statsRegistry.splice(i2, 1);
  }
  gatherStats() {
    const e9 = [];
    for (const { processorID: t2, processorName: i2, type: n2, cb: r2 } of this.statsRegistry) try {
      const o2 = r2();
      e9.push({ processorID: t2, processorName: i2, type: n2, stats: o2 });
    } catch (e10) {
      fb.error(new Cy(Ry.UNEXPECTED_ERROR, e10.message));
    }
    return e9;
  }
  registerUsage(e9, t2) {
    this.usageRegistry.find((t3) => t3.processorID === e9.ID && t3.processorName === e9.name) || this.usageRegistry.push({ processorID: e9.ID, processorName: e9.name, cb: t2 });
  }
  unregisterUsage(e9) {
    const t2 = this.usageRegistry.findIndex((t3) => t3.processorID === e9.ID && t3.processorName === e9.name);
    -1 !== t2 && this.usageRegistry.splice(t2, 1);
  }
  async gatherUsage() {
    const e9 = [];
    if (!this.chained) return [];
    for (const { cb: t2 } of this.usageRegistry) try {
      let i2 = t2();
      i2 instanceof Gh && (i2 = await i2), e9.push(GL(GL({}, i2), {}, { direction: this.direction }));
    } catch (e10) {
      fb.error("gather extension usage error", e10);
    }
    return e9;
  }
  getDirection() {
    return this.direction;
  }
};
var Rk = class extends xy {
  constructor(e9) {
    super(), BL(this, "name", "AudioProcessorDestination"), BL(this, "ID", "0"), BL(this, "inputTrack", void 0), BL(this, "inputNode", void 0), BL(this, "audioProcessorContext", void 0), BL(this, "_source", void 0), this.audioProcessorContext = e9;
  }
  get kind() {
    return "audio";
  }
  get enabled() {
    return true;
  }
  pipe() {
    throw new Cy(Ry.NOT_SUPPORTED, "AudioProcessorDestination cannot pipe to any other Processor");
  }
  unpipe() {
    throw new Cy(Ry.NOT_SUPPORTED, "AudioProcessor cannot unpipe to any other Processor");
  }
  enable() {
  }
  disable() {
  }
  reset() {
    this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = false, this.emit(DL.ON_TRACK, void 0), this.emit(DL.ON_NODE, void 0);
  }
  updateInput(e9) {
    if (e9.context !== this.audioProcessorContext) throw new Error("ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).");
    e9.track && this.inputTrack !== e9.track && (this.audioProcessorContext.chained = true, this.inputTrack = e9.track, this.emit(DL.ON_TRACK, this.inputTrack)), e9.node && this.inputNode !== e9.node && (this.audioProcessorContext.chained = true, this.inputNode = e9.node, this.emit(DL.ON_NODE, this.inputNode));
  }
};
var Ck = class extends xy {
  set chained(e9) {
    this._chained = e9;
  }
  get chained() {
    return this._chained;
  }
  constructor(e9, t2, i2) {
    super(), BL(this, "constraintsMap", /* @__PURE__ */ new Map()), BL(this, "statsRegistry", []), BL(this, "audioContext", void 0), BL(this, "trackId", void 0), BL(this, "direction", void 0), BL(this, "usageRegistry", []), BL(this, "_chained", false), this.audioContext = e9, this.trackId = t2, this.direction = i2;
  }
  async getConstraints() {
    return Zy(this, PL.REQUEST_CONSTRAINTS);
  }
  getAudioContext() {
    return this.audioContext;
  }
  async requestApplyConstraints(e9, t2) {
    var i2;
    return fb.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e9 && this.constraintsMap.set(t2, e9), $y(this, PL.REQUEST_UPDATE_CONSTRAINTS, Array.from(_N(i2 = this.constraintsMap).call(i2)));
  }
  async requestRevertConstraints(e9) {
    var t2;
    if (this.constraintsMap.has(e9)) return this.constraintsMap.delete(e9), $y(this, PL.REQUEST_UPDATE_CONSTRAINTS, Array.from(_N(t2 = this.constraintsMap).call(t2)));
  }
  registerStats(e9, t2, i2) {
    this.statsRegistry.find((i3) => i3.processorID === e9.ID && i3.processorName === e9.name && i3.type === t2) || this.statsRegistry.push({ processorName: e9.name, processorID: e9.ID, type: t2, cb: i2 });
  }
  unregisterStats(e9, t2) {
    const i2 = this.statsRegistry.findIndex((i3) => i3.processorID === e9.ID && i3.processorName === e9.name && i3.type === t2);
    -1 !== i2 && this.statsRegistry.splice(i2, 1);
  }
  gatherStats() {
    const e9 = [];
    for (const { processorID: t2, processorName: i2, type: n2, cb: r2 } of this.statsRegistry) try {
      const o2 = r2();
      e9.push({ processorID: t2, processorName: i2, type: n2, stats: o2 });
    } catch (e10) {
      fb.error(new Cy(Ry.UNEXPECTED_ERROR, e10.message));
    }
    return e9;
  }
  registerUsage(e9, t2) {
    this.usageRegistry.find((t3) => t3.processorID === e9.ID && t3.processorName === e9.name) || this.usageRegistry.push({ processorID: e9.ID, processorName: e9.name, cb: t2 });
  }
  unregisterUsage(e9) {
    const t2 = this.usageRegistry.findIndex((t3) => t3.processorID === e9.ID && t3.processorName === e9.name);
    -1 !== t2 && this.usageRegistry.splice(t2, 1);
  }
  async gatherUsage() {
    const e9 = [];
    if (!this.chained) return [];
    for (const { cb: t2 } of this.usageRegistry) try {
      let i2 = t2();
      i2 instanceof Gh && (i2 = await i2), e9.push(GL(GL({}, i2), {}, { direction: this.direction }));
    } catch (e10) {
      fb.error("gather extension usage error", e10);
    }
    return e9;
  }
  getDirection() {
    return this.direction;
  }
};
var Ik = class extends xy {
  get isPlayed() {
    return true;
  }
  get isFreeze() {
    return false;
  }
  constructor() {
    super(), BL(this, "context", void 0), BL(this, "processSourceNode", void 0), BL(this, "outputTrack", void 0), BL(this, "processedNode", void 0), BL(this, "clonedTrack", void 0), BL(this, "outputNode", void 0), this.outputNode = new vk();
  }
  setVolume() {
  }
  createOutputTrack() {
    throw new Cy(Ry.NOT_SUPPORTED, "can not create output MediaStreamTrack when WebAudio disabled");
  }
  getOriginVolumeLevel() {
    return 0;
  }
  getAccurateVolumeLevel() {
    return 0;
  }
  stopGetAudioBuffer() {
  }
  startGetAudioBuffer() {
  }
  play() {
  }
  stop() {
  }
  destroy() {
  }
  updateTrack() {
  }
  updateOriginTrack() {
  }
  createMediaStreamSourceNode() {
  }
};
var vk = class {
  disconnect() {
  }
  connect() {
  }
};
function yk(e9) {
  return new Gh((t2, i2) => {
    let n2 = false;
    const r2 = document.createElement("video");
    r2.setAttribute("autoplay", ""), r2.setAttribute("muted", ""), r2.muted = true, r2.autoplay = true, r2.setAttribute("playsinline", ""), r2.setAttribute("style", "position: fixed; top: 0; left: 0; width: 1px; height: 1px"), document.body.appendChild(r2);
    const o2 = $v() ? "canplay" : "playing";
    r2.addEventListener(o2, () => {
      const e10 = r2.videoWidth, i3 = r2.videoHeight;
      !e10 && Zv() || (n2 = true, r2.srcObject = null, r2.remove(), t2([e10, i3]));
    }), r2.srcObject = new MediaStream([e9]), r2.play().catch(gA), setTimeout(() => {
      n2 || (r2.srcObject = null, r2.remove(), t2([r2.videoWidth, r2.videoHeight]));
    }, 4e3);
  });
}
function Ak(e9) {
  const t2 = {};
  e9.facingMode && (t2.facingMode = e9.facingMode), e9.cameraId && (t2.deviceId = { exact: e9.cameraId });
  const i2 = dL(e9.encoderConfig);
  return null != i2.width && (t2.width = i2.width), null != i2.height && (t2.height = i2.height), !py() && i2.frameRate && (t2.frameRate = i2.frameRate), Qv() && "object" == typeof t2.frameRate && (t2.frameRate.max = 60), Zv() && (t2.frameRate = { ideal: 30, max: 30 }), t2;
}
function bk(e9) {
  const t2 = {};
  if (py() || (void 0 !== e9.AGC && (t2.autoGainControl = e9.AGC), void 0 !== e9.AEC && (t2.echoCancellation = e9.AEC), void 0 !== e9.ANS && (t2.noiseSuppression = e9.ANS, Jv() && e9.ANS && (t2.googHighpassFilter = e9.ANS))), e9.encoderConfig) {
    const i2 = pL(e9.encoderConfig);
    t2.channelCount = i2.stereo ? 2 : 1, t2.sampleRate = i2.sampleRate, t2.sampleSize = i2.sampleSize;
  }
  return e9.microphoneId && (t2.deviceId = { exact: e9.microphoneId }), fy() && (t2.sampleRate = void 0), t2;
}
var wk = (e9) => {
  const t2 = e9._encoderConfig;
  if (!t2) return;
  const { frameRate: i2, width: n2, height: r2 } = e9.getMediaStreamTrackSettings();
  let { frameRate: o2 = i2, width: s2 = n2, height: a2 = r2 } = t2;
  if (!o2 || !s2 || !a2) return;
  s2 = AA(s2), a2 = AA(a2), o2 = AA(o2);
  const { max: c2, min: d2 } = function(e10, t3, i3) {
    const n3 = 200 * Math.pow(i3 / 15, 0.6) * Math.pow(e10 * t3 / 640 / 360, 0.75);
    return { min: Math.floor(n3), max: Math.floor(4 * n3) };
  }(s2, a2, o2), { bitrateMax: l2, bitrateMin: u2 } = t2 || {};
  l2 || fb.debug("calculate bitrate: [w: ".concat(s2, ", h: ").concat(a2, ", fps: ").concat(o2, "] => [brMax: ").concat(l2, ", brMin: ").concat(u2, "]"));
  const { maxFramerate: h2 } = XA("ENCODER_CONFIG_LIMIT");
  return h2 && "number" == typeof h2 && (o2 = Math.min(o2, h2)), { frameRate: o2, bitrateMax: l2 || c2, bitrateMin: u2 || d2, scaleResolutionDownBy: 1, scale: 0 };
};
var Ok = async (e9, t2, i2) => await (async (e10, t3, i3) => {
  const n2 = function(e11) {
    const t4 = [];
    for (let i4 = 0; i4 < e11.length; i4 += 2) t4.push(parseInt(e11.slice(i4, i4 + 2), 16));
    return Uint8Array.from(t4);
  }(bA("" + t3 + i3)).slice(0, 16), r2 = n2.slice(0, 12), o2 = await window.crypto.subtle.importKey("raw", n2, "AES-GCM", true, ["encrypt"]);
  return new Uint8Array(await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: r2 }, o2, e10));
})(e9.buffer, t2, i2);
var Nk = (e9) => {
  const t2 = document.createElement("canvas");
  return t2.width = 2, t2.height = 2, new Gh((i2, n2) => {
    t2.toBlob(async (e10) => {
      if (t2.remove(), e10) {
        const n3 = await Dk(e10);
        i2({ buffer: n3, width: t2.width, height: t2.height });
      } else n2(new Cy(Ry.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
    }, e9, 1);
  });
};
var Dk = async (e9) => {
  const t2 = await e9.arrayBuffer();
  return new Uint8Array(t2);
};
var Pk;
var Lk;
var kk;
var Mk;
var Uk;
var xk;
var Vk;
var Fk;
var Bk;
var jk;
var Gk;
var Wk;
var Hk;
var Kk;
var Yk;
var qk;
var zk;
var Jk;
var Xk;
var Qk;
var Zk;
var $k;
var eM;
var tM;
var iM;
var nM;
var rM;
var oM;
var sM;
var aM;
var cM;
var dM;
var lM;
var uM;
var hM;
var pM;
var _M;
var EM;
var fM;
var mM;
var TM = (Pk = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2], throttleTime: 300 }), Lk = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2] }), kk = Tk(), Mk = DA("LocalAudioTrack", "_enabledMutex"), Uk = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2] }), xk = Tk(), Vk = DA("LocalAudioTrack", "_enabledMutex"), Fk = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2] }), Bk = Tk(), jk = Tk(), Gk = Tk(), Wk = Ib({ argsMap: (e9) => [e9.getTrackId()] }), Hk = Tk(), Kk = Ib({ argsMap: (e9) => [e9.getTrackId()] }), Yk = Tk(), qk = Ib({ argsMap: (e9) => [e9.getTrackId()] }), zk = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2.name] }), Jk = Ib({ argsMap: (e9) => [e9.getTrackId()] }), FL((Xk = class extends HL {
  get _source() {
    return this.initWebAudio();
  }
  set _source(e9) {
    this._trackSource = e9;
  }
  get processorContext() {
    return this._processorContext || (this._processorContext = this.initProcessor().processorContext), this._processorContext;
  }
  get processorDestination() {
    return this._processorDestination || (this._processorDestination = this.initProcessor().processorDestination), this._processorDestination;
  }
  get isPlaying() {
    return this._useAudioElement ? mk.isPlaying(this.getTrackId()) : this._source.isPlayed;
  }
  get __className__() {
    return "LocalAudioTrack";
  }
  constructor(e9, t2, i2, n2) {
    super(e9, i2), BL(this, "trackMediaType", vL.AUDIO), BL(this, "_encoderConfig", void 0), BL(this, "_trackSource", void 0), BL(this, "_enabled", true), BL(this, "_volume", 100), BL(this, "_useAudioElement", true), BL(this, "_bypassWebAudio", false), BL(this, "processor", void 0), BL(this, "_processorContext", void 0), BL(this, "_processorDestination", void 0), BL(this, "_getOriginVolumeLevel", void 0), this._encoderConfig = t2, this._getOriginVolumeLevel = !!n2, this._trackSource = new Ik(), XA("DISABLE_WEBAUDIO") && (this._bypassWebAudio = true), XA("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false), Xv() && !YL ? setTimeout(() => this.initWebAudio()) : this.initWebAudio();
  }
  setVolume(e9) {
    yy(e9, "volume", 0, 1e3), this._volume = e9, this._source.setVolume(e9 / 100), this._useAudioElement && mk.setVolume(this.getTrackId(), e9);
    try {
      if (this._bypassWebAudio) return void fb.debug("[".concat(this.getTrackId(), "] setVolume returned because no pass through WebAudio."));
      const e10 = this._source.createOutputTrack();
      this._mediaStreamTrack !== e10 && (this._mediaStreamTrack = e10, $y(this, fL.NEED_REPLACE_TRACK, this).then(() => {
        fb.debug("[".concat(this.getTrackId(), "] replace web audio track success"));
      }).catch((e11) => {
        fb.warning("[".concat(this.getTrackId(), "] replace web audio track failed"), e11);
      }));
    } catch (e10) {
    }
  }
  getVolumeLevel() {
    return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel();
  }
  async setPlaybackDevice(e9) {
    if (!this._useAudioElement || !$P()) throw new Cy(Ry.NOT_SUPPORTED, "your browser does not support setting the audio output device");
    await mk.setSinkID(this.getTrackId(), e9);
  }
  async setEnabled(e9, t2, i2) {
    return this._setEnabled(e9, t2, i2);
  }
  async _setEnabled(e9, t2, i2) {
    if (!i2) {
      if (e9 === this._enabled) return;
      this.stateCheck("enabled", e9);
    }
    if (fb.info("[".concat(this.getTrackId(), "] start setEnabled"), e9), e9) {
      this._originMediaStreamTrack.enabled = true;
      try {
        i2 || (this._enabled = true), await $y(this, fL.NEED_ENABLE_TRACK, this), fb.info("[".concat(this.getTrackId(), "] setEnabled to ").concat(e9, " success"));
      } catch (e10) {
        throw i2 || (this._enabled = false), fb.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e10.toString()), e10;
      }
    } else {
      this._originMediaStreamTrack.enabled = false, i2 || (this._enabled = false);
      try {
        await $y(this, fL.NEED_DISABLE_TRACK, this);
      } catch (e10) {
        throw i2 || (this._enabled = true), fb.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e10.toString()), e10;
      }
    }
  }
  async setMuted(e9) {
    e9 !== this._muted && (this.stateCheck("muted", e9), this._muted = e9, this._originMediaStreamTrack.enabled = !e9, fb.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e9)), e9 ? await $y(this, fL.NEED_MUTE_TRACK, this) : await $y(this, fL.NEED_UNMUTE_TRACK, this));
  }
  getStats() {
    dA(() => {
      fb.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");
    }, "localAudioTrackGetStatsWarning");
    return eA(this, fL.GET_STATS) || GL({}, AL);
  }
  setAudioFrameCallback(e9) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
    if (!e9) return this._source.removeAllListeners(yL.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
    this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(yL.ON_AUDIO_BUFFER), this._source.on(yL.ON_AUDIO_BUFFER, (t3) => e9(t3));
  }
  play() {
    fb.debug("[".concat(this.getTrackId(), "] start audio playback")), this._useAudioElement ? (fb.debug("[".concat(this.getTrackId(), "] start audio playback in element")), mk.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();
  }
  stop() {
    fb.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._useAudioElement ? mk.stop(this.getTrackId()) : this._source.stop();
  }
  close() {
    super.close(), this._processorDestination && this.unbindProcessorDestinationEvents(this._processorDestination), this._processorContext && this.unbindProcessorContextEvents(this._processorContext), this.unpipe(), this._processorDestination && this._processorDestination._source && this._processorDestination._source.unpipe(), this._source.destroy();
  }
  _updatePlayerSource() {
    let e9 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    fb.debug("[".concat(this.getTrackId(), "] update player source track")), e9 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && mk.updateTrack(this.getTrackId(), this._mediaStreamTrack);
  }
  async _updateOriginMediaStreamTrack(e9, t2) {
    this._originMediaStreamTrack !== e9 && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop()), e9.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e9, this._muted && (this._originMediaStreamTrack.enabled = false), this.processor && this._processorContext && this.processor.updateInput({ track: e9, context: this._processorContext }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await $y(this, fL.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e9));
  }
  renewMediaStreamTrack(e9) {
    return Gh.resolve(void 0);
  }
  pipe(e9) {
    if (this._bypassWebAudio) throw new Cy(Ry.INVALID_OPERATION, "Can not process AudioTrack when bypassWebAudio set to true.");
    if (this.processor === e9) return e9;
    if (e9._source) throw new Cy(Ry.INVALID_OPERATION, "Processor ".concat(e9.name, " already piped, please call unpipe beforehand."));
    return this.unpipe(), this.processor = e9, this.processor._source = this, e9.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e9;
  }
  unpipe() {
    var e9;
    if (!this.processor) return;
    const t2 = this.processor;
    null === (e9 = this._source.processSourceNode) || void 0 === e9 || e9.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
  }
  bindProcessorDestinationEvents(e9) {
    e9.on(DL.ON_TRACK, async (e10) => {
      e10 ? e10 !== this._mediaStreamTrack && (this._mediaStreamTrack = e10, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e10), await $y(this, fL.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await $y(this, fL.NEED_REPLACE_TRACK, this));
    }), e9.on(DL.ON_NODE, (e10) => {
      this._source.processedNode = e10;
    });
  }
  unbindProcessorDestinationEvents(e9) {
    e9.removeAllListeners(DL.ON_TRACK), e9.removeAllListeners(DL.ON_NODE);
  }
  bindProcessorContextEvents(e9) {
    e9.on(PL.REQUEST_CONSTRAINTS, async (e10) => {
      e10(this._originMediaStreamTrack.getSettings());
    });
  }
  unbindProcessorContextEvents(e9) {
    e9.removeAllListeners(PL.REQUEST_CONSTRAINTS);
  }
  initWebAudio() {
    return this._trackSource instanceof Ik && (this._trackSource = new ek(this._mediaStreamTrack, false, this._getOriginVolumeLevel ? this._mediaStreamTrack : void 0)), this._trackSource;
  }
  initProcessor() {
    const e9 = new Ck(this._source.context, this.getTrackId(), "local"), t2 = new Rk(e9);
    return this._processorContext = e9, this._processorDestination = t2, this.bindProcessorContextEvents(e9), this.bindProcessorDestinationEvents(t2), this._source.on(yL.UPDATE_SOURCE, () => {
      this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: e9 });
    }), this._useAudioElement && (this._useAudioElement = false, this.isPlaying && (mk.stop(this.getTrackId()), this._source.play()), $y(this, fL.NEED_REPLACE_MIXING_TRACK, this).then(() => {
      fb.debug("[".concat(this.getTrackId(), "] replace from origin track to web audio track success"));
    }).catch((e10) => {
      fb.warning("[".concat(this.getTrackId(), "] replace from origin track to web audio track failed"), e10);
    })), { processorContext: e9, processorDestination: t2 };
  }
}).prototype, "setVolume", [Pk], Object.getOwnPropertyDescriptor(Xk.prototype, "setVolume"), Xk.prototype), FL(Xk.prototype, "setPlaybackDevice", [Lk, kk], Object.getOwnPropertyDescriptor(Xk.prototype, "setPlaybackDevice"), Xk.prototype), FL(Xk.prototype, "setEnabled", [Mk, Uk, xk], Object.getOwnPropertyDescriptor(Xk.prototype, "setEnabled"), Xk.prototype), FL(Xk.prototype, "setMuted", [Vk, Fk, Bk], Object.getOwnPropertyDescriptor(Xk.prototype, "setMuted"), Xk.prototype), FL(Xk.prototype, "getStats", [jk], Object.getOwnPropertyDescriptor(Xk.prototype, "getStats"), Xk.prototype), FL(Xk.prototype, "setAudioFrameCallback", [Gk], Object.getOwnPropertyDescriptor(Xk.prototype, "setAudioFrameCallback"), Xk.prototype), FL(Xk.prototype, "play", [Wk, Hk], Object.getOwnPropertyDescriptor(Xk.prototype, "play"), Xk.prototype), FL(Xk.prototype, "stop", [Kk, Yk], Object.getOwnPropertyDescriptor(Xk.prototype, "stop"), Xk.prototype), FL(Xk.prototype, "close", [qk], Object.getOwnPropertyDescriptor(Xk.prototype, "close"), Xk.prototype), FL(Xk.prototype, "pipe", [zk], Object.getOwnPropertyDescriptor(Xk.prototype, "pipe"), Xk.prototype), FL(Xk.prototype, "unpipe", [Jk], Object.getOwnPropertyDescriptor(Xk.prototype, "unpipe"), Xk.prototype), Xk);
var SM = (Qk = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2] }), Zk = Tk(), $k = DA("MicrophoneAudioTrack", "_enabledMutex"), eM = Ib({ argsMap: (e9, t2, i2) => [e9.getTrackId(), t2, i2] }), tM = Tk(), iM = Ib({ argsMap: (e9) => [e9.getTrackId()] }), FL((nM = class extends TM {
  get __className__() {
    return "MicrophoneAudioTrack";
  }
  constructor(e9, t2, i2, n2) {
    super(e9, t2.encoderConfig ? pL(t2.encoderConfig) : {}, n2, XA("GET_VOLUME_OF_MUTED_AUDIO_TRACK")), BL(this, "_config", void 0), BL(this, "_deviceName", "default"), BL(this, "_constraints", void 0), BL(this, "_originalConstraints", void 0), BL(this, "_enabled", true), this._config = t2, this._constraints = i2, this._originalConstraints = i2, this._deviceName = e9.label, "boolean" == typeof t2.bypassWebAudio && (this._bypassWebAudio = t2.bypassWebAudio), (cy() || dy()) && qL.bindInterruptDetectorTrack(this);
  }
  async setDevice(e9) {
    if (fb.info("[".concat(this.getTrackId(), "] start set device to ").concat(e9)), this._enabled) try {
      const t2 = await uk.getDeviceById(e9), i2 = {};
      i2.audio = GL({}, this._constraints), i2.audio.deviceId = { exact: e9 }, this._originMediaStreamTrack.stop();
      let n2 = null;
      try {
        n2 = await ak(i2, this.getTrackId());
      } catch (e10) {
        throw fb.error("[".concat(this.getTrackId(), "] setDevice failed"), e10.toString()), n2 = await ak({ audio: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), e10;
      }
      await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), this._deviceName = t2.label, this._config.microphoneId = e9, this._constraints.deviceId = { exact: e9 };
    } catch (e10) {
      throw fb.error("[".concat(this.getTrackId(), "] setDevice error"), e10.toString()), e10;
    }
    else try {
      const t2 = await uk.getDeviceById(e9);
      this._deviceName = t2.label, this._config.microphoneId = e9, this._constraints.deviceId = { exact: e9 };
    } catch (e10) {
      throw fb.error("[".concat(this.getTrackId(), "] setDevice error"), e10.toString()), e10;
    }
    fb.info("[".concat(this.getTrackId(), "] set device to ").concat(e9, " success"));
  }
  async setEnabled(e9, t2, i2) {
    if (t2) return fb.debug("[".concat(this.getTrackId(), "] setEnabled false (do not close microphone)")), await super._setEnabled(e9);
    if (!i2) {
      if (e9 === this._enabled) return;
      this.stateCheck("enabled", e9);
    }
    if (fb.info("[".concat(this.getTrackId(), "] start setEnabled"), e9), XA("AUTO_RESET_AUDIO_ROUTE") && ($v() || uy())) {
      const t3 = navigator.audioSession;
      t3 && (e9 || (t3.type = "playback"), t3.type = "auto");
    }
    if (!e9) {
      var n2;
      this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (n2 = this._source.clonedTrack) || void 0 === n2 || n2.stop(), i2 || (this._enabled = false);
      try {
        await $y(this, fL.NEED_DISABLE_TRACK, this);
      } catch (e10) {
        throw fb.error("[".concat(this.getTrackId(), "] setEnabled false failed"), e10.toString()), e10;
      }
      return;
    }
    const r2 = GL({}, this._constraints), o2 = uk.searchDeviceIdByName(this._deviceName);
    o2 && !r2.deviceId && (r2.deviceId = o2);
    try {
      i2 || (this._enabled = true);
      const e10 = await ak({ audio: this._constraints }, this.getTrackId());
      await this._updateOriginMediaStreamTrack(e10.getAudioTracks()[0], false), await $y(this, fL.NEED_ENABLE_TRACK, this);
    } catch (e10) {
      throw i2 || (this._enabled = false), fb.error("[".concat(this.getTrackId(), "] setEnabled true failed"), e10.toString()), e10;
    }
    fb.info("[".concat(this.getTrackId(), "] setEnabled success"));
  }
  close() {
    super.close(), (cy() || dy()) && qL.unbindInterruptDetectorTrack(this);
  }
  onTrackEnded() {
    if (($v() || uy()) && this._enabled && !this._isClosed && qL.duringInterruption) {
      const e9 = async () => {
        qL.off(tL.IOS_INTERRUPTION_END, e9), this._enabled && !this._isClosed && (fb.debug("[".concat(this.getTrackId(), "] try capture microphone media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
      };
      qL.on(tL.IOS_INTERRUPTION_END, e9);
    } else fb.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(CL.TRACK_ENDED);
  }
  async renewMediaStreamTrack(e9) {
    const t2 = e9 || this._constraints, i2 = uk.searchDeviceIdByName(this._deviceName);
    if (i2 && !t2.deviceId && (t2.deviceId = i2), this._constraints = t2, this._enabled) {
      this._originMediaStreamTrack.stop();
      const e10 = await ak({ audio: this._constraints }, this.getTrackId());
      await this._updateOriginMediaStreamTrack(e10.getAudioTracks()[0], true);
    }
  }
  bindProcessorContextEvents(e9) {
    super.bindProcessorContextEvents(e9), e9.on(PL.REQUEST_UPDATE_CONSTRAINTS, async (e10, t2, i2) => {
      try {
        const i3 = Object.assign({}, this._originalConstraints, ...e10);
        await this.renewMediaStreamTrack(i3), t2();
      } catch (e11) {
        i2(e11);
      }
    });
  }
  unbindProcessorContextEvents(e9) {
    super.unbindProcessorContextEvents(e9), e9.removeAllListeners(PL.REQUEST_UPDATE_CONSTRAINTS);
  }
}).prototype, "setDevice", [Qk, Zk], Object.getOwnPropertyDescriptor(nM.prototype, "setDevice"), nM.prototype), FL(nM.prototype, "setEnabled", [$k, eM, tM], Object.getOwnPropertyDescriptor(nM.prototype, "setEnabled"), nM.prototype), FL(nM.prototype, "close", [iM], Object.getOwnPropertyDescriptor(nM.prototype, "close"), nM.prototype), nM);
var gM = (rM = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2, e9.duration] }), oM = Tk(), sM = Ib({ argsMap: (e9) => [e9.getTrackId()] }), aM = Tk(), cM = Ib({ argsMap: (e9) => [e9.getTrackId()] }), dM = Tk(), lM = Ib({ argsMap: (e9) => [e9.getTrackId()] }), uM = Tk(), hM = Ib({ argsMap: (e9) => [e9.getTrackId()] }), pM = Tk(), _M = Ib({ argsMap: (e9) => [e9.getTrackId()] }), EM = Ib({ argsMap: (e9) => [e9.getTrackId()] }), fM = Tk(), FL((mM = class extends TM {
  get __className__() {
    return "BufferSourceAudioTrack";
  }
  constructor(e9, t2, i2, n2) {
    super(t2.createOutputTrack(), i2, n2), BL(this, "source", void 0), BL(this, "_bufferSource", void 0), this._useAudioElement = false, this.source = e9, this._bufferSource = t2, this._bufferSource.on(yL.AUDIO_SOURCE_STATE_CHANGE, (e10) => {
      this.safeEmit(CL.SOURCE_STATE_CHANGE, e10);
    });
    try {
      this._mediaStreamTrack = this._source.createOutputTrack();
    } catch (e10) {
    }
  }
  get currentState() {
    return this._bufferSource.currentState;
  }
  get duration() {
    return this._bufferSource.duration;
  }
  get playbackSpeed() {
    return this._bufferSource.playbackSpeed;
  }
  getCurrentTime() {
    return this._bufferSource.currentTime;
  }
  startProcessAudioBuffer(e9) {
    e9 && this._bufferSource.updateOptions(e9), this._bufferSource.startProcessAudioBuffer();
  }
  pauseProcessAudioBuffer() {
    this._bufferSource.pauseProcessAudioBuffer();
  }
  seekAudioBuffer(e9) {
    this._bufferSource.seekAudioBuffer(e9);
  }
  resumeProcessAudioBuffer() {
    this._bufferSource.resumeProcessAudioBuffer();
  }
  stopProcessAudioBuffer() {
    this._bufferSource.stopProcessAudioBuffer();
  }
  close() {
    this.source = null, this._bufferSource.destroy(), super.close();
  }
  setAudioBufferPlaybackSpeed(e9) {
    yy(e9, "speed", 0), this._bufferSource.setAudioBufferPlaybackSpeed(e9);
  }
}).prototype, "startProcessAudioBuffer", [rM, oM], Object.getOwnPropertyDescriptor(mM.prototype, "startProcessAudioBuffer"), mM.prototype), FL(mM.prototype, "pauseProcessAudioBuffer", [sM, aM], Object.getOwnPropertyDescriptor(mM.prototype, "pauseProcessAudioBuffer"), mM.prototype), FL(mM.prototype, "seekAudioBuffer", [cM, dM], Object.getOwnPropertyDescriptor(mM.prototype, "seekAudioBuffer"), mM.prototype), FL(mM.prototype, "resumeProcessAudioBuffer", [lM, uM], Object.getOwnPropertyDescriptor(mM.prototype, "resumeProcessAudioBuffer"), mM.prototype), FL(mM.prototype, "stopProcessAudioBuffer", [hM, pM], Object.getOwnPropertyDescriptor(mM.prototype, "stopProcessAudioBuffer"), mM.prototype), FL(mM.prototype, "close", [_M], Object.getOwnPropertyDescriptor(mM.prototype, "close"), mM.prototype), FL(mM.prototype, "setAudioBufferPlaybackSpeed", [EM, fM], Object.getOwnPropertyDescriptor(mM.prototype, "setAudioBufferPlaybackSpeed"), mM.prototype), mM);
var RM = class _RM extends TM {
  get __className__() {
    return "MixingAudioTrack";
  }
  get isActive() {
    for (const e9 of this.trackList) if (e9._enabled && !e9._isClosed && !e9.muted) return true;
    return false;
  }
  constructor() {
    const e9 = zL().createMediaStreamDestination();
    super(e9.stream.getAudioTracks()[0], void 0, TA(8, "track-mix-")), BL(this, "trackList", void 0), BL(this, "destNode", void 0), this._useAudioElement = false;
    try {
      this._mediaStreamTrack = this._source.createOutputTrack();
    } catch (e10) {
    }
    this.destNode = e9, this.trackList = [];
  }
  hasAudioTrack(e9) {
    return -1 !== this.trackList.indexOf(e9);
  }
  addAudioTrack(e9) {
    -1 === this.trackList.indexOf(e9) ? (fb.debug("add ".concat(e9.getTrackId(), " to mixing track")), e9._source.outputNode.connect(this.destNode), this.trackList.push(e9), this.updateEncoderConfig()) : fb.debug("track ".concat(e9.getTrackId(), " is already added"));
  }
  removeAudioTrack(e9) {
    if (-1 !== this.trackList.indexOf(e9)) {
      fb.debug("remove ".concat(e9.getTrackId(), " from mixing track"));
      try {
        e9._source.outputNode.disconnect(this.destNode);
      } catch (e10) {
      }
      nA(this.trackList, e9), this.updateEncoderConfig();
    }
  }
  updateEncoderConfig() {
    const e9 = {};
    this.trackList.forEach((t2) => {
      t2._encoderConfig && ((t2._encoderConfig.bitrate || 0) > (e9.bitrate || 0) && (e9.bitrate = t2._encoderConfig.bitrate), (t2._encoderConfig.sampleRate || 0) > (e9.sampleRate || 0) && (e9.sampleRate = t2._encoderConfig.sampleRate), (t2._encoderConfig.sampleSize || 0) > (e9.sampleSize || 0) && (e9.sampleSize = t2._encoderConfig.sampleSize), t2._encoderConfig.stereo && (e9.stereo = true));
    }), this._encoderConfig = e9;
  }
  _updateRtpTransceiver(e9) {
    this._rtpTransceiver !== e9 && (this._rtpTransceiver = e9, this.trackList.forEach((t2) => {
      t2 instanceof _RM ? t2.emit(RL.TRANSCEIVER_UPDATED, e9) : t2._updateRtpTransceiver(e9);
    }));
  }
};
var CM = class extends $L {
  set currentState(e9) {
    e9 !== this._currentState && (this._currentState = e9, this.safeEmit(yL.AUDIO_SOURCE_STATE_CHANGE, this._currentState));
  }
  get currentState() {
    return this._currentState;
  }
  constructor(e9) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    super(), BL(this, "audioBuffer", void 0), BL(this, "sourceNode", void 0), BL(this, "startPlayTime", 0), BL(this, "startPlayOffset", 0), BL(this, "pausePlayTime", 0), BL(this, "options", void 0), BL(this, "currentLoopCount", 0), BL(this, "currentPlaybackSpeed", 100), BL(this, "_currentState", "stopped"), this.audioBuffer = e9, this.options = t2, this.startPlayOffset = this.options.startPlayTime || 0;
  }
  createWebAudioDiagram() {
    return this.context.createGain();
  }
  get duration() {
    return this.audioBuffer ? this.audioBuffer.duration : 0;
  }
  get playbackSpeed() {
    return this.currentPlaybackSpeed;
  }
  get currentTime() {
    return this.audioBuffer ? "stopped" === this.currentState ? 0 : "paused" === this.currentState ? this.pausePlayTime : ((this.context.currentTime - this.startPlayTime) * (this.playbackSpeed / 100) + this.startPlayOffset) % this.audioBuffer.duration : 0;
  }
  updateOptions(e9) {
    "stopped" === this.currentState ? (this.options = e9, this.startPlayOffset = this.options.startPlayTime || 0) : fb.warning("can not set audio source options");
  }
  startProcessAudioBuffer() {
    this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = "playing";
  }
  pauseProcessAudioBuffer() {
    this.sourceNode && "playing" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = "paused");
  }
  seekAudioBuffer(e9) {
    this.sourceNode && (this.sourceNode.onended = null, "playing" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), "playing" === this.currentState ? (this.startPlayOffset = e9, this.startSourceNode()) : "paused" === this.currentState && (this.pausePlayTime = e9));
  }
  resumeProcessAudioBuffer() {
    "paused" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = "playing");
  }
  stopProcessAudioBuffer() {
    if (this.sourceNode) {
      this.sourceNode.onended = null;
      try {
        this.sourceNode.stop();
      } catch (e9) {
      }
      this.reset();
    }
  }
  destroy() {
    this.audioBuffer = null, super.destroy();
  }
  setAudioBufferPlaybackSpeed(e9) {
    this.sourceNode && ("playing" === this.currentState && (this.startPlayOffset = this.currentTime, this.startPlayTime = this.context.currentTime), this.sourceNode.playbackRate.value = e9 / 100), this.currentPlaybackSpeed = e9;
  }
  startSourceNode() {
    this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));
  }
  createSourceNode() {
    const e9 = this.context.createBufferSource();
    return e9.buffer = this.audioBuffer, e9.loop = !!this.options.loop, e9.connect(this.outputNode), e9.playbackRate.value = this.currentPlaybackSpeed / 100, e9;
  }
  handleSourceNodeEnded() {
    if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount) return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();
    this.reset();
  }
  reset() {
    this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = "stopped", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;
  }
};
var IM = /* @__PURE__ */ new Map();
var vM = class {
  get rendFrameRate() {
    if (this.renderStats && this.renderStats.curTs !== this.renderStats.lastTs) {
      const e9 = this.renderStats.curTs - this.renderStats.lastTs, t2 = (this.renderStats.renderNum - this.renderStats.lastRenderNum) / e9;
      return this.renderStats.lastRenderNum = this.renderStats.renderNum, this.renderStats.lastTs = this.renderStats.curTs, t2;
    }
    return 0;
  }
  get videoElementStatus() {
    return this._videoElementStatus;
  }
  set videoElementStatus(e9) {
    e9 !== this._videoElementStatus && (fb.debug("[".concat(this.trackId, "] video-element-status change ").concat(this._videoElementStatus, " => ").concat(e9)), this._videoElementStatus = e9);
  }
  get videoState() {
    return this._videoState;
  }
  set videoState(e9) {
    var t2;
    e9 !== this._videoState && (this._videoState = e9, null === (t2 = this.onVideoStateChanged) || void 0 === t2 || t2.call(this, this.videoState));
  }
  constructor(e9) {
    BL(this, "trackId", void 0), BL(this, "config", void 0), BL(this, "onFirstVideoFrameDecoded", void 0), BL(this, "onVideoStateChanged", void 0), BL(this, "freezeTimeCounterList", []), BL(this, "renderFreezeAccTime", 0), BL(this, "isKeepLastFrame", false), BL(this, "timeUpdatedCount", 0), BL(this, "freezeTime", 0), BL(this, "playbackTime", 0), BL(this, "lastTimeUpdatedTime", 0), BL(this, "autoplayFailed", false), BL(this, "videoTrack", void 0), BL(this, "videoElement", void 0), BL(this, "cacheVideoElement", void 0), BL(this, "renderStats", void 0), BL(this, "_videoState", UL.VideoStateStopped), BL(this, "videoElementCheckInterval", void 0), BL(this, "videoElementFreezeTimeout", void 0), BL(this, "_videoElementStatus", ML.NONE), BL(this, "isGettingVideoDimensions", false), BL(this, "startGetVideoDimensions", () => {
      const e10 = () => {
        if (this.isGettingVideoDimensions = true, this.videoElement.videoWidth * this.videoElement.videoHeight > 4) return fb.debug("[".concat(this.trackId, "] current video dimensions:"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = false);
        setTimeout(e10, 500);
      };
      !this.isGettingVideoDimensions && e10();
    }), BL(this, "autoResumeAfterInterruption", () => {
      this.videoTrack && "live" === this.videoTrack.readyState && "running" === qL.curState && (fb.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(qv())), ly() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
    }), BL(this, "handleVideoEvents", (e10) => {
      switch (e10.type) {
        case "play":
        case "playing":
          this.startGetVideoDimensions(), this.videoElementStatus = ML.PLAYING;
          break;
        case "loadeddata":
          if (this.videoState = UL.VideoStateStarting, this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded(), this.cacheVideoElement) {
            try {
              this.cacheVideoElement.srcObject = null, this.cacheVideoElement.remove();
            } catch (e11) {
            }
            this.cacheVideoElement = void 0;
          }
          break;
        case "canplay":
          this.videoElementStatus = ML.CANPLAY;
          break;
        case "stalled":
          this.videoElementStatus = ML.STALLED;
          break;
        case "suspend":
          this.videoElementStatus = ML.SUSPEND;
          break;
        case "pause":
          this.videoElementStatus = ML.PAUSED, $v() || uy() || Xv() && this.autoplayFailed || !this.videoTrack || "live" !== this.videoTrack.readyState || (fb.debug("[track-".concat(this.trackId, "] video element paused, auto resume")), this.videoElement.play());
          break;
        case "waiting":
          this.videoElementStatus = ML.WAITING;
          break;
        case "abort":
          this.videoElementStatus = ML.ABORT;
          break;
        case "ended":
          this.videoElementStatus = ML.ENDED;
          break;
        case "emptied":
          this.videoElementStatus = ML.EMPTIED;
          break;
        case "error": {
          const e11 = this.videoElement.error, t2 = e11 ? "".concat(e11.message, " (").concat(e11.code, ")") : "";
          e11 && (this.videoElementStatus = ML.ERROR), fb.error("[".concat(this.trackId, "] media error: ").concat(t2, " "));
          break;
        }
        case "timeupdate": {
          const e11 = performance.now();
          if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10) return void (this.lastTimeUpdatedTime = e11);
          const t2 = e11 - this.lastTimeUpdatedTime, i2 = this.lastTimeUpdatedTime;
          if (this.lastTimeUpdatedTime = e11, yU.lastVisibleTime < yU.lastHiddenTime || i2 < yU.lastHiddenTime || i2 < yU.lastVisibleTime) return;
          for (t2 > XA("VIDEO_FREEZE_DURATION") && (this.freezeTime += t2), this.playbackTime += t2; this.playbackTime >= 6e3; ) {
            this.playbackTime -= 6e3;
            const e12 = Math.min(6e3, this.freezeTime);
            this.freezeTimeCounterList.push(e12), this.freezeTime = Math.max(0, this.freezeTime - 6e3);
          }
          break;
        }
      }
    }), BL(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
      this.videoTrack && "live" === this.videoTrack.readyState && (fb.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(qv())), ly() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
    }), this.trackId = e9.trackId, this.config = e9, e9.element instanceof HTMLVideoElement ? this.videoElement = e9.element : this.videoElement = document.createElement("video"), qL.on(tL.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), qL.on(tL.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16);
  }
  getVideoElement() {
    return this.videoElement;
  }
  getContainerElement() {
    var e9;
    return null !== (e9 = this.videoElement.parentElement) && void 0 !== e9 ? e9 : void 0;
  }
  updateConfig(e9) {
    this.config = e9, this.trackId = e9.trackId, e9.element !== this.videoElement && (this.destroy(), this.videoElement = e9.element), this.videoTrack && this.initVideoElement();
  }
  updateVideoTrack(e9) {
    this.videoTrack !== e9 && (this.videoTrack = e9, this.initVideoElement());
  }
  play(e9) {
    const t2 = this.videoElement.play();
    t2 && t2.catch && t2.catch((t3) => {
      e9 && Ek(e9, "video", t3.message, this.trackId), "NotAllowedError" === t3.name ? (fb.warning("detected video element autoplay failed", t3), this.autoplayFailed = true, this.handleAutoPlayFailed()) : fb.warning("[".concat(this.trackId, "] play warning: "), t3);
    });
    const i2 = Hv();
    if (("Safari" === i2.name && 15 === Number(i2.version) || cy()) && t2 && t2.then) {
      const e10 = () => {
        this.config.mirror && (this.videoElement.style.transform = "rotateY(180deg)");
      };
      t2.then(e10).catch(e10);
    }
  }
  getCurrentFrame() {
    const e9 = document.createElement("canvas");
    e9.width = this.videoElement.videoWidth, e9.height = this.videoElement.videoHeight;
    const t2 = e9.getContext("2d");
    if (!t2) return fb.error("create canvas context failed!"), new ImageData(2, 2);
    t2.drawImage(this.videoElement, 0, 0, e9.width, e9.height);
    const i2 = t2.getImageData(0, 0, e9.width, e9.height);
    return e9.remove(), i2;
  }
  async getCurrentFrameToUint8Array(e9) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    const i2 = document.createElement("canvas");
    i2.width = this.videoElement.videoWidth, i2.height = this.videoElement.videoHeight;
    const n2 = i2.getContext("2d");
    return n2 ? (n2.drawImage(this.videoElement, 0, 0, i2.width, i2.height), new Gh((n3, r2) => {
      i2.toBlob(async (e10) => {
        if (i2.remove(), e10) {
          const t3 = await Dk(e10);
          n3({ buffer: t3, width: i2.width, height: i2.height });
        } else r2(new Cy(Ry.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
      }, e9, t2 < 0 ? 0.1 : t2 > 1 ? 1 : t2);
    })) : await Nk(e9);
  }
  destroy() {
    this.renderStats = void 0, qL.off(tL.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), qL.off(tL.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), this.videoElement.srcObject = null, this.resetVideoElement(), this.freezeTimeCounterList = [], this.videoState = UL.VideoStateStopped;
  }
  initVideoElement() {
    if (this.videoElementStatus = ML.INIT, !this.videoElementCheckInterval && (yM.forEach((e10) => {
      this.videoElement.addEventListener(e10, this.handleVideoEvents);
    }), this.videoElementCheckInterval = window.setInterval(() => {
      (function(e10) {
        return e10 !== document.body && document.body.contains(e10);
      })(this.videoElement) || (this.videoElementStatus = ML.DESTROYED);
    }, 1e3), XA("ENABLE_VIDEO_FRAME_CALLBACK"))) {
      var e9, t2;
      let i3;
      const n3 = () => {
        "visible" === document.visibilityState && (document.removeEventListener("visibilitychange", n3), this.videoElementFreezeTimeout = window.setTimeout(r2, XA("VIDEO_FREEZE_DURATION")));
      }, r2 = () => {
        this.videoElementFreezeTimeout = void 0, this.videoState === UL.VideoStateDecoding && ("visible" === document.visibilityState ? this.videoState = UL.VideoStateFrozen : document.addEventListener("visibilitychange", n3));
      }, o2 = (e10, t3) => {
        if (this.videoElementStatus === ML.PLAYING) {
          if (this.renderStats ? (this.renderStats.renderNum++, this.renderStats.curTs = t3.mediaTime) : this.renderStats = { lastTs: t3.mediaTime, curTs: t3.mediaTime, lastRenderNum: 0, renderNum: 0 }, i3) {
            const e11 = t3.presentationTime - i3.presentationTime;
            this.videoState === UL.VideoStateStarting && (this.videoState = UL.VideoStateDecoding), this.videoState === UL.VideoStateDecoding && this.onVideoStateChanged && (this.videoElementFreezeTimeout && window.clearTimeout(this.videoElementFreezeTimeout), this.videoElementFreezeTimeout = window.setTimeout(r2, XA("VIDEO_FREEZE_DURATION"))), e11 < XA("VIDEO_FREEZE_DURATION") && this.videoState === UL.VideoStateFrozen && (this.videoState = UL.VideoStateDecoding), e11 > XA("VIDEO_FREEZE_DURATION") && yU.lastVisibleTime >= yU.lastHiddenTime && i3.timestamp > yU.lastVisibleTime && i3.timestamp > yU.lastHiddenTime && (this.renderFreezeAccTime += e11);
          }
          i3 = GL(GL({}, t3), {}, { timestamp: e10 });
        }
        var n4, s2;
        XA("ENABLE_VIDEO_FRAME_CALLBACK") && (null === (n4 = (s2 = this.videoElement).requestVideoFrameCallback) || void 0 === n4 || n4.call(s2, o2));
      };
      null === (e9 = (t2 = this.videoElement).requestVideoFrameCallback) || void 0 === e9 || e9.call(t2, o2);
    }
    this.videoElement.controls = false, this.videoElement.setAttribute("playsinline", ""), fy() && !XA("HIDE_NO_POSTER") && (this.videoElement.poster = "noposter");
    const i2 = Hv();
    "Safari" === i2.name && 15 === Number(i2.version) || cy() || !this.config.mirror || (this.videoElement.style.transform = "rotateY(180deg)"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", this.videoElement.setAttribute("muted", ""), this.videoElement.muted = true, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream ? this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Zv() && this.videoElement.load()) : (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Zv() && this.videoElement.load());
    const n2 = this.videoElement.play();
    void 0 !== n2 && n2.catch((e10) => {
      fb.debug("[".concat(this.trackId, "] playback interrupted"), e10.toString());
    });
  }
  resetVideoElement() {
    yM.forEach((e9) => {
      this.videoElement && this.videoElement.removeEventListener(e9, this.handleVideoEvents);
    }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0), this.videoElementStatus = ML.NONE;
  }
  handleAutoPlayFailed() {
    const e9 = (t2) => {
      t2.preventDefault(), this.videoElement.play().then(() => {
        fb.debug("[".concat(this.trackId, "] Video element for trackId:").concat(this.trackId, " autoplay resumed."));
      }).catch((e10) => {
        fb.error(e10);
      }), this.autoplayFailed = false, my() ? document.body.removeEventListener("click", e9, true) : (document.body.removeEventListener("touchstart", e9, true), document.body.removeEventListener("mousedown", e9, true));
    };
    my() ? document.body.addEventListener("click", e9, true) : (document.body.addEventListener("touchstart", e9, true), document.body.addEventListener("mousedown", e9, true)), _k();
  }
};
var yM = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "timeupdate", "error"];
var AM = class extends vM {
  constructor(e9) {
    super(e9), BL(this, "container", void 0), BL(this, "slot", void 0), this.slot = e9.element, this.updateConfig(e9);
  }
  updateConfig(e9) {
    this.config = e9, this.trackId = e9.trackId;
    const t2 = e9.element;
    t2 !== this.slot && (this.destroy(), this.slot = t2), this.createElements();
  }
  updateVideoTrack(e9) {
    this.videoTrack !== e9 && (this.videoTrack = e9, this.createElements());
  }
  play(e9) {
    var t2;
    null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) && super.play(e9);
  }
  getCurrentFrame() {
    var e9;
    return null !== (e9 = this.container) && void 0 !== e9 && e9.contains(this.videoElement) ? super.getCurrentFrame() : new ImageData(2, 2);
  }
  async getCurrentFrameToUint8Array(e9) {
    var t2;
    let i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    return null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) ? await super.getCurrentFrameToUint8Array(e9, i2) : await Nk(e9);
  }
  destroy() {
    if (super.destroy(), this.videoElement.remove(), this.videoElement = document.createElement("video"), this.container) {
      try {
        this.container.remove(), this.slot.removeChild(this.container);
      } catch (e9) {
      }
      this.container = void 0;
    }
  }
  createElements() {
    this.container || (this.container = document.createElement("div")), this.container.id = "agora-video-player-".concat(this.trackId), this.container.style.width = "100%", this.container.style.height = "100%", this.container.style.position = "relative", this.container.style.overflow = "hidden", this.videoTrack ? (this.container.style.backgroundColor = "black", XA("KEEP_LAST_FRAME") && this.isKeepLastFrame && this.videoElement.paused && this.resetVideoElement(), this.mountedVideoElement()) : this.unmountedVideoElement(), this.slot.appendChild(this.container);
  }
  mountedVideoElement() {
    var e9;
    !this.container || null !== (e9 = this.container) && void 0 !== e9 && e9.contains(this.videoElement) || this.container.appendChild(this.videoElement), super.initVideoElement(), this.videoElement.id = "video_".concat(this.trackId), this.videoElement.className = "agora_video_player", this.videoElement.style.width = "100%", this.videoElement.style.height = "100%", this.videoElement.style.position = "absolute", this.videoElement.style.left = "0", this.videoElement.style.top = "0";
  }
  unmountedVideoElement() {
    var e9;
    if (null !== (e9 = this.container) && void 0 !== e9 && e9.contains(this.videoElement)) {
      super.resetVideoElement();
      try {
        this.container && this.container.removeChild(this.videoElement);
      } catch (e10) {
      }
      this.videoElement = document.createElement("video");
    }
  }
  resetVideoElement() {
    var e9;
    null !== (e9 = this.container) && void 0 !== e9 && e9.contains(this.videoElement) && (super.resetVideoElement(), this.cacheVideoElement = this.videoElement, this.videoElement = document.createElement("video"));
  }
  getContainerElement() {
    return this.container;
  }
};
var bM;
var wM;
var OM;
var NM;
var DM;
var PM;
var LM;
var kM;
var MM;
var UM;
var xM;
var VM;
var FM;
var BM;
var jM;
var GM;
var WM;
var HM;
var KM;
var YM;
var qM;
var zM;
var JM;
var XM;
var QM;
var ZM;
var $M;
var eU;
var tU;
var iU;
var nU;
var rU;
var oU;
var sU;
var aU = (bM = Ib({ argsMap: (e9, t2, i2) => [e9.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i2] }), wM = Tk(), OM = Ib({ argsMap: (e9) => [e9.getTrackId()] }), NM = DA("LocalVideoTrack", "_enabledMutex"), DM = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2] }), PM = Tk(), LM = DA("LocalVideoTrack", "_enabledMutex"), kM = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2] }), MM = Tk(), UM = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2] }), xM = Tk(), VM = Tk(), FM = Ib({ argsMap: (e9, t2, i2) => [e9.getTrackId(), t2, i2] }), BM = Tk(), jM = Tk(), GM = Tk(), WM = Tk(), HM = Tk(), KM = Tk(), YM = Tk(), qM = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2.name] }), zM = Ib({ argsMap: (e9) => [e9.getTrackId()] }), JM = Ib({ argsMap: (e9) => [e9.getTrackId()] }), XM = Ib({ argsMap: (e9, t2, i2) => [e9.getTrackId(), t2.label, i2] }), QM = class e4 extends HL {
  get videoHeight() {
    if (Xv()) {
      const { height: e9 } = this._mediaStreamTrack.getSettings();
      return this._videoHeight = e9, this._videoHeight;
    }
    return this._videoHeight;
  }
  get videoWidth() {
    if (Xv()) {
      const { width: e9 } = this._mediaStreamTrack.getSettings();
      return this._videoWidth = e9, this._videoWidth;
    }
    return this._videoWidth;
  }
  get isPlaying() {
    return !(!this._player || this._player.videoElementStatus !== ML.PLAYING);
  }
  get processorDestination() {
    return this._processorDestination;
  }
  get processorContext() {
    return this._processorContext;
  }
  set processorContext(e9) {
    this._processorContext = e9;
  }
  get __className__() {
    return "LocalVideoTrack";
  }
  constructor(e9, t2, i2, n2, r2, o2) {
    if (super(e9, r2), BL(this, "trackMediaType", vL.VIDEO), BL(this, "_player", void 0), BL(this, "isUseScaleResolutionDownBy", false), BL(this, "_videoVisibleTimer", null), BL(this, "_previousVideoVisibleStatus", void 0), BL(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), BL(this, "_encoderConfig", void 0), BL(this, "_scalabilityMode", { numSpatialLayers: 1, numTemporalLayers: 1 }), BL(this, "_optimizationMode", void 0), BL(this, "_videoHeight", void 0), BL(this, "_videoWidth", void 0), BL(this, "_forceBitrateLimit", void 0), BL(this, "_enabled", true), BL(this, "_processorDestination", void 0), BL(this, "_processorContext", void 0), Xv()) {
      const { width: t3, height: i3 } = e9.getSettings();
      this._videoWidth = t3, this._videoHeight = i3;
    } else this.updateMediaStreamTrackResolution();
    if (this._encoderConfig = t2, this._scalabilityMode = i2, this._optimizationMode = n2, this._hints = o2 || [], -1 === this._hints.indexOf(mL.SCREEN_TRACK)) this.updateBitrateFromProfile();
    else if (function(e10, t3, i3) {
      const n3 = Hv();
      return !(n3.name !== e10 || !n3.osVersion) && (i3 ? Number(n3.version) >= t3 && Number(n3.version) <= i3 : Number(n3.version) === t3);
    }(Bv.CHROME, 115) && -1 !== Yv().indexOf("Windows")) {
      const t3 = function(e10, t4) {
        if ("VideoFrame" in window && "TransformStream" in window && ZP().supportWebRTCInsertableStream) {
          const i3 = new MediaStreamTrackProcessor(e10), n3 = new MediaStreamTrackGenerator({ kind: "video" });
          let r3, o3, s2 = Date.now();
          const a2 = () => {
            c2 && (clearInterval(c2), c2 = void 0), r3 && (r3.close(), r3 = void 0), e10.stop(), o3 = void 0, n3.removeEventListener("ended", a2);
          };
          let c2 = window.setInterval(() => {
            if (o3 && r3 && Date.now() - s2 > (null != t4 ? t4 : 1e3)) try {
              "live" === n3.readyState ? o3.enqueue(r3.clone()) : a2();
            } catch (e11) {
              a2();
            }
          }, null != t4 ? t4 : 1e3);
          const d2 = new TransformStream({ transform: (e11, t5) => {
            "live" === n3.readyState ? (o3 = t5, s2 = Date.now(), void 0 === r3 ? (r3 = e11, t5.enqueue(e11.clone())) : (t5.enqueue(r3), r3 = e11)) : e11.close();
          } });
          return n3.addEventListener("ended", a2), i3.readable.pipeThrough(d2).pipeTo(n3.writable), n3;
        }
      }(e9);
      t3 && (fb.info("local screen video track begin to inject frame"), this._mediaStreamTrack = t3);
    }
    t2 && -1 !== this._hints.indexOf(mL.CUSTOM_TRACK) && this.setEncoderConfiguration(t2), this._processorContext = new gk(this.getTrackId(), "local"), this._processorDestination = new Sk(this.processorContext), this.bindProcessorDestinationEvents();
  }
  play(e9) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if ("string" == typeof e9) {
      const t3 = document.getElementById(e9);
      t3 ? e9 = t3 : (fb.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e9, '" element, use document.body')), e9 = document.body);
    }
    fb.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e9 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
    const i2 = GL(GL(GL({}, this._getDefaultPlayerConfig()), t2), {}, { trackId: this.getTrackId(), element: e9 });
    this._player ? this._player.updateConfig(i2) : (e9 instanceof HTMLVideoElement ? this._player = new vM(i2) : this._player = new AM(i2), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
      try {
        const e10 = this.getVideoElementVisibleStatus();
        this.safeEmit(CL.VIDEO_ELEMENT_VISIBLE_STATUS, e10);
      } catch (e10) {
      }
    }, XA("CHECK_VIDEO_VISIBLE_INTERVAL"));
  }
  stop() {
    this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, fb.debug("[".concat(this.getTrackId(), "] stop video playback")));
  }
  async setEnabled(e9, t2) {
    if (!t2) {
      if (e9 === this._enabled) return;
      this.stateCheck("enabled", e9);
    }
    if (fb.info("[".concat(this.getTrackId(), "] start setEnabled"), e9), !e9) {
      this._originMediaStreamTrack.enabled = false;
      try {
        await $y(this, fL.NEED_DISABLE_TRACK, this);
      } catch (e10) {
        throw fb.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e10.toString()), e10;
      }
      return t2 || (this._enabled = false), void fb.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
    }
    this._originMediaStreamTrack.enabled = true;
    try {
      await $y(this, fL.NEED_ENABLE_TRACK, this);
    } catch (e10) {
      throw fb.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e10.toString()), e10;
    }
    fb.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
  }
  async setMuted(e9) {
    e9 !== this._muted && (this.stateCheck("muted", e9), this._muted = e9, this._originMediaStreamTrack.enabled = !e9, fb.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e9)), e9 ? await $y(this, fL.NEED_MUTE_TRACK, this) : await $y(this, fL.NEED_UNMUTE_TRACK, this));
  }
  async setEncoderConfiguration(e9, t2) {
    if (!this._enabled) throw new Cy(Ry.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
    if (e9 = dL(e9), this._forceBitrateLimit && (e9.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e9.bitrateMax, e9.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e9.bitrateMin), e9.width || e9.height || e9.frameRate) {
      const t3 = Ak({ encoderConfig: e9 });
      (Xv() || $v() || uy()) && (t3.deviceId = void 0), fb.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e9), JSON.stringify(t3));
      try {
        await this._originMediaStreamTrack.applyConstraints(t3), this.updateMediaStreamTrackResolution();
      } catch (e10) {
        const t4 = new Cy(Ry.UNEXPECTED_ERROR, e10.toString());
        throw fb.error("[".concat(this.getTrackId(), "] applyConstraints error"), t4.toString()), t4;
      }
    }
    this._encoderConfig = e9, -1 === this._hints.indexOf(mL.SCREEN_TRACK) && this.updateBitrateFromProfile();
    try {
      await $y(this, fL.NEED_UPDATE_VIDEO_ENCODER, this);
    } catch (e10) {
      return e10.throw(fb);
    }
  }
  getStats() {
    dA(() => {
      fb.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");
    }, "localVideoTrackGetStatsWarning");
    return eA(this, fL.GET_STATS) || GL({}, bL);
  }
  async setBeautyEffect(e9) {
    fb.error("LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect");
  }
  getCurrentFrameData() {
    return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
  }
  async getCurrentFrameImage(e9) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    return this._player ? this._player.getCurrentFrameToUint8Array(e9, t2) : await Nk(e9);
  }
  async setBitrateLimit(e9) {
    if (fb.debug("[".concat(this.getTrackId(), "] set bitrate limit, ").concat(JSON.stringify(e9))), e9) {
      this._forceBitrateLimit = e9, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e9.max_bitrate ? this._encoderConfig.bitrateMax : e9.max_bitrate : this._encoderConfig.bitrateMax = e9.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e9.min_bitrate);
      try {
        await $y(this, fL.NEED_UPDATE_VIDEO_ENCODER, this);
      } catch (e10) {
        return e10.throw(fb);
      }
    }
  }
  async setOptimizationMode(e9) {
    if ("motion" !== e9 && "detail" !== e9 && "balanced" !== e9) return void fb.error(Ry.INVALID_PARAMS, "optimization mode must be motion, detail or balanced");
    const t2 = this._optimizationMode;
    try {
      this._optimizationMode = e9, await $y(this, fL.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this);
    } catch (e10) {
      throw this._optimizationMode = t2, fb.error("[".concat(this.getTrackId(), "] set optimization mode failed"), e10.toString()), e10;
    }
    fb.info("[".concat(this.getTrackId(), "] set optimization mode success (").concat(e9, ")"));
  }
  setScalabiltyMode(e9) {
    if (1 === e9.numSpatialLayers && 1 !== e9.numTemporalLayers) return fb.error(Ry.INVALID_PARAMS, "scalability mode currently not supported, no SVC."), void (this._scalabilityMode = { numSpatialLayers: 1, numTemporalLayers: 1 });
    this._scalabilityMode = e9, fb.info("[".concat(this.getTrackId(), "] set scalability mode success (").concat(e9, ")"));
  }
  updateMediaStreamTrackResolution() {
    yk(this._originMediaStreamTrack).then((e9) => {
      let [t2, i2] = e9;
      this._videoHeight = i2, this._videoWidth = t2;
    }).catch(gA);
  }
  _updatePlayerSource() {
    this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
  }
  _getDefaultPlayerConfig() {
    return { fit: "contain" };
  }
  async setSenderConfiguration(e9) {
    if (!this._enabled) throw new Cy(Ry.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
    fb.debug("[".concat(this.getTrackId(), "] setSenderConfiguration applyConstraints"), JSON.stringify(e9)), e9 = dL(e9), this._forceBitrateLimit && (e9.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e9.bitrateMax, e9.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e9.bitrateMin), this._encoderConfig = e9, -1 === this._hints.indexOf(mL.SCREEN_TRACK) && this.updateBitrateFromProfile();
    try {
      await $y(this, fL.NEED_UPDATE_VIDEO_ENCODER, this);
    } catch (e10) {
      return e10.throw(fb);
    }
  }
  updateBitrateFromProfile() {
    if (!this._encoderConfig) return;
    const { width: e9, height: t2, frameRate: i2 } = this.getMediaStreamTrackSettings();
    if (!e9 || !t2 || !i2) return;
    const { bitrateMax: n2, bitrateMin: r2 } = this._encoderConfig;
    if (null == r2 || null == n2) {
      const { max: o2, min: s2 } = function(e10, t3, i3, n3, r3) {
        const o3 = XA("BITRATE_ADAPTER_TYPE");
        if ("DEFAULT_BITRATE" === o3) return { min: n3, max: r3 };
        if (void 0 === r3) {
          var s3;
          const a3 = Math.floor(200 * Math.pow(i3 / 15, 0.6) * Math.pow(e10 * t3 / 640 / 360, 0.75));
          r3 = "STANDARD_BITRATE" === o3 ? 4 * a3 : 2 * a3, n3 = null !== (s3 = n3) && void 0 !== s3 ? s3 : a3;
        } else {
          var a2;
          n3 = null !== (a2 = n3) && void 0 !== a2 ? a2 : Math.floor(r3 / 10);
        }
        return { min: n3, max: r3 };
      }(e9, t2, i2, r2, n2);
      this._encoderConfig.bitrateMin = s2, this._encoderConfig.bitrateMax = o2, fb.debug("[".concat(this.getTrackId(), "] update bitrate from profile, [w: ").concat(e9, ", h: ").concat(t2, ", fps: ").concat(i2, "] => [brMax: ").concat(o2, ", brMin: ").concat(s2, "]"));
    }
  }
  getVideoElementVisibleStatus() {
    try {
      var e9, t2;
      const i2 = null == this || null === (e9 = this._player) || void 0 === e9 ? void 0 : e9.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i2 ? void 0 : i2.parentElement }, { element: r2, slot: o2 } = n2;
      if (this.isPlaying && r2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
        const e10 = Ly.checkOneElementVisible(r2), t3 = Object.assign({}, e10);
        if (t3.visible !== this._previousVideoVisibleStatus) {
          this._previousVideoVisibleStatus = t3.visible;
          const e11 = vb.reportApiInvoke(null, { tag: jy.TRACER, name: By.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
          t3.visible ? e11.onSuccess("Video is visible") : e11.onSuccess("Invisible because of ".concat(t3.reason));
        }
        return t3;
      }
      return;
    } catch (e10) {
      throw new Cy(Ry.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e10.message);
    }
  }
  async renewMediaStreamTrack(e9) {
  }
  pipe(e9) {
    if (this.processor === e9) return e9;
    if (e9._source) throw new Cy(Ry.INVALID_OPERATION, "Processor ".concat(e9.name, " already piped, please call unpipe beforehand."));
    return this.unpipe(), this.processor = e9, this.processor._source = this, e9.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e9;
  }
  unpipe() {
    if (!this.processor) return;
    const e9 = this.processor;
    this.processor._source = void 0, this.processor = void 0, e9.reset();
  }
  close() {
    super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();
  }
  clone(t2) {
    let i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n2 = this._encoderConfig;
    t2 && (n2 = GL(GL({}, n2), dL(t2))), n2 = aA(n2);
    const r2 = TA(8, "track-video-cloned-"), o2 = new e4(i2 ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, n2, aA(this._scalabilityMode), this._optimizationMode, r2, aA(this._hints));
    return t2 && n2 && o2.setEncoderConfiguration(n2), fb.debug("clone video track from ".concat(this.getTrackId(), " to ").concat(r2, ", clone ").concat(i2)), o2;
  }
  async replaceTrack(e9, t2) {
    if (!(e9 instanceof MediaStreamTrack)) throw new Cy(Ry.INVALID_PARAMS, "track should be an instance of MediaStreamTrack");
    if ("video" !== e9.kind) throw new Cy(Ry.INVALID_PARAMS, "track should be a video MediaStreamTrack");
    await this._updateOriginMediaStreamTrack(e9, t2, true), this.updateMediaStreamTrackResolution();
  }
  sendSeiData(e9) {
    if (dA(() => {
      vb.reportApiInvoke(null, { name: By.LOCAL_VIDEO_SEND_SEI_DATA, options: [], tag: jy.TRACER }).onSuccess("");
    }, this._mediaStreamTrack.id || this.getTrackId()), !XA("ENABLE_VIDEO_SEI") || !XA("ENABLE_ENCODED_TRANSFORM")) return void fb.warning('To send/receive SEI, please call AgoraRTC.setParameter("ENABLE_VIDEO_SEI", true) before instantiate IAgoraRtcClient');
    if (e9 instanceof Uint8Array == 0) return new Cy(Ry.INVALID_PARAMS, "Invalid argument type, ILocalVideoTrack.sendSeiData() only accept Uint8Array argument.").throw();
    const t2 = this.getRTCRtpTransceiver();
    if (!t2) return void fb.warning("Video track is not published, SEI can not be send");
    const i2 = t2.sender.getParameters();
    if (0 === i2.codecs.length) return;
    const n2 = i2.codecs[0].mimeType.toLocaleLowerCase();
    "video/h264" === n2 ? this.safeEmit("sei-to-send", e9) : fb.warning("SEI is not supported by ".concat(n2));
  }
  bindProcessorDestinationEvents() {
    this.processorDestination.on(DL.ON_TRACK, async (e9) => {
      e9 ? e9 !== this._mediaStreamTrack && (this._mediaStreamTrack = e9, this._updatePlayerSource(), await $y(this, fL.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await $y(this, fL.NEED_REPLACE_TRACK, this));
    });
  }
  unbindProcessorDestinationEvents() {
    this.processorDestination.removeAllListeners(DL.ON_TRACK);
  }
  unbindProcessorContextEvents() {
    this.processorContext.removeAllListeners(PL.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(PL.REQUEST_CONSTRAINTS);
  }
}, FL(QM.prototype, "play", [bM, wM], Object.getOwnPropertyDescriptor(QM.prototype, "play"), QM.prototype), FL(QM.prototype, "stop", [OM], Object.getOwnPropertyDescriptor(QM.prototype, "stop"), QM.prototype), FL(QM.prototype, "setEnabled", [NM, DM, PM], Object.getOwnPropertyDescriptor(QM.prototype, "setEnabled"), QM.prototype), FL(QM.prototype, "setMuted", [LM, kM, MM], Object.getOwnPropertyDescriptor(QM.prototype, "setMuted"), QM.prototype), FL(QM.prototype, "setEncoderConfiguration", [UM, xM], Object.getOwnPropertyDescriptor(QM.prototype, "setEncoderConfiguration"), QM.prototype), FL(QM.prototype, "getStats", [VM], Object.getOwnPropertyDescriptor(QM.prototype, "getStats"), QM.prototype), FL(QM.prototype, "setBeautyEffect", [FM, BM], Object.getOwnPropertyDescriptor(QM.prototype, "setBeautyEffect"), QM.prototype), FL(QM.prototype, "getCurrentFrameData", [jM], Object.getOwnPropertyDescriptor(QM.prototype, "getCurrentFrameData"), QM.prototype), FL(QM.prototype, "getCurrentFrameImage", [GM], Object.getOwnPropertyDescriptor(QM.prototype, "getCurrentFrameImage"), QM.prototype), FL(QM.prototype, "setBitrateLimit", [WM], Object.getOwnPropertyDescriptor(QM.prototype, "setBitrateLimit"), QM.prototype), FL(QM.prototype, "setOptimizationMode", [HM], Object.getOwnPropertyDescriptor(QM.prototype, "setOptimizationMode"), QM.prototype), FL(QM.prototype, "setScalabiltyMode", [KM], Object.getOwnPropertyDescriptor(QM.prototype, "setScalabiltyMode"), QM.prototype), FL(QM.prototype, "updateMediaStreamTrackResolution", [YM], Object.getOwnPropertyDescriptor(QM.prototype, "updateMediaStreamTrackResolution"), QM.prototype), FL(QM.prototype, "pipe", [qM], Object.getOwnPropertyDescriptor(QM.prototype, "pipe"), QM.prototype), FL(QM.prototype, "unpipe", [zM], Object.getOwnPropertyDescriptor(QM.prototype, "unpipe"), QM.prototype), FL(QM.prototype, "close", [JM], Object.getOwnPropertyDescriptor(QM.prototype, "close"), QM.prototype), FL(QM.prototype, "replaceTrack", [XM], Object.getOwnPropertyDescriptor(QM.prototype, "replaceTrack"), QM.prototype), QM);
var cU = (ZM = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2] }), $M = Tk(), eU = DA("CameraVideoTrack", "_enabledMutex"), tU = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2] }), iU = Tk(), nU = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2] }), rU = Tk(), oU = Ib({ argsMap: (e9) => [e9.getTrackId()] }), sU = class e5 extends aU {
  get __className__() {
    return "CameraVideoTrack";
  }
  constructor(e9, t2, i2, n2, r2, o2) {
    super(e9, dL(t2.encoderConfig), n2, r2, o2), BL(this, "_config", void 0), BL(this, "_originalConstraints", void 0), BL(this, "_constraints", void 0), BL(this, "_enabled", true), BL(this, "_deviceName", "default"), BL(this, "tryResumeVideoForIOS15_16WeChat", async () => {
      (cy() || dy()) && !function() {
        const e10 = Hv();
        if (e10.os !== Fv.IOS || !e10.osVersion) return false;
        const t3 = e10.osVersion.split(".");
        return 15 === Number(t3[0]) && Number(t3[1]) >= 2;
      }() && hy() && this._enabled && !this._isClosed && (fb.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS 15 device on WeChat.")), await this.renewMediaStreamTrack());
    }), this._config = t2, this._originalConstraints = i2, this._constraints = i2, this._deviceName = e9.label, this._encoderConfig = dL(this._config.encoderConfig), qL.on(tL.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), qL.on(tL.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), this.bindProcessorContextEvents();
  }
  async setDevice(e9) {
    return "string" == typeof e9 ? this._setDeviceById(e9) : e9.deviceId ? this._setDeviceById(e9.deviceId) : e9.facingMode ? this._setDeviceByFacingModel(e9.facingMode) : void 0;
  }
  async _setDeviceById(e9) {
    if (fb.info("[".concat(this.getTrackId(), "] set device to ").concat(e9)), this._enabled) try {
      const t2 = await uk.getDeviceById(e9), i2 = {};
      i2.video = GL({}, this._constraints), i2.video.deviceId = { exact: e9 }, i2.video.facingMode = void 0, this._originMediaStreamTrack.stop();
      let n2 = null;
      try {
        n2 = await ak(i2, this.getTrackId());
      } catch (e10) {
        throw fb.error("[".concat(this.getTrackId(), "] setDevice failed"), e10.toString()), n2 = await ak({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), e10;
      }
      await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution(), this._deviceName = t2.label, this._config.cameraId = e9, this._constraints.deviceId = { exact: e9 };
    } catch (e10) {
      throw fb.error("[".concat(this.getTrackId(), "] setDevice error"), e10.toString()), e10;
    }
    else try {
      const t2 = await uk.getDeviceById(e9);
      this._deviceName = t2.label, this._config.cameraId = e9, this._constraints.deviceId = { exact: e9 };
    } catch (e10) {
      throw fb.error("[".concat(this.getTrackId(), "] setDevice error"), e10.toString()), e10;
    }
    fb.info("[".concat(this.getTrackId(), "] setDevice success"));
  }
  async _setDeviceByFacingModel(e9) {
    fb.info("[".concat(this.getTrackId(), "] set facingMode ").concat(e9));
    const t2 = { video: GL(GL({}, this._constraints), {}, { deviceId: void 0, facingMode: { exact: e9 } }) };
    if (this._enabled) {
      this._originMediaStreamTrack.stop();
      let e10 = null;
      try {
        e10 = await ak(t2, this.getTrackId());
      } catch (t3) {
        throw fb.error("[".concat(this.getTrackId(), "] setDeviceByFacingModel failed"), t3.toString()), e10 = await ak({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(e10.getVideoTracks()[0], false), t3;
      }
      await this._updateOriginMediaStreamTrack(e10.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution();
    }
    this._deviceName = "", this._config.facingMode = e9, this._config.cameraId = void 0, this._constraints = GL({}, t2.video), fb.info("[".concat(this.getTrackId(), "] setDeviceByFacingModel success"));
  }
  async setEnabled(e9, t2) {
    if (!t2) {
      if (e9 === this._enabled) return;
      this.stateCheck("enabled", e9);
    }
    if (fb.info("[".concat(this.getTrackId(), "] start setEnabled"), e9), e9) {
      try {
        if (this.isExternalTrack) this._originMediaStreamTrack.enabled = true;
        else {
          const e10 = await ak({ video: this._constraints }, this.getTrackId());
          await this._updateOriginMediaStreamTrack(e10.getVideoTracks()[0], false);
        }
        await $y(this, fL.NEED_ENABLE_TRACK, this);
      } catch (e10) {
        throw fb.error("[".concat(this.getTrackId(), "] setEnabled true error"), e10.toString()), e10;
      }
      this.updateMediaStreamTrackResolution(), fb.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
    } else {
      this.isExternalTrack ? this._originMediaStreamTrack.enabled = false : (this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop()), t2 || (this._enabled = false);
      try {
        await $y(this, fL.NEED_DISABLE_TRACK, this);
      } catch (e10) {
        throw fb.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e10.toString()), e10;
      }
      fb.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
    }
  }
  async setEncoderConfiguration(e9, t2) {
    if (!this._enabled) throw new Cy(Ry.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
    e9 = dL(e9), this._forceBitrateLimit && (e9.bitrateMax = this._forceBitrateLimit.max_bitrate || e9.bitrateMax, e9.bitrateMin = this._forceBitrateLimit.min_bitrate || e9.bitrateMin);
    const i2 = sA(this._config);
    i2.encoderConfig = e9;
    const n2 = Ak(i2);
    (Xv() || $v() || uy()) && (n2.deviceId = void 0), fb.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e9), JSON.stringify(n2));
    try {
      await this._originMediaStreamTrack.applyConstraints(n2), this.updateMediaStreamTrackResolution();
    } catch (e10) {
      const t3 = new Cy(Ry.UNEXPECTED_ERROR, e10.toString());
      throw fb.error("[".concat(this.getTrackId(), "] applyConstraints error"), t3.toString()), t3;
    }
    this._config = i2, this._constraints = n2, this._originalConstraints = n2, this._encoderConfig = e9, -1 === this._hints.indexOf(mL.SCREEN_TRACK) && this.updateBitrateFromProfile();
    try {
      await $y(this, fL.NEED_UPDATE_VIDEO_ENCODER, this);
    } catch (e10) {
      return e10.throw(fb);
    }
  }
  _getDefaultPlayerConfig() {
    return { mirror: true, fit: "cover" };
  }
  onTrackEnded() {
    if (($v() || uy()) && this._enabled && !this._isClosed && qL.duringInterruption) {
      const e9 = async () => {
        qL.off(tL.IOS_INTERRUPTION_END, e9), this._enabled && !this._isClosed && (fb.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
      };
      qL.on(tL.IOS_INTERRUPTION_END, e9);
    } else fb.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(CL.TRACK_ENDED);
  }
  async renewMediaStreamTrack(e9) {
    const t2 = e9 || this._constraints, i2 = uk.searchDeviceIdByName(this._deviceName);
    if (i2 && !t2.deviceId && (t2.deviceId = { exact: i2 }), this._enabled) {
      const e10 = await ak({ video: t2 }, this.getTrackId());
      this._constraints = t2, await this._updateOriginMediaStreamTrack(e10.getVideoTracks()[0], true), this.updateMediaStreamTrackResolution();
    }
  }
  close() {
    super.close(), qL.off(tL.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), qL.off(tL.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat);
  }
  clone(t2) {
    let i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n2 = this._encoderConfig;
    t2 && (n2 = GL(GL({}, n2), dL(t2))), n2 = aA(n2);
    const r2 = TA(8, "track-cam-cloned-"), o2 = new e5(i2 ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, aA(GL(GL({}, this._config), {}, { encoderConfig: n2 })), aA(this._constraints), aA(this._scalabilityMode), this._optimizationMode, r2);
    return t2 && n2 && o2.setEncoderConfiguration(n2), fb.debug("clone track from ".concat(this.getTrackId(), " to ").concat(r2, ", clone ").concat(i2)), o2;
  }
  bindProcessorContextEvents() {
    this.processorContext.on(PL.REQUEST_UPDATE_CONSTRAINTS, async (e9, t2, i2) => {
      try {
        const i3 = Object.assign({}, this._originalConstraints, ...e9);
        await this.renewMediaStreamTrack(i3), t2();
      } catch (e10) {
        i2(e10);
      }
    }), this.processorContext.on(PL.REQUEST_CONSTRAINTS, async (e9) => {
      e9(this._originMediaStreamTrack.getSettings());
    });
  }
}, FL(sU.prototype, "setDevice", [ZM, $M], Object.getOwnPropertyDescriptor(sU.prototype, "setDevice"), sU.prototype), FL(sU.prototype, "setEnabled", [eU, tU, iU], Object.getOwnPropertyDescriptor(sU.prototype, "setEnabled"), sU.prototype), FL(sU.prototype, "setEncoderConfiguration", [nU, rU], Object.getOwnPropertyDescriptor(sU.prototype, "setEncoderConfiguration"), sU.prototype), FL(sU.prototype, "close", [oU], Object.getOwnPropertyDescriptor(sU.prototype, "close"), sU.prototype), sU);
function dU(e9, t2, i2, n2) {
  i2.optimizationMode && (n2 && n2.width && n2.height ? (i2.encoderConfig = GL(GL({}, n2), {}, { bitrateMin: n2.bitrateMin, bitrateMax: n2.bitrateMax }), "motion" !== i2.optimizationMode && "detail" !== i2.optimizationMode || (t2.contentHint = i2.optimizationMode, t2.contentHint === i2.optimizationMode ? fb.debug("[".concat(e9, "] set content hint to"), i2.optimizationMode) : fb.debug("[".concat(e9, "] set content hint failed")))) : fb.warning("[".concat(e9, "] can not apply optimization mode bitrate config, no encoderConfig")));
}
var lU;
var uU;
var hU;
var pU;
var _U;
var EU;
var fU;
var mU;
var TU;
var SU;
var gU;
var RU;
var CU = class extends WL {
  getUserId() {
    return this._userId;
  }
  constructor(e9, t2, i2, n2) {
    super(e9, "track-".concat(e9.kind, "-").concat(t2, "-").concat(n2.clientId, "_").concat(TA(5, ""))), BL(this, "_userId", void 0), BL(this, "_uintId", void 0), BL(this, "_isDestroyed", false), BL(this, "store", void 0), BL(this, "processor", void 0), BL(this, "processorContext", void 0), this._userId = t2, this._uintId = i2, this.store = n2;
  }
  _updateOriginMediaStreamTrack(e9) {
    this._originMediaStreamTrack = e9, this._mediaStreamTrack = e9, this._updatePlayerSource(), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext });
  }
  _destroy() {
    this._isDestroyed = true, fb.info("[".concat(this.getTrackId(), "] is destroyed")), this.stop(), super.close();
  }
  getProcessorStats() {
    return this.processorContext.gatherStats();
  }
  getProcessorUsage() {
    return this.processorContext.gatherUsage();
  }
};
var IU = (lU = Ib({ argsMap: (e9, t2, i2) => [e9.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i2] }), uU = Ib({ argsMap: (e9) => [e9.getTrackId()] }), hU = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2.name] }), pU = Ib({ argsMap: (e9) => [e9.getTrackId()] }), FL((_U = class extends CU {
  get isPlaying() {
    return !(!this._player || this._player.videoElementStatus !== ML.PLAYING);
  }
  get __className__() {
    return "RemoteVideoTrack";
  }
  constructor(e9, t2, i2, n2) {
    super(e9, t2, i2, n2), BL(this, "_videoVisibleTimer", null), BL(this, "_previousVideoVisibleStatus", void 0), BL(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), BL(this, "trackMediaType", vL.VIDEO), BL(this, "_videoWidth", void 0), BL(this, "_videoHeight", void 0), BL(this, "_player", void 0), BL(this, "processorDestination", void 0), BL(this, "processorContext", void 0), this.updateMediaStreamTrackResolution(), this.processorContext = new gk(this.getTrackId(), "remote"), this.processorDestination = new Sk(this.processorContext), this.bindProcessorDestinationEvents();
  }
  getStats() {
    return dA(() => {
      fb.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");
    }, "remoteVideoTrackGetStatsWarning"), eA(this, fL.GET_STATS) || GL({}, NL);
  }
  play(e9) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if ("string" == typeof e9) {
      const t3 = document.getElementById(e9);
      t3 ? e9 = t3 : (fb.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e9, '" element, use document.body')), e9 = document.body);
    }
    fb.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e9 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
    const i2 = GL(GL({ fit: "cover" }, t2), {}, { trackId: this.getTrackId(), element: e9 });
    this._player ? this._player.updateConfig(i2) : (e9 instanceof HTMLVideoElement ? this._player = new vM(i2) : this._player = new AM(i2), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {
      this.store.subscribe(this.getUserId(), "video", void 0, void 0, Date.now()), this.safeEmit(IL.FIRST_FRAME_DECODED);
    }, this._player.onVideoStateChanged = (e10) => {
      this.safeEmit(IL.VIDEO_STATE_CHANGED, e10);
    }), this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
      try {
        const e10 = this.getVideoElementVisibleStatus();
        this.safeEmit(IL.VIDEO_ELEMENT_VISIBLE_STATUS, e10);
      } catch (e10) {
      }
    }, XA("CHECK_VIDEO_VISIBLE_INTERVAL"));
  }
  stop() {
    this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, fb.debug("[".concat(this.getTrackId(), "] stop video playback")));
  }
  getCurrentFrameData() {
    return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
  }
  updateMediaStreamTrackResolution() {
    yk(this._originMediaStreamTrack).then((e9) => {
      let [t2, i2] = e9;
      this._videoHeight = i2, this._videoWidth = t2;
    }).catch(gA);
  }
  _updatePlayerSource() {
    fb.debug("[".concat(this.getTrackId(), "] update player source track")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
  }
  getVideoElementVisibleStatus() {
    try {
      var e9, t2;
      const i2 = null == this || null === (e9 = this._player) || void 0 === e9 ? void 0 : e9.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i2 ? void 0 : i2.parentElement }, { element: r2, slot: o2 } = n2;
      if (this.isPlaying && r2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
        const e10 = Ly.checkOneElementVisible(r2), t3 = Object.assign({}, e10);
        if (t3.visible !== this._previousVideoVisibleStatus) {
          this._previousVideoVisibleStatus = t3.visible;
          const e11 = vb.reportApiInvoke(null, { tag: jy.TRACER, name: By.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
          t3.visible ? e11.onSuccess("Video is visible") : e11.onSuccess("Invisible because of ".concat(t3.reason));
        }
        return t3;
      }
      return;
    } catch (e10) {
      throw new Cy(Ry.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e10.message);
    }
  }
  pipe(e9) {
    if (this.processor === e9) return e9;
    if (e9._source) throw new Cy(Ry.INVALID_OPERATION, "Processor ".concat(e9.name, " already piped, please call unpipe beforehand."));
    return this.unpipe(), this.processor = e9, this.processor._source = this, e9.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e9;
  }
  unpipe() {
    if (!this.processor) return;
    const e9 = this.processor;
    this.processor._source = void 0, this.processor = void 0, e9.reset();
  }
  bindProcessorDestinationEvents() {
    this.processorDestination.on(DL.ON_TRACK, async (e9) => {
      e9 ? e9 !== this._mediaStreamTrack && (this._mediaStreamTrack = e9, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
    });
  }
  unbindProcessorDestinationEvents() {
    this.processorDestination.removeAllListeners(DL.ON_TRACK);
  }
  _destroy() {
    super._destroy(), this.unbindProcessorDestinationEvents();
  }
  _onSei(e9) {
    this.emit(RL.SEI_RECEIVED, e9);
  }
}).prototype, "play", [lU], Object.getOwnPropertyDescriptor(_U.prototype, "play"), _U.prototype), FL(_U.prototype, "stop", [uU], Object.getOwnPropertyDescriptor(_U.prototype, "stop"), _U.prototype), FL(_U.prototype, "pipe", [hU], Object.getOwnPropertyDescriptor(_U.prototype, "pipe"), _U.prototype), FL(_U.prototype, "unpipe", [pU], Object.getOwnPropertyDescriptor(_U.prototype, "unpipe"), _U.prototype), _U);
var vU = (EU = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2], throttleTime: 300 }), fU = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2] }), mU = Ib({ argsMap: (e9) => [e9.getTrackId()] }), TU = Ib({ argsMap: (e9) => [e9.getTrackId()] }), SU = Ib({ argsMap: (e9, t2) => [e9.getTrackId(), t2.name] }), gU = Ib({ argsMap: (e9) => [e9.getTrackId()] }), FL((RU = class extends CU {
  get isPlaying() {
    return this._useAudioElement ? mk.isPlaying(this.getTrackId()) : this._source.isPlayed;
  }
  get __className__() {
    return "RemoteAudioTrack";
  }
  constructor(e9, t2, i2, n2) {
    super(e9, t2, i2, n2), BL(this, "trackMediaType", vL.AUDIO), BL(this, "_source", void 0), BL(this, "_useAudioElement", true), BL(this, "_volume", 100), BL(this, "processorContext", void 0), BL(this, "processorDestination", void 0), BL(this, "_played", false), BL(this, "_bypassWebAudio", false), XA("DISABLE_WEBAUDIO") ? (this._source = new Ik(), this._bypassWebAudio = true, this._useAudioElement = true) : (this._source = new ek(e9, true), XA("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false)), this._source.once(yL.RECEIVE_TRACK_BUFFER, () => {
      this.safeEmit(IL.FIRST_FRAME_DECODED);
    }), this.processorContext = new Ck(this._source.context, this.getTrackId(), "remote"), this.processorDestination = new Rk(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(yL.UPDATE_SOURCE, () => {
      this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
    });
  }
  setAudioFrameCallback(e9) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
    if (!e9) return this._source.removeAllListeners(yL.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
    this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(yL.ON_AUDIO_BUFFER), this._source.on(yL.ON_AUDIO_BUFFER, (t3) => e9(t3));
  }
  setVolume(e9) {
    this._volume = e9, this._useAudioElement ? mk.setVolume(this.getTrackId(), e9) : this._source.setVolume(e9 / 100);
  }
  async setPlaybackDevice(e9) {
    if (!this._useAudioElement || !$P()) throw new Cy(Ry.NOT_SUPPORTED, "your browser does not support setting the audio output device");
    await mk.setSinkID(this.getTrackId(), e9);
  }
  getVolumeLevel() {
    return this._source.getAccurateVolumeLevel();
  }
  getStats() {
    return dA(() => {
      fb.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");
    }, "remoteAudioTrackGetStatsWarning"), eA(this, fL.GET_STATS) || GL({}, wL);
  }
  play() {
    fb.debug("[".concat(this.getTrackId(), "] start audio playback")), this._played = true, this._useAudioElement ? (fb.debug("[".concat(this.getTrackId(), "] use audio element to play")), mk.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play();
  }
  stop() {
    fb.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._played = false, this._useAudioElement ? mk.stop(this.getTrackId()) : this._source.stop();
  }
  _destroy() {
    super._destroy(), this._played = false, this.unbindProcessorDestinationEvents(), this._source.destroy();
  }
  _isFreeze() {
    return this._source.isFreeze;
  }
  _updatePlayerSource() {
    let e9 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    fb.debug("[".concat(this.getTrackId(), "] update player source track")), e9 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && mk.updateTrack(this.getTrackId(), this._mediaStreamTrack);
  }
  pipe(e9) {
    if (this._bypassWebAudio) throw new Cy(Ry.NOT_SUPPORTED, "can not pipe extension when WebAudio disabled");
    if (this.processor === e9) return e9;
    if (e9._source) throw new Cy(Ry.INVALID_OPERATION, "Processor ".concat(e9.name, " already piped, please call unpipe beforehand."));
    return this.unpipe(), this.processor = e9, this.processor._source = this, e9.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e9;
  }
  unpipe() {
    var e9;
    if (this._bypassWebAudio) throw new Cy(Ry.NOT_SUPPORTED, "can not unpipe extension when WebAudio disabled");
    if (!this.processor) return;
    const t2 = this.processor;
    null === (e9 = this._source.processSourceNode) || void 0 === e9 || e9.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
  }
  bindProcessorDestinationEvents() {
    this.processorDestination.on(DL.ON_TRACK, async (e9) => {
      e9 ? e9 !== this._mediaStreamTrack && (this._mediaStreamTrack = e9, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e9)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
    }), this.processorDestination.on(DL.ON_NODE, (e9) => {
      this._source.processedNode = e9;
      const t2 = !e9;
      this._useAudioElement !== t2 && (this._played ? (this.stop(), this._useAudioElement = t2, this.play()) : this._useAudioElement = t2);
    });
  }
  unbindProcessorDestinationEvents() {
    this.processorDestination.removeAllListeners(DL.ON_TRACK), this.processorDestination.removeAllListeners(DL.ON_NODE);
  }
}).prototype, "setVolume", [EU], Object.getOwnPropertyDescriptor(RU.prototype, "setVolume"), RU.prototype), FL(RU.prototype, "setPlaybackDevice", [fU], Object.getOwnPropertyDescriptor(RU.prototype, "setPlaybackDevice"), RU.prototype), FL(RU.prototype, "play", [mU], Object.getOwnPropertyDescriptor(RU.prototype, "play"), RU.prototype), FL(RU.prototype, "stop", [TU], Object.getOwnPropertyDescriptor(RU.prototype, "stop"), RU.prototype), FL(RU.prototype, "pipe", [SU], Object.getOwnPropertyDescriptor(RU.prototype, "pipe"), RU.prototype), FL(RU.prototype, "unpipe", [gU], Object.getOwnPropertyDescriptor(RU.prototype, "unpipe"), RU.prototype), RU);
var yU = new class extends xy {
  get visibility() {
    return document.visibilityState;
  }
  get lastHiddenTime() {
    return this._lastHiddenTime;
  }
  get lastVisibleTime() {
    return this._lastVisibleTime;
  }
  constructor() {
    super(), BL(this, "_lastHiddenTime", 0), BL(this, "_lastVisibleTime", 0), document.addEventListener("visibilitychange", () => {
      "hidden" === document.visibilityState ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), fb.debug("document visibility went ".concat(document.visibilityState)), this.emit("VISIBILITY_CHANGE", document.visibilityState);
    });
  }
}();
var AU = class extends xy {
  constructor(e9, t2) {
    super(), BL(this, "trackMediaType", vL.DATA), BL(this, "_version", 1), BL(this, "_type", 3), BL(this, "_config", void 0), BL(this, "_originDataChannel", void 0), BL(this, "_dataStreamPacketHeader", new ArrayBuffer(4)), BL(this, "_dataStreamPacketHandler", { serialize: (e10) => e10, deserialize: (e10) => e10 }), BL(this, "_datachannelEventMap", /* @__PURE__ */ new Map()), this._config = e9, t2 && (this._originDataChannel = t2, this._bandDataChannelEvents(t2)), this._initPacketHeader();
  }
  useDataStream(e9) {
    this._dataStreamPacketHandler = e9;
  }
  get id() {
    return this._config.id;
  }
  get ordered() {
    return this._config.ordered;
  }
  get maxRetransmits() {
    return XA("DATASTREAM_MAX_RETRANSMITS");
  }
  get metadata() {
    return this._config.metadata;
  }
  get readyState() {
    var e9, t2;
    return null !== (e9 = null === (t2 = this._originDataChannel) || void 0 === t2 ? void 0 : t2.readyState) && void 0 !== e9 ? e9 : "connecting";
  }
  get _originDataChannelId() {
    var e9, t2;
    return null !== (e9 = null === (t2 = this._originDataChannel) || void 0 === t2 ? void 0 : t2.id) && void 0 !== e9 ? e9 : null;
  }
  getChannelId() {
    return this.id;
  }
  getConfig() {
    return this._config;
  }
  _close() {
    this._originDataChannel && (this._unbindDataChannelEvents(this._originDataChannel), this._originDataChannel = void 0);
  }
  async _waitTillOpen() {
    return new Gh((e9, t2) => {
      if (this._originDataChannel) {
        "open" === this._originDataChannel.readyState && e9();
        const i2 = setTimeout(() => {
          var e10;
          t2(new Cy(Ry.DATACHANNEL_CONNECTION_TIMEOUT, "Cannot create datachannel, id: ".concat(null === (e10 = this._originDataChannel) || void 0 === e10 ? void 0 : e10.id)));
        }, 1e4);
        this._originDataChannel.onopen = () => {
          clearTimeout(i2), this._originDataChannel && this._bandDataChannelEvents(this._originDataChannel), e9();
        }, this._originDataChannel.onerror = () => {
          throw clearTimeout(i2), new Cy(Ry.DATACHANNEL_CONNECTION_TIMEOUT);
        };
      } else t2(new Cy(Ry.DATACHANNEL_CONNECTION_TIMEOUT, "cannot find dataChannel"));
    });
  }
  _updateOriginDataChannel(e9) {
    this._originDataChannel = e9, this._bandDataChannelEvents(e9);
  }
  _initPacketHeader() {
    const e9 = new DataView(this._dataStreamPacketHeader);
    e9.setUint16(0, this._version), e9.setUint8(2, this._type), e9.setUint8(3, this._config.id);
  }
  _bandDataChannelEvents(e9) {
    this._unbindDataChannelEvents(e9), [VL.OPEN, VL.CLOSE, VL.ERROR].forEach((t2) => {
      const i2 = () => {
        this.emit(t2);
      };
      this._datachannelEventMap.set(t2, i2), e9.addEventListener(t2, i2);
    });
  }
  _unbindDataChannelEvents(e9) {
    Array.from(this._datachannelEventMap.entries()).forEach((t2) => {
      let [i2, n2] = t2;
      e9.removeEventListener(i2, n2);
    }), this._datachannelEventMap.clear();
  }
};
var bU = class extends AU {
  constructor(e9) {
    super(e9), BL(this, "_messageListener", void 0), this._messageListener = (e10) => {
      if (e10.data.byteLength < this._dataStreamPacketHeader.byteLength) throw Error("invalid byteLength: the byte length must exceed " + this._dataStreamPacketHeader.byteLength);
      const t2 = e10.data.slice(0, this._dataStreamPacketHeader.byteLength), i2 = new DataView(t2).getUint8(3);
      if (i2 !== this.id) return void (XA("SHOW_DATASTREAM2_LOG") && fb.debug("invalid datachannel id: ".concat(i2, " !== ").concat(this.id)));
      let n2 = e10.data.slice(this._dataStreamPacketHeader.byteLength);
      n2 = this._dataStreamPacketHandler.deserialize(n2), this.emit(VL.MESSAGE, n2);
    };
  }
  _updateOriginDataChannel(e9) {
    super._updateOriginDataChannel(e9), this._bandRemoteDataChannelEvents();
  }
  _close() {
    this._originDataChannel && (this._originDataChannel.removeEventListener("message", this._messageListener), super._close());
  }
  _bandRemoteDataChannelEvents() {
    this._originDataChannel && this._originDataChannel.addEventListener("message", this._messageListener);
  }
};
var wU = class extends AU {
  send(e9) {
    if (this._originDataChannel) {
      let t2 = e9;
      t2 = this._dataStreamPacketHandler.serialize(e9);
      const i2 = new Uint8Array(this._dataStreamPacketHeader.byteLength + t2.byteLength);
      i2.set(new Uint8Array(this._dataStreamPacketHeader), 0), i2.set(new Uint8Array(t2), this._dataStreamPacketHeader.byteLength), this._originDataChannel.send(i2.buffer);
    }
  }
};
function OU() {
  const e9 = new Blob([atob("ZnVuY3Rpb24gZShlLHQsbil7bGV0IHI9bmV3IFVpbnQ4QXJyYXkoZSx0LG4pLGE9W10sbz0wO2Zvcig7YS5sZW5ndGg8bjspbyszPG4mJjA9PT1yW29dJiYwPT09cltvKzFdJiYzPT09cltvKzJdJiYoMD09PXJbbyszXXx8MT09PXJbbyszXXx8Mj09PXJbbyszXXx8Mz09PXJbbyszXSk/KGEucHVzaChyW29dLHJbbysxXSxyW28rM10pLG8rPTQpOihhLnB1c2gocltvXSksbysrKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSl9ZnVuY3Rpb24gdChlLHQpe2NvbnN0IG49ZnVuY3Rpb24oZSl7Y29uc3QgdD1lLmxlbmd0aDtsZXQgbj1bXSxyPTA7Zm9yKDtyPHQ7KXIrMjx0JiYwPT09ZVtyXSYmMD09PWVbcisxXSYmKDA9PT1lW3IrMl18fDE9PT1lW3IrMl18fDI9PT1lW3IrMl18fDM9PT1lW3IrMl0pPyhuLnB1c2goZVtyXSxlW3IrMV0sMyxlW3IrMl0pLHIrPTMpOihuLnB1c2goZVtyXSkscisrKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkobil9KHQpLHI9bi5sZW5ndGgsYT1NYXRoLmZsb29yKHIvMjU1KSxvPXIlMjU1LHM9bmV3IFVpbnQ4QXJyYXkoNithKzErcitlLmJ5dGVMZW5ndGgpO3NbMF09MCxzWzFdPTAsc1syXT0wLHNbM109MSxzWzRdPTYsc1s1XT0xMDE7bGV0IGk9MDtmb3IoO2k8YTspc1s2K2ldPTI1NSxpKys7cmV0dXJuIHNbNitpXT1vLGkrKyxzLnNldChuLDYraSkscy5zZXQobmV3IFVpbnQ4QXJyYXkoZSksNitpK3IpLHMuYnVmZmVyfW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiU2FmYXJpIik+LTEmJi0xPT09bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJDaHJvbWUiKSYmKHNlbGYub25ydGN0cmFuc2Zvcm09bj0+e2NvbnN0IHI9bi50cmFuc2Zvcm1lcjtsZXQgYT1bXTtyLm9wdGlvbnMucG9ydC5vbm1lc3NhZ2U9ZT0+e2UuZGF0YS5zZWkmJmEucHVzaChlLmRhdGEuc2VpKX0sc2VsZi5wb3N0TWVzc2FnZSgic3RhcnRlZCIpO2NvbnN0IG89ci5yZWFkYWJsZS5nZXRSZWFkZXIoKSxzPXIud3JpdGFibGUuZ2V0V3JpdGVyKCk7InJ4Ij09PXIub3B0aW9ucy5uYW1lP2Z1bmN0aW9uIHQobil7by5yZWFkKCkudGhlbigocj0+e2lmKCFyLmRvbmUpe2lmKHIudmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkVmlkZW9GcmFtZSl7Y29uc3QgdD1mdW5jdGlvbih0KXtjb25zdCBuPW5ldyBEYXRhVmlldyh0LmRhdGEpO2xldCByPTA7Zm9yKDtyKzQ8dC5kYXRhLmJ5dGVMZW5ndGg7KXtpZigwPT09bi5nZXRVaW50OChyKzApJiYwPT09bi5nZXRVaW50OChyKzEpJiYwPT09bi5nZXRVaW50OChyKzIpJiYxPT09bi5nZXRVaW50OChyKzMpJiY2PT09bi5nZXRVaW50OChyKzQpKXtsZXQgYT1yKzYsbz0wLHM9MDtmb3IoOzI1NT09PShzPW4uZ2V0VWludDgoYSsrKSk7KW8rPTI1NTtvKz1zO2NvbnN0IGk9ZSh0LmRhdGEsYSxvKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaSl9cisrfXJldHVybiBudWxsfShyLnZhbHVlKTt0JiZuLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7c2VpOnR9KX1zLndyaXRlKHIudmFsdWUpLG4ub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHt0cmFuc2Zvcm1lZDohMH0pLHQobil9fSkpfShyKToidHgiPT09ci5vcHRpb25zLm5hbWUmJmZ1bmN0aW9uIGUobil7by5yZWFkKCkudGhlbigocj0+e2lmKCFyLmRvbmUpe2lmKHIudmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkVmlkZW9GcmFtZSl7Y29uc3QgZT1hLnNoaWZ0KCk7ZSYmKHIudmFsdWUuZGF0YT10KHIudmFsdWUuZGF0YSxlKSl9cy53cml0ZShyLnZhbHVlKSxuLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7dHJhbnNmb3JtZWQ6ITB9KSxlKG4pfX0pKX0ocil9LHNlbGYucG9zdE1lc3NhZ2UoInJlZ2lzdGVyZWQiKSk7Cg==")], { type: "text/javascript" });
  return setTimeout(() => XP.revokeObjectURL(e9), 0), new Worker(XP.createObjectURL(e9));
}
var NU = /* @__PURE__ */ new Map();
var DU = /* @__PURE__ */ new Map();
function PU(e9, t2, i2) {
  let n2 = new Uint8Array(e9, t2, i2), r2 = [], o2 = 0;
  for (; r2.length < i2; ) o2 + 3 < i2 && 0 === n2[o2] && 0 === n2[o2 + 1] && 3 === n2[o2 + 2] && (0 === n2[o2 + 3] || 1 === n2[o2 + 3] || 2 === n2[o2 + 3] || 3 === n2[o2 + 3]) ? (r2.push(n2[o2], n2[o2 + 1], n2[o2 + 3]), o2 += 4) : (r2.push(n2[o2]), o2++);
  return new Uint8Array(r2);
}
var LU = /* @__PURE__ */ new Map();
async function kU(e9, t2) {
  if (!ZP().supportWebRTCEncodedTransform) return void fb.warning("browser not support video encoded transform");
  if (LU.has(e9)) return;
  if (!e9.track) return;
  const i2 = { track: e9.track };
  if (Jv()) {
    if (!e9.createEncodedStreams) return void fb.warning("browser not support createEncodedStreams() API");
    let r2 = null;
    try {
      r2 = e9.createEncodedStreams();
    } catch (e10) {
      return void fb.error("create video-encoded-streams error", e10 && e10.message);
    }
    let o2 = [];
    t2.on("sei-to-send", (e10) => {
      o2.push(e10);
    });
    const s2 = new TransformStream({ transform(t3, r3) {
      i2.controller || (i2.controller = r3), e9.track && e9.track.id !== i2.track.id && (fb.debug("video track changed: ".concat(i2.track.id, " => ").concat(e9.track.id)), i2.track.removeEventListener("ended", n2), i2.track = e9.track, i2.track.addEventListener("ended", n2));
      const s3 = o2.shift();
      s3 && (t3.data = function(e10, t4) {
        const i3 = function(e11) {
          const t5 = e11.length;
          let i4 = [], n4 = 0;
          for (; n4 < t5; ) n4 + 2 < t5 && 0 === e11[n4] && 0 === e11[n4 + 1] && (0 === e11[n4 + 2] || 1 === e11[n4 + 2] || 2 === e11[n4 + 2] || 3 === e11[n4 + 2]) ? (i4.push(e11[n4], e11[n4 + 1], 3, e11[n4 + 2]), n4 += 3) : (i4.push(e11[n4]), n4++);
          return new Uint8Array(i4);
        }(t4), n3 = i3.length, r4 = Math.floor(n3 / 255), o3 = n3 % 255, s4 = new Uint8Array(6 + r4 + 1 + n3 + e10.byteLength);
        s4[0] = 0, s4[1] = 0, s4[2] = 0, s4[3] = 1, s4[4] = 6, s4[5] = 101;
        let a2 = 0;
        for (; a2 < r4; ) s4[6 + a2] = 255, a2++;
        return s4[6 + a2] = o3, a2++, s4.set(i3, 6 + a2), s4.set(new Uint8Array(e10), 6 + a2 + n3), s4.buffer;
      }(t3.data, s3)), r3.enqueue(t3);
    } });
    r2.readable.pipeThrough(s2).pipeTo(r2.writable);
  } else {
    if (!Xv()) return;
    {
      if ("undefined" == typeof RTCRtpScriptTransform) return void fb.warning("browser not support RTCRtpScriptTransform");
      const r2 = OU(), o2 = new MessageChannel();
      await new Gh((e10) => r2.onmessage = (t3) => {
        "registered" === t3.data && e10(void 0);
      });
      const s2 = new RTCRtpScriptTransform(r2, { name: "tx", port: o2.port2 }, [o2.port2]);
      e9.transform = s2, await new Gh((e10) => r2.onmessage = (t3) => {
        "started" === t3.data && e10(void 0);
      }), t2.on("sei-to-send", (e10) => {
        o2.port1.postMessage({ sei: e10 });
      }), o2.port1.onmessage = (t3) => {
        var r3;
        t3.data.transformed && e9.track && (null === (r3 = e9.track) || void 0 === r3 ? void 0 : r3.id) !== i2.track.id && (fb.debug("video track changed: ".concat(i2.track.id, " => ").concat(e9.track.id)), i2.track.removeEventListener("ended", n2), i2.track = e9.track, i2.track.addEventListener("ended", n2));
      }, i2.worker = r2;
    }
  }
  function n2() {
    if (e9.track) {
      if (this.id !== e9.track.id) return;
      e9.track.removeEventListener("ended", n2);
    }
    const t3 = LU.get(e9);
    if (t3) {
      LU.delete(e9);
      try {
        var i3, r2;
        null === (i3 = t3.controller) || void 0 === i3 || i3.terminate(), null === (r2 = t3.worker) || void 0 === r2 || r2.terminate();
      } catch (e10) {
        fb.warning(e10 && e10.message);
      }
    }
  }
  LU.set(e9, i2), e9.track.addEventListener("ended", n2);
}
var MU = /* @__PURE__ */ new Map();
!function() {
  const e9 = Hv();
  QP.getDisplayMedia = !(!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia), QP.getStreamFromExtension = e9.name === Bv.CHROME && Number(e9.version) > 34, QP.supportUnifiedPlan = function() {
    if (!window.RTCRtpTransceiver) return false;
    if (!("currentDirection" in RTCRtpTransceiver.prototype)) return false;
    const e10 = new RTCPeerConnection();
    let t2 = false;
    try {
      e10.addTransceiver("audio"), t2 = true;
    } catch (e11) {
    }
    return e10.close(), t2;
  }(), QP.supportMinBitrate = e9.name === Bv.CHROME || e9.name === Bv.EDGE, QP.supportSetRtpSenderParameters = function() {
    const e10 = Hv();
    return !!(window.RTCRtpSender && window.RTCRtpSender.prototype.setParameters && window.RTCRtpSender.prototype.getParameters) && (!!Ey() || !(!Xv() && !zv()) || e10.name === Bv.FIREFOX && Number(e10.version) >= 64);
  }(), e9.name === Bv.SAFARI && (Number(e9.version) >= 14 ? QP.supportDualStream = true : QP.supportDualStream = false), QP.webAudioMediaStreamDest = function() {
    const e10 = Hv();
    return !(e10.name === Bv.SAFARI && Number(e10.version) < 12);
  }(), QP.supportReplaceTrack = !!window.RTCRtpSender && "function" == typeof RTCRtpSender.prototype.replaceTrack, QP.supportWebGL = "undefined" != typeof WebGLRenderingContext, QP.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, Ey() || (QP.webAudioWithAEC = true), QP.supportShareAudio = function() {
    const e10 = Hv();
    return (e10.os === Fv.WIN_10 || e10.os === Fv.WIN_81 || e10.os === Fv.WIN_7 || e10.os === Fv.LINUX || e10.os === Fv.MAC_OS || e10.os === Fv.CHROMIUM_OS) && e10.name === Bv.CHROME && Number(e10.version) >= 74;
  }(), QP.supportDataChannel = !!(ey(76) || function(e10) {
    const t2 = Hv();
    return !(t2.name !== Bv.FIREFOX || !t2.osVersion) && Number(t2.version) >= e10;
  }(68) || ny(14)), QP.supportPCSetConfiguration = function() {
    const e10 = window.RTCPeerConnection;
    return !Zv() && !!e10 && e10.prototype.setConfiguration instanceof Function;
  }(), QP.supportWebRTCEncodedTransform = function() {
    const e10 = Hv();
    return "Chrome" === e10.name && Number(e10.version) >= 86 || "Safari" === e10.name && Number(e10.version) >= 15;
  }(), QP.supportWebRTCInsertableStream = function() {
    const e10 = Hv();
    return (e10.name === Bv.CHROME || e10.name === Bv.EDGE) && Number(e10.version) >= 94 && "MediaStreamTrackGenerator" in window && "MediaStreamTrackProcessor" in window;
  }(), QP.supportRequestVideoFrameCallback = "requestVideoFrameCallback" in HTMLVideoElement.prototype, QP.supportWebCrypto = "undefined" != typeof window && void 0 !== window.crypto && void 0 !== window.crypto.subtle, oA(() => {
    QP.supportDualStreamEncoding = function() {
      const e10 = Hv();
      return !!XA("DISABLE_WEBAUDIO") || ("Safari" === e10.name && Number(e10.version) >= 14 || !!("Chrome" === e10.name && /Windows/i.test(e10.os || "") && Number(e10.version) >= 100 && XA("CHROME_DUAL_STREAM_USE_ENCODING")));
    }(), fb.info("browser compatibility", JSON.stringify(QP), JSON.stringify(e9));
  });
}();
var UU = class _UU extends xy {
  constructor(e9, t2) {
    super(), Fg(this, "signal", void 0), Fg(this, "token", void 0), Fg(this, "tokenTimeout", void 0), Fg(this, "tokenInterval", void 0), Fg(this, "_sequence", 0), Fg(this, "userMap", /* @__PURE__ */ new Map()), Fg(this, "encoder", new TextEncoder()), this.signal = e9, this.token = t2;
    const i2 = () => {
      this.signal.connectionState === Nw.CONNECTED && this.check(), 0 === this.userMap.size ? this.tokenInterval = window.setTimeout(i2, 1e3) : this.tokenInterval = window.setTimeout(i2, 3 * XA("P2P_TOKEN_INTERVAL"));
    };
    i2();
  }
  async send(e9, t2, i2, n2, r2) {
    var o2, s2, a2;
    if (0 === this.userMap.size) return;
    const c2 = Array.from(_N(o2 = this.userMap).call(o2))[0].token;
    "string" != typeof t2 && (t2 = JSON.stringify(t2)), n2 = null !== (s2 = n2) && void 0 !== s2 ? s2 : TA(6, ""), r2 = null !== (a2 = r2) && void 0 !== a2 ? a2 : this._sequence++;
    const d2 = { _id: n2, _type: e9, _seq: r2, _message: t2, token: "".concat(this.token, "_").concat(c2) };
    XA("SHOW_P2P_LOG") && fb.debug("send message", d2, "noNeedResponse : ".concat(i2));
    this.splitMessage(JSON.stringify(d2)).forEach((e10) => {
      this.signal.request(Pw.DATA_STREAM, { payload: uA(this.encoder.encode(e10)) });
    });
    const l2 = new Gh((t3, r3) => {
      const o3 = window.setTimeout(() => {
        this.off("res-@".concat(n2, "_ack"), s3), this.off("res-@".concat(n2), c3), this.off(vO.ABORT, a3), fb.debug("[external-signal] request timeout, type: ".concat(e9, ", requestId: ").concat(n2)), 0 === this.userMap.size ? r3(new Cy(Ry.INVALID_REMOTE_USER)) : r3(new Cy(Ry.TIMEOUT));
      }, XA("EXTERNAL_SIGNAL_REQUEST_TIMEOUT")), s3 = () => {
        o3 && window.clearTimeout(o3), this.off(vO.ABORT, a3), i2 && t3();
      }, a3 = () => {
        o3 && window.clearTimeout(o3), this.off("res-@".concat(n2, "_ack"), s3), this.off("res-@".concat(n2), c3), r3(new Cy(Ry.EXTERNAL_SIGNAL_ABORT, "type: ".concat(e9, ", requestId: ").concat(n2)));
      };
      this.once(vO.ABORT, a3), this.once("res-@".concat(n2, "_ack"), s3);
      const c3 = (i3, c4) => {
        l3 = true, o3 && window.clearTimeout(o3), this.off("res-@".concat(n2, "_ack"), s3), this.off(vO.ABORT, a3), "success" === i3 ? t3(c4) : r3(new Cy(Ry.P2P_MESSAGE_FAILED, "request ".concat(e9, " failed, requestId: ").concat(n2)));
      };
      let l3 = false;
      i2 || (this.once("res-@".concat(n2), c3), mA(XA("SIGNAL_REQUEST_TIMEOUT")).then(() => {
        l3 || fb.warning("external_signal request timeout, type: ".concat(e9, ", requestId: ").concat(n2, ", ").concat(d2));
      }));
    });
    try {
      return await l2;
    } catch (o3) {
      if (o3.code === Ry.TIMEOUT) return await this.send(e9, t2, i2, n2, r2);
      throw o3;
    }
  }
  onMessage(e9) {
    var t2;
    const { _uid: i2 } = e9;
    let n2, r2 = this.userMap.get(i2);
    if (r2) n2 = r2.splitMessageMap;
    else {
      if (this.userMap.size > 0 || !("_type" in e9) || e9._type !== IO.CHECK) return;
      const { token: t3 } = e9;
      n2 = /* @__PURE__ */ new Map(), r2 = { uid: i2, isStart: true, token: t3, splitMessageMap: n2, nextExpectedSequenceNumber: 0, receivedMessagesMap: /* @__PURE__ */ new Map() }, this.userMap.set(i2, r2), this.signal.emit(kw.ON_USER_ONLINE, { uid: i2 }), this.handleUserOnline();
    }
    if ("id" in e9 && "total" in e9) {
      var o2;
      const { id: t3, total: r3 } = e9, s3 = null !== (o2 = n2.get(t3)) && void 0 !== o2 ? o2 : [];
      if (s3.push(e9), n2.has(t3) || n2.set(t3, s3), s3.length !== r3) return;
      {
        const r4 = aE(s3).call(s3, (e10, t4) => e10.index - t4.index).map((e10) => e10.payload).join("");
        n2.delete(t3), (e9 = JSON.parse(r4))._uid = i2;
      }
    }
    const { _type: s2, token: a2 } = e9;
    if (Dn(t2 = [IO.ACK, IO.CHECK]).call(t2, s2)) return s2 === IO.CHECK && this.handleCheckToken(r2, a2), void this.receiveMessage(e9);
    a2 === "".concat(r2.token, "_").concat(this.token) ? this.handleReceivedMessage(e9) : fb.debug('Receive unexpected message", '.concat(a2, ", cur_token: ").concat(r2.token, "_").concat(this.token), e9);
  }
  check() {
    const e9 = { _id: TA(6, ""), token: this.token, _type: IO.CHECK };
    XA("SHOW_P2P_LOG") && fb.debug("send message", e9), this.signal.request(Pw.DATA_STREAM, { payload: uA(this.encoder.encode(JSON.stringify(e9))) });
  }
  ack(e9) {
    const t2 = { _id: e9, _type: IO.ACK, token: this.token };
    XA("SHOW_P2P_LOG") && fb.debug("send message", t2), this.signal.request(Pw.DATA_STREAM, { payload: uA(this.encoder.encode(JSON.stringify(t2))) });
  }
  response(e9, t2, i2) {
    this.send(IO.RESPONSE, JSON.stringify({ success: !i2, message: t2 }), true, e9);
  }
  handleReceivedMessage(e9) {
    const t2 = () => {
      this.userMap.forEach((e10) => {
        const { receivedMessagesMap: t3, nextExpectedSequenceNumber: i3 } = e10;
        for (; t3.has(i3); ) {
          const n3 = t3.get(i3);
          t3.delete(i3), this.receiveMessage(n3), e10.nextExpectedSequenceNumber++;
        }
      });
    };
    if (!e9) return void t2();
    const { _uid: i2, _seq: n2 } = e9, r2 = this.userMap.get(i2), { receivedMessagesMap: o2, isStart: s2, nextExpectedSequenceNumber: a2 } = r2;
    if (n2 < a2) return this.ack(e9._id), void fb.debug("[external-signal] receive old message, seq: ".concat(n2, ", ").concat(e9._message));
    o2.set(n2, e9), s2 && n2 === a2 && (this.receiveMessage(e9), o2.delete(a2), r2.nextExpectedSequenceNumber++, t2());
  }
  receiveMessage(e9) {
    const { _id: t2, _type: i2, _message: n2, _uid: r2 } = e9;
    if (XA("SHOW_P2P_LOG") && fb.debug("receive message", e9), t2) {
      let o2;
      switch (e9._type !== IO.ACK && (n2 && (o2 = JSON.parse(n2)), this.ack(e9._id)), e9._type) {
        case IO.CANDIDATE:
        case IO.CONTROL:
          this.signal.emit(i2, o2, r2);
          break;
        case IO.PUBLISH:
        case IO.UNPUBLISH:
        case IO.RESTART_ICE:
        case IO.CALL:
          o2.uid = r2, Zy(this.signal, i2, o2).then((t3) => {
            this.response(e9._id, t3);
          }).catch(() => {
            this.response(e9._id, void 0, true);
          });
          break;
        case IO.ACK:
          this.getListeners("res-@".concat(t2, "_ack")).length > 0 && this.emit("res-@".concat(t2, "_ack"));
          break;
        case IO.RESPONSE: {
          const { success: e10, message: i3 } = o2;
          this.emit("res-@".concat(t2), e10 ? "success" : "failed", i3);
          break;
        }
      }
    }
  }
  splitMessage(e9) {
    if (e9.length < _UU.MAX_MESSAGE_SIZE) return [e9];
    const t2 = [], { remoteToken: i2 } = JSON.parse(e9), n2 = TA(6, "");
    let r2 = 0, o2 = 800;
    const s2 = Math.ceil(e9.length / o2);
    for (; e9.length > 0; ) {
      r2++;
      const a2 = { id: n2, index: r2, total: s2, payload: e9.slice(0, o2), token: "".concat(this.token, "_").concat(i2) };
      JSON.stringify(a2).length > _UU.MAX_MESSAGE_SIZE ? o2 -= 50 : (t2.push(a2), e9 = e9.slice(o2));
    }
    return t2.map((e10) => JSON.stringify(e10));
  }
  handleCheckToken(e9, t2) {
    return e9.token !== t2 ? (fb.debug("token changed, from ".concat(e9.token, " to ").concat(t2)), this.reset(e9.uid, t2), false) : (this.tokenTimeout && (window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0), this.tokenTimeout = window.setTimeout(() => {
      fb.debug("token timeout, ".concat(t2)), this.reset(e9.uid);
    }, XA("MAX_P2P_TIMEOUT")), true);
  }
  async handleUserOnline() {
    const e9 = await Zy(this.signal, IO.CALL, void 0), t2 = await this.send(IO.CALL, e9);
    this.signal.emit(Dw.P2P_CONNECTION, t2, true);
  }
  async reset(e9, t2) {
    const i2 = this.userMap.get(e9);
    i2 && (this.emit(vO.ABORT), this.signal.emit(kw.ON_USER_OFFLINE, { uid: i2.uid, reason: AO.P2P_TOKEN_CHANGED }), this._sequence = 0, this.userMap.clear(), t2 || (fb.debug("change local token from ".concat(t2, " to ").concat(t2)), this.token = TA(6, "")));
  }
  clear() {
    this._sequence = 0, this.userMap.clear(), this.tokenInterval && window.clearTimeout(this.tokenInterval), this.tokenInterval = void 0, this.tokenTimeout && window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0, this.emit(vO.ABORT);
  }
};
Fg(UU, "MAX_SIZE", 1), Fg(UU, "MAX_MESSAGE_SIZE", 1024);
var xU = class extends xy {
  get connectionState() {
    return this._connectionState;
  }
  set connectionState(e9) {
    e9 !== this._connectionState && (this._connectionState = e9, e9 === Nw.CONNECTED ? this.emit(Dw.WS_CONNECTED) : e9 === Nw.RECONNECTING ? this.emit(Dw.WS_RECONNECTING, this._websocketReconnectReason) : e9 === Nw.CLOSED && this.emit(Dw.WS_CLOSED, this._disconnectedReason));
  }
  get currentURLIndex() {
    return this.websocket.currentURLIndex;
  }
  get url() {
    return this.websocket && this.websocket.url || null;
  }
  get rtt() {
    return this.rttRolling.mean();
  }
  constructor(e9, t2) {
    super(), Fg(this, "_disconnectedReason", void 0), Fg(this, "_websocketReconnectReason", void 0), Fg(this, "_connectionState", Nw.CLOSED), Fg(this, "reconnectToken", void 0), Fg(this, "p2pToken", void 0), Fg(this, "websocket", void 0), Fg(this, "openConnectionTime", void 0), Fg(this, "clientId", void 0), Fg(this, "lastMsgTime", Date.now()), Fg(this, "uploadCache", []), Fg(this, "uploadCacheInterval", void 0), Fg(this, "rttRolling", new MA(5)), Fg(this, "pingpongTimer", void 0), Fg(this, "pingpongTimeoutCount", 0), Fg(this, "joinResponse", void 0), Fg(this, "multiIpOption", void 0), Fg(this, "initError", void 0), Fg(this, "spec", void 0), Fg(this, "store", void 0), Fg(this, "_external_signal", void 0), Fg(this, "onWebsocketMessage", (e10) => {
      if (e10.data instanceof ArrayBuffer) return void this.emit(Dw.ON_BINARY_DATA, e10.data);
      const t3 = JSON.parse(e10.data);
      if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
        const e11 = "res-@".concat(t3._id);
        this.emit(e11, t3._result, t3._message);
      } else if (Object.prototype.hasOwnProperty.call(t3, "_type")) {
        switch (t3._type) {
          case kw.ON_DATA_STREAM:
            return void this.handleDataStream(t3._message);
          case kw.MUTE_AUDIO:
          case kw.MUTE_VIDEO:
          case kw.ON_P2P_LOST:
          case kw.ON_USER_ONLINE:
            return;
          case kw.ON_USER_OFFLINE:
            const { uid: e11 } = t3._message;
            return fb.debug("[".concat(this.clientId, "] user-offline uid: ").concat(e11)), void this._external_signal.reset(e11);
        }
        if (this.emit(t3._type, t3._message), t3._type === kw.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === kw.ON_USER_BANNED) switch (t3._message.error_code) {
          case 14:
            this.close(Hy.UID_BANNED);
            break;
          case 15:
            this.close(Hy.IP_BANNED);
            break;
          case 16:
            this.close(Hy.CHANNEL_BANNED);
        }
        if (t3._type === kw.ON_USER_LICENSE_BANNED) switch (t3._message.error_code) {
          case Ow.ERR_LICENSE_MISSING:
            this.close(Hy.LICENSE_MISSING);
            break;
          case Ow.ERR_LICENSE_EXPIRED:
            this.close(Hy.LICENSE_EXPIRED);
            break;
          case Ow.ERR_LICENSE_MINUTES_EXCEEDED:
            this.close(Hy.LICENSE_MINUTES_EXCEEDED);
            break;
          case Ow.ERR_LICENSE_PERIOD_INVALID:
            this.close(Hy.LICENSE_PERIOD_INVALID);
            break;
          case Ow.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
            this.close(Hy.LICENSE_MULTIPLE_SDK_SERVICE);
            break;
          case Ow.ERR_LICENSE_ILLEGAL:
            this.close(Hy.LICENSE_ILLEGAL);
            break;
          default:
            this.close();
        }
      }
    }), this.clientId = e9.clientId, this.spec = e9, this.store = t2, this.websocket = new WO("gateway-".concat(this.clientId), this.spec.retryConfig, true, XA("JOIN_GATEWAY_USE_DUAL_DOMAIN"), XA("JOIN_GATEWAY_USE_443PORT_ONLY"), t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
      this.connectionState === Nw.CONNECTED && this.reconnect("retry", Jy.OFFLINE);
    }), this.p2pToken = TA(6, ""), this._external_signal = new UU(this, this.p2pToken);
  }
  async request(e9, t2, i2, n2) {
    const r2 = TA(6, ""), o2 = { _id: r2, _type: e9, _message: t2 }, s2 = this.websocket.connectionID, a2 = () => new Gh((e10, t3) => {
      if (this.connectionState === Nw.CONNECTED) return e10();
      const i3 = () => {
        this.off(Dw.WS_CLOSED, n3), e10();
      }, n3 = () => {
        this.off(Dw.WS_CONNECTED, i3), t3(new Cy(Ry.WS_ABORT));
      };
      this.once(Dw.WS_CONNECTED, i3), this.once(Dw.WS_CLOSED, n3);
    });
    if (this.connectionState !== Nw.CONNECTING && this.connectionState !== Nw.RECONNECTING || e9 === Pw.JOIN || e9 === Pw.REJOIN || await a2(), this.websocket.sendMessage(o2, true), n2) return;
    const c2 = new Gh((i3, n3) => {
      let o3 = false;
      const a3 = (n4, r3) => {
        o3 = true, i3({ isSuccess: "success" === n4, message: r3 || {} }), this.off(Dw.WS_CLOSED, c3), this.off(Dw.WS_RECONNECTING, c3), this.emit(Dw.REQUEST_SUCCESS, e9, t2);
      };
      this.once("res-@".concat(r2), a3);
      const c3 = () => {
        n3(new Cy(Ry.WS_ABORT, "type: ".concat(e9))), this.off(Dw.WS_CLOSED, c3), this.off(Dw.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
      };
      this.once(Dw.WS_CLOSED, c3), this.once(Dw.WS_RECONNECTING, c3), mA(XA("SIGNAL_REQUEST_TIMEOUT")).then(() => {
        this.websocket.connectionID !== s2 || o3 || (fb.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e9)), this.emit(Dw.REQUEST_TIMEOUT, e9, t2));
      });
    });
    let d2 = null;
    try {
      d2 = await c2;
    } catch (n3) {
      if (this.connectionState === Nw.CLOSED || e9 === Pw.LEAVE) throw new Cy(Ry.WS_ABORT);
      return !this.spec.forceWaitGatewayResponse || i2 ? n3.throw() : e9 === Pw.JOIN || e9 === Pw.REJOIN ? null : (await a2(), await this.request(e9, t2));
    }
    if (d2.isSuccess) return d2.message;
    const l2 = Number(d2.message.error_code || d2.message.code), u2 = NO(l2), h2 = new Cy(Ry.UNEXPECTED_RESPONSE, "".concat(u2.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message, desc: u2.desc });
    return "success" === u2.action ? d2.message : (fb.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e9, ", error_code: ").concat(l2, ", message: ").concat(u2.desc, ", action: ").concat(u2.action)), l2 === Ow.ERR_TOO_MANY_BROADCASTERS ? e9 === Pw.JOIN || e9 === Pw.REJOIN ? (this.initError = h2, this.close(), h2.throw()) : h2.throw() : "failed" === u2.action ? h2.throw() : "quit" === u2.action ? (this.initError = h2, this.close(), h2.throw()) : (l2 === Ow.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, fb.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", Jy.MULTI_IP)) : this.reconnect(u2.action, Jy.SERVER_ERROR), e9 === Pw.JOIN || e9 === Pw.REJOIN ? null : await this.request(e9, t2)));
  }
  waitMessage(e9, t2) {
    return new Gh((i2) => {
      const n2 = (r2) => {
        (!t2 || t2(r2)) && (this.off(e9, n2), i2(r2));
      };
      this.on(e9, n2);
    });
  }
  uploadWRTCStats(e9) {
    if (!this.store.sessionId) return void fb.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
    const t2 = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e9 };
    this.upload(Lw.WRTC_STATS, t2);
  }
  upload(e9, t2) {
    const i2 = { _type: e9, _message: t2 };
    try {
      this.websocket.sendMessage(i2);
    } catch (e10) {
      const t3 = XA("MAX_UPLOAD_CACHE") || 50;
      this.uploadCache.push(i2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
        if (this.connectionState !== Nw.CONNECTED) return;
        const e11 = this.uploadCache.splice(0, 1)[0];
        0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e11._type, e11._message);
      }, XA("UPLOAD_CACHE_INTERVAL") || 2e3));
    }
  }
  send(e9, t2) {
    const i2 = { _type: e9, _message: t2 };
    this.websocket.sendMessage(i2);
  }
  async sendExtensionMessage(e9, t2, i2) {
    return await this._external_signal.send(e9, t2, i2);
  }
  init(e9) {
    return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Gh((t2, i2) => {
      this.once(Dw.WS_CONNECTED, () => t2(this.joinResponse)), this.once(Dw.WS_CLOSED, () => i2(this.initError || new Cy(Ry.WS_ABORT))), this.connectionState = Nw.CONNECTING, this.websocket.init(e9).catch(i2);
    });
  }
  close(e9) {
    this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._external_signal.clear(), this._disconnectedReason = e9 || Hy.LEAVE, this.connectionState = Nw.CLOSED, fb.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), this.p2pToken = TA(6, ""), this._external_signal.clear(), this._external_signal = new UU(this, this.p2pToken);
  }
  async join() {
    if (!this.joinResponse) {
      this.emit(Dw.ABORT_P2P_EXECUTION);
      const e9 = await Zy(this, Dw.REQUEST_JOIN_INFO), t2 = await this.request(Pw.JOIN, e9);
      if (!t2) return this.emit(Dw.REPORT_JOIN_GATEWAY, Ry.TIMEOUT, this.url || ""), false;
      this.joinResponse = t2, this.emit(Dw.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
    }
    return this.connectionState = Nw.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
  }
  reconnect(e9, t2) {
    this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e9, t2);
  }
  handleDataStream(e9) {
    try {
      var t2;
      const i2 = lA(e9.payload), n2 = new TextDecoder().decode(i2), r2 = JSON.parse(n2);
      "total" in r2 && "id" in r2 || Dn(t2 = Object.values(IO)).call(t2, r2._type) ? (r2._uid = e9.uid, this._external_signal.onMessage(r2)) : this.emit(kw.ON_DATA_STREAM, e9);
    } catch (t3) {
      this.emit(kw.ON_DATA_STREAM, e9);
    }
  }
  handleNotification(e9) {
    fb.debug("[".concat(this.clientId, "] receive notification: "), e9);
    const t2 = NO(e9.code);
    if ("success" !== t2.action) {
      if ("failed" !== t2.action) return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(Hy.UID_BANNED), void this.close()) : void this.reconnect(t2.action, Jy.SERVER_ERROR);
      fb.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
    }
  }
  handlePingPong() {
    if (!this.websocket || "connected" !== this.websocket.state) return;
    this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
    const e9 = XA("PING_PONG_TIME_OUT"), t2 = Date.now();
    this.pingpongTimeoutCount >= e9 && (fb.warning("[".concat(this.clientId, "] PINGPONG Timeout. Last Socket Message: ").concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > XA("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", Jy.TIMEOUT) : this.request(Pw.PING, void 0, true).then(() => {
      this.pingpongTimeoutCount = 0;
      const e10 = Date.now() - t2;
      this.rttRolling.add(e10), XA("REPORT_STATS") && this.send(Pw.PING_BACK, { pingpongElapse: e10 });
    }).catch((e10) => {
    });
  }
  handleWebsocketEvents() {
    this.websocket.on(Uw.RECONNECT_WAITTING_FINISH, (e9) => {
      this.emit(Dw.WS_RECONNECT_WAITTING_FINISH, e9);
    }), this.websocket.on(Uw.RECONNECT_CREATE_CONNECTION, (e9) => {
      this.emit(Dw.WS_RECONNECT_CREATE_CONNECTION, e9);
    }), this.websocket.on(Uw.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(Uw.CLOSED, () => {
      this.connectionState = Nw.CLOSED;
    }), this.websocket.on(Uw.FAILED, () => {
      this._disconnectedReason = Hy.NETWORK_ERROR, this.connectionState = Nw.CLOSED;
    }), this.websocket.on(Uw.RECONNECTING, (e9) => {
      this._websocketReconnectReason = e9, this.joinResponse = void 0, this.connectionState === Nw.CONNECTED ? this.connectionState = Nw.RECONNECTING : this.connectionState = Nw.CONNECTING;
    }), this.websocket.on(Uw.WILL_RECONNECT, (e9, t2, i2) => {
      "retry" !== e9 ? (fb.debug("".concat(this.clientId, " websocket will_connect event, renewSession reconnectMode is ").concat(e9)), this.reconnectToken = void 0) : fb.debug("".concat(this.clientId, " reconnect mode is retry, no need to renew session")), i2(e9);
    }), this.websocket.on(Uw.CONNECTED, () => {
      this.openConnectionTime = Date.now(), this.join().catch((e9) => {
        if (this.emit(Dw.REPORT_JOIN_GATEWAY, e9, this.url || ""), e9 instanceof Cy && e9.code === Ry.UNEXPECTED_RESPONSE && e9.data.code === Ow.ERR_NO_AUTHORIZED) return fb.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", Jy.SERVER_ERROR);
        fb.error("[".concat(this.clientId, "] join gateway request failed"), e9.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", Jy.SERVER_ERROR) : (this.initError = e9, this.close());
      });
    }), this.websocket.on(Uw.REQUEST_NEW_URLS, (e9, t2) => {
      Zy(this, Dw.REQUEST_RECOVER, this.multiIpOption).then(e9).catch(t2);
    }), this.websocket.on(Uw.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
      this.emit(kw.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
    });
  }
};
var VU = { exports: {} };
VU.exports = (() => {
  var e9 = { 8: (e10, t3, i3) => {
    i3.r(t3), i3.d(t3, { Parser: () => C2, Printer: () => b2, parse: () => D2, print: () => P2 });
    const n2 = "\n", r2 = "".concat("\r").concat(n2), o2 = " ";
    let s2;
    function a2(e11) {
      return e11 >= "0" && e11 <= "9";
    }
    function c2(e11) {
      return e11 >= "!" && e11 <= "~";
    }
    function d2(e11) {
      return c2(e11) || e11 >= "Â" && e11 <= "Ã¿";
    }
    function l2(e11) {
      return "!" === e11 || e11 >= "#" && e11 <= "'" || e11 >= "*" && e11 <= "+" || e11 >= "-" && e11 <= "." || e11 >= "0" && e11 <= "9" || e11 >= "A" && e11 <= "Z" || e11 >= "^" && e11 <= "~";
    }
    function u2(e11) {
      return e11 >= "1" && e11 <= "9";
    }
    function h2(e11) {
      return e11 >= "A" && e11 <= "Z" || e11 >= "a" && e11 <= "z";
    }
    function p2(e11) {
      return "d" === e11 || "h" === e11 || "m" === e11 || "s" === e11;
    }
    function _2(e11) {
      return e11 > "" && e11 < "	" || e11 > "\v" && e11 < "\f" || e11 > "" && e11 < "Ã¿";
    }
    function E2(e11) {
      return h2(e11) || a2(e11) || "+" === e11 || "/" === e11;
    }
    function f2(e11) {
      return a2(e11) || h2(e11) || "+" === e11 || "/" === e11 || "-" === e11 || "_" === e11;
    }
    function m2(e11) {
      return h2(e11) || a2(e11) || "+" === e11 || "/" === e11;
    }
    function T2(e11, t4) {
      var i4 = Object.keys(e11);
      if (Object.getOwnPropertySymbols) {
        var n3 = Object.getOwnPropertySymbols(e11);
        t4 && (n3 = n3.filter(function(t5) {
          return Object.getOwnPropertyDescriptor(e11, t5).enumerable;
        })), i4.push.apply(i4, n3);
      }
      return i4;
    }
    function S2(e11) {
      for (var t4 = 1; t4 < arguments.length; t4++) {
        var i4 = null != arguments[t4] ? arguments[t4] : {};
        t4 % 2 ? T2(Object(i4), true).forEach(function(t5) {
          g2(e11, t5, i4[t5]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e11, Object.getOwnPropertyDescriptors(i4)) : T2(Object(i4)).forEach(function(t5) {
          Object.defineProperty(e11, t5, Object.getOwnPropertyDescriptor(i4, t5));
        });
      }
      return e11;
    }
    function g2(e11, t4, i4) {
      return t4 in e11 ? Object.defineProperty(e11, t4, { value: i4, enumerable: true, configurable: true, writable: true }) : e11[t4] = i4, e11;
    }
    !function(e11) {
      e11.VERSION = "v", e11.ORIGIN = "o", e11.SESSION_NAME = "s", e11.INFORMATION = "i", e11.URI = "u", e11.EMAIL = "e", e11.PHONE = "p", e11.CONNECTION = "c", e11.BANDWIDTH = "b", e11.TIME = "t", e11.REPEAT = "r", e11.ZONE_ADJUSTMENTS = "z", e11.KEY = "k", e11.ATTRIBUTE = "a", e11.MEDIA = "m";
    }(s2 || (s2 = {}));
    class R2 {
      consumeText(e11, t4) {
        let i4 = t4;
        for (; i4 < e11.length; ) {
          const t5 = e11[i4];
          if ("\0" === t5 || "\r" === t5 || t5 === n2) break;
          i4 += 1;
        }
        if (i4 - t4 == 0) throw new Error("Invalid text, at ".concat(e11));
        return i4;
      }
      consumeUnicastAddress(e11, t4, i4) {
        return this.consumeTill(e11, t4, o2);
      }
      consumeOneOrMore(e11, t4, i4) {
        let n3 = t4;
        for (; i4(e11[n3]); ) n3++;
        if (n3 - t4 == 0) throw new Error("Invalid rule at ".concat(t4, "."));
        return n3;
      }
      consumeSpace(e11, t4) {
        if (e11[t4] === o2) return t4 + 1;
        throw new Error("Invalid space at ".concat(t4, "."));
      }
      consumeIP4Address(e11, t4) {
        let i4 = t4;
        for (let t5 = 0; t5 < 4; t5++) if (i4 = this.consumeDecimalUChar(e11, i4), 3 !== t5) {
          if ("." !== e11[i4]) throw new Error("Invalid IP4 address.");
          i4++;
        }
        return i4;
      }
      consumeDecimalUChar(e11, t4) {
        let i4 = t4;
        for (let t5 = 0; t5 < 3 && a2(e11[i4]); t5++, i4++) ;
        if (i4 - t4 == 0) throw new Error("Invalid decimal uchar.");
        const n3 = parseInt(e11.slice(t4, i4));
        if (n3 >= 0 && n3 <= 255) return i4;
        throw new Error("Invalid decimal uchar");
      }
      consumeIP6Address(e11, t4) {
        let i4 = this.consumeHexpart(e11, t4);
        return ":" === e11[i4] ? (i4 += 1, i4 = this.consumeIP4Address(e11, i4), i4) : i4;
      }
      consumeHexpart(e11, t4) {
        let i4 = t4;
        if (":" === e11[i4] && ":" === e11[i4 + 1]) {
          i4 += 2;
          try {
            i4 = this.consumeHexseq(e11, i4);
          } catch (e12) {
          }
          return i4;
        }
        if (i4 = this.consumeHexseq(e11, i4), ":" === e11[i4] && ":" === e11[i4 + 1]) {
          i4 += 2;
          try {
            i4 = this.consumeHexseq(e11, i4);
          } catch (e12) {
          }
          return i4;
        }
        return i4;
      }
      consumeHexseq(e11, t4) {
        let i4 = t4;
        for (; i4 = this.consumeHex4(e11, i4), ":" === e11[i4] && ":" !== e11[i4 + 1]; ) i4 += 1;
        return i4;
      }
      consumeHex4(e11, t4) {
        let i4 = 0;
        for (; i4 < 4; i4++) if (!((n3 = e11[t4 + i4]) >= "0" && n3 <= "9" || n3 >= "a" && n3 <= "f" || n3 >= "A" && n3 <= "F")) {
          if (0 === i4) throw new Error("Invalid hex 4");
          break;
        }
        var n3;
        return t4 + i4;
      }
      consumeFQDN(e11, t4) {
        let i4 = t4;
        for (; a2(e11[i4]) || h2(e11[i4]) || "-" === e11[i4] || "." === e11[i4]; ) i4 += 1;
        if (i4 - t4 < 4) throw new Error("Invalid FQDN");
        return i4;
      }
      consumeExtnAddr(e11, t4) {
        return this.consumeOneOrMore(e11, t4, d2);
      }
      consumeMulticastAddress(e11, t4, i4) {
        switch (i4) {
          case "IP4":
          case "ip4":
            return this.consumeIP4MulticastAddress(e11, t4);
          case "IP6":
          case "ip6":
            return this.consumeIP6MulticastAddress(e11, t4);
          default:
            try {
              return this.consumeFQDN(e11, t4);
            } catch (i5) {
              return this.consumeExtnAddr(e11, t4);
            }
        }
      }
      consumeIP6MulticastAddress(e11, t4) {
        const i4 = this.consumeHexpart(e11, t4);
        return "/" === e11[i4] ? this.consumeInteger(e11, i4 + 1) : i4;
      }
      consumeIP4MulticastAddress(e11, t4) {
        let i4 = t4 + 3;
        const n3 = e11.slice(t4, i4), r3 = parseInt(n3);
        if (r3 < 224 || r3 > 239) throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");
        for (let t5 = 0; t5 < 3; t5++) {
          if ("." !== e11[i4]) throw new Error("Invalid IP4 multicast address.");
          i4 += 1, i4 = this.consumeDecimalUChar(e11, i4);
        }
        return "/" === e11[i4] && (i4 += 1), i4 = this.consumeTTL(e11, i4), "/" === e11[i4] && (i4 = this.consumeInteger(e11, i4)), i4;
      }
      consumeInteger(e11, t4) {
        if (!u2(e11[t4])) throw new Error("Invalid integer.");
        for (t4 += 1; a2(e11[t4]); ) t4 += 1;
        return t4;
      }
      consumeTTL(e11, t4) {
        if ("0" === e11[t4]) return t4 + 1;
        if (!u2(e11[t4])) throw new Error("Invalid TTL.");
        t4 += 1;
        for (let i4 = 0; i4 < 2 && a2(e11[t4]); i4++) t4 += 1;
        return t4;
      }
      consumeToken(e11, t4) {
        return this.consumeOneOrMore(e11, t4, l2);
      }
      consumeTime(e11, t4) {
        let i4 = t4;
        if ("0" === e11[i4]) return i4 + 1;
        for (u2(e11[i4]) && (i4 += 1); a2(e11[i4]); ) i4++;
        if (i4 - t4 < 10) throw new Error("Invalid time");
        return i4;
      }
      consumeAddress(e11, t4) {
        return this.consumeTill(e11, t4, o2);
      }
      consumeTypedTime(e11, t4) {
        let i4 = t4;
        return i4 = this.consumeOneOrMore(e11, i4, a2), p2(e11[i4]) ? i4 + 1 : i4;
      }
      consumeRepeatInterval(e11, t4) {
        if (!u2(e11[t4])) throw new Error("Invalid repeat interval");
        for (t4 += 1; a2(e11[t4]); ) t4 += 1;
        return p2(e11[t4]) && (t4 += 1), t4;
      }
      consumePort(e11, t4) {
        return this.consumeOneOrMore(e11, t4, a2);
      }
      consume(e11, t4, i4) {
        for (let n3 = 0; n3 < i4.length; n3++) {
          if (t4 + n3 >= e11.length) throw new Error("consume exceeding value length");
          if (e11[t4 + n3] !== i4[n3]) throw new Error("consume ".concat(i4, " failed at ").concat(n3));
        }
        return t4 + i4.length;
      }
      consumeTill(e11, t4, i4) {
        let n3 = t4;
        for (; n3 < e11.length && ("string" != typeof i4 || e11[n3] !== i4) && ("function" != typeof i4 || !i4(e11[n3])); ) n3++;
        return n3;
      }
    }
    class C2 extends R2 {
      constructor() {
        super(), g2(this, "records", []), g2(this, "currentLine", 0);
      }
      parse(e11) {
        const t4 = this.probeEOL(e11);
        this.records = e11.split(t4).filter((e12) => !!jp(e12).call(e12)).map(this.parseLine), this.currentLine = 0;
        const i4 = this.parseVersion(), n3 = this.parseOrigin(), r3 = this.parseSessionName(), o3 = this.parseInformation(), s3 = this.parseUri(), a3 = this.parseEmail(), c3 = this.parsePhone(), d3 = this.parseConnection(), l3 = this.parseBandWidth(), u3 = this.parseTimeFields(), h3 = this.parseKey(), p3 = this.parseSessionAttribute(), _3 = this.parseMediaDescription();
        if (this.currentLine !== this.records.length) throw new Error("parsing failed, non exhaustive sdp lines.");
        return { version: i4, origin: n3, sessionName: r3, information: o3, uri: s3, emails: a3, phones: c3, connection: d3, bandwidths: l3, timeFields: u3, key: h3, attributes: p3, mediaDescriptions: _3 };
      }
      getCurrentRecord() {
        const e11 = this.records[this.currentLine];
        if (!e11) throw new Error("Record doesn't exit.");
        return e11;
      }
      probeEOL(e11) {
        for (let t4 = 0; t4 < e11.length; t4++) if (e11[t4] === n2) return "\r" === e11[t4 - 1] ? r2 : n2;
        throw new Error("Invalid newline character.");
      }
      parseLine(e11, t4) {
        if (e11.length < 2) throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");
        const i4 = e11[0];
        if ("=" !== e11[1]) throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');
        return { type: i4, value: e11.slice(2), line: t4, cur: 0 };
      }
      parseSessionAttribute() {
        const e11 = new v2();
        for (; this.currentLine < this.records.length; ) {
          const t4 = this.getCurrentRecord();
          if (t4.type !== s2.ATTRIBUTE) break;
          const i4 = { attField: this.extractOneOrMore(t4, (e12) => l2(e12) && ":" !== e12), _cur: 0 };
          ":" === t4.value[t4.cur] && (t4.cur += 1, i4.attValue = this.extractOneOrMore(t4, _2)), e11.parse(i4), this.currentLine++;
        }
        return e11.digest();
      }
      parseMediaAttributes(e11) {
        const t4 = new y2(e11);
        for (; this.currentLine < this.records.length; ) {
          const e12 = this.getCurrentRecord();
          if (e12.type !== s2.ATTRIBUTE) break;
          const i4 = { attField: this.extractOneOrMore(e12, (e13) => l2(e13) && ":" !== e13), _cur: 0 };
          ":" === e12.value[e12.cur] && (e12.cur += 1, i4.attValue = this.extractOneOrMore(e12, _2)), t4.parse(i4), this.currentLine++;
        }
        return t4.digest();
      }
      parseKey() {
        const e11 = this.getCurrentRecord();
        if (e11.type === s2.KEY) {
          if ("prompt" === e11.value || "clear:" === e11.value || "base64:" === e11.value || "uri:" === e11.value) return e11.value;
          throw this.currentLine++, new Error("Invalid key.");
        }
      }
      parseZone() {
        const e11 = this.getCurrentRecord();
        if (e11.type === s2.ZONE_ADJUSTMENTS) {
          const t4 = [];
          for (; ; ) try {
            const i4 = this.extract(e11, this.consumeTime);
            this.consumeSpaceForRecord(e11);
            let n3 = false;
            "-" === e11.value[e11.cur] && (n3 = true, e11.cur += 1);
            const r3 = this.extract(e11, this.consumeTypedTime);
            t4.push({ time: i4, typedTime: r3, back: n3 });
          } catch (e12) {
            break;
          }
          if (0 === t4.length) throw new Error("Invalid zone adjustments");
          return this.currentLine++, t4;
        }
        return [];
      }
      parseRepeat() {
        const e11 = [];
        for (; ; ) {
          const t4 = this.getCurrentRecord();
          if (t4.type !== s2.REPEAT) break;
          {
            const i4 = this.extract(t4, this.consumeRepeatInterval), n3 = this.parseTypedTime(t4);
            e11.push({ repeatInterval: i4, typedTimes: n3 }), this.currentLine++;
          }
        }
        return e11;
      }
      parseTypedTime(e11) {
        const t4 = [];
        for (; ; ) try {
          this.consumeSpaceForRecord(e11), t4.push(this.extract(e11, this.consumeTypedTime));
        } catch (e12) {
          break;
        }
        if (0 === t4.length) throw new Error("Invalid typed time.");
        return t4;
      }
      parseTime() {
        const e11 = this.getCurrentRecord(), t4 = this.extract(e11, this.consumeTime);
        this.consumeSpaceForRecord(e11);
        const i4 = this.extract(e11, this.consumeTime);
        return this.currentLine++, { startTime: t4, stopTime: i4 };
      }
      parseBandWidth() {
        const e11 = [];
        for (; this.currentLine < this.records.length; ) {
          const t4 = this.getCurrentRecord();
          if (t4.type !== s2.BANDWIDTH) break;
          {
            const i4 = this.extractOneOrMore(t4, l2);
            if (":" !== t4.value[t4.cur]) throw new Error("Invalid bandwidth field.");
            t4.cur++;
            const n3 = this.extractOneOrMore(t4, a2);
            e11.push({ bwtype: i4, bandwidth: n3 }), this.currentLine++;
          }
        }
        return e11;
      }
      parseVersion() {
        const e11 = this.getCurrentRecord();
        if (e11.type !== s2.VERSION) throw new Error("first sdp record must be version");
        const t4 = e11.value.slice(0, this.consumeOneOrMore(e11.value, 0, a2));
        if (t4.length !== e11.value.length) throw new Error('invalid proto version, "v='.concat(e11.value, '"'));
        return this.currentLine++, t4;
      }
      parseOrigin() {
        const e11 = this.getCurrentRecord();
        if (e11.type !== s2.ORIGIN) throw new Error("second line of sdp must be origin");
        const t4 = this.extractOneOrMore(e11, d2);
        this.consumeSpaceForRecord(e11);
        const i4 = this.extractOneOrMore(e11, a2);
        this.consumeSpaceForRecord(e11);
        const n3 = this.extractOneOrMore(e11, a2);
        this.consumeSpaceForRecord(e11);
        const r3 = this.extractOneOrMore(e11, l2);
        this.consumeSpaceForRecord(e11);
        const o3 = this.extractOneOrMore(e11, l2);
        this.consumeSpaceForRecord(e11);
        const c3 = this.extract(e11, this.consumeUnicastAddress);
        return this.currentLine++, { username: t4, sessId: i4, sessVersion: n3, nettype: r3, addrtype: o3, unicastAddress: c3 };
      }
      parseSessionName() {
        const e11 = this.getCurrentRecord();
        if (e11.type === s2.SESSION_NAME) {
          const t4 = this.extract(e11, this.consumeText);
          return this.currentLine++, t4;
        }
      }
      parseInformation() {
        const e11 = this.getCurrentRecord();
        if (e11.type !== s2.INFORMATION) return;
        const t4 = this.extract(e11, this.consumeText);
        return this.currentLine++, t4;
      }
      parseUri() {
        const e11 = this.getCurrentRecord();
        if (e11.type === s2.URI) return this.currentLine++, e11.value;
      }
      parseEmail() {
        const e11 = [];
        for (; ; ) {
          const t4 = this.getCurrentRecord();
          if (t4.type !== s2.EMAIL) break;
          e11.push(t4.value), this.currentLine++;
        }
        return e11;
      }
      parsePhone() {
        const e11 = [];
        for (; ; ) {
          const t4 = this.getCurrentRecord();
          if (t4.type !== s2.PHONE) break;
          e11.push(t4.value), this.currentLine++;
        }
        return e11;
      }
      parseConnection() {
        const e11 = this.getCurrentRecord();
        if (e11.type === s2.CONNECTION) {
          const t4 = this.extractOneOrMore(e11, l2);
          this.consumeSpaceForRecord(e11);
          const i4 = this.extractOneOrMore(e11, l2);
          this.consumeSpaceForRecord(e11);
          const n3 = this.extract(e11, this.consumeAddress);
          return this.currentLine++, { nettype: t4, addrtype: i4, address: n3 };
        }
      }
      parseMedia() {
        const e11 = this.getCurrentRecord(), t4 = this.extract(e11, this.consumeToken);
        this.consumeSpaceForRecord(e11);
        let i4 = this.extract(e11, this.consumePort);
        "/" === e11.value[e11.cur] && (e11.cur += 1, i4 += this.extract(e11, this.consumeInteger)), this.consumeSpaceForRecord(e11);
        const n3 = [];
        for (n3.push(this.extract(e11, this.consumeToken)); "/" === e11.value[e11.cur]; ) e11.cur += 1, n3.push(this.extract(e11, this.consumeToken));
        if (0 === n3.length) throw new Error("Invalid proto");
        const r3 = this.parseFmt(e11);
        return this.currentLine++, { mediaType: t4, port: i4, protos: n3, fmts: r3 };
      }
      parseTimeFields() {
        const e11 = [];
        for (; this.getCurrentRecord().type === s2.TIME; ) {
          const t4 = this.parseTime(), i4 = this.parseRepeat(), n3 = this.parseZone();
          e11.push({ time: t4, repeats: i4, zones: n3 });
        }
        return e11;
      }
      parseMediaDescription() {
        const e11 = [];
        for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.MEDIA; ) {
          const t4 = this.parseMedia(), i4 = this.parseInformation(), n3 = this.parseConnections(), r3 = this.parseBandWidth(), o3 = this.parseKey(), s3 = this.parseMediaAttributes(t4);
          e11.push({ media: t4, information: i4, connections: n3, bandwidths: r3, key: o3, attributes: s3 });
        }
        return e11;
      }
      parseConnections() {
        const e11 = [];
        for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.CONNECTION; ) e11.push(this.parseConnection());
        return e11;
      }
      parseFmt(e11) {
        const t4 = [];
        for (; ; ) try {
          this.consumeSpaceForRecord(e11), t4.push(this.extract(e11, this.consumeToken));
        } catch (e12) {
          break;
        }
        if (0 === t4.length) throw new Error("Invalid fmts");
        return t4;
      }
      extract(e11, t4) {
        for (var i4 = arguments.length, n3 = new Array(i4 > 2 ? i4 - 2 : 0), r3 = 2; r3 < i4; r3++) n3[r3 - 2] = arguments[r3];
        const o3 = t4.call(this, e11.value, e11.cur, ...n3), s3 = e11.value.slice(e11.cur, o3);
        return e11.cur = o3, s3;
      }
      extractOneOrMore(e11, t4) {
        const i4 = this.consumeOneOrMore(e11.value, e11.cur, t4), n3 = e11.value.slice(e11.cur, i4);
        return e11.cur = i4, n3;
      }
      consumeSpaceForRecord(e11) {
        if (e11.value[e11.cur] !== o2) throw new Error("Invalid space at ".concat(e11.cur, "."));
        e11.cur += 1;
      }
    }
    class I2 extends R2 {
      constructor() {
        super(...arguments), g2(this, "attributes", void 0), g2(this, "digested", false);
      }
      extractOneOrMore(e11, t4, i4) {
        const n3 = this.consumeOneOrMore(e11.attValue, e11._cur, t4), r3 = e11.attValue.slice(e11._cur, n3), [o3, s3] = i4 || [];
        if ("number" == typeof o3 && r3.length < o3) throw new Error("error in length, should be more or equal than ".concat(o3, " characters."));
        if ("number" == typeof s3 && r3.length > s3) throw new Error("error in length, should be less or equal than ".concat(s3, " characters."));
        return e11._cur = n3, r3;
      }
      consumeAttributeSpace(e11) {
        if (e11.attValue[e11._cur] !== o2) throw new Error("Invalid space at ".concat(e11._cur, "."));
        e11._cur += 1;
      }
      extract(e11, t4) {
        if (!e11.attValue) throw new Error("Nothing to extract from attValue.");
        for (var i4 = arguments.length, n3 = new Array(i4 > 2 ? i4 - 2 : 0), r3 = 2; r3 < i4; r3++) n3[r3 - 2] = arguments[r3];
        const o3 = t4.call(this, e11.attValue, e11._cur, ...n3), s3 = e11.attValue.slice(e11._cur, o3);
        return e11._cur = o3, s3;
      }
      atEnd(e11) {
        if (!e11.attValue) throw new Error();
        return e11._cur >= e11.attValue.length;
      }
      peekChar(e11) {
        if (!e11.attValue) throw new Error();
        return e11.attValue[e11._cur];
      }
      peek(e11, t4) {
        if (!e11.attValue) throw new Error();
        for (let i4 = 0; i4 < t4.length; i4++) if (t4[i4] !== e11.attValue[e11._cur + i4]) return false;
        return true;
      }
      parseIceUfrag(e11) {
        if (this.attributes.iceUfrag) throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");
        this.attributes.iceUfrag = this.extractOneOrMore(e11, E2, [4, 256]);
      }
      parseIcePwd(e11) {
        if (this.attributes.icePwd) throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");
        this.attributes.icePwd = this.extractOneOrMore(e11, E2, [22, 256]);
      }
      parseIceOptions(e11) {
        if (this.attributes.iceOptions) throw new Error("Invalid ice-options, should be only one 'ice-options' line");
        const t4 = [];
        for (; !this.atEnd(e11); ) {
          t4.push(this.extractOneOrMore(e11, E2));
          try {
            this.consumeAttributeSpace(e11);
          } catch (t5) {
            if (this.atEnd(e11)) break;
            throw t5;
          }
        }
        this.attributes.iceOptions = t4;
      }
      parseFingerprint(e11) {
        const t4 = this.extract(e11, this.consumeToken);
        this.consumeAttributeSpace(e11);
        const i4 = this.extract(e11, this.consumeTill);
        this.attributes.fingerprints.push({ hashFunction: t4, fingerprint: i4 });
      }
      parseExtmap(e11) {
        const t4 = this.extractOneOrMore(e11, a2);
        let i4;
        "/" === this.peekChar(e11) && (this.extract(e11, this.consume, "/"), i4 = this.extract(e11, this.consumeToken)), this.consumeAttributeSpace(e11);
        const n3 = this.extract(e11, this.consumeTill, o2), r3 = S2(S2({ entry: parseInt(t4, 10) }, i4 && { direction: i4 }), {}, { extensionName: n3 });
        this.peekChar(e11) === o2 && (this.consumeAttributeSpace(e11), r3.extensionAttributes = this.extract(e11, this.consumeTill)), this.attributes.extmaps.push(r3);
      }
      parseSetup(e11) {
        if (this.attributes.setup) throw new Error("must only be one single 'a=setup' line.");
        const t4 = this.extract(e11, this.consumeTill);
        if ("active" !== t4 && "passive" !== t4 && "actpass" !== t4 && "holdconn" !== t4) throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");
        this.attributes.setup = t4;
      }
    }
    class v2 extends I2 {
      constructor() {
        super(...arguments), g2(this, "attributes", { unrecognized: [], groups: [], extmaps: [], fingerprints: [], identities: [] });
      }
      parse(e11) {
        if (this.digested) throw new Error("already digested");
        try {
          switch (e11.attField) {
            case "group":
              this.parseGroup(e11);
              break;
            case "ice-lite":
              this.parseIceLite();
              break;
            case "ice-ufrag":
              this.parseIceUfrag(e11);
              break;
            case "ice-pwd":
              this.parseIcePwd(e11);
              break;
            case "ice-options":
              this.parseIceOptions(e11);
              break;
            case "fingerprint":
              this.parseFingerprint(e11);
              break;
            case "setup":
              this.parseSetup(e11);
              break;
            case "tls-id":
              this.parseTlsId(e11);
              break;
            case "identity":
              this.parseIdentity(e11);
              break;
            case "extmap":
              this.parseExtmap(e11);
              break;
            case "msid-semantic":
              this.parseMsidSemantic(e11);
              break;
            default:
              e11.ignored = true, this.attributes.unrecognized.push(e11);
          }
        } catch (t4) {
          throw console.error("parsing session attribute ".concat(e11.attField, ' error, "a=').concat(e11.attField, ":").concat(e11.attValue, '"')), t4;
        }
        if (!e11.ignored && e11.attValue && !this.atEnd(e11)) throw new Error("attribute parsing error");
      }
      digest() {
        return this.digested = true, this.attributes;
      }
      parseGroup(e11) {
        const t4 = this.extract(e11, this.consumeToken), i4 = [];
        for (; !this.atEnd(e11) && this.peekChar(e11) === o2; ) this.consumeAttributeSpace(e11), i4.push(this.extract(e11, this.consumeToken));
        this.attributes.groups.push({ semantic: t4, identificationTag: i4 });
      }
      parseIceLite() {
        if (this.attributes.iceLite) throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");
        this.attributes.iceLite = true;
      }
      parseTlsId(e11) {
        if (this.attributes.tlsId) throw new Error("must be only one tld-id line");
        this.attributes.tlsId = this.extractOneOrMore(e11, f2);
      }
      parseIdentity(e11) {
        const t4 = this.extractOneOrMore(e11, m2), i4 = [];
        for (; !this.atEnd(e11) && this.peekChar(e11) === o2; ) {
          this.consumeAttributeSpace(e11);
          const t5 = this.extract(e11, this.consumeToken);
          this.extract(e11, this.consume, "=");
          const n3 = this.extractOneOrMore(e11, (e12) => e12 !== o2 && _2(e12));
          i4.push({ name: t5, value: n3 });
        }
        this.attributes.identities.push({ assertionValue: t4, extensions: i4 });
      }
      parseMsidSemantic(e11) {
        this.peekChar(e11) === o2 && this.consumeAttributeSpace(e11);
        const t4 = { semantic: this.extract(e11, this.consumeToken), identifierList: [] };
        for (; ; ) {
          try {
            this.consumeAttributeSpace(e11);
          } catch (e12) {
            break;
          }
          if ("*" === this.peekChar(e11)) {
            this.extract(e11, this.consume, "*"), t4.applyForAll = true;
            break;
          }
          {
            const i4 = this.extract(e11, this.consumeTill, o2);
            t4.identifierList.push(i4);
          }
        }
        this.attributes.msidSemantic = t4;
      }
    }
    class y2 extends I2 {
      constructor(e11) {
        super(), g2(this, "attributes", void 0), -1 !== e11.protos.indexOf("RTP") || e11.protos.indexOf("rtp"), this.attributes = { unrecognized: [], candidates: [], extmaps: [], fingerprints: [], imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [] };
      }
      parse(e11) {
        if (this.digested) throw new Error("already digested");
        try {
          switch (e11.attField) {
            case "extmap":
              this.parseExtmap(e11);
              break;
            case "setup":
              this.parseSetup(e11);
              break;
            case "ice-ufrag":
              this.parseIceUfrag(e11);
              break;
            case "ice-pwd":
              this.parseIcePwd(e11);
              break;
            case "ice-options":
              this.parseIceOptions(e11);
              break;
            case "candidate":
              this.parseCandidate(e11);
              break;
            case "remote-candidate":
              this.parseRemoteCandidate(e11);
              break;
            case "end-of-candidates":
              this.parseEndOfCandidates();
              break;
            case "fingerprint":
              this.parseFingerprint(e11);
              break;
            case "rtpmap":
              this.parseRtpmap(e11);
              break;
            case "ptime":
              this.parsePtime(e11);
              break;
            case "maxptime":
              this.parseMaxPtime(e11);
              break;
            case "sendrecv":
            case "recvonly":
            case "sendonly":
            case "inactive":
              this.parseDirection(e11);
              break;
            case "ssrc":
              this.parseSSRC(e11);
              break;
            case "fmtp":
              this.parseFmtp(e11);
              break;
            case "rtcp-fb":
              this.parseRtcpFb(e11);
              break;
            case "rtcp-mux":
              this.parseRTCPMux();
              break;
            case "rtcp-mux-only":
              this.parseRTCPMuxOnly();
              break;
            case "rtcp-rsize":
              this.parseRTCPRsize();
              break;
            case "rtcp":
              this.parseRTCP(e11);
              break;
            case "mid":
              this.parseMid(e11);
              break;
            case "msid":
              this.parseMsid(e11);
              break;
            case "imageattr":
              this.parseImageAttr(e11);
              break;
            case "rid":
              this.parseRid(e11);
              break;
            case "simulcast":
              this.parseSimulcast(e11);
              break;
            case "sctp-port":
              this.parseSctpPort(e11);
              break;
            case "max-message-size":
              this.parseMaxMessageSize(e11);
              break;
            case "ssrc-group":
              this.parseSSRCGroup(e11);
              break;
            default:
              e11.ignored = true, this.attributes.unrecognized.push(e11);
          }
        } catch (t4) {
          throw console.error("parsing media attribute ".concat(e11.attField, ' error, "a=').concat(e11.attField, ":").concat(e11.attValue, '"')), t4;
        }
        if (!e11.ignored && e11.attValue && !this.atEnd(e11)) throw new Error("attribute parsing error");
      }
      parseCandidate(e11) {
        const t4 = this.extractOneOrMore(e11, E2, [1, 32]);
        this.consumeAttributeSpace(e11);
        const i4 = this.extractOneOrMore(e11, a2, [1, 5]);
        this.consumeAttributeSpace(e11);
        const n3 = this.extract(e11, this.consumeToken);
        this.consumeAttributeSpace(e11);
        const r3 = this.extractOneOrMore(e11, a2, [1, 10]);
        this.consumeAttributeSpace(e11);
        const s3 = this.extract(e11, this.consumeAddress);
        this.consumeAttributeSpace(e11);
        const d3 = this.extract(e11, this.consumePort);
        this.consumeAttributeSpace(e11), this.extract(e11, this.consume, "typ"), this.consumeAttributeSpace(e11);
        const l3 = { foundation: t4, componentId: i4, transport: n3, priority: r3, connectionAddress: s3, port: d3, type: this.extract(e11, this.consumeToken), extension: {} };
        for (this.peek(e11, " raddr") && (this.extract(e11, this.consume, " raddr"), this.consumeAttributeSpace(e11), l3.relAddr = this.extract(e11, this.consumeAddress)), this.peek(e11, " rport") && (this.extract(e11, this.consume, " rport"), this.consumeAttributeSpace(e11), l3.relPort = this.extract(e11, this.consumePort)); this.peekChar(e11) === o2; ) {
          this.consumeAttributeSpace(e11);
          const t5 = this.extract(e11, this.consumeToken);
          this.consumeAttributeSpace(e11), l3.extension[t5] = this.extractOneOrMore(e11, c2);
        }
        this.attributes.candidates.push(l3);
      }
      parseRemoteCandidate(e11) {
        const t4 = [];
        for (; ; ) {
          const i4 = this.extractOneOrMore(e11, a2, [1, 5]);
          this.consumeAttributeSpace(e11);
          const n3 = this.extract(e11, this.consumeAddress);
          this.consumeAttributeSpace(e11);
          const r3 = this.extract(e11, this.consumePort);
          t4.push({ componentId: i4, connectionAddress: n3, port: r3 });
          try {
            this.consumeAttributeSpace(e11);
          } catch (e12) {
            break;
          }
        }
        this.attributes.remoteCandidatesList.push(t4);
      }
      parseEndOfCandidates() {
        if (this.attributes.endOfCandidates) throw new Error("must be only one line of end-of-candidates");
        this.attributes.endOfCandidates = true;
      }
      parseRtpmap(e11) {
        const t4 = this.extract(e11, this.consumeToken);
        this.consumeAttributeSpace(e11);
        const i4 = this.extract(e11, this.consumeTill, "/");
        this.extract(e11, this.consume, "/");
        const n3 = { encodingName: i4, clockRate: this.extractOneOrMore(e11, a2) };
        this.atEnd(e11) || "/" !== this.peekChar(e11) || (this.extract(e11, this.consume, "/"), n3.encodingParameters = parseInt(this.extract(e11, this.consumeTill), 10));
        const r3 = this.attributes.payloads.find((e12) => e12.payloadType === parseInt(t4, 10));
        r3 ? r3.rtpMap = n3 : this.attributes.payloads.push({ payloadType: parseInt(t4, 10), rtpMap: n3, rtcpFeedbacks: [] });
      }
      parsePtime(e11) {
        if (this.attributes.ptime) throw new Error("must be only one line of ptime");
        this.attributes.ptime = this.extract(e11, this.consumeTill);
      }
      parseMaxPtime(e11) {
        if (this.attributes.maxPtime) throw new Error("must be only one line of ptime");
        this.attributes.maxPtime = this.extract(e11, this.consumeTill);
      }
      parseDirection(e11) {
        if (this.attributes.direction) throw new Error("must be only one line of direction info");
        this.attributes.direction = e11.attField;
      }
      parseSSRC(e11) {
        const t4 = this.extractOneOrMore(e11, a2);
        this.consumeAttributeSpace(e11);
        const i4 = this.extract(e11, this.consumeTill, ":");
        let n3;
        ":" === this.peekChar(e11) && (this.extract(e11, this.consume, ":"), n3 = this.extract(e11, this.consumeTill));
        const r3 = this.attributes.ssrcs.find((e12) => e12.ssrcId === parseInt(t4, 10));
        r3 ? r3.attributes[i4] = n3 : this.attributes.ssrcs.push({ ssrcId: parseInt(t4, 10), attributes: { [i4]: n3 } });
      }
      parseFmtp(e11) {
        const t4 = this.extract(e11, this.consumeTill, o2);
        this.consumeAttributeSpace(e11);
        const i4 = this.extract(e11, this.consumeTill), n3 = {};
        i4.split(";").forEach((e12) => {
          let [t5, i5] = e12.split("=");
          t5 = jp(t5).call(t5);
          const r4 = "string" == typeof i5 ? jp(i5).call(i5) : null;
          "string" == typeof t5 && t5.length > 0 && (n3[t5] = r4);
        });
        const r3 = this.attributes.payloads.find((e12) => e12.payloadType === parseInt(t4, 10));
        r3 ? r3.fmtp = { parameters: n3 } : this.attributes.payloads.push({ payloadType: parseInt(t4, 10), rtcpFeedbacks: [], fmtp: { parameters: n3 } });
      }
      parseFmtParameters(e11) {
        const t4 = {}, i4 = this.extract(e11, this.consumeTill, "=");
        e11._cur++;
        const n3 = this.extract(e11, this.consumeTill, ";");
        for (t4[i4] = n3; ";" === e11.attValue[e11._cur]; ) {
          const i5 = this.extract(e11, this.consumeTill, "=");
          e11._cur++;
          const n4 = this.extract(e11, this.consumeTill, ";");
          t4[i5] = n4;
        }
        return t4;
      }
      parseRtcpFb(e11) {
        let t4 = "";
        t4 = "*" === this.peekChar(e11) ? this.extract(e11, this.consume, "*") : this.extract(e11, this.consumeTill, o2), this.consumeAttributeSpace(e11);
        const i4 = this.extract(e11, this.consumeTill, o2);
        let n3;
        if ("trr-int" === i4) n3 = { type: i4, interval: this.extract(e11, this.consumeTill) };
        else {
          const t5 = { type: i4 };
          this.peekChar(e11) === o2 && (this.consumeAttributeSpace(e11), t5.parameter = this.extract(e11, this.consumeToken), this.peekChar(e11) === o2 && (t5.additional = this.extract(e11, this.consumeTill))), n3 = t5;
        }
        if ("*" === t4) this.attributes.rtcpFeedbackWildcards.push(n3);
        else {
          const e12 = this.attributes.payloads.find((e13) => e13.payloadType === parseInt(t4, 10));
          e12 ? e12.rtcpFeedbacks.push(n3) : this.attributes.payloads.push({ payloadType: parseInt(t4, 10), rtcpFeedbacks: [n3] });
        }
      }
      parseRTCPMux() {
        if (this.attributes.rtcpMux) throw new Error("must be single line of rtcp-mux");
        this.attributes.rtcpMux = true;
      }
      parseRTCPMuxOnly() {
        if (this.attributes.rtcpMuxOnly) throw new Error("must be single line of rtcp-only");
        this.attributes.rtcpMuxOnly = true;
      }
      parseRTCPRsize() {
        if (this.attributes.rtcpRsize) throw new Error("must be single line of rtcp-rsize");
        this.attributes.rtcpRsize = true;
      }
      parseRTCP(e11) {
        if (this.attributes.rtcp) throw new Error("must be single line of rtcp");
        const t4 = { port: this.extract(e11, this.consumePort) };
        this.peekChar(e11) === o2 && (this.consumeAttributeSpace(e11), t4.netType = this.extractOneOrMore(e11, l2), this.consumeAttributeSpace(e11), t4.addressType = this.extractOneOrMore(e11, l2), this.consumeAttributeSpace(e11), t4.address = this.extract(e11, this.consumeAddress)), this.attributes.rtcp = t4;
      }
      parseMsid(e11) {
        const t4 = { id: this.extractOneOrMore(e11, l2, [1, 64]) };
        this.peekChar(e11) === o2 && (this.consumeAttributeSpace(e11), t4.appdata = this.extractOneOrMore(e11, l2, [1, 64])), this.attributes.msids.push(t4);
      }
      parseImageAttr(e11) {
        this.attributes.imageattr.push(e11.attValue);
      }
      parseRid(e11) {
        const t4 = this.extractOneOrMore(e11, (e12) => h2(e12) || a2(e12) || "_" === e12 || "-" === e12);
        this.consumeAttributeSpace(e11);
        const i4 = { id: t4, direction: this.extract(e11, this.consumeToken), params: [] };
        if (this.peekChar(e11) === o2) {
          if (this.consumeAttributeSpace(e11), this.peek(e11, "pt=")) {
            this.extract(e11, this.consume, "pt=");
            const t5 = [];
            for (; ; ) {
              const i5 = this.extract(e11, this.consumeToken);
              t5.push(i5);
              try {
                this.extract(e11, this.consume, ",");
              } catch (e12) {
                break;
              }
            }
            i4.payloads = t5, this.peekChar(e11) === o2 && this.extract(e11, this.consume, o2);
          }
          for (; ; ) {
            const t5 = this.extract(e11, this.consumeToken);
            switch (t5) {
              case "depend": {
                const n3 = { type: t5, rids: this.extract(e11, this.consume, "=").split(",") };
                i4.params.push(n3);
                break;
              }
              default: {
                const n3 = { type: t5 };
                "=" === this.peekChar(e11) && (this.extract(e11, this.consume, "="), n3.val = this.extract(e11, this.consumeTill, ";")), i4.params.push(n3);
              }
            }
            try {
              this.extract(e11, this.consume, ";");
            } catch (e12) {
              break;
            }
          }
        }
        this.attributes.rids.push(i4);
      }
      parseSimulcast(e11) {
        if (this.attributes.simulcast) throw new Error("must be single line of simulcast");
        this.attributes.simulcast = e11.attValue, this.extract(e11, this.consumeTill);
      }
      parseSctpPort(e11) {
        this.attributes.sctpPort = this.extractOneOrMore(e11, a2, [1, 5]);
      }
      parseMaxMessageSize(e11) {
        this.attributes.maxMessageSize = this.extractOneOrMore(e11, a2, [1, void 0]);
      }
      digest() {
        return this.digested = true, this.attributes;
      }
      parseMid(e11) {
        this.attributes.mid = this.extract(e11, this.consumeToken);
      }
      parseSSRCGroup(e11) {
        const t4 = this.extract(e11, this.consumeToken), i4 = [];
        for (; ; ) try {
          this.consumeAttributeSpace(e11);
          const t5 = this.extract(e11, this.consumeInteger);
          i4.push(parseInt(t5, 10));
        } catch (e12) {
          break;
        }
        this.attributes.ssrcGroups.push({ semantic: t4, ssrcIds: i4 });
      }
    }
    function A2(e11, t4, i4) {
      return t4 in e11 ? Object.defineProperty(e11, t4, { value: i4, enumerable: true, configurable: true, writable: true }) : e11[t4] = i4, e11;
    }
    class b2 {
      constructor() {
        A2(this, "eol", r2);
      }
      print(e11, t4) {
        let i4 = "";
        return t4 && (this.eol = t4), i4 += this.printVersion(e11.version), i4 += this.printOrigin(e11.origin), i4 += this.printSessionName(e11.sessionName), i4 += this.printInformation(e11.information), i4 += this.printUri(e11.uri), i4 += this.printEmail(e11.emails), i4 += this.printPhone(e11.phones), i4 += this.printConnection(e11.connection), i4 += this.printBandwidth(e11.bandwidths), i4 += this.printTimeFields(e11.timeFields), i4 += this.printKey(e11.key), i4 += this.printSessionAttributes(e11.attributes), i4 += this.printMediaDescription(e11.mediaDescriptions), i4;
      }
      printVersion(e11) {
        return "v=".concat(e11).concat(this.eol);
      }
      printOrigin(e11) {
        return "o=".concat(e11.username, " ").concat(e11.sessId, " ").concat(e11.sessVersion, " ").concat(e11.nettype, " ").concat(e11.addrtype, " ").concat(e11.unicastAddress).concat(this.eol);
      }
      printSessionName(e11) {
        return e11 ? "s=".concat(e11).concat(this.eol) : "";
      }
      printInformation(e11) {
        return e11 ? "i=".concat(e11).concat(this.eol) : "";
      }
      printUri(e11) {
        return e11 ? "u=".concat(e11).concat(this.eol) : "";
      }
      printEmail(e11) {
        let t4 = "";
        for (const i4 of e11) t4 += "e=".concat(i4).concat(this.eol);
        return t4;
      }
      printPhone(e11) {
        let t4 = "";
        for (const i4 of e11) t4 += "e=".concat(i4).concat(this.eol);
        return t4;
      }
      printConnection(e11) {
        return e11 ? "c=".concat(e11.nettype, " ").concat(e11.addrtype, " ").concat(e11.address).concat(this.eol) : "";
      }
      printBandwidth(e11) {
        let t4 = "";
        for (const i4 of e11) t4 += "b=".concat(i4.bwtype, ":").concat(i4.bandwidth).concat(this.eol);
        return t4;
      }
      printTimeFields(e11) {
        let t4 = "";
        for (const i4 of e11) {
          t4 += "t=".concat(i4.time.startTime, " ").concat(i4.time.startTime).concat(this.eol);
          for (const e12 of i4.repeats) t4 += "r=".concat(e12.repeatInterval, " ").concat(e12.typedTimes.join(" ")).concat(this.eol);
          i4.zoneAdjustments && (t4 += "z=", t4 += "z=".concat(i4.zoneAdjustments.map((e12) => "".concat(e12.time, " ").concat(e12.back ? "-" : "", " ").concat(e12.typedTime)).join(" ")).concat(this.eol), t4 += this.eol);
        }
        return t4;
      }
      printKey(e11) {
        return e11 ? "k=".concat(e11).concat(this.eol) : "";
      }
      printAttributes(e11) {
        let t4 = "";
        for (const i4 of e11) t4 += "a=".concat(i4.attField).concat(i4.attValue ? ":".concat(i4.attValue) : "").concat(this.eol);
        return t4;
      }
      printMediaDescription(e11) {
        let t4 = "";
        for (const i4 of e11) t4 += this.printMedia(i4.media), t4 += this.printInformation(i4.information), t4 += this.printConnections(i4.connections), t4 += this.printBandwidth(i4.bandwidths), t4 += this.printKey(i4.key), t4 += this.printMediaAttributes(i4);
        return t4;
      }
      printConnections(e11) {
        let t4 = "";
        for (const i4 of e11) t4 += this.printConnection(i4);
        return t4;
      }
      printMedia(e11) {
        return "m=".concat(e11.mediaType, " ").concat(e11.port, " ").concat(e11.protos.join("/"), " ").concat(e11.fmts.join(" ")).concat(this.eol);
      }
      printSessionAttributes(e11) {
        return new O2(this.eol).print(e11);
      }
      printMediaAttributes(e11) {
        return new N2(this.eol).print(e11);
      }
    }
    class w2 {
      constructor(e11) {
        A2(this, "eol", void 0), this.eol = e11;
      }
      printIceUfrag(e11) {
        return void 0 === e11 ? "" : "a=ice-ufrag:".concat(e11).concat(this.eol);
      }
      printIcePwd(e11) {
        return void 0 === e11 ? "" : "a=ice-pwd:".concat(e11).concat(this.eol);
      }
      printIceOptions(e11) {
        return void 0 === e11 ? "" : "a=ice-options:".concat(e11.join(o2)).concat(this.eol);
      }
      printFingerprints(e11) {
        return e11.length > 0 ? e11.map((e12) => "a=fingerprint:".concat(e12.hashFunction).concat(o2).concat(e12.fingerprint)).join(this.eol) + this.eol : "";
      }
      printExtmap(e11) {
        return e11.map((e12) => "a=extmap:".concat(e12.entry).concat(e12.direction ? "/".concat(e12.direction) : "").concat(o2).concat(e12.extensionName).concat(e12.extensionAttributes ? "".concat(o2).concat(e12.extensionAttributes) : "").concat(this.eol)).join("");
      }
      printSetup(e11) {
        return void 0 === e11 ? "" : "a=setup:".concat(e11).concat(this.eol);
      }
      printUnrecognized(e11) {
        return e11.map((e12) => "a=".concat(e12.attField).concat(e12.attValue ? ":".concat(e12.attValue) : "").concat(this.eol)).join("");
      }
    }
    class O2 extends w2 {
      print(e11) {
        let t4 = "";
        return t4 += this.printGroups(e11.groups), t4 += this.printMsidSemantic(e11.msidSemantic), t4 += this.printIceLite(e11.iceLite), t4 += this.printIceUfrag(e11.iceUfrag), t4 += this.printIcePwd(e11.icePwd), t4 += this.printIceOptions(e11.iceOptions), t4 += this.printFingerprints(e11.fingerprints), t4 += this.printSetup(e11.setup), t4 += this.printTlsId(e11.tlsId), t4 += this.printIdentity(e11.identities), t4 += this.printExtmap(e11.extmaps), t4 += this.printUnrecognized(e11.unrecognized), t4;
      }
      printGroups(e11) {
        let t4 = "";
        return e11.length > 0 && (t4 += e11.map((e12) => "a=group:".concat(e12.semantic).concat(e12.identificationTag.map((e13) => "".concat(o2).concat(e13)).join("")).concat(this.eol)).join("")), t4;
      }
      printIceLite(e11) {
        return void 0 === e11 ? "" : "a=ice-lite" + this.eol;
      }
      printTlsId(e11) {
        return e11 ? "a=tls-id:".concat(e11).concat(this.eol) : "";
      }
      printIdentity(e11) {
        return 0 === e11.length ? "" : e11.map((e12) => "a=identity:".concat(e12.assertionValue).concat(e12.extensions.map((e13) => "".concat(o2).concat(e13.name).concat(e13.value ? "=".concat(e13.value) : "")))).join(this.eol) + this.eol;
      }
      printMsidSemantic(e11) {
        if (!e11) return "";
        let t4 = "a=msid-semantic:".concat(e11.semantic);
        return e11.applyForAll ? t4 += "".concat(o2, "*") : e11.identifierList.length > 0 && (t4 += e11.identifierList.map((e12) => "".concat(o2).concat(e12))), t4 + this.eol;
      }
    }
    class N2 extends w2 {
      print(e11) {
        const t4 = e11.attributes;
        let i4 = "";
        return i4 += this.printRTCP(t4.rtcp), i4 += this.printIceUfrag(t4.iceUfrag), i4 += this.printIcePwd(t4.icePwd), i4 += this.printIceOptions(t4.iceOptions), i4 += this.printCandidates(t4.candidates), i4 += this.printRemoteCandidatesList(t4.remoteCandidatesList), i4 += this.printEndOfCandidates(t4.endOfCandidates), i4 += this.printFingerprints(t4.fingerprints), i4 += this.printSetup(t4.setup), i4 += this.printMid(t4.mid), i4 += this.printExtmap(t4.extmaps), i4 += this.printRTPRelated(t4), i4 += this.printPtime(t4.ptime), i4 += this.printMaxPtime(t4.maxPtime), i4 += this.printDirection(t4.direction), i4 += this.printSSRCGroups(t4.ssrcGroups), i4 += this.printSSRC(t4.ssrcs), i4 += this.printRTCPMux(t4.rtcpMux), i4 += this.printRTCPMuxOnly(t4.rtcpMuxOnly), i4 += this.printRTCPRsize(t4.rtcpRsize), i4 += this.printMSId(t4.msids), i4 += this.printImageattr(t4.imageattr), i4 += this.printRid(t4.rids), i4 += this.printSimulcast(t4.simulcast), i4 += this.printSCTPPort(t4.sctpPort), i4 += this.printMaxMessageSize(t4.maxMessageSize), i4 += this.printUnrecognized(t4.unrecognized), i4;
      }
      printCandidates(e11) {
        return e11.map((e12) => "a=candidate:".concat(e12.foundation).concat(o2).concat(e12.componentId).concat(o2).concat(e12.transport).concat(o2).concat(e12.priority).concat(o2).concat(e12.connectionAddress).concat(o2).concat(e12.port).concat(o2, "typ").concat(o2).concat(e12.type).concat(e12.relAddr ? "".concat(o2, "raddr").concat(o2).concat(e12.relAddr) : "").concat(e12.relPort ? "".concat(o2, "rport").concat(o2).concat(e12.relPort) : "").concat(Object.keys(e12.extension).map((t4) => "".concat(o2).concat(t4).concat(o2).concat(e12.extension[t4])).join("")).concat(this.eol)).join("");
      }
      printRemoteCandidatesList(e11) {
        return e11.map((e12) => "a=remote-candidates:".concat(e12.join(o2)).concat(this.eol)).join("");
      }
      printEndOfCandidates(e11) {
        return void 0 === e11 ? "" : "a=end-of-candidates" + this.eol;
      }
      printRTPRelated(e11) {
        if (!e11.payloads) return "";
        const t4 = e11.payloads;
        let i4 = "";
        i4 += e11.rtcpFeedbackWildcards.map((e12) => this.printRTCPFeedback("*", e12)).join("");
        for (const e12 of t4) i4 += this.printRtpMap(e12.payloadType, e12.rtpMap), i4 += this.printFmtp(e12.payloadType, e12.fmtp), i4 += e12.rtcpFeedbacks.map((t5) => this.printRTCPFeedback(e12.payloadType, t5)).join("");
        return i4;
      }
      printFmtp(e11, t4) {
        if (!t4) return "";
        const i4 = Object.keys(t4.parameters);
        return 1 === i4.length && null === t4.parameters[i4[0]] ? "a=fmtp:".concat(e11).concat(o2).concat(i4[0]).concat(this.eol) : "a=fmtp:".concat(e11).concat(o2).concat(Object.keys(t4.parameters).map((e12) => "".concat(e12, "=").concat(t4.parameters[e12])).join(";")).concat(this.eol);
      }
      printRtpMap(e11, t4) {
        return t4 ? "a=rtpmap:".concat(e11).concat(o2).concat(t4.encodingName, "/").concat(t4.clockRate).concat(t4.encodingParameters ? "/".concat(t4.encodingParameters) : "").concat(this.eol) : "";
      }
      printRTCPFeedback(e11, t4) {
        let i4 = "a=rtcp-fb:".concat(e11).concat(o2), n3 = t4;
        return "trr-int" === n3.type ? i4 += "ttr-int".concat(o2).concat(n3.interval) : (i4 += "".concat(n3.type), n3.parameter && (i4 += "".concat(o2).concat(n3.parameter), n3.additional && (i4 += "".concat(o2).concat(n3.additional)))), i4 + this.eol;
      }
      printPtime(e11) {
        return void 0 === e11 ? "" : "a=ptime:".concat(e11).concat(this.eol);
      }
      printMaxPtime(e11) {
        return void 0 === e11 ? "" : "a=maxptime:".concat(e11).concat(this.eol);
      }
      printDirection(e11) {
        return void 0 === e11 ? "" : "a=".concat(e11).concat(this.eol);
      }
      printSSRC(e11) {
        return e11.map((e12) => Object.keys(e12.attributes).map((t4) => "a=ssrc:".concat(e12.ssrcId.toString(10)).concat(o2).concat(t4).concat(e12.attributes[t4] ? ":".concat(e12.attributes[t4]) : "").concat(this.eol)).join("")).join("");
      }
      printRTCPMux(e11) {
        return void 0 === e11 ? "" : "a=rtcp-mux".concat(this.eol);
      }
      printRTCPMuxOnly(e11) {
        return void 0 === e11 ? "" : "a=rtcp-mux-only".concat(this.eol);
      }
      printRTCPRsize(e11) {
        return void 0 === e11 ? "" : "a=rtcp-rsize".concat(this.eol);
      }
      printRTCP(e11) {
        if (void 0 === e11) return "";
        let t4 = "a=rtcp:".concat(e11.port);
        return e11.netType && (t4 += "".concat(o2).concat(e11.netType)), e11.addressType && (t4 += "".concat(o2).concat(e11.addressType)), e11.address && (t4 += "".concat(o2).concat(e11.address)), t4 + this.eol;
      }
      printMSId(e11) {
        return e11.map((e12) => "a=msid:".concat(e12.id).concat(e12.appdata ? "".concat(o2).concat(e12.appdata) : "").concat(this.eol)).join("");
      }
      printImageattr(e11) {
        return e11.map((e12) => "a=imageattr:".concat(e12).concat(this.eol)).join("");
      }
      printRid(e11) {
        return e11.map((e12) => {
          let t4 = "a=rid:".concat(e12.id).concat(o2).concat(e12.direction);
          return e12.payloads && (t4 += "".concat(o2, "pt=").concat(e12.payloads.join(","))), e12.params.length > 0 && (t4 += "".concat(o2).concat(e12.params.map((e13) => "depend" === e13.type ? "depend=".concat(e13.rids.join(",")) : "".concat(e13.type, "=").concat(e13.val)).join(";"))), t4 + this.eol;
        }).join("");
      }
      printSimulcast(e11) {
        return void 0 === e11 ? "" : "a=simulcast:".concat(e11).concat(this.eol);
      }
      printSCTPPort(e11) {
        return void 0 === e11 ? "" : "a=sctp-port:".concat(e11).concat(this.eol);
      }
      printMaxMessageSize(e11) {
        return void 0 === e11 ? "" : "a=max-message-size:".concat(e11).concat(this.eol);
      }
      printMid(e11) {
        return void 0 === e11 ? "" : "a=mid:".concat(e11).concat(this.eol);
      }
      printSSRCGroups(e11) {
        return e11.map((e12) => "a=ssrc-group:".concat(e12.semantic).concat(e12.ssrcIds.map((e13) => "".concat(o2).concat(e13.toString(10))).join("")).concat(this.eol)).join("");
      }
    }
    function D2(e11) {
      return new C2().parse(e11);
    }
    function P2(e11, t4) {
      return new b2().print(e11, t4);
    }
  } }, t2 = {};
  function i2(n2) {
    if (t2[n2]) return t2[n2].exports;
    var r2 = t2[n2] = { exports: {} };
    return e9[n2](r2, r2.exports, i2), r2.exports;
  }
  return i2.d = (e10, t3) => {
    for (var n2 in t3) i2.o(t3, n2) && !i2.o(e10, n2) && Object.defineProperty(e10, n2, { enumerable: true, get: t3[n2] });
  }, i2.o = (e10, t3) => Object.prototype.hasOwnProperty.call(e10, t3), i2.r = (e10) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e10, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e10, "__esModule", { value: true });
  }, i2(8);
})();
var FU = VU.exports;
function BU() {
  let e9 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : XA("SVC_MODE");
  if (XA("ENABLE_SVC")) return function(e10) {
    return e10 in Iw;
  }(e9) ? e9 : Iw.L1T3;
}
function jU(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function GU(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? jU(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : jU(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
function WU(e9) {
  let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n2 = arguments.length > 3 ? arguments[3] : void 0;
  const { filterRTX: r2, filterVideoFec: o2, filterAudioFec: s2, filterAudioCodec: a2, filterVideoCodec: c2 } = t2, { useXR: d2 } = i2;
  let l2 = [], u2 = [], h2 = [], p2 = [], _2 = false, E2 = false;
  if (FU.parse(e9).mediaDescriptions.forEach((e10) => {
    n2 && n2 !== e10.attributes.direction || ("video" !== e10.media.mediaType || _2 || (u2 = e10.attributes.payloads, p2 = e10.attributes.extmaps, _2 = true), "audio" !== e10.media.mediaType || E2 || (l2 = e10.attributes.payloads, h2 = e10.attributes.extmaps, E2 = true));
  }), !p2 || 0 === u2.length) throw new Error("Cannot get video capabilities from SDP.");
  if (!h2 || 0 === l2.length) throw new Error("Cannot get audio capabilities from SDP.");
  if (u2.forEach((e10) => {
    var t3;
    null !== (t3 = e10.rtpMap) && void 0 !== t3 && t3.clockRate && (e10.rtpMap.clockRate = parseInt(e10.rtpMap.clockRate)), d2 && e10.rtcpFeedbacks.push({ type: "rrtr" });
  }), l2.forEach((e10) => {
    var t3;
    null !== (t3 = e10.rtpMap) && void 0 !== t3 && t3.clockRate && (e10.rtpMap.clockRate = parseInt(e10.rtpMap.clockRate)), d2 && e10.rtcpFeedbacks.push({ type: "rrtr" });
  }), r2 && (l2 = l2.filter((e10) => {
    var t3;
    return "rtx" !== (null === (t3 = e10.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
  }), u2 = u2.filter((e10) => {
    var t3;
    return "rtx" !== (null === (t3 = e10.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
  })), o2 && (u2 = u2.filter((e10) => {
    var t3;
    return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t3 = e10.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName) || "");
  })), s2 && (l2 = l2.filter((e10) => {
    var t3;
    return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t3 = e10.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName) || "");
  })), a2 && (null == a2 ? void 0 : a2.length) > 0 && (l2 = l2.filter((e10) => {
    var t3;
    return Dn(a2).call(a2, (null === (t3 = e10.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
  })), c2 && (null == c2 ? void 0 : c2.length) > 0) {
    const e10 = u2.filter((e11) => {
      var t3;
      return Dn(c2).call(c2, (null === (t3 = e11.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
    });
    u2 = e10.concat(r2 ? [] : ax(e10, u2));
  }
  const f2 = XA("UNSUPPORTED_VIDEO_CODEC");
  return f2 && f2.length > 0 && (u2 = u2.filter((e10) => !(e10.rtpMap && Dn(f2).call(f2, e10.rtpMap.encodingName.toLowerCase())))), { audioCodecs: l2, videoCodecs: u2, audioExtensions: h2, videoExtensions: p2 };
}
function HU(e9) {
  const t2 = FU.parse(e9);
  let i2, n2;
  for (const e10 of t2.mediaDescriptions) {
    if (!i2) {
      const t3 = e10.attributes.iceUfrag, n3 = e10.attributes.icePwd;
      if (!t3 || !n3) throw new Error("Cannot get iceUfrag or icePwd from SDP.");
      i2 = { iceUfrag: t3, icePwd: n3 };
    }
    if (!n2) {
      const t3 = e10.attributes.fingerprints;
      t3.length > 0 && (n2 = { fingerprints: t3 });
    }
  }
  if (!n2 && t2.attributes.fingerprints.length > 0 && (n2 = { fingerprints: t2.attributes.fingerprints }), !n2 || !i2) throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");
  return { iceParameters: i2, dtlsParameters: n2 };
}
function KU(e9, t2) {
  const i2 = [], n2 = e9.attributes.ssrcGroups.filter((e10) => "FID" === e10.semantic), r2 = e9.attributes.ssrcGroups.find((e10) => "SIM" === e10.semantic), o2 = e9.attributes.ssrcs;
  if (r2) r2.ssrcIds.forEach((e10) => {
    var r3;
    const o3 = null === (r3 = n2.find((t3) => t3.ssrcIds[0] === e10)) || void 0 === r3 ? void 0 : r3.ssrcIds[1];
    i2.push({ ssrcId: e10, rtx: t2 ? o3 : void 0 });
  });
  else if (n2.length > 0) {
    const e10 = n2[0].ssrcIds[0], r3 = n2[0].ssrcIds[1];
    i2.push({ ssrcId: e10, rtx: t2 ? r3 : void 0 });
  } else {
    if (0 === o2.length) throw new Error("No ssrcs found on local media description.");
    i2.push({ ssrcId: o2[0].ssrcId });
  }
  return i2;
}
function YU(e9, t2, i2) {
  const { cname: n2 } = e9;
  let r2 = [];
  t2 && (r2 = qU(t2)), 0 === r2.length && (r2 = e9.iceParameters.candidates.map((e10) => ({ foundation: e10.foundation, componentId: "1", transport: e10.protocol, priority: e10.priority.toString(), connectionAddress: e10.ip, port: e10.port.toString(), type: e10.type, extension: {} })), fb.debug("Using candidates from gateway."));
  const o2 = { fingerprints: e9.dtlsParameters.fingerprints.map((e10) => ({ hashFunction: e10.algorithm, fingerprint: e10.fingerprint })) }, s2 = { iceUfrag: e9.iceParameters.iceUfrag, icePwd: e9.iceParameters.icePwd };
  let a2;
  switch (e9.dtlsParameters.role) {
    case "server":
      a2 = "passive";
      break;
    case "client":
      a2 = "active";
      break;
    case "auto":
      a2 = "actpass";
  }
  const c2 = rx(e9.rtpCapabilities), d2 = [];
  return Array.isArray(i2) && i2.length > 0 && i2.forEach((e10) => {
    d2.push({ kind: dO.VIDEO, ssrcId: e10.v, rtx: e10.v_rtx, mslabel: "".concat(e10.v, "_").concat(e10.a) }, { kind: dO.AUDIO, ssrcId: e10.a, mslabel: "".concat(e10.v, "_").concat(e10.a) });
  }), { dtlsParameters: o2, iceParameters: s2, candidates: r2, rtpCapabilities: c2, setup: a2, cname: n2, preSSRCs: d2 };
}
function qU(e9) {
  let t2 = [];
  return e9.ip && "number" == typeof e9.port && (t2 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e9.ip, port: e9.port.toString(), type: "host", extension: {} }], fb.debug("Using remote candidate from AP ".concat(e9.ip, ":").concat(e9.port)), e9.ip6 && (t2.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e9.ip6, port: e9.port.toString(), type: "host", extension: {} }), fb.debug("Using IPV6 remote candidate from AP ".concat(e9.ip6, ":").concat(e9.port)))), t2;
}
function zU(e9, t2, i2) {
  const n2 = [], r2 = [];
  return e9.forEach((e10) => {
    let { ssrcId: o2, rtx: s2 } = e10;
    const a2 = TA(8, "track-"), c2 = { ssrcId: o2, attributes: GU({ label: a2, mslabel: i2 = i2 || TA(10, ""), msid: "".concat(i2, " ").concat(a2) }, t2 && { cname: t2 }) };
    if (n2.push(c2), void 0 !== s2) {
      const e11 = { ssrcId: s2, attributes: GU({ label: a2, mslabel: i2, msid: "".concat(i2, " ").concat(a2) }, t2 && { cname: t2 }) };
      n2.push(e11), r2.push({ semantic: "FID", ssrcIds: [o2, s2] });
    }
  }), e9.length > 1 && r2.push({ semantic: "SIM", ssrcIds: e9.map((e10) => {
    let { ssrcId: t3 } = e10;
    return t3;
  }) }), { ssrcs: n2, ssrcGroups: r2 };
}
function JU(e9, t2) {
  t2 instanceof TM && e9.attributes.payloads.forEach((e10) => {
    var i2;
    const n2 = null === (i2 = e10.rtpMap) || void 0 === i2 ? void 0 : i2.encodingName.toLowerCase();
    if (!n2 || -1 === ["opus", "pcmu", "pcma", "g722"].indexOf(n2)) return;
    e10.fmtp || (e10.fmtp = { parameters: {} }), e10.fmtp.parameters.minptime = "10", e10.fmtp.parameters.useinbandfec = "1";
    const r2 = t2._encoderConfig;
    r2 && "pcmu" !== n2 && "pcma" !== n2 && "g722" !== n2 && (r2.bitrate && !Zv() && (e10.fmtp.parameters.maxaveragebitrate = "".concat(Math.floor(1e3 * r2.bitrate))), r2.sampleRate && (e10.fmtp.parameters.maxplaybackrate = "".concat(r2.sampleRate), e10.fmtp.parameters["sprop-maxcapturerate"] = "".concat(r2.sampleRate)), r2.stereo && (e10.fmtp.parameters.stereo = "1", e10.fmtp.parameters["sprop-stereo"] = "1"));
  });
}
function XU(e9) {
  const t2 = e9.attributes.unrecognized.findIndex((e10) => "x-google-flag" === e10.attField && "conference" === e10.attValue);
  -1 !== t2 && e9.attributes.unrecognized.splice(t2, 1);
}
function QU(e9, t2) {
  var i2;
  if (!(t2 instanceof aU && t2._encoderConfig && -1 === t2._hints.indexOf(mL.SCREEN_TRACK))) return;
  const n2 = t2._encoderConfig;
  ZP().supportMinBitrate && n2.bitrateMin && e9.attributes.payloads.forEach((e10) => {
    var t3, i3;
    Dn(t3 = ["h264", "h265", "vp8", "vp9", "av1"]).call(t3, (null === (i3 = e10.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName.toLowerCase()) || "") && (e10.fmtp || (e10.fmtp = { parameters: {} }), e10.fmtp.parameters["x-google-min-bitrate"] = "".concat(n2.bitrateMin));
  }), ZP().supportMinBitrate && !Dn(i2 = t2._hints).call(i2, mL.LOW_STREAM) && n2.bitrateMax && e9.attributes.payloads.forEach((e10) => {
    var t3, i3;
    Dn(t3 = ["h264", "h265", "vp8", "vp9", "av1"]).call(t3, (null === (i3 = e10.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName.toLowerCase()) || "") && (e10.fmtp || (e10.fmtp = { parameters: {} }), e10.fmtp.parameters["x-google-start-bitrate"] = "".concat(XA("X_GOOGLE_START_BITRATE") || Math.floor(n2.bitrateMax)));
  });
}
function ZU(e9) {
  if ("video" !== e9.media.mediaType) return;
  const t2 = Hv();
  if (t2.name !== Bv.SAFARI && t2.os !== Fv.IOS) return;
  const i2 = e9.attributes.extmaps.findIndex((e10) => /video-orientation/g.test(e10.extensionName));
  -1 !== i2 && e9.attributes.extmaps.splice(i2, 1);
}
function $U(e9, t2, i2) {
  if (!t2) return;
  let n2, r2;
  if ("video" === e9.media.mediaType ? (n2 = i2.videoExtensions, r2 = i2.videoCodecs) : (n2 = i2.audioExtensions, r2 = i2.audioCodecs), true === t2.twcc) {
    const t3 = n2.find((e10) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e10.extensionName);
    if (t3) {
      e9.attributes.extmaps.find((e10) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e10.extensionName) || e9.attributes.extmaps.push({ entry: t3.entry, extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" });
      const i3 = function(e10, t4) {
        return t4.filter((t5) => !!e10.find((e11) => e11.payloadType === t5.payloadType && !!e11.rtcpFeedbacks.find((e12) => "transport-cc" === e12.type)));
      }(r2, e9.attributes.payloads);
      i3.forEach((e10) => {
        e10.rtcpFeedbacks.find((e11) => "transport-cc" === e11.type) || e10.rtcpFeedbacks.push({ type: "transport-cc" });
      });
    }
  } else if (false === t2.twcc) {
    const t3 = e9.attributes.extmaps.findIndex((e10) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e10.extensionName);
    -1 !== t3 && e9.attributes.extmaps.splice(t3, 1), e9.attributes.payloads.forEach((e10) => {
      const t4 = e10.rtcpFeedbacks.findIndex((e11) => "transport-cc" === e11.type);
      -1 !== t4 && e10.rtcpFeedbacks.splice(t4, 1);
    });
  }
  if (true === t2.remb) {
    const t3 = n2.find((e10) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e10.extensionName);
    if (t3) {
      e9.attributes.extmaps.find((e10) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e10.extensionName) || e9.attributes.extmaps.push({ entry: t3.entry, extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" });
      const i3 = function(e10, t4) {
        return t4.filter((t5) => !!e10.find((e11) => e11.payloadType === t5.payloadType && !!e11.rtcpFeedbacks.find((e12) => "goog-remb" === e12.type)));
      }(r2, e9.attributes.payloads);
      i3.forEach((e10) => {
        e10.rtcpFeedbacks.find((e11) => "goog-remb" === e11.type) || e10.rtcpFeedbacks.push({ type: "goog-remb" });
      });
    }
  } else if (false === t2.remb) {
    const t3 = e9.attributes.extmaps.findIndex((e10) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e10.extensionName);
    -1 !== t3 && e9.attributes.extmaps.splice(t3, 1), e9.attributes.payloads.forEach((e10) => {
      const t4 = e10.rtcpFeedbacks.findIndex((e11) => "goog-remb" === e11.type);
      -1 !== t4 && e10.rtcpFeedbacks.splice(t4, 1);
    });
  }
}
function ex(e9, t2, i2) {
  if (Zv()) return;
  if ("video" !== e9.media.mediaType) return;
  if (!(t2 instanceof aU)) return;
  if ("vp9" !== i2 && "vp8" !== i2) return;
  if ("vp8" === i2 && !XA("SIMULCAST")) return;
  if ("vp9" === i2 && XA("ENABLE_SVC")) return;
  if (void 0 === t2._scalabilityMode || t2._scalabilityMode.numSpatialLayers <= 1) return;
  const n2 = "vp8" === i2 ? 2 : t2._scalabilityMode.numSpatialLayers, r2 = e9.attributes.ssrcs[0], o2 = e9.attributes.ssrcGroups.find((e10) => "FID" === e10.semantic && e10.ssrcIds[0] === r2.ssrcId), s2 = { semantic: "SIM", ssrcIds: [r2.ssrcId] };
  for (let t3 = 1; t3 < n2; t3++) e9.attributes.ssrcs.push({ ssrcId: r2.ssrcId + t3, attributes: sA(r2.attributes) }), s2.ssrcIds.push(r2.ssrcId + t3), o2 && (e9.attributes.ssrcs.push({ ssrcId: o2.ssrcIds[1] + t3, attributes: sA(r2.attributes) }), e9.attributes.ssrcGroups.push({ semantic: "FID", ssrcIds: [r2.ssrcId + t3, o2.ssrcIds[1] + t3] }));
  e9.attributes.ssrcGroups.unshift(s2);
}
async function tx() {
  let e9 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  const i2 = new RTCPeerConnection();
  i2.addTransceiver("video", { direction: "sendonly" }), i2.addTransceiver("audio", { direction: "sendonly" }), i2.addTransceiver("video", { direction: "recvonly" }), i2.addTransceiver("audio", { direction: "recvonly" });
  const n2 = (await i2.createOffer()).sdp, { send: r2, recv: o2, sendrecv: s2 } = function() {
    let e10 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i3 = arguments.length > 2 ? arguments[2] : void 0;
    const n3 = WU(i3, e10, t3, "sendonly"), r3 = WU(i3, e10, t3, "recvonly"), o3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, s3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, a2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
    if (nx(n3, r3, "videoExtensions", o3, s3, a2), nx(n3, r3, "videoCodecs", o3, s3, a2), nx(n3, r3, "audioExtensions", o3, s3, a2), nx(n3, r3, "audioCodecs", o3, s3, a2), XA("RAISE_H264_BASELINE_PRIORITY")) {
      const e11 = a2.videoCodecs.findIndex((e12) => {
        var t4, i4;
        return "h264" === (null === (t4 = e12.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLocaleLowerCase()) && "42001f" === (null === (i4 = e12.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]);
      });
      if (-1 !== e11) {
        const t4 = a2.videoCodecs.findIndex((e12) => {
          var t5;
          return "h264" === (null === (t5 = e12.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName.toLocaleLowerCase());
        });
        if (t4 < e11) {
          fb.debug("raising H264 baseline profile priority");
          const i4 = a2.videoCodecs[e11];
          a2.videoCodecs.splice(e11, 1), a2.videoCodecs.splice(t4, 0, i4);
        }
        -1 !== t4 && (s3.videoCodecs = s3.videoCodecs.filter((e12) => {
          var t5, i4;
          return !("h264" === (null === (t5 = e12.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (i4 = e12.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]));
        })), -1 !== t4 && XA("FILTER_SEND_H264_BASELINE") && (o3.videoCodecs = o3.videoCodecs.filter((e12) => {
          var t5, i4;
          return !("h264" === (null === (t5 = e12.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (i4 = e12.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]));
        }));
      }
    }
    return { send: o3, recv: s3, sendrecv: a2 };
  }(e9, t2, n2);
  try {
    i2.close();
  } catch (e10) {
  }
  return { send: r2, recv: o2, sendrecv: s2 };
}
function ix() {
  const e9 = { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, t2 = WU(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, "recvonly"), i2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, n2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
  if (nx(e9, t2, "videoExtensions", i2, n2, r2), nx(e9, t2, "videoCodecs", i2, n2, r2), nx(e9, t2, "audioExtensions", i2, n2, r2), nx(e9, t2, "audioCodecs", i2, n2, r2), XA("RAISE_H264_BASELINE_PRIORITY")) {
    const e10 = r2.videoCodecs.findIndex((e11) => e11.rtpMap && "h264" === e11.rtpMap.encodingName.toLocaleLowerCase() && e11.fmtp && "42001f" === e11.fmtp.parameters["profile-level-id"]);
    if (-1 !== e10) {
      const t3 = r2.videoCodecs.findIndex((e11) => e11.rtpMap && "h264" === e11.rtpMap.encodingName.toLocaleLowerCase());
      if (t3 < e10) {
        fb.debug("raising H264 baseline profile priority");
        const i3 = r2.videoCodecs[e10];
        r2.videoCodecs.splice(e10, 1), r2.videoCodecs.splice(t3, 0, i3);
      }
      -1 !== t3 && (n2.videoCodecs = n2.videoCodecs.filter((e11) => !(e11.rtpMap && "h264" === e11.rtpMap.encodingName.toLocaleLowerCase() && e11.fmtp && "42001f" !== e11.fmtp.parameters["profile-level-id"])));
    }
  }
  return { send: i2, recv: n2, sendrecv: r2 };
}
function nx(e9, t2, i2, n2, r2, o2) {
  if ("videoExtensions" === i2 || "audioExtensions" === i2) {
    const s2 = [];
    return e9[i2].forEach((e10) => {
      t2[i2].some((t3, i3) => {
        if (e10.entry === t3.entry && e10.extensionName === t3.extensionName) return s2.push(i3), true;
      }) ? o2[i2].push(e10) : n2[i2].push(e10);
    }), void t2[i2].forEach((e10, t3) => {
      -1 === s2.indexOf(t3) && r2[i2].push(e10);
    });
  }
  if ("videoCodecs" === i2 || "audioCodecs" === i2) {
    const s2 = [];
    return e9[i2].forEach((e10) => {
      t2[i2].some((t3, i3) => {
        if (e10.payloadType === t3.payloadType && JSON.stringify(e10) === JSON.stringify(t3)) return s2.push(i3), true;
      }) ? o2[i2].push(e10) : n2[i2].push(e10);
    }), void t2[i2].forEach((e10, t3) => {
      -1 === s2.indexOf(t3) && r2[i2].push(e10);
    });
  }
}
function rx(e9) {
  const { send: t2, recv: i2, sendrecv: n2 } = e9;
  if (!n2) {
    if (!t2 || !i2) throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");
    return { send: t2, recv: i2 };
  }
  let r2, o2;
  return t2 ? (r2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r2.audioCodecs = [...t2.audioCodecs, ...n2.audioCodecs], r2.videoCodecs = [...t2.videoCodecs, ...n2.videoCodecs], r2.audioExtensions = [...t2.audioExtensions, ...n2.audioExtensions], r2.videoExtensions = [...t2.videoExtensions, ...n2.videoExtensions]) : r2 = n2, i2 ? (o2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, o2.audioCodecs = [...i2.audioCodecs, ...n2.audioCodecs], o2.videoCodecs = [...i2.videoCodecs, ...n2.videoCodecs], o2.audioExtensions = [...i2.audioExtensions, ...n2.audioExtensions], o2.videoExtensions = [...i2.videoExtensions, ...n2.videoExtensions]) : o2 = n2, { send: r2, recv: o2 };
}
function ox(e9) {
  if ("audio" !== e9.media.mediaType) return;
  e9.attributes.payloads.filter((e10) => {
    var t2;
    return "opus" === (null === (t2 = e10.rtpMap) || void 0 === t2 ? void 0 : t2.encodingName.toLowerCase());
  }).forEach((e10) => {
    e10.fmtp || (e10.fmtp = { parameters: {} }), e10.fmtp.parameters.stereo = "1", e10.fmtp.parameters["sprop-stereo"] = "1";
  });
}
function sx(e9, t2, i2, n2) {
  let r2 = [];
  if (e9 === dO.VIDEO) {
    if (XA("H264_PROFILE_LEVEL_ID") && "h264" === n2 && (r2 = t2.videoCodecs.filter((e10) => {
      var t3;
      return Dn(t3 = e10.rtpMap && e10.rtpMap.encodingName.toLowerCase() || "").call(t3, n2) && e10 && e10.fmtp && e10.fmtp.parameters["profile-level-id"] === XA("H264_PROFILE_LEVEL_ID");
    })), !Array.isArray(r2) || 0 === r2.length) {
      let e10 = [];
      const o2 = [], s2 = [], a2 = [];
      if (i2.videoCodecs.forEach((t3) => {
        const i3 = t3.rtpMap && t3.rtpMap.encodingName.toLowerCase() || "";
        Dn(i3).call(i3, n2) ? e10.push(t3) : Dn(i3).call(i3, "vp9") ? o2.push(t3) : Dn(i3).call(i3, "vp8") ? s2.push(t3) : Dn(i3).call(i3, "h264") && a2.push(t3);
      }), 0 === e10.length) {
        let t3 = "";
        0 !== o2.length ? (e10 = o2, t3 = "vp9") : 0 !== s2.length ? (e10 = s2, t3 = "vp8") : 0 !== a2.length && (e10 = a2, t3 = "h264"), fb.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: ").concat(t3));
      }
      0 !== e10.length && (r2 = t2.videoCodecs.filter((t3) => e10.some((e11) => e11.payloadType === t3.payloadType)));
    }
    if (0 === r2.length && (fb.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: ").concat(t2.videoCodecs[0].rtpMap && t2.videoCodecs[0].rtpMap.encodingName)), r2 = t2.videoCodecs), XA("USE_PUB_RTX") || XA("USE_SUB_RTX")) {
      const e10 = ax(r2, t2.videoCodecs);
      r2 = [...r2, ...e10];
    }
  } else r2 = t2.audioCodecs.filter((e10) => {
    var t3;
    return Dn(t3 = e10.rtpMap && e10.rtpMap.encodingName.toLowerCase() || "").call(t3, n2);
  }), 0 === r2.length && (fb.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to opus")), r2 = t2.audioCodecs.filter((e10) => {
    var t3;
    return Dn(t3 = e10.rtpMap && e10.rtpMap.encodingName.toLowerCase() || "").call(t3, "opus");
  }));
  return r2;
}
function ax(e9, t2) {
  const i2 = e9.map((e10) => e10.payloadType.toString());
  return t2.filter((e10) => e10.rtpMap && "rtx" === e10.rtpMap.encodingName && e10.fmtp && e10.fmtp.parameters.apt && Dn(i2).call(i2, e10.fmtp && e10.fmtp.parameters.apt));
}
async function cx(e9, t2, i2) {
  const n2 = t2.toString(), r2 = lx(n2, "offer", "remote", "exchangeSDP");
  await e9.setRemoteDescription({ type: "offer", sdp: n2 });
  const o2 = await e9.createAnswer();
  if (!o2.sdp) throw new Error("cannot get answer sdp");
  let s2 = o2.sdp;
  s2 = dx(s2, i2 || {}), null == r2 || r2(s2 || ""), await e9.setLocalDescription({ type: "answer", sdp: s2 });
}
function dx(e9, t2, i2) {
  const n2 = FU.parse(e9), { useXR: r2 } = t2;
  return n2.mediaDescriptions.forEach((e10) => {
    var t3;
    e10.attributes.mid && (Array.isArray(i2) && !Dn(i2).call(i2, e10.attributes.mid) || ("audio" === e10.media.mediaType && ox(e10), r2 && Dn(t3 = ["audio", "video"]).call(t3, e10.media.mediaType) && e10.attributes.payloads.forEach((e11) => {
      -1 === e11.rtcpFeedbacks.findIndex((e12) => "rrtr" === e12.type) && e11.rtcpFeedbacks.push({ type: "rrtr" });
    })));
  }), FU.print(n2);
}
function lx(e9, t2, i2, n2) {
  if (XA("SDP_LOGGING")) return fb.upload("exchanging ".concat(i2, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e9), "offer" === t2 ? (e10) => {
    lx(e10, "answer", "local" === i2 ? "remote" : "local", n2);
  } : void 0;
}
function ux(e9, t2) {
  return typeof XA(e9) === t2 ? XA(e9) : void 0;
}
function hx(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function px(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? hx(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : hx(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var _x = /* @__PURE__ */ new Map();
var Ex = class extends xy {
  get state() {
    return this._state;
  }
  set state(e9) {
    if (e9 === this._state) return;
    const t2 = this._state;
    this._state = e9, "DISCONNECTED" === e9 && this._disconnectedReason ? this.emit($w.CONNECTION_STATE_CHANGE, e9, t2, this._disconnectedReason) : this.emit($w.CONNECTION_STATE_CHANGE, e9, t2);
  }
  get joinGatewayStartTime() {
    return this._joinGatewayStartTime;
  }
  set joinGatewayStartTime(e9) {
    fb.debug("[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e9)), this._joinGatewayStartTime = e9;
  }
  constructor(e9, t2) {
    super(), Fg(this, "store", void 0), Fg(this, "joinInfo", void 0), Fg(this, "key", void 0), Fg(this, "ntpOffset", 0), Fg(this, "signal", void 0), Fg(this, "role", void 0), Fg(this, "inChannelInfo", { joinAt: null, duration: 0 }), Fg(this, "spec", void 0), Fg(this, "_state", "DISCONNECTED"), Fg(this, "_statsCollector", void 0), Fg(this, "_disconnectedReason", void 0), Fg(this, "isSignalRecover", false), Fg(this, "hasChangeBGPAddress", false), Fg(this, "trafficStatsInterval", void 0), Fg(this, "networkQualityInterval", void 0), Fg(this, "_joinGatewayStartTime", 0), Fg(this, "_signalTimeout", false), Fg(this, "_clientRoleOptions", void 0), Fg(this, "_isProactiveJoin", false), this.store = e9, this.spec = t2, this.signal = this.store.useP2P ? new xU(px(px({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e9) : new KO(px(px({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e9), this._statsCollector = t2.statsCollector, this.role = t2.role || "audience", this._clientRoleOptions = t2.clientRoleOptions, this.handleSignalEvents();
  }
  async join(e9, t2, i2) {
    this.store.joinGatewayStart(), "disabled" !== e9.cloudProxyServer && (this.hasChangeBGPAddress = true);
    const n2 = Date.now();
    let r2 = _x.get(e9.cname);
    if (r2 || (r2 = /* @__PURE__ */ new Map(), _x.set(e9.cname, r2)), this._isProactiveJoin = true, r2.has(e9.uid)) {
      const t3 = new yb(Ry.UID_CONFLICT);
      throw vb.joinGateway(e9.sid, { lts: n2, succ: false, ec: t3.code, addr: null, uid: e9.uid, cid: e9.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!e9.proxyServer, signalChannel: "0", preload: e9.preload }), this._isProactiveJoin = false, t3;
    }
    r2.set(e9.uid, true), this.joinInfo = e9, this.key = t2;
    let o2 = 0;
    this.joinGatewayStartTime = n2;
    const s2 = e9.proxyServer;
    try {
      fb.debug("[".concat(this.store.clientId, "] use websocket join uid ").concat(o2));
      const t3 = e9.gatewayAddrs.map((t4) => {
        let { address: i3 } = t4;
        const [n3, r3] = i3.split(":"), o3 = { host: n3, port: r3 };
        return e9.proxyServer && (o3.proxy = e9.proxyServer), o3;
      });
      o2 = (await this.signal.init(t3, i2)).uid, fb.debug("[".concat(this.store.clientId, "] websocket join uid ").concat(o2, " cost ").concat(Date.now() - this.joinGatewayStartTime));
    } catch (t3) {
      var a2;
      throw fb.error("[".concat(this.store.clientId, "] User join failed"), t3.toString()), vb.joinGateway(e9.sid, { lts: n2, succ: false, ec: (null === (a2 = t3.data) || void 0 === a2 ? void 0 : a2.desc) || t3.code, errorMsg: t3.message, addr: this.signal.url, uid: e9.uid, cid: e9.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!s2, signalChannel: "0", preload: e9.preload }), this._isProactiveJoin = false, r2.delete(e9.uid), this.signal.close(), t3;
    }
    return this.state = "CONNECTED", this.inChannelInfo.joinAt = Date.now(), fb.debug("[".concat(this.store.clientId, "] Connected to gateway server")), this.trafficStatsInterval = window.setInterval(() => {
      this.updateTrafficStats().catch((e10) => {
        fb.warning("[".concat(this.store.clientId, "] get traffic stats error"), e10.toString());
      });
    }, 3e3), this.networkQualityInterval = window.setInterval(() => {
      navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit($w.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 }) : this._signalTimeout ? this.emit($w.NETWORK_QUALITY, { downlinkNetworkQuality: 5, uplinkNetworkQuality: 5 }) : "CONNECTED" === this.state && this._statsCollector.trafficStats ? this.emit($w.NETWORK_QUALITY, { uplinkNetworkQuality: $O(this._statsCollector.trafficStats.B_unq), downlinkNetworkQuality: $O(this._statsCollector.trafficStats.B_dnq) }) : this.emit($w.NETWORK_QUALITY, { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 });
    }, 2e3), this.store.joinGatewayEnd(), o2;
  }
  async leave() {
    let e9 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t2 = arguments.length > 1 ? arguments[1] : void 0;
    if ("DISCONNECTED" !== this.state) {
      t2 !== Hy.FALLBACK && (this.state = "DISCONNECTING");
      try {
        e9 || this.signal.connectionState !== Nw.CONNECTED || await function(e10, t3) {
          return t3 === 1 / 0 ? e10 : Gh.race([e10, fA(t3)]);
        }(this.signal.request(Pw.LEAVE, void 0, true), 3e3);
      } catch (e10) {
        fb.warning("[".concat(this.store.clientId, "] leave request failed, ignore"), e10);
      }
      this.signal.close(t2), t2 !== Hy.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
    }
  }
  async publish(e9, t2, i2) {
    if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new yb(Ry.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
    const n2 = { state: "offer", p2p_id: this.store.p2pId, ortc: t2, mode: this.spec.mode, extend: XA("PUB_EXTEND"), twcc: !!XA("PUBLISH_TWCC"), rtx: !!XA("USE_PUB_RTX") };
    try {
      return (await this.signal.request(Pw.PUBLISH, n2, true))._message;
    } catch (n3) {
      if (i2 && n3.data && n3.data.code === Ow.ERR_PUBLISH_REQUEST_INVALID) return fb.warning("[".concat(this.store.clientId, "] receive publish error code, retry"), n3.toString()), await this.tryUnpubBeforeRepub(e9, t2), this.publish(e9, t2, false);
      throw n3;
    }
  }
  async publishDataChannel(e9, t2, i2) {
    var n2;
    if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new yb(Ry.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
    const r2 = { stream_id: t2.streamId, ordered: t2.ordered ? 1 : 0, max_retrans_times: null !== (n2 = t2.maxRetransmits) && void 0 !== n2 ? n2 : 10, channel_id: t2.channelId, metadata: t2.metadata };
    try {
      await this.signal.request(Pw.PUBLISH_DATASTREAM, r2, true);
    } catch (n3) {
      if (i2 && n3.data && n3.data.code === Ow.ERR_PUBLISH_REQUEST_INVALID) return fb.warning("[".concat(this.store.clientId, "] receive publish datachannels error code, retry"), n3.toString()), await this.tryUnpubDataChannelBeforeRepub(e9, t2), this.publishDataChannel(e9, t2, false);
      throw n3;
    }
  }
  async unpublish(e9, t2) {
    try {
      if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new yb(Ry.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
      await this.signal.request(Pw.UNPUBLISH, { stream_id: t2, ortc: e9 }, true);
    } catch (e10) {
      fb.warning("[".concat(this.store.clientId, "] unpublish warning: "), e10);
    }
  }
  async unpublishDataChannel(e9) {
    try {
      if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new yb(Ry.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
      await Gh.all(e9.map((e10) => this.signal.request(Pw.UNPUBLISH_DATASTREAM, { channel_id: e10 }, true)));
    } catch (e10) {
      fb.warning("unpublish datachannels warning: ", e10);
    }
  }
  async presubscribe(e9, t2, i2) {
    if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new yb(Ry.INVALID_OPERATION, "can not presubscribe when connection state is ".concat(this.state));
    const n2 = { stream_id: e9, stream_type: t2, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!XA("SUBSCRIBE_TWCC"), rtx: !!XA("USE_SUB_RTX") || void 0, extend: XA("SUB_EXTEND"), svc: Array.isArray(XA("SVC")) && 0 !== XA("SVC").length ? XA("SVC") : void 0 };
    try {
      return await this.signal.request(Pw.PRE_SUBSCRIBE, n2, true);
    } catch (n3) {
      if (i2 && n3.data && n3.data.code === Ow.ERR_SUBSCRIBE_REQUEST_INVALID) return fb.warning("[".concat(this.store.clientId, "] pre-subscribe error, retry"), n3.toString()), this.presubscribe(e9, t2, false);
      throw n3;
    }
  }
  async subscribe(e9, t2, i2) {
    if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new yb(Ry.INVALID_OPERATION, "can not subscribe when connection state is ".concat(this.state));
    const n2 = { stream_id: e9, stream_type: t2.stream_type, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!XA("SUBSCRIBE_TWCC"), rtx: !!XA("USE_SUB_RTX"), extend: XA("SUB_EXTEND"), ssrcId: t2.ssrcId, svc: Array.isArray(XA("SVC")) && 0 !== XA("SVC").length ? XA("SVC") : void 0 };
    try {
      return (await this.signal.request(Pw.SUBSCRIBE, n2, true))._message;
    } catch (n3) {
      if (i2 && n3.data && n3.data.code === Ow.ERR_SUBSCRIBE_REQUEST_INVALID) return fb.warning("[".concat(this.store.clientId, "] receiver subscribe error code, retry"), n3.toString()), await this.tryUnsubBeforeResub(e9, t2), await this.subscribe(e9, t2, false);
      throw n3;
    }
  }
  async subscribeDataChannel(e9, t2, i2) {
    if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new yb(Ry.INVALID_OPERATION, "can not subscribe datachannel when connection state is ".concat(this.state));
    const n2 = { uid: e9, stream_id: t2.id, channel_id: t2.datachannelId };
    try {
      return void await this.signal.request(Pw.SUBSCRIBE_DATASTREAM, n2, true);
    } catch (n3) {
      if (i2 && n3.data && n3.data.code === Ow.ERR_SUBSCRIBE_REQUEST_INVALID) return fb.warning("[".concat(this.store.clientId, "] receiver subscribe datachannel error code, retry"), n3.toString()), await this.tryUnsubDataChannelBeforeResub(e9, t2), await this.subscribeDataChannel(e9, t2, false);
      throw n3;
    }
  }
  async subscribeAll(e9, t2) {
    if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new yb(Ry.INVALID_OPERATION, "can not massSubscribe when connection state is ".concat(this.state));
    const i2 = { p2p_id: this.store.p2pId, users: e9, dtx: false, rtx: !!XA("USE_SUB_RTX"), twcc: !!XA("SUBSCRIBE_TWCC"), svc: Array.isArray(XA("SVC")) && 0 !== XA("SVC").length ? XA("SVC") : void 0 };
    try {
      return await this.signal.request(Pw.SUBSCRIBE_STREAMS, i2, true);
    } catch (i3) {
      if (t2 && i3.data && i3.data.code === Ow.ERR_SUBSCRIBE_REQUEST_INVALID) return fb.warning("[".concat(this.store.clientId, "] receiver massSubscribe error code, retry"), i3.toString()), await this.tryMassUnsubBeforeResub(e9), await this.subscribeAll(e9, false);
      throw i3;
    }
  }
  async setVideoProfile(e9) {
    const t2 = function(e10) {
      if (!(e10.bitrateMax && e10.bitrateMin && e10.frameRate && e10.height && e10.width)) return;
      let t3 = e10.frameRate, i2 = e10.width, n2 = e10.height, r2 = true;
      return "number" != typeof t3 && (t3 = t3.exact || t3.ideal || t3.max || t3.min || 0, t3 || (r2 = false)), "number" != typeof i2 && (i2 = i2.exact || i2.ideal || i2.max || i2.min || 0, i2 || (r2 = false)), "number" != typeof n2 && (n2 = n2.exact || n2.ideal || n2.max || n2.min || 0, t3 || (r2 = false)), r2 ? { stream_type: 0, width: i2, height: n2, fps: t3, start_bps: 1e3 * e10.bitrateMax, min_bps: 1e3 * e10.bitrateMin, target_bps: 1e3 * e10.bitrateMax } : void 0;
    }(e9);
    if (t2) return this.signal.request(Pw.SET_VIDEO_PROFILE, t2);
    fb.debug("[".concat(this.store.clientId, "] encoder config is not complete, do not report to gateway"));
  }
  async unsubscribe(e9, t2) {
    try {
      await this.signal.request(Pw.UNSUBSCRIBE, { p2p_id: this.store.p2pId, ortc: e9, stream_id: t2 }, true);
    } catch (e10) {
      fb.warning("[".concat(this.store.clientId, "] unsubscribe warning: "), e10);
    }
  }
  async unsubscribeDataChannel(e9, t2) {
    try {
      if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new yb(Ry.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
      await Gh.all(e9.map((e10) => this.signal.request(Pw.UNSUBSCRIBE_DATASTREAM, { stream_id: e10, uid: t2 }, true)));
    } catch (e10) {
      fb.warning("unsubscribeDataChannel warning: ", e10);
    }
  }
  async massUnsubscribe(e9) {
    try {
      await this.signal.request(Pw.UNSUBSCRIBE_STREAMS, e9, true);
    } catch (e10) {
      fb.warning("[".concat(this.store.clientId, "] massUnsubscribeAll warning: "), e10);
    }
  }
  async reconnectPC(e9) {
    const { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } = e9;
    return { gatewayEstablishParams: await this.signal.request(Pw.CONNECT_PC, { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } }, true), gatewayAddress: this.getCurrentGatewayAddress() };
  }
  getGatewayInfo() {
    return this.signal.request(Pw.GATEWAY_INFO);
  }
  async renewToken(e9) {
    await this.signal.request(Pw.RENEW_TOKEN, e9), this.key = e9.token;
  }
  async setClientRole(e9, t2) {
    if (t2 && (this._clientRoleOptions = Object.assign({}, t2)), "CONNECTED" !== this.state) return void (this.role = e9);
    let i2, n2 = 0;
    "audience" === e9 ? this._clientRoleOptions && this._clientRoleOptions.delay ? (i2 = this._clientRoleOptions.delay, n2 = 1) : n2 = this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : n2 = 0, await this.signal.request(Pw.SET_CLIENT_ROLE, { role: e9, level: n2, delay: i2, client_ts: Date.now() }), this.role = e9;
  }
  async setRemoteVideoStreamType(e9, t2) {
    await this.signal.request(Pw.SWITCH_VIDEO_STREAM, { stream_id: e9, stream_type: t2 });
  }
  async setDefaultRemoteVideoStreamType(e9) {
    await this.signal.request(Pw.DEFAULT_VIDEO_STREAM, { stream_type: e9 });
  }
  async setStreamFallbackOption(e9, t2) {
    await this.signal.request(Pw.SET_FALLBACK_OPTION, { stream_id: e9, fallback_type: t2 });
  }
  async pickSVCLayer(e9, t2) {
    await this.signal.request(Pw.PICK_SVC_LAYER, { stream_id: e9, spatial_layer: t2.spatialLayer, temporal_layer: t2.temporalLayer });
  }
  async setRTM2Flag(e9) {
    await this.signal.request(Pw.SET_RTM2_FLAG, { rtm2_flag: e9 });
  }
  async sendExtensionMessage(e9, t2, i2) {
    if (this.signal instanceof xU) return this.signal.sendExtensionMessage(e9, t2, i2);
  }
  getInChannelInfo() {
    return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), px({}, this.inChannelInfo);
  }
  async getGatewayVersion() {
    return (await this.signal.request(Pw.GATEWAY_INFO)).version;
  }
  reset() {
    if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {
      const e9 = _x.get(this.joinInfo.cname);
      e9 && e9.delete(this.joinInfo.uid);
    }
    this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0);
  }
  updateTurnConfigFromSignal() {
    if (!this.joinInfo) return;
    const e9 = function(e10) {
      let t2;
      return t2 = e10.startsWith("dc") ? e10.match(/(dc\:\/\/)?([^:]+):(\d+)/) : e10.match(/(wss\:\/\/)?([^:]+):(\d+)/), t2 ? { username: KA.username, password: KA.password, turnServerURL: t2[2], tcpport: parseInt(t2[3]) + 30, udpport: parseInt(t2[3]) + 30, forceturn: false } : null;
    }(("disabled" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || "");
    this.joinInfo.turnServer.serversFromGateway = [], e9 && "off" !== this.joinInfo.turnServer.mode && "disabled" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(px(px({}, KA), {}, { turnServerURL: e9.turnServerURL, tcpport: e9.tcpport, udpport: e9.udpport, username: this.joinInfo.uid.toString(), password: this.joinInfo.token }));
  }
  async updateTrafficStats() {
    if ("CONNECTED" !== this.state) return;
    const e9 = await this.signal.request(Pw.TRAFFIC_STATS, void 0, true);
    e9.timestamp = Date.now(), null != e9.ntp_offset && (this.ntpOffset = e9.ntp_offset), e9.peer_delay.forEach((e10) => {
      const t2 = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find((t3) => t3.peer_uid === e10.peer_uid);
      t2 && t2.B_st !== e10.B_st && oA(() => {
        this.emit($w.STREAM_TYPE_CHANGE, e10.peer_uid, e10.B_st);
      });
    }), this._statsCollector.updateTrafficStats(e9);
  }
  getJoinMessage(e9) {
    if (!this.joinInfo || !this.key) throw new yb(Ry.UNEXPECTED_ERROR, "can not generate join message, no join info");
    const t2 = Object.assign({}, this.joinInfo.apResponse);
    let i2 = XA("REPORT_APP_SCENARIO");
    if ("string" != typeof i2) try {
      i2 = JSON.stringify(i2);
    } catch (e10) {
      i2 = void 0;
    }
    i2 && i2.length > 128 && (i2 = void 0);
    const n2 = !(Zv() || ty(87) || eL()) && ("boolean" == typeof XA("ENABLE_PRE_SUB") && XA("ENABLE_PRE_SUB")), r2 = !eL() && ux("ENABLE_PREALLOC_PC", "boolean"), o2 = px({ license: this.joinInfo.license, p2p_id: this.store.p2pId, session_id: this.joinInfo.sid, app_id: this.joinInfo.appId, channel_key: this.key, channel_name: this.joinInfo.cname, sdk_version: GA, browser: navigator.userAgent, process_id: XA("PROCESS_ID"), mode: this.store.useP2P ? "p2p" : this.spec.mode, codec: this.spec.codec, role: this.role, has_changed_gateway: this.hasChangeBGPAddress, ap_response: t2, extend: XA("JOIN_EXTEND"), details: { 6: this.joinInfo.stringUid, cservice_map: "proxy3" === this.joinInfo.cloudProxyServer ? "1" : "proxy5" === this.joinInfo.cloudProxyServer ? "2" : void 0 }, features: { rejoin: true }, optionalInfo: this.joinInfo.optionalInfo, appScenario: i2, attributes: { userAttributes: { enablePublishedUserList: XA("ENABLE_PUBLISHED_USER_LIST"), maxSubscription: XA("MAX_SUBSCRIPTION"), subscribeAudioFilterTopN: "number" == typeof XA("SUBSCRIBE_AUDIO_FILTER_TOPN") ? XA("SUBSCRIBE_AUDIO_FILTER_TOPN") : void 0, enablePublishAudioFilter: "boolean" == typeof XA("ENABLE_PUBLISH_AUDIO_FILTER") ? XA("ENABLE_PUBLISH_AUDIO_FILTER") : void 0, enableUserLicenseCheck: "boolean" == typeof XA("ENABLE_USER_LICENSE_CHECK") ? XA("ENABLE_USER_LICENSE_CHECK") : void 0, enableRTX: true === XA("USE_PUB_RTX") || true === XA("USE_SUB_RTX") || void 0, disableFEC: XA("DISABLE_FEC"), enableNTPReport: !!XA("ENABLE_NTP_REPORT") || void 0, enableInstantVideo: !!XA("ENABLE_INSTANT_VIDEO") || void 0, enableFulllinkAvSync: !!XA("ENABLE_FULL_LINK_AV_SYNC") || void 0, enableDataStream2: ux("ENABLE_DATASTREAM_2", "boolean"), enableAutFeedback: !!XA("ENABLE_AUT_FEEDBACK") || void 0, rtm2Flag: "number" == typeof this.joinInfo.rtmFlag ? this.joinInfo.rtmFlag : void 0, enableUserAutoRebalanceCheck: !!XA("ENABLE_USER_AUTO_REBALANCE_CHECK"), enableXR: ux("USE_XR", "boolean"), enableLossbasedBwe: ux("ENABLE_LOSSBASED_BWE", "boolean"), enableAutCC: !!XA("ENABLE_AUT_CC") || void 0, enableCCFallback: ux("ENABLE_CC_FALLBACK", "boolean"), enablePreallocPC: r2, preSubNum: n2 ? ux("PRE_SUB_NUM", "number") : void 0, enablePubTWCC: ux("PUBLISH_TWCC", "boolean"), enableSubTWCC: ux("SUBSCRIBE_TWCC", "boolean"), enablePubRTX: ux("USE_PUB_RTX", "boolean"), enableSubRTX: ux("USE_SUB_RTX", "boolean"), enableSubSVC: XA("ENABLE_SVC") ? XA("ENABLE_SVC_DEFAULT_CODECS") : Array.isArray(XA("SVC")) && 0 !== XA("SVC").length ? XA("SVC") : void 0 } }, join_ts: this.joinGatewayStartTime }, e9);
    return this.joinInfo.stringUid && (o2.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (o2.aes_mode = this.joinInfo.aesmode, XA("ENCRYPT_AES") ? (o2.aes_secret = this.joinInfo.aespassword, o2.aes_encrypt = true) : o2.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (o2.aes_salt = this.joinInfo.aessalt)), t2.addresses[this.signal.websocket.currentURLIndex] && (o2.ap_response.ticket = t2.addresses[this.signal.websocket.currentURLIndex].ticket, delete t2.addresses), void 0 !== this.joinInfo.defaultVideoStream && (o2.default_video_stream = this.joinInfo.defaultVideoStream), o2;
  }
  getRejoinMessage() {
    if (!this.joinInfo) throw new yb(Ry.UNEXPECTED_ERROR, "can not generate rejoin message, no join info");
    return { session_id: this.joinInfo.sid, channel_name: this.joinInfo.cname, cid: this.joinInfo.cid, uid: this.joinInfo.uid, vid: Number(this.joinInfo.vid) };
  }
  handleSignalEvents() {
    this.signal.on(Dw.WS_RECONNECT_WAITTING_FINISH, (e9) => {
      var t2;
      Dn(t2 = ["tryNext", "recover"]).call(t2, e9) && this.joinInfo && vb.adjustSessionStartTime(this.joinInfo.sid);
    }), this.signal.on(Dw.WS_RECONNECT_CREATE_CONNECTION, (e9) => {
      this.joinGatewayStartTime = Date.now();
    }), this.signal.on(Dw.WS_RECONNECTING, (e9) => {
      this.joinInfo && vb.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: e9 || Jy.NETWORK_ERROR }), this.joinInfo && (this.state = "RECONNECTING", vb.sessionInit(this.joinInfo.sid, { lts: (/* @__PURE__ */ new Date()).getTime(), extend: this.isSignalRecover ? { recover: true } : { rejoin: true }, cname: this.joinInfo.cname, appid: this.joinInfo.appId, mode: this.spec.mode, stringUid: this.joinInfo.stringUid, channelProfile: "live" === this.spec.mode ? 1 : 0, channelMode: 0, lsid: this.joinInfo.sid, clientRole: "audience" === this.role ? 2 : 1, buildFormat: 2 }), this.isSignalRecover = false, this.joinGatewayStartTime = Date.now());
    }), this.signal.on(Dw.WS_CLOSED, (e9) => {
      let t2;
      switch (e9) {
        case Hy.LEAVE:
          t2 = Jy.LEAVE;
          break;
        case Hy.UID_BANNED:
        case Hy.IP_BANNED:
        case Hy.CHANNEL_BANNED:
        case Hy.SERVER_ERROR:
          t2 = Jy.SERVER_ERROR;
          break;
        case Hy.FALLBACK:
          t2 = Jy.FALLBACK;
          break;
        case Hy.LICENSE_MISSING:
        case Hy.LICENSE_EXPIRED:
        case Hy.LICENSE_MINUTES_EXCEEDED:
        case Hy.LICENSE_PERIOD_INVALID:
        case Hy.LICENSE_MULTIPLE_SDK_SERVICE:
        case Hy.LICENSE_ILLEGAL:
        case Hy.TOKEN_EXPIRE:
          t2 = e9;
          break;
        default:
          t2 = Jy.NETWORK_ERROR;
      }
      fb.debug("[".concat(this.store.clientId, "] [signal] websocket closed, reason: ").concat(t2 || "undefined -> " + Jy.NETWORK_ERROR)), this.joinInfo && vb.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: e9 === Hy.LEAVE ? 1 : -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: t2 }), this._disconnectedReason = e9, e9 !== Hy.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
    }), this.signal.on(Dw.WS_CONNECTED, () => {
      if (this.updateTurnConfigFromSignal(), this.state = "CONNECTED", this.joinInfo && ("audience" === this.role && this._clientRoleOptions && (this._clientRoleOptions.level || this._clientRoleOptions.delay) && (fb.debug("[".concat(this.store.clientId, "] patch to send set client role, role: ").concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(this._clientRoleOptions.level, ", delay: ").concat(this._clientRoleOptions.delay)), this.setClientRole(this.role, this._clientRoleOptions)), vb.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: true, ec: null, vid: this.joinInfo.vid, addr: this.signal.url, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: "0", preload: this.joinInfo.preload }), this._isProactiveJoin = false, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion)) {
        const e9 = this.signal.url && this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);
        if (!e9) return void fb.error("[".concat(this.store.clientId, "] set local access point after joined failed: ").concat(e9));
        JA("EVENT_REPORT_DOMAIN", e9[1]), JA("EVENT_REPORT_BACKUP_DOMAIN", e9[1]), JA("LOG_UPLOAD_SERVER", "".concat(e9[1], ":6444"));
      }
    }), this.signal.on(kw.ON_UPLINK_STATS, (e9) => {
      this._statsCollector.updateUplinkStats(e9);
    }), this.signal.on(Dw.REQUEST_RECOVER, (e9, t2, i2) => {
      if (!this.joinInfo) return i2(new yb(Ry.UNEXPECTED_ERROR, "gateway: can not recover, no join info"));
      e9 && (this.joinInfo.multiIP = e9, this.hasChangeBGPAddress = true), this.isSignalRecover = true, Zy(this, $w.REQUEST_NEW_GATEWAY_LIST).then(t2).catch(i2);
    }), this.signal.on(Dw.REQUEST_JOIN_INFO, async (e9) => {
      var t2;
      if (this.updateTurnConfigFromSignal(), this.store.useP2P) return void e9(this.getJoinMessage({ ortc: {} }));
      const { iceParameters: i2, dtlsParameters: n2, rtpCapabilities: r2 } = await Zy(this, $w.REQUEST_P2P_CONNECTION_PARAMS, { turnServer: null === (t2 = this.joinInfo) || void 0 === t2 ? void 0 : t2.turnServer });
      e9(this.getJoinMessage({ ortc: { iceParameters: i2, dtlsParameters: n2, rtpCapabilities: r2, version: "2" } }));
    }), this.signal.on(Dw.REQUEST_REJOIN_INFO, (e9) => {
      e9(this.getRejoinMessage());
    }), this.signal.on(Dw.REPORT_JOIN_GATEWAY, (e9, t2) => {
      if (!this.joinInfo) return;
      let i2, n2 = "";
      var r2;
      e9 instanceof yb ? (i2 = (null === (r2 = e9.data) || void 0 === r2 ? void 0 : r2.desc) || e9.code, n2 = e9.message) : i2 = e9;
      vb.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: false, ec: i2, errorMsg: n2, addr: t2, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: "0", preload: this.joinInfo.preload }), this._isProactiveJoin = false;
    }), this.signal.on(Dw.IS_P2P_DISCONNECTED, (e9) => {
      e9(tA(this, $w.IS_P2P_DISCONNECTED));
    }), this.signal.on(Dw.DISCONNECT_P2P, () => {
      this.emit($w.DISCONNECT_P2P);
    }), this.signal.on(Dw.REQUEST_SUCCESS, () => {
      this._signalTimeout = false;
    }), this.signal.on(Dw.REQUEST_TIMEOUT, () => {
      this._signalTimeout = true;
    }), this.signal.on(Dw.JOIN_RESPONSE, (e9) => {
      const t2 = this.getCurrentGatewayAddress();
      this.emit($w.JOIN_RESPONSE, e9, t2);
    }), this.signal.on(Dw.PRE_CONNECT_PC, async () => {
      if (this.joinInfo) {
        this.updateTurnConfigFromSignal();
        const e9 = this.getCurrentGatewayAddress(), t2 = XA("FINGERPRINT") || this.joinInfo.apResponse.addresses[this.signal.currentURLIndex].fingerprint;
        if (e9 && t2) {
          const i2 = qU(e9);
          this.emit($w.PRE_CONNECT_PC, { candidates: i2, fingerprint: t2 });
        }
      }
    }), this.signal.on(Dw.RECOVER_NOTIFICATION, (e9) => {
      this.joinInfo && "string" == typeof XA("AP_REQUEST_DETAIL") && (this.joinInfo.apRequestDetail = "".concat(XA("AP_REQUEST_DETAIL"), ";").concat(e9));
    });
  }
  async tryUnsubBeforeResub(e9, t2) {
    try {
      await this.signal.request(Pw.UNSUBSCRIBE, { p2p_id: this.store.p2pId, stream_id: e9, ortc: [t2] }, true);
    } catch (e10) {
      throw fb.warning("[".concat(this.store.clientId, "] tryUnsubBeforeResub warning"), e10), e10;
    }
  }
  async tryUnsubDataChannelBeforeResub(e9, t2) {
    try {
      await this.signal.request(Pw.UNSUBSCRIBE, { stream_id: t2.id }, true);
    } catch (e10) {
      throw fb.warning("unsubscribe datachannel warning", e10), e10;
    }
  }
  async tryUnpubBeforeRepub(e9, t2) {
    try {
      await this.signal.request(Pw.UNPUBLISH, { stream_id: e9, ortc: t2 }, true);
    } catch (e10) {
      throw fb.warning("[".concat(this.store.clientId, "] tryUnpubBeforeRepub warning: "), e10), e10;
    }
  }
  async tryUnpubDataChannelBeforeRepub(e9, t2) {
    try {
      await this.signal.request(Pw.UNPUBLISH_DATASTREAM, { channnel_id: t2.channelId }, true);
    } catch (e10) {
      throw fb.warning("unpublish datastream warning: ", e10), e10;
    }
  }
  async tryMassUnsubBeforeResub(e9) {
    const t2 = { users: e9.map((e10) => ({ stream_id: e10.stream_id, stream_type: e10.stream_type })) };
    try {
      await this.signal.request(Pw.UNSUBSCRIBE_STREAMS, t2, true);
    } catch (e10) {
      throw fb.warning("[".concat(this.store.clientId, "] tryMassUnsubBeforeResub warning"), e10), e10;
    }
  }
  async muteLocal(e9, t2) {
    const i2 = { action: e9.find((e10) => e10.stream_type === Zw.Audio) ? "mute_local_audio" : "mute_local_video", p2p_id: this.store.p2pId, ortc: e9, stream_id: t2 };
    try {
      await this.signal.request(Pw.CONTROL, i2, true, true);
    } catch (e10) {
      throw fb.warning("[".concat(this.store.clientId, "] gateway muteLocal warning: "), e10), e10;
    }
  }
  async unmuteLocal(e9, t2) {
    const i2 = { action: e9.find((e10) => e10.stream_type === Zw.Audio) ? "unmute_local_audio" : "unmute_local_video", p2p_id: this.store.p2pId, ortc: e9, stream_id: t2 };
    try {
      await this.signal.request(Pw.CONTROL, i2, true, true);
    } catch (e10) {
      throw fb.warning("[".concat(this.store.clientId, "] gateway unmuteLocal warning: "), e10), e10;
    }
  }
  async muteRemote(e9, t2) {
    const i2 = { action: e9 === dO.AUDIO ? "mute_remote_audio" : "mute_remote_video", p2p_id: this.store.p2pId, stream_id: t2 };
    try {
      await this.signal.request(Pw.CONTROL, i2, true, true);
    } catch (e10) {
      throw fb.warning("[".concat(this.store.clientId, "] gateway muteRemote warning: "), e10), e10;
    }
  }
  async unmuteRemote(e9, t2) {
    const i2 = { action: e9 === dO.AUDIO ? "unmute_remote_audio" : "unmute_remote_video", p2p_id: this.store.p2pId, stream_id: t2 };
    try {
      await this.signal.request(Pw.CONTROL, i2, true, true);
    } catch (e10) {
      throw fb.warning("[".concat(this.store.clientId, "] gateway unmuteRemote warning: "), e10), e10;
    }
  }
  uploadWRTCStats(e9) {
    this.signal.uploadWRTCStats(e9);
  }
  upload(e9, t2) {
    this.signal.upload(e9, t2);
  }
  getSignalRTT() {
    return this.signal.rtt;
  }
  async restartICE(e9) {
    const t2 = { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: e9 };
    try {
      return await this.signal.request(Pw.RESTART_ICE, t2, true);
    } catch (e10) {
      throw fb.warning("[".concat(this.store.clientId, "] P2PChannel.restartICE warning: "), e10), e10;
    }
  }
  reconnect() {
    "CONNECTED" === this.state && this.signal.reconnect(void 0, Jy.P2P_FAILED);
  }
  getCurrentGatewayAddress() {
    var e9, t2;
    if (!XA("GATEWAY_WSS_ADDRESS")) return XA("USE_CANDIDATE_FROM_AP_DETAIL") && null !== (e9 = this.joinInfo) && void 0 !== e9 && e9.apGatewayAddress ? (fb.debug("[".concat(this.store.clientId, "] use candidate from ap detail, ").concat(JSON.stringify(this.joinInfo.apGatewayAddress))), this.joinInfo.apGatewayAddress) : null !== (t2 = this.joinInfo) && void 0 !== t2 && t2.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0;
  }
  async setPublishAudioFilterEnabled(e9) {
    await this.signal.request(Pw.SET_PARAMETER, { enablePublishAudioFilter: e9 });
  }
};
var fx = 0;
var mx = 0;
function Tx(e9, t2, i2, n2) {
  return new Gh((r2, o2) => {
    t2.timeout = t2.timeout || XA("HTTP_CONNECT_TIMEOUT"), t2.responseType = t2.responseType || "json", t2.data && !i2 ? (t2.data = JSON.stringify(t2.data), fx += _A(t2.data)) : i2 && (t2.data.size ? fx += t2.data.size : t2.data instanceof FormData ? fx += EA(t2.data) : fx += _A(JSON.stringify(t2.data))), t2.headers = t2.headers || {}, t2.headers["Content-Type"] = t2.headers["Content-Type"] || "application/json", t2.method = "POST", t2.url = e9, Lv.request(t2).then((e10) => {
      "string" == typeof e10.data ? mx += _A(e10.data) : e10.data instanceof ArrayBuffer || e10.data instanceof Uint8Array ? mx += e10.data.byteLength : mx += _A(JSON.stringify(e10.data)), n2 && r2({ data: e10.data, headers: e10.headers }), r2(e10.data);
    }).catch((e10) => {
      Lv.isCancel(e10) ? o2(new yb(Ry.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e10.code ? o2(new yb(Ry.NETWORK_TIMEOUT, e10.message)) : e10.response ? o2(new yb(Ry.NETWORK_RESPONSE_ERROR, e10.response.status)) : o2(new yb(Ry.NETWORK_ERROR, e10.message));
    });
  });
}
!function() {
  var e9;
  function i2(e10) {
    var t2 = 0;
    return function() {
      return t2 < e10.length ? { done: false, value: e10[t2++] } : { done: true };
    };
  }
  var n2 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(e10, t2, i3) {
    return e10 == Array.prototype || e10 == Object.prototype || (e10[t2] = i3.value), e10;
  };
  var r2, o2 = function(e10) {
    e10 = ["object" == typeof globalThis && globalThis, e10, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof t && t];
    for (var i3 = 0; i3 < e10.length; ++i3) {
      var n3 = e10[i3];
      if (n3 && n3.Math == Math) return n3;
    }
    throw Error("Cannot find global object");
  }(this);
  function s2(e10, t2) {
    if (t2) e: {
      var i3 = o2;
      e10 = e10.split(".");
      for (var r3 = 0; r3 < e10.length - 1; r3++) {
        var s3 = e10[r3];
        if (!(s3 in i3)) break e;
        i3 = i3[s3];
      }
      (t2 = t2(r3 = i3[e10 = e10[e10.length - 1]])) != r3 && null != t2 && n2(i3, e10, { configurable: true, writable: true, value: t2 });
    }
  }
  function a2(e10) {
    return (e10 = { next: e10 })[Symbol.iterator] = function() {
      return this;
    }, e10;
  }
  function c2(e10) {
    var t2 = "undefined" != typeof Symbol && Symbol.iterator && e10[Symbol.iterator];
    return t2 ? t2.call(e10) : { next: i2(e10) };
  }
  if (s2("Symbol", function(e10) {
    function t2(e11, t3) {
      this.A = e11, n2(this, "description", { configurable: true, writable: true, value: t3 });
    }
    if (e10) return e10;
    t2.prototype.toString = function() {
      return this.A;
    };
    var i3 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", r3 = 0;
    return function e11(n3) {
      if (this instanceof e11) throw new TypeError("Symbol is not a constructor");
      return new t2(i3 + (n3 || "") + "_" + r3++, n3);
    };
  }), s2("Symbol.iterator", function(e10) {
    if (e10) return e10;
    e10 = Symbol("Symbol.iterator");
    for (var t2 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), r3 = 0; r3 < t2.length; r3++) {
      var s3 = o2[t2[r3]];
      "function" == typeof s3 && "function" != typeof s3.prototype[e10] && n2(s3.prototype, e10, { configurable: true, writable: true, value: function() {
        return a2(i2(this));
      } });
    }
    return e10;
  }), "function" == typeof Object.setPrototypeOf) r2 = Object.setPrototypeOf;
  else {
    var d2;
    e: {
      var l2 = {};
      try {
        l2.__proto__ = { a: true }, d2 = l2.a;
        break e;
      } catch (e10) {
      }
      d2 = false;
    }
    r2 = d2 ? function(e10, t2) {
      if (e10.__proto__ = t2, e10.__proto__ !== t2) throw new TypeError(e10 + " is not extensible");
      return e10;
    } : null;
  }
  var u2 = r2;
  function h2() {
    this.m = false, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;
  }
  function p2(e10) {
    if (e10.m) throw new TypeError("Generator is already running");
    e10.m = true;
  }
  function _2(e10, t2) {
    return e10.h = 3, { value: t2 };
  }
  function E2(e10) {
    this.g = new h2(), this.G = e10;
  }
  function f2(e10, t2, i3, n3) {
    try {
      var r3 = t2.call(e10.g.j, i3);
      if (!(r3 instanceof Object)) throw new TypeError("Iterator result " + r3 + " is not an object");
      if (!r3.done) return e10.g.m = false, r3;
      var o3 = r3.value;
    } catch (t3) {
      return e10.g.j = null, e10.g.s(t3), m2(e10);
    }
    return e10.g.j = null, n3.call(e10.g, o3), m2(e10);
  }
  function m2(e10) {
    for (; e10.g.h; ) try {
      var t2 = e10.G(e10.g);
      if (t2) return e10.g.m = false, { value: t2.value, done: false };
    } catch (t3) {
      e10.g.v = void 0, e10.g.s(t3);
    }
    if (e10.g.m = false, e10.g.l) {
      if (t2 = e10.g.l, e10.g.l = null, t2.F) throw t2.D;
      return { value: t2.return, done: true };
    }
    return { value: void 0, done: true };
  }
  function T2(e10) {
    this.next = function(t2) {
      return e10.o(t2);
    }, this.throw = function(t2) {
      return e10.s(t2);
    }, this.return = function(t2) {
      return function(e11, t3) {
        p2(e11.g);
        var i3 = e11.g.j;
        return i3 ? f2(e11, "return" in i3 ? i3.return : function(e12) {
          return { value: e12, done: true };
        }, t3, e11.g.return) : (e11.g.return(t3), m2(e11));
      }(e10, t2);
    }, this[Symbol.iterator] = function() {
      return this;
    };
  }
  function S2(e10, t2) {
    return t2 = new T2(new E2(t2)), u2 && e10.prototype && u2(t2, e10.prototype), t2;
  }
  if (h2.prototype.o = function(e10) {
    this.v = e10;
  }, h2.prototype.s = function(e10) {
    this.l = { D: e10, F: true }, this.h = this.C || this.u;
  }, h2.prototype.return = function(e10) {
    this.l = { return: e10 }, this.h = this.u;
  }, E2.prototype.o = function(e10) {
    return p2(this.g), this.g.j ? f2(this, this.g.j.next, e10, this.g.o) : (this.g.o(e10), m2(this));
  }, E2.prototype.s = function(e10) {
    return p2(this.g), this.g.j ? f2(this, this.g.j.throw, e10, this.g.o) : (this.g.s(e10), m2(this));
  }, s2("Array.prototype.entries", function(e10) {
    return e10 || function() {
      return function(e11, t2) {
        e11 instanceof String && (e11 += "");
        var i3 = 0, n3 = false, r3 = { next: function() {
          if (!n3 && i3 < e11.length) {
            var r4 = i3++;
            return { value: t2(r4, e11[r4]), done: false };
          }
          return n3 = true, { done: true, value: void 0 };
        } };
        return r3[Symbol.iterator] = function() {
          return r3;
        }, r3;
      }(this, function(e11, t2) {
        return [e11, t2];
      });
    };
  }), "undefined" != typeof Blob && ("undefined" == typeof FormData || !FormData.prototype.keys)) {
    var g2 = function(e10, t2) {
      for (var i3 = 0; i3 < e10.length; i3++) t2(e10[i3]);
    }, R2 = function(e10) {
      return e10.replace(/\r?\n|\r/g, "\r\n");
    }, C2 = function(e10, t2, i3) {
      return t2 instanceof Blob ? (i3 = void 0 !== i3 ? String(i3 + "") : "string" == typeof t2.name ? t2.name : "blob", t2.name === i3 && "[object Blob]" !== Object.prototype.toString.call(t2) || (t2 = new File([t2], i3)), [String(e10), t2]) : [String(e10), String(t2)];
    }, I2 = function(e10, t2) {
      if (e10.length < t2) throw new TypeError(t2 + " argument required, but only " + e10.length + " present.");
    }, v2 = "object" == typeof globalThis ? globalThis : "object" == typeof window ? window : "object" == typeof self ? self : this, y2 = v2.FormData, A2 = v2.XMLHttpRequest && v2.XMLHttpRequest.prototype.send, b2 = v2.Request && v2.fetch, w2 = v2.navigator && v2.navigator.sendBeacon, O2 = v2.Element && v2.Element.prototype, N2 = v2.Symbol && Symbol.toStringTag;
    N2 && (Blob.prototype[N2] || (Blob.prototype[N2] = "Blob"), "File" in v2 && !File.prototype[N2] && (File.prototype[N2] = "File"));
    try {
      new File([], "");
    } catch (e10) {
      v2.File = function(e11, t2, i3) {
        return e11 = new Blob(e11, i3 || {}), Object.defineProperties(e11, { name: { value: t2 }, lastModified: { value: +(i3 && void 0 !== i3.lastModified ? new Date(i3.lastModified) : /* @__PURE__ */ new Date()) }, toString: { value: function() {
          return "[object File]";
        } } }), N2 && Object.defineProperty(e11, N2, { value: "File" }), e11;
      };
    }
    var D2 = function(e10) {
      return e10.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    }, P2 = function(e10) {
      this.i = [];
      var t2 = this;
      e10 && g2(e10.elements, function(e11) {
        if (e11.name && !e11.disabled && "submit" !== e11.type && "button" !== e11.type && !e11.matches("form fieldset[disabled] *")) if ("file" === e11.type) {
          var i3 = e11.files && e11.files.length ? e11.files : [new File([], "", { type: "application/octet-stream" })];
          g2(i3, function(i4) {
            t2.append(e11.name, i4);
          });
        } else "select-multiple" === e11.type || "select-one" === e11.type ? g2(e11.options, function(i4) {
          !i4.disabled && i4.selected && t2.append(e11.name, i4.value);
        }) : "checkbox" === e11.type || "radio" === e11.type ? e11.checked && t2.append(e11.name, e11.value) : (i3 = "textarea" === e11.type ? R2(e11.value) : e11.value, t2.append(e11.name, i3));
      });
    };
    if ((e9 = P2.prototype).append = function(e10, t2, i3) {
      I2(arguments, 2), this.i.push(C2(e10, t2, i3));
    }, e9.delete = function(e10) {
      I2(arguments, 1);
      var t2 = [];
      e10 = String(e10), g2(this.i, function(i3) {
        i3[0] !== e10 && t2.push(i3);
      }), this.i = t2;
    }, e9.entries = function e10() {
      var t2, i3 = this;
      return S2(e10, function(e11) {
        if (1 == e11.h && (t2 = 0), 3 != e11.h) return t2 < i3.i.length ? e11 = _2(e11, i3.i[t2]) : (e11.h = 0, e11 = void 0), e11;
        t2++, e11.h = 2;
      });
    }, e9.forEach = function(e10, t2) {
      I2(arguments, 1);
      for (var i3 = c2(this), n3 = i3.next(); !n3.done; n3 = i3.next()) {
        var r3 = c2(n3.value);
        n3 = r3.next().value, r3 = r3.next().value, e10.call(t2, r3, n3, this);
      }
    }, e9.get = function(e10) {
      I2(arguments, 1);
      var t2 = this.i;
      e10 = String(e10);
      for (var i3 = 0; i3 < t2.length; i3++) if (t2[i3][0] === e10) return t2[i3][1];
      return null;
    }, e9.getAll = function(e10) {
      I2(arguments, 1);
      var t2 = [];
      return e10 = String(e10), g2(this.i, function(i3) {
        i3[0] === e10 && t2.push(i3[1]);
      }), t2;
    }, e9.has = function(e10) {
      I2(arguments, 1), e10 = String(e10);
      for (var t2 = 0; t2 < this.i.length; t2++) if (this.i[t2][0] === e10) return true;
      return false;
    }, e9.keys = function e10() {
      var t2, i3, n3, r3, o3 = this;
      return S2(e10, function(e11) {
        if (1 == e11.h && (t2 = c2(o3), i3 = t2.next()), 3 != e11.h) return i3.done ? void (e11.h = 0) : (n3 = i3.value, r3 = c2(n3), _2(e11, r3.next().value));
        i3 = t2.next(), e11.h = 2;
      });
    }, e9.set = function(e10, t2, i3) {
      I2(arguments, 2), e10 = String(e10);
      var n3 = [], r3 = C2(e10, t2, i3), o3 = true;
      g2(this.i, function(t3) {
        t3[0] === e10 ? o3 && (o3 = !n3.push(r3)) : n3.push(t3);
      }), o3 && n3.push(r3), this.i = n3;
    }, e9.values = function e10() {
      var t2, i3, n3, r3, o3 = this;
      return S2(e10, function(e11) {
        if (1 == e11.h && (t2 = c2(o3), i3 = t2.next()), 3 != e11.h) return i3.done ? void (e11.h = 0) : (n3 = i3.value, (r3 = c2(n3)).next(), _2(e11, r3.next().value));
        i3 = t2.next(), e11.h = 2;
      });
    }, P2.prototype._asNative = function() {
      for (var e10 = new y2(), t2 = c2(this), i3 = t2.next(); !i3.done; i3 = t2.next()) {
        var n3 = c2(i3.value);
        i3 = n3.next().value, n3 = n3.next().value, e10.append(i3, n3);
      }
      return e10;
    }, P2.prototype._blob = function() {
      var e10 = "----formdata-polyfill-" + Math.random(), t2 = [], i3 = "--" + e10 + '\r\nContent-Disposition: form-data; name="';
      return this.forEach(function(e11, n3) {
        return "string" == typeof e11 ? t2.push(i3 + D2(R2(n3)) + '"\r\n\r\n' + R2(e11) + "\r\n") : t2.push(i3 + D2(R2(n3)) + '"; filename="' + D2(e11.name) + '"\r\nContent-Type: ' + (e11.type || "application/octet-stream") + "\r\n\r\n", e11, "\r\n");
      }), t2.push("--" + e10 + "--"), new Blob(t2, { type: "multipart/form-data; boundary=" + e10 });
    }, P2.prototype[Symbol.iterator] = function() {
      return this.entries();
    }, P2.prototype.toString = function() {
      return "[object FormData]";
    }, O2 && !O2.matches && (O2.matches = O2.matchesSelector || O2.mozMatchesSelector || O2.msMatchesSelector || O2.oMatchesSelector || O2.webkitMatchesSelector || function(e10) {
      for (var t2 = (e10 = (this.document || this.ownerDocument).querySelectorAll(e10)).length; 0 <= --t2 && e10.item(t2) !== this; ) ;
      return -1 < t2;
    }), N2 && (P2.prototype[N2] = "FormData"), A2) {
      var L2 = v2.XMLHttpRequest.prototype.setRequestHeader;
      v2.XMLHttpRequest.prototype.setRequestHeader = function(e10, t2) {
        L2.call(this, e10, t2), "content-type" === e10.toLowerCase() && (this.B = true);
      }, v2.XMLHttpRequest.prototype.send = function(e10) {
        e10 instanceof P2 ? (e10 = e10._blob(), this.B || this.setRequestHeader("Content-Type", e10.type), A2.call(this, e10)) : A2.call(this, e10);
      };
    }
    b2 && (v2.fetch = function(e10, t2) {
      return t2 && t2.body && t2.body instanceof P2 && (t2.body = t2.body._blob()), b2.call(this, e10, t2);
    }), w2 && (v2.navigator.sendBeacon = function(e10, t2) {
      return t2 instanceof P2 && (t2 = t2._asNative()), w2.call(this, e10, t2);
    }), v2.FormData = P2;
  }
}();
var Sx = () => {
  const e9 = XA("AREAS");
  0 === e9.length && e9.push(iO.GLOBAL);
  return Jn(e9).call(e9, (e10, t2, i2) => {
    const n2 = gx(t2);
    return n2 ? 0 === i2 ? n2 : "".concat(e10, ",").concat(n2) : e10;
  }, "");
};
var gx = (e9) => e9 === iO.OVERSEA ? "".concat(rO.ASIA, ",").concat(rO.EUROPE, ",").concat(rO.AFRICA, ",").concat(rO.NORTH_AMERICA, ",").concat(rO.SOUTH_AMERICA, ",").concat(rO.OCEANIA) : rO[e9];
var Rx = (e9) => {
  const t2 = { CODE: "", WEBCS_DOMAIN: [], WEBCS_DOMAIN_BACKUP_LIST: [], PROXY_CS: [], CDS_AP: [], ACCOUNT_REGISTER: [], UAP_AP: [], EVENT_REPORT_DOMAIN: [], EVENT_REPORT_BACKUP_DOMAIN: [], LOG_UPLOAD_SERVER: [], PROXY_SERVER_TYPE3: [] };
  return e9.map((e10) => {
    const i2 = oO[e10], n2 = Object.keys(i2);
    n2 && n2.map((e11) => {
      "CODE" !== e11 && (t2[e11] = t2[e11].concat(i2[e11]));
    });
  }), t2;
};
var Cx = { GLOBAL: { ASIA: [iO.CHINA, iO.JAPAN, iO.INDIA, iO.KOREA, iO.HKMC], EUROPE: [], NORTH_AMERICA: [iO.US], SOUTH_AMERICA: [], OCEANIA: [], AFRICA: [] } };
var Ix = Object.keys(Cx[iO.GLOBAL]);
var vx = [iO.CHINA, iO.NORTH_AMERICA, iO.EUROPE, iO.ASIA, iO.JAPAN, iO.INDIA, iO.OCEANIA, iO.SOUTH_AMERICA, iO.AFRICA, iO.KOREA, iO.HKMC, iO.US];
var yx = function(e9, t2) {
  let i2 = [];
  if (Dn(e9).call(e9, iO.GLOBAL)) {
    const o2 = [iO.GLOBAL, iO.OVERSEA], s2 = Object.keys(oO);
    if (t2 === iO.GLOBAL) throw new yb(Ry.INVALID_PARAMS, "GLOBAL is an invalid excludedArea value");
    if (t2 === iO.CHINA) i2 = [iO.OVERSEA];
    else if (r2 = t2, Dn(Ix).call(Ix, r2)) {
      const e10 = (n2 = t2, Cx[iO.GLOBAL][n2] || []), r3 = [...o2, t2, ...e10];
      i2 = s2.filter((e11) => !Dn(r3).call(r3, e11));
    } else if (function(e10) {
      let t3 = false;
      return Ix.forEach((i3) => {
        var n3;
        Dn(n3 = Cx[iO.GLOBAL][i3]).call(n3, e10) && (t3 = true);
      }), t3;
    }(t2)) {
      const e10 = function(e11) {
        let t3;
        return Ix.forEach((i3) => {
          var n4;
          Dn(n4 = Cx[iO.GLOBAL][i3]).call(n4, e11) && (t3 = i3);
        }), t3;
      }(t2), n3 = [...o2, e10, t2];
      i2 = s2.filter((e11) => !Dn(n3).call(n3, e11));
    } else i2 = e9;
    i2 = function(e10) {
      const t3 = [];
      return vx.forEach((i3) => {
        Dn(e10).call(e10, i3) && t3.push(i3);
      }), t3.concat(e10.filter((e11) => !Dn(vx).call(vx, e11)));
    }(i2);
  } else i2 = e9;
  var n2, r2;
  return i2;
};
function Ax(e9) {
  var t2, i2;
  if (!e9 && Dn(t2 = XA("AREAS")).call(t2, iO.EXTENSIONS)) return fb.debug("update area from ap : reset"), void bx(Ab, true);
  if (!Dn(i2 = XA("AREAS")).call(i2, iO.GLOBAL) || !e9) return;
  let n2 = oO.EXTENSIONS;
  n2 && (n2 = { CODE: gx(iO.EXTENSIONS), WEBCS_DOMAIN: ["ap-web-1-".concat(e9, ".agora.io")], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-".concat(e9, ".ap.sd-rtn.com")], PROXY_CS: ["proxy-ap-web-".concat(e9, ".agora.io")], CDS_AP: ["cds-ap-web-1-".concat(e9, ".agora.io"), "cds-ap-web-2-".concat(e9, ".ap.sd-rtn.com")], ACCOUNT_REGISTER: ["sua-ap-web-1-".concat(e9, ".agora.io"), "sua-ap-web-2-".concat(e9, ".ap.sd-rtn.com")], UAP_AP: ["uap-ap-web-1-".concat(e9, ".agora.io"), "uap-ap-web-2-".concat(e9, ".ap.sd-rtn.com")], EVENT_REPORT_DOMAIN: ["statscollector-1-".concat(e9, ".agora.io")], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-".concat(e9, ".agora.io")], LOG_UPLOAD_SERVER: ["logservice-".concat(e9, ".agora.io")], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy-".concat(e9, ".agora.io")] }, fb.debug("update area from ap success: ".concat(e9, ",config is "), n2), JA("AREAS", [iO.EXTENSIONS], true), Object.keys(n2).map((e10) => {
    if ("LOG_UPLOAD_SERVER" === e10 || "EVENT_REPORT_DOMAIN" === e10 || "EVENT_REPORT_BACKUP_DOMAIN" === e10 || "PROXY_SERVER_TYPE3" === e10) {
      JA(e10, n2[e10][0]);
    } else JA(e10, n2[e10]);
  }));
}
function bx(e9) {
  let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
  const i2 = vb.reportApiInvoke(null, { name: By.SET_AREA, options: e9, tag: jy.TRACER });
  try {
    let n2 = [];
    if ("string" == typeof e9 && (n2 = [e9]), Array.isArray(e9) && (e9.forEach((e10) => {
      if (!Dn(nO).call(nO, e10)) throw new yb(Ry.INVALID_PARAMS, "invalid area code");
    }), n2 = e9), "[object Object]" === Object.prototype.toString.call(e9)) {
      const { areaCode: t3, excludedArea: i3 } = e9;
      if (!t3) throw new yb(Ry.INVALID_PARAMS, "area code is needed");
      let r3 = t3;
      "string" == typeof t3 && (r3 = [t3]), n2 = i3 ? yx(r3, i3) : r3;
    }
    if (!t2) {
      if (QA.AREAS) {
        const e10 = new yb(Ry.PROHIBITED_OPERATION, "setArea is prohibited because of config-distribute");
        return i2.onError(e10), void fb.warning("setArea is prohibited because of config-distribute");
      }
      if (Dn(n2).call(n2, iO.GLOBAL) && XA("AREAS") === iO.EXTENSIONS) {
        const e10 = new yb(Ry.PROHIBITED_OPERATION, "setArea is prohibited because of ap extensions");
        return i2.onError(e10), void fb.warning("setArea is prohibited because of ap extensions");
      }
    }
    JA("AREAS", n2, t2);
    const r2 = Rx(n2);
    Object.keys(r2).map((e10) => {
      if ("LOG_UPLOAD_SERVER" === e10 || "EVENT_REPORT_DOMAIN" === e10 || "EVENT_REPORT_BACKUP_DOMAIN" === e10 || "PROXY_SERVER_TYPE3" === e10) {
        JA(e10, r2[e10][0]);
      } else JA(e10, r2[e10]);
    }), fb.debug("set area success:", n2.join(","));
  } catch (e10) {
    throw i2.onError(e10), e10;
  }
  i2.onSuccess();
}
function wx(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function Ox(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? wx(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : wx(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var Nx = 1;
function Dx(e9, t2, i2, n2, r2) {
  Nx += 1;
  const o2 = { sid: i2.sid, command: "convergeAllocateEdge", uid: "666", appId: i2.appId, ts: Math.floor(Date.now() / 1e3), seq: Nx, requestId: Nx, version: GA, cname: i2.cname }, s2 = { service_name: t2, json_body: JSON.stringify(o2) };
  let a2, c2, d2 = e9[0];
  return kA(async () => {
    a2 = Date.now();
    const e10 = await Tx(d2, { data: s2, cancelToken: n2, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" } });
    if (c2 = Date.now() - a2, 0 !== e10.code) {
      const t3 = new yb(Ry.UNEXPECTED_RESPONSE, "live streaming ap error, code" + e10.code, { retry: true, responseTime: c2 });
      throw fb.error(t3.toString()), t3;
    }
    const i3 = JSON.parse(e10.json_body);
    if (200 !== i3.code) {
      const e11 = new yb(Ry.UNEXPECTED_RESPONSE, "live streaming app center error, code: ".concat(i3.code, ", reason: ").concat(i3.reason), { code: i3.code, responseTime: c2 });
      throw fb.error(e11.toString()), e11;
    }
    if (!i3.servers || 0 === i3.servers.length) {
      const e11 = new yb(Ry.UNEXPECTED_RESPONSE, "live streaming app center empty server", { code: i3.code, responseTime: c2 });
      throw fb.error(e11.toString()), e11;
    }
    const r3 = function(e11, t3) {
      return { addressList: e11.servers.map((e12) => "wss://".concat(e12.address.replace(/\./g, "-"), ".").concat(XA("WORKER_DOMAIN"), ":").concat(e12.wss, "?serviceName=").concat(encodeURIComponent(t3))), workerToken: e11.workerToken, vid: e11.vid };
    }(i3, t2);
    return XA("LIVE_STREAMING_ADDRESS") && (r3.addressList = XA("LIVE_STREAMING_ADDRESS") instanceof Array ? XA("LIVE_STREAMING_ADDRESS") : [XA("LIVE_STREAMING_ADDRESS")]), Ox(Ox({}, r3), {}, { responseTime: c2 });
  }, (n3, r3) => (vb.apworkerEvent(i2.sid, { success: true, sc: 200, serviceName: t2, responseDetail: JSON.stringify(n3.addressList), firstSuccess: 0 === r3, responseTime: c2, serverIp: e9[r3 % e9.length] }), false), (n3, r3) => (vb.apworkerEvent(i2.sid, { success: false, sc: n3.data && n3.data.code || 200, serviceName: t2, responseTime: c2, serverIp: e9[r3 % e9.length] }), !!(n3.code !== Ry.OPERATION_ABORTED && n3.code !== Ry.UNEXPECTED_RESPONSE || n3.data && n3.data.retry) && (d2 = e9[(r3 + 1) % e9.length], true)), r2);
}
var Px = 1;
function Lx(e9, t2, i2, n2) {
  let { url: r2, areaCode: o2 } = e9;
  const { clientId: s2, sid: a2 } = t2, c2 = Date.now();
  let d2;
  const [l2, u2] = Vx(t2, o2, [YO.CHOOSE_SERVER]);
  let h2 = iA.networkState;
  return kA(async () => {
    h2 && iA.networkState === Xy.OFFLINE && iA.onlineWaiter && await Gh.race([iA.onlineWaiter, mA(n2 && n2.maxRetryTimeout || PA.maxRetryTimeout)]), h2 = iA.networkState;
    const { data: e10, headers: o3 } = await Tx(r2, { data: l2, cancelToken: i2, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
    d2 = "1" === o3.http3 ? 1 : -1, vb.reportResourceTiming(r2, a2), Mx(e10, r2, t2, c2, [YO.CHOOSE_SERVER], d2);
    const s3 = eN(e10, YO.CHOOSE_SERVER);
    return Ux(s3), XO(s3, r2);
  }, (e10) => (e10 && vb.joinChooseServer(a2, { lts: c2, succ: true, csAddr: r2, opid: u2, serverList: e10.gatewayAddrs.map((e11) => e11.address), ec: null, cid: e10.cid.toString(), uid: e10.uid.toString(), csIp: e10.csIp, unilbsServerIds: [YO.CHOOSE_SERVER].toString(), isHttp3: d2, corssRegionTagReq: t2.apRequestDetail, corssRegionTagRes: e10.res.detail && e10.res.detail[38] }), false), (e10) => e10.code !== Ry.OPERATION_ABORTED && (e10.code === Ry.CAN_NOT_GET_GATEWAY_SERVER ? e10.data.retry : (vb.joinChooseServer(a2, { lts: c2, succ: false, csAddr: r2, serverList: null, opid: u2, ec: e10.code, csIp: e10.data && e10.data.csIp, unilbsServerIds: [YO.CHOOSE_SERVER].toString(), extend: JSON.stringify({ networkState: h2 }), isHttp3: d2, corssRegionTagReq: t2.apRequestDetail }), fb.warning("[".concat(s2 || "sid-".concat(a2.slice(0, 6)), "] Choose server network error, retry"), e10), true)), n2);
}
function kx(e9, t2, i2, n2) {
  let r2, { url: o2, areaCode: s2, serviceIds: a2 } = e9;
  const c2 = Date.now(), [d2, l2] = Vx(t2, s2, a2);
  let u2;
  return kA(async () => {
    u2 && iA.networkState === Xy.OFFLINE && iA.onlineWaiter && await Gh.race([iA.onlineWaiter, mA(n2 && n2.maxRetryTimeout || PA.maxRetryTimeout)]), u2 = iA.networkState;
    const { data: e10, headers: s3 } = await Tx(o2, { data: d2, cancelToken: i2, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
    r2 = "1" === s3.http3 ? 1 : -1, vb.reportResourceTiming(o2, t2.sid), Mx(e10, o2, t2, c2, a2, r2);
    const l3 = eN(e10, YO.CHOOSE_SERVER), h2 = eN(e10, "proxy5" === t2.cloudProxyServer ? YO.CLOUD_PROXY_5 : "proxy3" === t2.cloudProxyServer || "proxy4" === t2.cloudProxyServer ? YO.CLOUD_PROXY : YO.CLOUD_PROXY_FALLBACK);
    return Ux(l3), { gatewayInfo: XO(l3, o2), proxyInfo: h2, url: o2 };
  }, (e10) => (e10.gatewayInfo && vb.joinChooseServer(t2.sid, { lts: c2, succ: true, csAddr: o2, serverList: e10.gatewayInfo.gatewayAddrs.map((e11) => e11.address), ec: null, opid: l2, cid: e10.gatewayInfo.cid.toString(), uid: e10.gatewayInfo.uid.toString(), csIp: e10.gatewayInfo.csIp, unilbsServerIds: a2.toString(), isHttp3: r2, corssRegionTagReq: t2.apRequestDetail, corssRegionTagRes: e10.gatewayInfo.res.detail && e10.gatewayInfo.res.detail[38] }), e10.proxyInfo && vb.joinWebProxyAP(t2.sid, { lts: c2, sucess: 1, apServerAddr: o2, turnServerAddrList: e10.proxyInfo.addresses.map((e11) => e11.ip).join(","), errorCode: null, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString() }), false), (e10) => e10.code !== Ry.OPERATION_ABORTED && (e10.code === Ry.CAN_NOT_GET_GATEWAY_SERVER ? e10.data.retry : (vb.joinWebProxyAP(t2.sid, { lts: c2, sucess: 0, apServerAddr: o2, turnServerAddrList: null, errorCode: e10.code, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString(), extend: JSON.stringify({ networkState: u2 }) }), fb.warning("[".concat(t2.clientId, "] multi unilbs network error, retry"), e10), true)), n2);
}
var Mx = (e9, t2, i2, n2, r2, o2) => {
  const { sid: s2, clientId: a2, cloudProxyServer: c2 } = i2, d2 = [], l2 = (a3) => {
    4096 === a3.flag ? vb.joinChooseServer(s2, { lts: n2, succ: false, csAddr: t2, opid: e9.opid, serverList: null, ec: a3.error.message, csIp: a3.error.data && a3.error.data.csIp, unilbsServerIds: r2.toString(), isHttp3: o2, corssRegionTagReq: i2.apRequestDetail }) : 1048576 !== a3.flag && 4194304 !== a3.flag && 4194310 !== a3.flag || vb.joinWebProxyAP(s2, { lts: n2, sucess: 0, apServerAddr: t2, turnServerAddrList: null, errorCode: a3.error.code, eventType: c2, unilbsServerIds: r2.toString() });
  };
  if (e9.response_body.forEach((t3) => {
    const i3 = t3.buffer.code;
    if (23 === t3.uri && 0 === i3 && !t3.buffer.edges_services) if (4194310 === t3.buffer.flag) fb.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"), t3.buffer.edges_services = [];
    else {
      const i4 = { error: new yb(Ry.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: e9.detail[502] }), flag: t3.buffer.flag };
      d2.push(i4), l2(i4);
    }
    if (0 !== i3) {
      const n3 = wO(i3), r3 = { error: new yb(Ry.CAN_NOT_GET_GATEWAY_SERVER, n3.desc, { desc: n3.desc, retry: n3.retry, csIp: e9.detail[502] }), flag: t3.buffer.flag };
      4194310 === t3.buffer.flag ? fb.warning(r3.error.toString()) : d2.push(r3), l2(r3);
    }
  }), d2.length) throw fb.warning("[".concat(a2 || "sid-".concat(s2.slice(0, 6)), "] multi unilbs ").concat(t2, " failed, ").concat(d2.map((e10) => "flag: ".concat(e10.flag, ", message: ").concat(e10.error.message, ", retry: ").concat(e10.error.data.retry)).join(" | "))), new yb(Ry.CAN_NOT_GET_GATEWAY_SERVER, d2.map((e10) => "flag: ".concat(e10.flag, ", message: ").concat(e10.error.message)).join(" | "), { retry: !!d2.find((e10) => e10.error.data.retry), csIp: e9.detail[502], desc: [...new Set(d2.map((e10) => {
    var t3;
    return null == e10 || null === (t3 = e10.error) || void 0 === t3 || null === (t3 = t3.data) || void 0 === t3 ? void 0 : t3.desc;
  }).filter((e10) => !!e10))] });
};
var Ux = (e9) => {
  var t2, i2, n2, r2;
  if (e9.addresses && 0 === e9.addresses.length && 0 === e9.code) throw new yb(Ry.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", { retry: true, csIp: e9.detail && e9.detail[502] });
  XA("AP_AREA") && (null !== (n2 = e9.detail) && void 0 !== n2 && n2[23] && "string" == typeof (null === (r2 = e9.detail) || void 0 === r2 ? void 0 : r2[23]) ? Ax(e9.detail[23].toLowerCase()) : Ax());
  if (null !== (t2 = e9.detail) && void 0 !== t2 && t2[19] && "string" == typeof (null === (i2 = e9.detail) || void 0 === i2 ? void 0 : i2[19])) {
    const t3 = e9.detail[19], i3 = null == t3 ? void 0 : t3.split(";");
    for (let t4 = 0; t4 < i3.length; t4++) {
      var o2;
      const n3 = jp(o2 = i3[t4]).call(o2);
      e9.addresses[t4] && i3 && (e9.addresses[t4].fingerprint = n3);
    }
  }
  if (XA("GATEWAY_ADDRESS") && XA("GATEWAY_ADDRESS").length > 0) {
    fb.debug("assign gateway address to", XA("GATEWAY_ADDRESS"));
    const t3 = XA("GATEWAY_ADDRESS").map((t4) => {
      var i3, n3;
      const r3 = null !== (i3 = null === (n3 = e9.addresses.find((e10) => e10.ip === t4.ip && e10.port === t4.port)) || void 0 === n3 ? void 0 : n3.fingerprint) && void 0 !== i3 ? i3 : "";
      return { ip: t4.ip, port: t4.port, ticket: e9.addresses[0] && e9.addresses[0].ticket, fingerprint: r3 };
    });
    e9.addresses = t3;
  }
};
var xx = (e9, t2) => {
  if (e9.response_body && e9.response_body.length) {
    const t3 = e9.response_body[0];
    if (0 !== t3.buffer.code) {
      const e10 = wO(t3.buffer.code);
      throw new yb(Ry.UPDATE_TICKET_FAILED, "[".concat(t3.buffer.code, "]: ").concat(e10.desc), { retry: e10.retry });
    }
    return t3.buffer.ticket;
  }
  throw fb.debug("update ticket request received ap response without response body:", t2), new yb(Ry.UPDATE_TICKET_FAILED, "cannot find response body from ap response", { retry: false });
};
var Vx = (e9, t2, i2) => {
  const n2 = Math.floor(Math.random() * 10 ** 12), r2 = { appid: e9.appId, client_ts: Date.now(), opid: n2, sid: e9.sid, request_bodies: [{ uri: 22, buffer: { cname: e9.cname, detail: Ox(Ox({ 6: e9.stringUid, 11: t2, 12: XA("USE_NEW_TOKEN") ? "1" : void 0, 22: t2 }, e9.apRequestDetail ? { 33: e9.apRequestDetail } : {}), e9.apRTM ? { 26: "RTM2" } : {}), key: e9.token, service_ids: i2, uid: e9.uid || 0 } }] };
  r2.request_bodies.forEach((t3) => {
    e9.multiIP && e9.multiIP.gateway_ip && (t3.buffer.detail[5] = JSON.stringify({ vocs_ip: [e9.multiIP.uni_lbs_ip], vos_ip: [e9.multiIP.gateway_ip] }));
  });
  const o2 = new FormData();
  return o2.append("request", JSON.stringify(r2)), [o2, n2];
};
var Fx = (e9, t2) => {
  const i2 = Math.floor(Math.random() * 10 ** 12), n2 = { appid: e9.appId, client_ts: Date.now(), opid: i2, sid: e9.sid, request_bodies: [{ uri: 28, buffer: { cname: e9.cname, detail: { 1: "", 6: e9.stringUid, 12: "1" }, token: e9.token, service_ids: t2, uid: e9.uid || 0, edges_services: e9.apResponse.addresses.map((e10) => ({ ip: e10.ip, port: e10.port })) } }] }, r2 = new FormData();
  return r2.append("request", JSON.stringify(n2)), [r2, i2];
};
var Bx = 0;
function jx(e9) {
  return Gh.all(e9.map((e10) => e10.then((e11) => {
    throw e11;
  }, (e11) => e11))).then((e10) => {
    throw e10;
  }, (e10) => e10);
}
var Gx = async (e9) => {
  let { fragementLength: t2, referenceList: i2, asyncMapHandler: n2, allFailedhandler: r2, promisesCollector: o2 } = e9, s2 = 0;
  const a2 = t2;
  let c2, d2 = 0;
  const l2 = async () => {
    const e10 = (() => {
      const e11 = s2 * a2, t3 = e11 + a2;
      return i2.slice(e11, t3).map(n2);
    })();
    o2 && o2.push(...e10);
    try {
      c2 = await jx(e10);
    } catch (e11) {
      if (d2 += a2, s2++, !(d2 >= i2.length)) return void await l2();
      r2(e11);
    }
    e10.forEach((e11) => e11.cancel());
  };
  return await l2(), c2;
};
var Wx = async (e9) => {
  let { referenceList: t2, asyncMapHandler: i2, closeFn: n2 } = e9;
  const r2 = t2.length;
  let o2 = 0;
  const s2 = async () => {
    const e10 = i2(t2.shift());
    try {
      return await e10;
    } catch (e11) {
      if (o2++, o2 >= r2 || null != n2 && n2(e11)) throw e11;
      return s2();
    }
  };
  return s2();
};
async function Hx(e9, t2, i2, n2) {
  const r2 = async function(e10, t3, i3, n3) {
    let r3 = null;
    const o2 = [], s2 = async () => {
      const r4 = XA("WEBCS_DOMAIN").slice(0, XA("AJAX_REQUEST_CONCURRENT")).map((t4) => ({ url: e10.proxyServer ? "https://".concat(e10.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: Sx() })), s3 = n3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r4.map((e11) => e11.url) }), a3 = await Gx({ fragementLength: XA("FRAGEMENT_LENGTH"), referenceList: r4, asyncMapHandler: (n4) => (fb.debug("[".concat(e10.clientId, "] Connect to choose_server:"), n4.url), Lx(n4, e10, t3, i3)), allFailedhandler: (e11) => {
        throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e11 }, s3), e11[0];
      }, promisesCollector: o2 });
      return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), a3;
    }, a2 = async () => {
      if (await mA(1e3), null !== r3) return r3;
      const s3 = XA("WEBCS_DOMAIN_BACKUP_LIST").map((t4) => ({ url: e10.proxyServer ? "https://".concat(e10.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: Sx() })), a3 = n3.recordJoinChannelService({ endTs: void 0, startTs: Date.now(), status: "pending", service: "chooseServer", urls: s3.map((e11) => e11.url) }), c2 = await Gx({ fragementLength: XA("FRAGEMENT_LENGTH"), referenceList: s3, asyncMapHandler: (n4) => (fb.debug("[".concat(e10.clientId, "] Connect to backup choose_server:"), n4.url), Lx(n4, e10, t3, i3)), allFailedhandler: (e11) => {
        throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e11 }, a3), e11[0];
      }, promisesCollector: o2 });
      return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a3), c2;
    };
    try {
      return r3 = await jx([s2(), a2()]), o2.length && o2.forEach((e11) => e11.cancel && "function" == typeof e11.cancel && e11.cancel()), r3;
    } catch (e11) {
      throw e11[0];
    }
  }(e9, t2, i2, n2);
  return { gatewayInfo: await r2 };
}
async function Kx(e9, t2, i2, n2, r2) {
  const o2 = e9.cloudProxyServer;
  if ("disabled" === o2) {
    if (!n2) return;
    if (e9.useLocalAccessPoint) return await Hx(e9, t2, i2, r2);
    if (XA("JOIN_WITH_FALLBACK_MEDIA_PROXY")) {
      const { gatewayInfo: n3, proxyInfo: o3 } = await Xx(e9, t2, i2, r2);
      if (e9.turnServer && "auto" !== e9.turnServer.mode) return { gatewayInfo: n3 };
      const a3 = o3.map((e10) => ({ turnServerURL: e10.address, tcpport: e10.tcpport || KA.tcpport, udpport: e10.udpport || KA.udpport, username: e10.username || KA.username, password: e10.password || KA.password, forceturn: false, security: true }));
      if (r2.useP2P) {
        var s2;
        const t3 = null !== (s2 = e9.uid) && void 0 !== s2 ? s2 : n3.uid, i3 = "glb:".concat(t3.toString()), r3 = await Uy(i3), c3 = o3.map((e10) => ({ turnServerURL: e10.address, tcpport: e10.tcpport || KA.tcpport, udpport: e10.udpport || KA.udpport, username: i3, password: r3, forceturn: false, security: true }));
        a3.push(...c3);
      }
      return e9.turnServer = { mode: "manual", servers: a3 }, { gatewayInfo: n3 };
    }
    return await Hx(e9, t2, i2, r2);
  }
  const { proxyInfo: a2, gatewayInfo: c2 } = await Xx(e9, t2, i2, r2), d2 = { gatewayInfo: c2 }, l2 = a2.map((e10) => ({ turnServerURL: e10.address, tcpport: "proxy3" === o2 ? void 0 : e10.tcpport ? e10.tcpport : KA.tcpport, udpport: "proxy4" === o2 ? void 0 : e10.udpport ? e10.udpport : KA.udpport, username: e10.username || KA.username, password: e10.password || KA.password, forceturn: "proxy4" !== o2, security: "proxy5" === o2 }));
  if (r2.useP2P) {
    var u2;
    const t3 = null !== (u2 = e9.uid) && void 0 !== u2 ? u2 : c2.uid, i3 = "glb:".concat(t3.toString()), n3 = await Uy(i3), r3 = a2.map((e10) => ({ turnServerURL: e10.address, tcpport: "proxy3" === o2 ? void 0 : e10.tcpport || KA.tcpport, udpport: "proxy4" === o2 ? void 0 : e10.udpport || KA.udpport, username: i3, password: n3, forceturn: "proxy4" !== o2, security: "proxy5" === o2 }));
    l2.push(...r3);
  }
  return e9.turnServer = { mode: "manual", servers: l2 }, fb.debug("[".concat(e9.clientId, "] set proxy server: ").concat(e9.proxyServer, ", mode: ").concat(o2)), d2;
}
async function Yx(e9, t2, i2, n2, r2) {
  const o2 = XA("ACCOUNT_REGISTER").slice(0, XA("AJAX_REQUEST_CONCURRENT"));
  let s2 = [];
  s2 = t2.proxyServer ? o2.map((e10) => "https://".concat(t2.proxyServer, "/ap/?url=").concat(e10 + "/api/v1")) : o2.map((e10) => "https://".concat(e10, "/api/v1"));
  const a2 = null == r2 ? void 0 : r2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "stringUID", urls: s2 });
  try {
    const o3 = await async function(e10, t3, i3, n3, r3) {
      const o4 = Date.now(), s3 = { sid: i3.sid, opid: 10, appid: i3.appId, string_uid: t3 };
      let a3 = e10[0];
      const c2 = await kA(() => Tx(a3 + "".concat(-1 === a3.indexOf("?") ? "?" : "&", "action=stringuid"), { data: s3, cancelToken: n3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } }), (i4, n4) => {
        if (0 === i4.code) {
          if (i4.uid <= 0 || i4.uid >= Math.pow(2, 32)) throw fb.error("Invalid Uint Uid ".concat(t3, " => ").concat(i4.uid), i4), vb.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: i4.uid, errorCode: Ry.INVALID_UINT_UID_FROM_STRING_UID, extend: s3 }), new yb(Ry.INVALID_UINT_UID_FROM_STRING_UID);
          return vb.reqUserAccount(s3.sid, { lts: o4, success: true, serverAddr: a3, stringUid: s3.string_uid, uid: i4.uid, errorCode: null, extend: s3 }), false;
        }
        const r4 = wO(i4.code);
        return r4.retry && (a3 = e10[(n4 + 1) % e10.length]), vb.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: i4.uid, errorCode: r4.desc, extend: s3 }), r4.retry;
      }, (t4, i4) => t4.code !== Ry.OPERATION_ABORTED && (vb.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: null, errorCode: t4.code, extend: s3 }), a3 = e10[(i4 + 1) % e10.length], true), r3);
      if (0 !== c2.code) {
        const e11 = wO(c2.code);
        throw new yb(Ry.UNEXPECTED_RESPONSE, e11.desc);
      }
      return c2;
    }(s2, e9, t2, i2, n2);
    return null == r2 || r2.recordJoinChannelService({ status: "success", endTs: Date.now() }, a2), o3.uid;
  } catch (e10) {
    throw null == r2 || r2.recordJoinChannelService({ status: "error", endTs: Date.now(), errors: [e10] }, a2), e10;
  }
}
async function qx(e9, t2, i2) {
  const n2 = XA("ACCOUNT_REGISTER");
  let r2 = [];
  r2 = t2.proxyServer ? n2.map((e10) => "https://".concat(t2.proxyServer, "/ap/?url=").concat(e10 + "/api/v1")) : n2.map((e10) => "https://".concat(e10, "/api/v1"));
  try {
    const n3 = await Wx({ referenceList: r2, asyncMapHandler: (n4) => async function(e10, t3, i3, n5) {
      const r3 = Date.now(), o2 = { sid: i3.sid, opid: 10, appid: i3.appId, string_uid: t3 };
      try {
        const t4 = await Tx(e10 + "".concat(-1 === e10.indexOf("?") ? "?" : "&", "action=stringuid"), { data: o2, cancelToken: n5, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } });
        if (0 !== t4.code) {
          const e11 = wO(t4.code);
          throw new yb(Ry.UNEXPECTED_RESPONSE, "preload sua error:".concat(e11.desc), e11);
        }
        if (t4.uid <= 0 || t4.uid >= Math.pow(2, 32)) throw new yb(Ry.INVALID_UINT_UID_FROM_STRING_UID);
        return { requestTime: r3, url: e10, req: o2, uid: t4.uid, elapse: Date.now() - r3 };
      } catch (e11) {
        throw e11;
      }
    }(n4, e9, t2, i2), closeFn: (e10) => e10.code === Ry.OPERATION_ABORTED || e10.code === Ry.UNEXPECTED_RESPONSE && !e10.data.retry });
    return n3;
  } catch (e10) {
    throw e10;
  }
}
async function zx(e9, t2, i2) {
  const n2 = XA("CDS_AP").slice(0, XA("AJAX_REQUEST_CONCURRENT")).map((t3) => e9.proxyServer ? "https://".concat(e9.proxyServer, "/ap/?url=").concat(t3 + "/api/v1") : "https://".concat(t3, "/api/v1?action=config")), r2 = n2.map((n3) => function(e10, t3, i3, n4) {
    const r3 = Hv(), o3 = { flag: 64, cipher_method: 0, features: { device: r3.name, system: r3.os, system_general: navigator.userAgent, vendor: t3.appId, version: GA, cname: t3.cname, sid: t3.sid, session_id: t3.sid, detail: "", proxyServer: t3.proxyServer } };
    return kA(() => Tx(e10, { data: o3, timeout: 1e3, cancelToken: i3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 54 } }), void 0, (e11) => e11.code !== Ry.OPERATION_ABORTED, n4);
  }(n3, e9, t2, i2));
  let o2 = null, s2 = null, a2 = {};
  try {
    o2 = await jx(r2);
  } catch (e10) {
    if (e10.code === Ry.OPERATION_ABORTED) throw e10;
    s2 = e10;
  }
  r2.forEach((e10) => e10.cancel());
  if (vb.reportApiInvoke(e9.sid, { name: By.REQUEST_CONFIG_DISTRIBUTE, options: { error: s2, res: o2 } }).onSuccess(), o2 && o2.test_tags) try {
    a2 = function(e10) {
      if (!e10.test_tags) return {};
      const t3 = e10.test_tags, i3 = Object.keys(t3), n3 = {};
      return i3.forEach((e11) => {
        var i4;
        const r3 = jp(i4 = e11.slice(4)).call(i4), o3 = JSON.parse(t3[e11])[1];
        n3[r3] = o3;
      }), n3;
    }(o2);
  } catch (e10) {
  }
  return a2;
}
async function Jx(e9, t2) {
  const i2 = XA("WEBCS_DOMAIN").concat(XA("WEBCS_DOMAIN_BACKUP_LIST")).map((e10) => ({ url: "https://".concat(e10, "/api/v2/transpond/webrtc?v=2"), areaCode: Sx(), serviceIds: [YO.CHOOSE_SERVER, YO.CLOUD_PROXY_FALLBACK] }));
  try {
    const n2 = await Wx({ referenceList: i2, asyncMapHandler: (i3) => async function(e10, t3, i4) {
      let n3, { url: r2, areaCode: o2, serviceIds: s2 } = e10;
      const a2 = Date.now(), [c2, d2] = Vx(t3, o2, s2);
      let l2 = iA.networkState;
      try {
        l2 && iA.networkState === Xy.OFFLINE && iA.onlineWaiter && await Gh.race([iA.onlineWaiter, mA(PA.maxRetryTimeout)]), l2 = iA.networkState;
        const { data: e11, headers: t4 } = await Tx(r2, { data: c2, cancelToken: i4, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
        n3 = "1" === t4.http3 ? 1 : -1;
        const o3 = (e12) => {
          const t5 = [];
          if (e12.response_body.forEach((i5) => {
            const n4 = i5.buffer.code;
            if (23 === i5.uri && 0 === n4 && !i5.buffer.edges_services) if (4194310 === i5.buffer.flag) i5.buffer.edges_services = [];
            else {
              const n5 = { error: new yb(Ry.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: e12.detail[502] }), flag: i5.buffer.flag };
              t5.push(n5);
            }
            if (0 !== n4) {
              const r3 = wO(n4), o4 = { error: new yb(Ry.CAN_NOT_GET_GATEWAY_SERVER, r3.desc, { desc: r3.desc, retry: r3.retry, csIp: e12.detail[502] }), flag: i5.buffer.flag };
              4194310 === i5.buffer.flag ? fb.warning(o4.error.toString()) : t5.push(o4);
            }
          }), t5.length) throw new yb(Ry.CAN_NOT_GET_GATEWAY_SERVER, t5.map((e13) => "flag: ".concat(e13.flag, ", message: ").concat(e13.error.message)).join(" | "), { retry: !!t5.find((e13) => e13.error.data.retry), csIp: e12.detail[502], desc: [...new Set(t5.map((e13) => {
            var t6;
            return null == e13 || null === (t6 = e13.error) || void 0 === t6 || null === (t6 = t6.data) || void 0 === t6 ? void 0 : t6.desc;
          }).filter((e13) => !!e13))] });
        };
        o3(e11);
        const s3 = eN(e11, YO.CHOOSE_SERVER), u2 = eN(e11, YO.CLOUD_PROXY_FALLBACK);
        return Ux(s3), { gatewayInfo: XO(s3, r2), proxyInfo: u2, opid: d2, requestTime: a2, url: r2, isHttp3: n3, elapse: Date.now() - a2 };
      } catch (e11) {
        throw e11;
      }
    }(i3, e9, t2), closeFn: (e10) => e10.code === Ry.OPERATION_ABORTED || e10.code === Ry.CAN_NOT_GET_GATEWAY_SERVER && !e10.data.retry });
    return n2;
  } catch (e10) {
    throw e10;
  }
}
async function Xx(e9, t2, i2, n2) {
  const r2 = XA("PROXY_SERVER_TYPE3"), o2 = (e10, t3, i3) => {
    let n3 = i3 || r2;
    return Array.isArray(n3) && (n3 = t3 % 2 == 0 ? r2[1] : r2[0]), "https://".concat(n3, "/ap/?url=").concat(e10);
  };
  let s2 = null;
  const a2 = [], c2 = async () => {
    const r3 = XA("WEBCS_DOMAIN").slice(0, XA("AJAX_REQUEST_CONCURRENT")).map((t3, i3) => {
      let n3;
      return n3 = "disabled" === e9.cloudProxyServer && e9.proxyServer ? o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3, e9.proxyServer) : "disabled" === e9.cloudProxyServer || "fallback" === e9.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3), { url: n3, areaCode: Sx(), serviceIds: [YO.CHOOSE_SERVER, "proxy5" === e9.cloudProxyServer ? YO.CLOUD_PROXY_5 : "proxy3" === e9.cloudProxyServer || "proxy4" === e9.cloudProxyServer ? YO.CLOUD_PROXY : YO.CLOUD_PROXY_FALLBACK] };
    }), s3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e10) => e10.url) }), c3 = await Gx({ fragementLength: XA("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (fb.debug("[".concat(e9.clientId, "] Connect to choose_server:"), n3.url), kx(n3, e9, t2, i2)), allFailedhandler: (e10) => {
      throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e10 }, s3), e10[0];
    }, promisesCollector: a2 });
    return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), c3;
  }, d2 = async () => {
    if (await mA(1e3), null !== s2) return s2;
    const r3 = XA("WEBCS_DOMAIN_BACKUP_LIST").map((t3, i3) => {
      let n3;
      return n3 = "disabled" === e9.cloudProxyServer && e9.proxyServer ? o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3, e9.proxyServer) : "disabled" === e9.cloudProxyServer || "fallback" === e9.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3), { url: n3, areaCode: Sx(), serviceIds: [YO.CHOOSE_SERVER, "proxy5" === e9.cloudProxyServer ? YO.CLOUD_PROXY_5 : "proxy3" === e9.cloudProxyServer || "proxy4" === e9.cloudProxyServer ? YO.CLOUD_PROXY : YO.CLOUD_PROXY_FALLBACK] };
    }), c3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e10) => e10.url) }), d3 = await Gx({ fragementLength: XA("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (fb.debug("[".concat(e9.clientId, "] Connect to backup choose_server:"), n3.url), kx(n3, e9, t2, i2)), allFailedhandler: (e10) => {
      throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e10 }, c3), e10[0];
    }, promisesCollector: a2 });
    return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c3), d3;
  };
  let l2, u2, h2;
  try {
    ({ gatewayInfo: l2, proxyInfo: u2, url: h2 } = await jx([c2(), d2()]));
  } catch (e10) {
    throw e10[0];
  }
  if (a2.length && a2.forEach((e10) => e10.cancel && "function" == typeof e10.cancel && e10.cancel()), !l2 || !u2) throw new yb(Ry.UNEXPECTED_ERROR, "missing gateway or proxy response").print();
  if (e9.apUrl = h2, "disabled" !== e9.cloudProxyServer && Array.isArray(r2) && h2) {
    const t3 = /^https?:\/\/(.+?)(\/.*)?$/.exec(h2)[1];
    Dn(r2).call(r2, t3) && (e9.proxyServer = t3, fb.setProxyServer(t3), vb.setProxyServer(t3));
  }
  return s2 = { gatewayInfo: l2, proxyInfo: await tN(u2, l2.uid) }, s2;
}
async function Qx(e9, t2, i2) {
  const n2 = XA("UAP_AP").slice(0, XA("AJAX_REQUEST_CONCURRENT")).map((t3) => e9.proxyServer ? "https://".concat(e9.proxyServer, "/ap/?url=").concat(t3 + "/api/v1?action=uap") : "https://".concat(t3, "/api/v1?action=uap")), r2 = n2.map((n3) => function(e10, t3, i3, n4) {
    const r3 = { command: "convergeAllocateEdge", sid: t3.sid, appId: t3.appId, token: t3.token, ts: Date.now(), version: GA, cname: t3.cname, uid: t3.uid.toString(), requestId: Px, seq: Px };
    Px += 1;
    const o2 = { service_name: "tele_channel", json_body: JSON.stringify(r3) };
    return kA(async () => {
      const t4 = await Tx(e10, { data: o2, cancelToken: i3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 61 } });
      if (0 !== t4.code) {
        const e11 = new yb(Ry.UNEXPECTED_RESPONSE, "cross channel ap error, code" + t4.code, { retry: true });
        throw fb.error(e11.toString()), e11;
      }
      const n5 = JSON.parse(t4.json_body);
      if (200 !== n5.code) {
        const e11 = new yb(Ry.UNEXPECTED_RESPONSE, "cross channel app center error, code: ".concat(n5.code, ", reason: ").concat(n5.reason));
        throw fb.error(e11.toString()), e11;
      }
      if (!n5.servers || 0 === n5.servers.length) {
        const e11 = new yb(Ry.UNEXPECTED_RESPONSE, "cross channel app center empty server");
        throw fb.error(e11.toString()), e11;
      }
      return { vid: n5.vid, workerToken: n5.workerToken, addressList: (XA("CHANNEL_MEDIA_RELAY_SERVERS") || n5.servers).map((e11) => "wss://".concat(e11.address.replace(/\./g, "-"), ".").concat(XA("WORKER_DOMAIN"), ":").concat(e11.wss)) };
    }, void 0, (e11) => !!(e11.code !== Ry.OPERATION_ABORTED && e11.code !== Ry.UNEXPECTED_RESPONSE || e11.data && e11.data.retry), n4);
  }(n3, e9, t2, i2));
  try {
    const e10 = await jx(r2);
    return r2.forEach((e11) => e11.cancel()), e10;
  } catch (e10) {
    throw e10[0];
  }
}
async function Zx(e9, t2, i2) {
  let n2 = null;
  const r2 = [], o2 = async (o3) => {
    const s2 = XA(o3 ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map((t3) => e9.proxyServer ? "https://".concat(e9.proxyServer, "/ap/?url=").concat(t3 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t3, "/api/v2/transpond/webrtc?v=2"));
    return o3 && (await mA(1e3), null !== n2) ? n2 : await Gx({ fragementLength: XA("FRAGEMENT_LENGTH"), referenceList: s2, asyncMapHandler: (n3) => (fb.debug("[".concat(e9.clientId, "] update ticket, Connect to ").concat(o3 ? "backup" : "", " choose_server:"), n3), function(e10, t3, i3, n4) {
      const [r3] = Fx(t3, [YO.CHOOSE_SERVER]);
      let o4 = iA.networkState;
      return kA(async () => {
        o4 && iA.networkState === Xy.OFFLINE && iA.onlineWaiter && await Gh.race([iA.onlineWaiter, mA(n4 && n4.maxRetryTimeout || PA.maxRetryTimeout)]), o4 = iA.networkState;
        const t4 = await Tx(e10, { data: r3, cancelToken: i3, headers: { "Content-Type": "multipart/form-data;" } }, true);
        return xx(t4, e10);
      }, () => false, (e11) => e11.code !== Ry.OPERATION_ABORTED && (e11.code === Ry.UPDATE_TICKET_FAILED ? e11.data.retry : (fb.warning("[".concat(t3.clientId, "] update ticket network error, retry"), e11), true)), n4);
    }(n3, e9, t2, i2)), allFailedhandler: (e10) => {
      throw e10[0];
    }, promisesCollector: r2 });
  };
  try {
    return n2 = await jx([o2(false), o2(true)]), r2.length && r2.forEach((e10) => e10.cancel && "function" == typeof e10.cancel && e10.cancel()), n2;
  } catch (e10) {
    throw e10[0];
  }
}
function $x(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function eV(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? $x(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : $x(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var tV = class extends xy {
  get isSuccess() {
    return !!this.configs;
  }
  constructor() {
    super(), Fg(this, "configs", void 0), Fg(this, "joinInfo", void 0), Fg(this, "cancelToken", void 0), Fg(this, "retryConfig", { timeout: 3e3, timeoutFactor: 1.5, maxRetryCount: 1, maxRetryTimeout: 1e4 }), Fg(this, "interval", void 0), Fg(this, "mutex", new NA("config-distribute")), Fg(this, "mutableParamsRead", false);
  }
  startGetConfigDistribute(e9, t2) {
    this.joinInfo = e9, this.cancelToken = t2, this.interval && this.stopGetConfigDistribute(), XA("ENABLE_CONFIG_DISTRIBUTE") && (this.updateConfigDistribute(), this.interval = window.setInterval(() => {
      this.updateConfigDistribute();
    }, XA("CONFIG_DISTRIBUTE_INTERVAL")));
  }
  stopGetConfigDistribute() {
    this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0;
  }
  async awaitConfigDistributeComplete() {
    if (!this.mutex.isLocked) return;
    (await this.mutex.lock())();
  }
  async updateConfigDistribute() {
    if (!this.mutableParamsRead) {
      this.mutableParamsRead = true;
      vb.reportApiInvoke(null, { options: void 0, name: By.LOAD_CONFIG_FROM_LOCALSTORAGE, tag: jy.TRACER }).onSuccess(JSON.stringify(QA));
    }
    if (!this.joinInfo || !this.cancelToken || !this.retryConfig) return void fb.debug("[config-distribute] get config distribute interrupted have no joininfo");
    let e9;
    const t2 = await this.mutex.lock();
    try {
      e9 = await zx(this.joinInfo, this.cancelToken, this.retryConfig), fb.debug("[config-distribute] get config distribute", JSON.stringify(e9)), e9.limit_bitrate && this.handleBitrateLimit(e9.limit_bitrate), this.cacheGlobalParameterConfig(e9), this.configs = e9;
    } catch (e10) {
      const t3 = new yb(Ry.NETWORK_RESPONSE_ERROR, e10);
      fb.warning("[config-distribute] ".concat(t3.toString()));
    } finally {
      t2();
    }
  }
  getBitrateLimit() {
    return this.configs ? this.configs.limit_bitrate : void 0;
  }
  handleBitrateLimit(e9) {
    var t2;
    (t2 = e9) && t2.uplink && t2.id && void 0 !== t2.uplink.max_bitrate && void 0 !== t2.uplink.min_bitrate && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== e9.id && this.emit(sO.UPDATE_BITRATE_LIMIT, e9) : this.emit(sO.UPDATE_BITRATE_LIMIT, e9));
  }
  getLowStreamConfigDistribute() {
    return this.configs && this.configs.limit_bitrate && eV({}, this.configs.limit_bitrate.low_stream_uplink);
  }
  cacheGlobalParameterConfig(e9) {
    var t2;
    const i2 = aE(t2 = Object.keys(e9).filter((e10) => /^webrtc_ng_global_parameter/.test(e10))).call(t2);
    for (let t3 = 0; t3 < i2.length; t3++) for (let n3 = i2.length - 1; n3 > t3; n3--) {
      const t4 = i2[n3];
      if ("number" == typeof e9[t4].__priority) {
        const r2 = e9[t4].__priority, o2 = i2[n3 - 1];
        if ("number" == typeof e9[o2].__priority) {
          if (!(r2 > e9[o2].__priority)) continue;
          {
            const e10 = t4;
            i2[n3] = i2[n3 - 1], i2[n3 - 1] = e10;
          }
        } else {
          const e10 = t4;
          i2[n3] = i2[n3 - 1], i2[n3 - 1] = e10;
        }
      }
    }
    const n2 = {};
    i2.forEach((t3) => {
      const i3 = e9[t3], r2 = i3.__expires;
      Object.keys(i3).forEach((e10) => {
        "__priority" === e10 || "__expires" === e10 || Object.prototype.hasOwnProperty.call(n2, e10) || (n2[e10] = eV({ value: i3[e10] }, r2 && { expires: r2 }));
      });
    });
    try {
      !function(e11) {
        try {
          const t4 = Date.now();
          Object.keys(e11).forEach((i3) => {
            switch (i3) {
              case "ENABLE_EVENT_REPORT":
              case "UPLOAD_LOG":
              case "ENABLE_AG_ADAPTATION":
              case "FORCE_AG_HIGH_FRAMERATE":
              case "FORCE_SUPPORT_AG_ADAPTATION":
              case "ENCODER_CONFIG_LIMIT":
              case "CAMERA_CAPTURE_CONFIG":
              case "ENABLE_PRELOAD":
                if (Object.prototype.hasOwnProperty.call(zA, i3)) {
                  const { value: n3, expires: r2 } = e11[i3];
                  if (r2 && r2 <= t4) return;
                  QA[i3] = n3, zA[i3] = n3, fb.debug("Update global parameters from config distribute", i3, n3);
                }
            }
          });
        } catch (t4) {
          fb.error("Error update config immediately: ".concat(e11), t4.message);
        }
      }(n2);
      const e10 = JSON.stringify(n2), t3 = window.btoa(e10);
      window.localStorage.setItem("websdk_ng_global_parameter", t3), fb.debug("Caching global parameters ".concat(e10));
    } catch (e10) {
      fb.error("Error caching global parameters:", e10.message);
    }
  }
};
var iV = class extends xy {
  constructor() {
    super(...arguments), Fg(this, "resultStorage", /* @__PURE__ */ new Map());
  }
  setLocalAudioStats(e9, t2, i2) {
    this.record("AUDIO_INPUT_LEVEL_TOO_LOW", e9, this.checkAudioInputLevel(i2, t2)), this.record("SEND_AUDIO_BITRATE_TOO_LOW", e9, this.checkSendAudioBitrate(i2, t2));
  }
  setLocalVideoStats(e9, t2, i2) {
    this.record("SEND_VIDEO_BITRATE_TOO_LOW", e9, this.checkSendVideoBitrate(i2, t2)), this.record("FRAMERATE_INPUT_TOO_LOW", e9, this.checkFramerateInput(i2, t2)), this.record("FRAMERATE_SENT_TOO_LOW", e9, this.checkFramerateSent(i2));
  }
  setRemoteAudioStats(e9, t2) {
    const i2 = e9.getUserId();
    this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", i2, this.checkAudioOutputLevel(t2));
  }
  setRemoteVideoStats(e9, t2) {
    const i2 = e9.getUserId();
    this.record("RECV_VIDEO_DECODE_FAILED", i2, this.checkVideoDecode(t2));
  }
  record(e9, t2, i2) {
    if (XA("STATS_UPDATE_INTERVAL") > 500) return;
    this.resultStorage.has(e9) || this.resultStorage.set(e9, { result: [], isPrevNormal: true });
    const n2 = this.resultStorage.get(e9);
    if (n2 && (n2.result.push(i2), n2.result.length >= 5)) {
      var r2;
      const i3 = Dn(r2 = n2.result).call(r2, true);
      n2.isPrevNormal && !i3 && this.emit("exception", nV[e9], e9, t2), !n2.isPrevNormal && i3 && this.emit("exception", nV[e9] + 2e3, e9 + "_RECOVER", t2), n2.isPrevNormal = i3, n2.result = [];
    }
  }
  checkAudioOutputLevel(e9) {
    return !(e9.receiveBitrate > 0 && 0 === e9.receiveLevel);
  }
  checkAudioInputLevel(e9, t2) {
    return t2 instanceof RM && !t2.isActive || (!!t2.muted || 0 !== e9.sendVolumeLevel);
  }
  checkFramerateInput(e9, t2) {
    let i2 = null;
    t2._encoderConfig && t2._encoderConfig.frameRate && (i2 = QO(t2._encoderConfig.frameRate));
    const n2 = e9.captureFrameRate;
    return !i2 || !n2 || !(i2 > 10 && n2 < 5 || i2 < 10 && i2 >= 5 && n2 <= 1);
  }
  checkFramerateSent(e9) {
    return !(e9.captureFrameRate && e9.sendFrameRate && e9.captureFrameRate > 5 && e9.sendFrameRate <= 1);
  }
  checkSendVideoBitrate(e9, t2) {
    return !!t2.muted || 0 !== e9.sendBitrate;
  }
  checkSendAudioBitrate(e9, t2) {
    return t2 instanceof RM && !t2.isActive || (!!t2.muted || 0 !== e9.sendBitrate);
  }
  checkVideoDecode(e9) {
    return 0 === e9.receiveBitrate || 0 !== e9.decodeFrameRate;
  }
};
var nV = { FRAMERATE_INPUT_TOO_LOW: 1001, FRAMERATE_SENT_TOO_LOW: 1002, SEND_VIDEO_BITRATE_TOO_LOW: 1003, RECV_VIDEO_DECODE_FAILED: 1005, AUDIO_INPUT_LEVEL_TOO_LOW: 2001, AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002, SEND_AUDIO_BITRATE_TOO_LOW: 2003 };
var rV = new class {
  markSubscribeStart(e9, t2) {
    performance.mark("agora-web-sdk/".concat(e9, "/subscribe-").concat(t2));
  }
  markPublishStart(e9, t2) {
    performance.mark("agora-web-sdk/".concat(e9, "/publish-").concat(t2));
  }
  measureFromSubscribeStart(e9, t2) {
    const i2 = performance.getEntriesByName("agora-web-sdk/".concat(e9, "/subscribe-").concat(t2));
    if (i2.length > 0) {
      const e10 = i2[i2.length - 1];
      return Math.round(performance.now() - e10.startTime);
    }
    return 0;
  }
  measureFromPublishStart(e9, t2) {
    const i2 = performance.getEntriesByName("agora-web-sdk/".concat(e9, "/publish-").concat(t2));
    if (i2.length > 0) {
      const e10 = i2[i2.length - 1];
      return Math.round(performance.now() - e10.startTime);
    }
    return 0;
  }
}();
var oV = i(ie.Object.getOwnPropertySymbols);
var sV = wi;
var aV = qi.indexOf;
var cV = Bn;
var dV = v([].indexOf);
var lV = !!dV && 1 / dV([1], 1, -0) < 0;
sV({ target: "Array", proto: true, forced: lV || !cV("indexOf") }, { indexOf: function(e9) {
  var t2 = arguments.length > 1 ? arguments[1] : void 0;
  return lV ? dV(this, e9, t2) || 0 : aV(this, e9, t2);
} });
var uV = Xi("Array").indexOf;
var hV = l;
var pV = uV;
var _V = Array.prototype;
var EV = function(e9) {
  var t2 = e9.indexOf;
  return e9 === _V || hV(_V, e9) && t2 === _V.indexOf ? pV : t2;
};
var fV = i(EV);
function mV(e9, t2) {
  if (null == e9) return {};
  var i2, n2, r2 = function(e10, t3) {
    if (null == e10) return {};
    var i3, n3, r3 = {}, o3 = Wb(e10);
    for (n3 = 0; n3 < o3.length; n3++) i3 = o3[n3], fV(t3).call(t3, i3) >= 0 || (r3[i3] = e10[i3]);
    return r3;
  }(e9, t2);
  if (oV) {
    var o2 = oV(e9);
    for (n2 = 0; n2 < o2.length; n2++) i2 = o2[n2], fV(t2).call(t2, i2) >= 0 || Object.prototype.propertyIsEnumerable.call(e9, i2) && (r2[i2] = e9[i2]);
  }
  return r2;
}
function TV(e9) {
  if (Array.isArray(e9)) return e9.map((e10) => e10);
  if (!SV(e9)) return e9;
  const t2 = {};
  for (const i2 in e9) {
    const n2 = e9[i2];
    SV(n2) || Array.isArray(n2) ? t2[i2] = TV(n2) : t2[i2] = n2;
  }
  return t2;
}
function SV(e9) {
  return !("object" != typeof e9 || Array.isArray(e9) || !e9);
}
var gV = class {
  constructor(e9) {
    Fg(this, "input", []), Fg(this, "size", void 0), this.size = e9;
  }
  add(e9) {
    this.input.push(e9), this.input.length > this.size && this.input.splice(0, 1);
  }
  diffMean() {
    return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;
  }
};
var RV = { address: "unknown", candidateType: "unknown", id: "unknown", port: 0, priority: 0, protocol: "unknown", type: "unknown" };
var CV = { timestamp: 0, bitrate: { actualEncoded: 0, transmit: 0 }, sendPacketLossRate: 0, recvPacketLossRate: 0, videoRecv: [], videoSend: [], audioRecv: [], audioSend: [], selectedCandidatePair: { id: "unknown", localCandidate: RV, remoteCandidate: RV } };
var IV = { firsCount: 0, nacksCount: 0, plisCount: 0, framesDecodeCount: 0, framesDecodeInterval: 0, framesDecodeFreezeTime: 0, decodeFrameRate: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, qpSumPerFrame: 0, framesDroppedCount: 0, outputFrameRate: 0 };
var vV = { firsCount: 0, nacksCount: 0, plisCount: 0, frameCount: 0, bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0, qpSumPerFrame: 0 };
var yV = { bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0 };
var AV = { jitterBufferMs: 0, jitterMs: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packetsDiscarded: 0, packets: 0, ssrc: 0, receivedFrames: 0, droppedFrames: 0, concealedSamples: 0 };
function bV(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function wV(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? bV(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : bV(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var OV = class {
  constructor(e9, t2) {
    Fg(this, "onFirstVideoReceived", void 0), Fg(this, "onFirstVideoDecoded", void 0), Fg(this, "onFirstAudioReceived", void 0), Fg(this, "onFirstVideoDecodedTimeout", void 0), Fg(this, "onFirstAudioDecoded", void 0), Fg(this, "onSelectedLocalCandidateChanged", void 0), Fg(this, "onSelectedRemoteCandidateChanged", void 0), Fg(this, "videoIsReady", false), Fg(this, "videoIsReady2", {}), Fg(this, "pc", void 0), Fg(this, "options", void 0), Fg(this, "intervalTimer", void 0), Fg(this, "stats", TV(CV)), Fg(this, "isFirstVideoReceived", {}), Fg(this, "isFirstVideoDecoded", {}), Fg(this, "isFirstAudioReceived", {}), Fg(this, "isFirstAudioDecoded", {}), Fg(this, "isFirstVideoDecodedTimeout", {}), Fg(this, "lossRateWindowStats", []), this.pc = e9, this.options = t2, this.intervalTimer = window.setInterval(async () => {
      this.updateStats();
    }, this.options.updateInterval);
  }
  getStats() {
    return this.stats;
  }
  getSelectedCandidatePair() {
    return new Gh((e9) => {
      e9({ local: wV({}, RV), remote: wV({}, RV) });
    });
  }
  setVideoIsReady(e9) {
    this.videoIsReady = e9;
  }
  setVideoIsReady2(e9, t2) {
    this.videoIsReady2[e9] = t2;
  }
  getVideoIsReady(e9) {
    return this.videoIsReady2[e9] || false;
  }
  setIsFirstAudioDecoded(e9) {
  }
  destroy() {
    window.clearInterval(this.intervalTimer), this.pc = void 0;
  }
  calcLossRate(e9) {
    this.lossRateWindowStats.push(e9), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);
    const t2 = this.lossRateWindowStats.length, i2 = ["videoSend", "audioSend", "videoRecv", "audioRecv"];
    let n2 = 0, r2 = 0, o2 = 0, s2 = 0;
    for (const a2 of i2) e9[a2].forEach((e10, i3) => {
      if (!this.lossRateWindowStats[t2 - 1][a2][i3] || !this.lossRateWindowStats[0][a2][i3]) return;
      const c2 = this.lossRateWindowStats[t2 - 1][a2][i3].packets - this.lossRateWindowStats[0][a2][i3].packets, d2 = this.lossRateWindowStats[t2 - 1][a2][i3].packetsLost - this.lossRateWindowStats[0][a2][i3].packetsLost;
      "videoSend" === a2 || "audioSend" === a2 ? (n2 += c2, o2 += d2) : (r2 += c2, s2 += d2), Number.isNaN(c2) || Number.isNaN(c2) ? e10.packetLostRate = 0 : e10.packetLostRate = c2 <= 0 || d2 <= 0 ? 0 : d2 / (c2 + d2);
    });
    e9.sendPacketLossRate = n2 <= 0 || o2 <= 0 ? 0 : o2 / (n2 + o2), e9.recvPacketLossRate = r2 <= 0 || s2 <= 0 ? 0 : s2 / (r2 + s2);
  }
};
function NV(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function DV(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? NV(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : NV(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var PV = class extends OV {
  constructor() {
    super(...arguments), Fg(this, "_stats", CV), Fg(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map());
  }
  async updateStats() {
    const e9 = await this._getStats(), t2 = this.statsResponsesToObjects(e9);
    this._stats = TV(CV);
    const i2 = t2.filter((e10) => "ssrc" === e10.type);
    this.processSSRCStats(i2);
    const n2 = t2.find((e10) => "VideoBwe" === e10.type);
    n2 && this.processBandwidthStats(n2), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
  }
  processBandwidthStats(e9) {
    this._stats.bitrate = { actualEncoded: Number(e9.googActualEncBitrate), targetEncoded: Number(e9.googTargetEncBitrate), retransmit: Number(e9.googRetransmitBitrate), transmit: Number(e9.googTransmitBitrate) }, this._stats.sendBandwidth = Number(e9.googAvailableSendBandwidth);
  }
  processSSRCStats(e9) {
    e9.forEach((e10) => {
      var t2;
      const i2 = Dn(t2 = e10.id).call(t2, "send");
      switch ("".concat(e10.mediaType, "_").concat(i2 ? "send" : "recv")) {
        case "video_send": {
          const t3 = TV(vV);
          t3.codec = e10.googCodecName, t3.adaptionChangeReason = "none", e10.googCpuLimitedResolution && (t3.adaptionChangeReason = "cpu"), e10.googBandwidthLimitedResolution && (t3.adaptionChangeReason = "bandwidth"), t3.avgEncodeMs = Number(e10.googAvgEncodeMs), t3.inputFrame = { width: Number(e10.googFrameWidthInput) || Number(e10.googFrameWidthSent), height: Number(e10.googFrameHeightInput) || Number(e10.googFrameHeightSent), frameRate: Number(e10.googFrameRateInput) }, t3.sentFrame = { width: Number(e10.googFrameWidthSent), height: Number(e10.googFrameHeightSent), frameRate: Number(e10.googFrameRateInput) }, t3.firsCount = Number(e10.googFirReceived), t3.nacksCount = Number(e10.googNacksReceived), t3.plisCount = Number(e10.googPlisReceived), t3.frameCount = Number(e10.framesEncoded), t3.bytes = Number(e10.bytesSent), t3.packets = Number(e10.packetsSent), t3.packetsLost = Number(e10.packetsLost), t3.ssrc = Number(e10.ssrc), t3.rttMs = Number(e10.googRtt || 0), this._stats.videoSend.push(t3), this._stats.rtt = t3.rttMs;
          break;
        }
        case "video_recv": {
          const t3 = TV(IV), i3 = this.lastDecodeVideoReceiverStats.get(Number(e10.ssrc));
          if (t3.codec = e10.googCodecName, t3.targetDelayMs = Number(e10.googTargetDelayMs), t3.renderDelayMs = Number(e10.googRenderDelayMs), t3.currentDelayMs = Number(e10.googCurrentDelayMs), t3.minPlayoutDelayMs = Number(e10.googMinPlayoutDelayMs), t3.decodeMs = Number(e10.googDecodeMs), t3.maxDecodeMs = Number(e10.googMaxDecodeMs), t3.receivedFrame = { width: Number(e10.googFrameWidthReceived), height: Number(e10.googFrameHeightReceived), frameRate: Number(e10.googFrameRateReceived) }, t3.decodedFrame = { width: Number(e10.googFrameWidthReceived), height: Number(e10.googFrameHeightReceived), frameRate: Number(e10.googFrameRateDecoded) }, t3.decodeFrameRate = Number(e10.googFrameRateDecoded), t3.outputFrame = { width: Number(e10.googFrameWidthReceived), height: Number(e10.googFrameHeightReceived), frameRate: Number(e10.googFrameRateOutput) }, t3.jitterBufferMs = Number(e10.googJitterBufferMs), t3.firsCount = Number(e10.googFirsSent), t3.nacksCount = Number(e10.googNacksSent), t3.plisCount = Number(e10.googPlisSent), t3.framesDecodeCount = Number(e10.framesDecoded), t3.bytes = Number(e10.bytesReceived), t3.packets = Number(e10.packetsReceived), t3.packetsLost = Number(e10.packetsLost), t3.ssrc = Number(e10.ssrc), t3.packets > 0 && !this.isFirstVideoReceived[t3.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t3.ssrc), this.isFirstVideoReceived[t3.ssrc] = true), t3.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t3.ssrc] && (this.onFirstVideoDecoded && this.onFirstVideoDecoded(t3.ssrc, t3.decodedFrame.width, t3.decodedFrame.height), this.isFirstVideoDecoded[t3.ssrc] = true), i3) {
            const n2 = i3.stats, r2 = Date.now() - i3.lts;
            t3.framesDecodeFreezeTime = n2.framesDecodeFreezeTime, t3.framesDecodeInterval = n2.framesDecodeInterval, t3.framesDecodeCount > n2.framesDecodeCount && this.isFirstVideoDecoded[t3.ssrc] ? (i3.lts = Date.now(), t3.framesDecodeInterval = r2, t3.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e10.ssrc, 10)) ? t3.framesDecodeFreezeTime += t3.framesDecodeInterval : this.setVideoIsReady2(parseInt(e10.ssrc, 10), true))) : t3.framesDecodeCount < i3.stats.framesDecodeCount && (t3.framesDecodeInterval = 0);
          }
          this.lastDecodeVideoReceiverStats.set(t3.ssrc, { stats: DV({}, t3), lts: Date.now() }), this._stats.videoRecv.push(t3);
          break;
        }
        case "audio_recv": {
          const t3 = TV(AV);
          t3.codec = e10.googCodecName, t3.outputLevel = Math.abs(Number(e10.audioOutputLevel)) / 32767, t3.decodingCNG = Number(e10.googDecodingCNG), t3.decodingCTN = Number(e10.googDecodingCTN), t3.decodingCTSG = Number(e10.googDecodingCTSG), t3.decodingNormal = Number(e10.googDecodingNormal), t3.decodingPLC = Number(e10.googDecodingPLC), t3.decodingPLCCNG = Number(e10.googDecodingPLCCNG), t3.expandRate = Number(e10.googExpandRate), t3.accelerateRate = Number(e10.googAccelerateRate), t3.preemptiveExpandRate = Number(e10.googPreemptiveExpandRate), t3.secondaryDecodedRate = Number(e10.googSecondaryDecodedRate), t3.speechExpandRate = Number(e10.googSpeechExpandRate), t3.preferredJitterBufferMs = Number(e10.googPreferredJitterBufferMs), t3.jitterBufferMs = Number(e10.googJitterBufferMs), t3.jitterMs = Number(e10.googJitterReceived), t3.bytes = Number(e10.bytesReceived), t3.packets = Number(e10.packetsReceived), t3.packetsLost = Number(e10.packetsLost), t3.ssrc = Number(e10.ssrc), t3.receivedFrames = Number(e10.googDecodingCTN) || Number(e10.packetsReceived), t3.droppedFrames = Number(e10.googDecodingPLC) + Number(e10.googDecodingPLCCNG) || Number(e10.packetsLost), t3.receivedFrames > 0 && !this.isFirstAudioReceived[t3.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t3.ssrc), this.isFirstAudioReceived[t3.ssrc] = true), t3.decodingNormal > 0 && !this.isFirstAudioDecoded[t3.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t3.ssrc), this.isFirstAudioDecoded[t3.ssrc] = true), this._stats.audioRecv.push(t3);
          break;
        }
        case "audio_send": {
          const t3 = TV(yV);
          t3.codec = e10.googCodecName, t3.inputLevel = Math.abs(Number(e10.audioInputLevel)) / 32767, t3.aecReturnLoss = Number(e10.googEchoCancellationReturnLoss || 0), t3.aecReturnLossEnhancement = Number(e10.googEchoCancellationReturnLossEnhancement || 0), t3.residualEchoLikelihood = Number(e10.googResidualEchoLikelihood || 0), t3.residualEchoLikelihoodRecentMax = Number(e10.googResidualEchoLikelihoodRecentMax || 0), t3.bytes = Number(e10.bytesSent), t3.packets = Number(e10.packetsSent), t3.packetsLost = Number(e10.packetsLost), t3.ssrc = Number(e10.ssrc), t3.rttMs = Number(e10.googRtt || 0), this._stats.rtt = t3.rttMs, this._stats.audioSend.push(t3);
          break;
        }
      }
    });
  }
  _getStats() {
    return new Gh((e9, t2) => {
      this.pc.getStats(e9, t2);
    });
  }
  statsResponsesToObjects(e9) {
    const t2 = [];
    return e9.result().forEach((e10) => {
      const i2 = { id: e10.id, timestamp: e10.timestamp.valueOf().toString(), type: e10.type };
      e10.names().forEach((t3) => {
        i2[t3] = e10.stat(t3);
      }), t2.push(i2);
    }), t2;
  }
};
function LV(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function kV(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? LV(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : LV(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var MV = class extends OV {
  constructor() {
    super(...arguments), Fg(this, "_stats", CV), Fg(this, "report", void 0), Fg(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map()), Fg(this, "lastVideoFramesRecv", /* @__PURE__ */ new Map()), Fg(this, "lastVideoFramesSent", /* @__PURE__ */ new Map()), Fg(this, "lastVideoFramesDecode", /* @__PURE__ */ new Map()), Fg(this, "lastVideoFramesOutput", /* @__PURE__ */ new Map()), Fg(this, "lastVideoJBDelay", /* @__PURE__ */ new Map()), Fg(this, "lastAudioJBDelay", /* @__PURE__ */ new Map()), Fg(this, "mediaBytesSent", /* @__PURE__ */ new Map()), Fg(this, "mediaBytesRetransmit", /* @__PURE__ */ new Map()), Fg(this, "mediaBytesTargetEncode", /* @__PURE__ */ new Map()), Fg(this, "lastEncoderMs", /* @__PURE__ */ new Map());
  }
  async updateStats() {
    this.report = await this.pc.getStats(), this._stats = TV(CV), this.report.forEach((e9) => {
      switch (e9.type) {
        case vw.OUTBOUND:
        case vw.INBOUND: {
          const t2 = e9.mediaType || e9.kind, i2 = !t2 && "frameWidth" in e9, n2 = !t2 && !("frameWidth" in e9);
          e9.type === vw.OUTBOUND ? "audio" === t2 || n2 ? this.processAudioOutboundStats(e9) : ("video" === t2 || i2) && this.processVideoOutboundStats(e9) : e9.type === vw.INBOUND && ("audio" === t2 || n2 ? this.processAudioInboundStats(e9) : ("video" === t2 || i2) && this.processVideoInboundStats(e9));
          break;
        }
        case vw.TRANSPORT: {
          const t2 = this.report.get(e9.selectedCandidatePairId);
          t2 && this.processCandidatePairStats(t2);
          break;
        }
        case vw.CANDIDATE_PAIR:
          e9.selected && this.processCandidatePairStats(e9);
      }
    }), this.updateSendBitrate(), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
  }
  async getSelectedCandidatePair() {
    const e9 = await this.pc.getStats(), t2 = { local: kV({}, RV), remote: kV({}, RV) };
    return e9.forEach((i2) => {
      let n2;
      if (i2.type === vw.TRANSPORT && (n2 = e9.get(i2.selectedCandidatePairId)), i2.type === vw.CANDIDATE_PAIR && i2.selected && (n2 = i2), n2) {
        const i3 = (e10, t3) => {
          e10.type = t3.type, e10.id = t3.id, t3.address && (e10.address = t3.address), t3.candidateType && (e10.candidateType = t3.candidateType), t3.port && (e10.port = t3.port), t3.priority && (e10.priority = t3.priority), t3.protocol && (e10.protocol = t3.protocol), t3.relayProtocol && (e10.relayProtocol = t3.relayProtocol);
        };
        if (n2.localCandidateId) {
          const r2 = e9.get(n2.localCandidateId);
          r2 && i3(t2.local, r2);
        }
        if (n2.remoteCandidateId) {
          const r2 = e9.get(n2.remoteCandidateId);
          r2 && i3(t2.remote, r2);
        }
      }
    }), t2;
  }
  processCandidatePairStats(e9) {
    if (this._stats.sendBandwidth = e9.availableOutgoingBitrate || 0, e9.currentRoundTripTime && (this._stats.rtt = 1e3 * e9.currentRoundTripTime), this._stats.videoSend.forEach((t2) => {
      e9.currentRoundTripTime && (t2.rttMs = 1e3 * e9.currentRoundTripTime);
    }), this._stats.audioSend.forEach((t2) => {
      e9.currentRoundTripTime && (t2.rttMs = 1e3 * e9.currentRoundTripTime);
    }), this._stats.selectedCandidatePair.id = e9.id, e9.localCandidateId) {
      const t2 = this.report.get(e9.localCandidateId);
      t2 && this.processCandidateStats(t2);
    }
    if (e9.remoteCandidateId) {
      const t2 = this.report.get(e9.remoteCandidateId);
      t2 && this.processCandidateStats(t2);
    }
  }
  processCandidateStats(e9) {
    let t2;
    e9.type === vw.LOCAL_CANDIDATE && (t2 = this._stats.selectedCandidatePair.localCandidate), e9.type === vw.REMOTE_CANDIDATE && (t2 = this._stats.selectedCandidatePair.remoteCandidate), t2 && (t2.type = e9.type, t2.id = e9.id, e9.address && (t2.address = e9.address), e9.candidateType && (t2.candidateType = e9.candidateType), e9.port && (t2.port = e9.port), e9.priority && (t2.priority = e9.priority), e9.protocol && (t2.protocol = e9.protocol), e9.relayProtocol && (t2.relayProtocol = e9.relayProtocol), e9.type === vw.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t2.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(kV({}, t2), kV({}, this.stats.selectedCandidatePair.localCandidate)), e9.type === vw.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t2.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(kV({}, t2), kV({}, this.stats.selectedCandidatePair.remoteCandidate)));
  }
  processAudioInboundStats(e9) {
    let t2 = this._stats.audioRecv.find((t3) => t3.ssrc === e9.ssrc);
    t2 || (t2 = TV(AV), this._stats.audioRecv.push(t2)), t2.ssrc = e9.ssrc, t2.packets = e9.packetsReceived, t2.packetsLost = e9.packetsLost, t2.packetsDiscarded = e9.packetsDiscarded, t2.bytes = e9.bytesReceived, t2.jitterMs = 1e3 * e9.jitter, this.processAudioTrackReceiverStats(e9, e9.trackId, t2), e9.codecId && (t2.codec = this.getCodecFromCodecStats(e9.codecId)), t2.receivedFrames || (t2.receivedFrames = e9.packetsReceived), t2.droppedFrames || (t2.droppedFrames = e9.packetsLost), t2.receivedFrames > 0 && !this.isFirstAudioReceived[t2.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t2.ssrc), this.isFirstAudioReceived[t2.ssrc] = true), t2.outputLevel && t2.outputLevel > 0 && !this.isFirstAudioDecoded[t2.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t2.ssrc), this.isFirstAudioDecoded[t2.ssrc] = true), "number" == typeof e9.concealedSamples && (t2.concealedSamples = e9.concealedSamples);
  }
  processVideoInboundStats(e9) {
    let t2 = this._stats.videoRecv.find((t3) => t3.ssrc === e9.ssrc);
    t2 || (t2 = TV(IV), this._stats.videoRecv.push(t2)), t2.ssrc = e9.ssrc, t2.packets = e9.packetsReceived, t2.packetsLost = e9.packetsLost, t2.bytes = e9.bytesReceived, t2.firsCount = e9.firCount, t2.nacksCount = e9.nackCount, t2.plisCount = e9.pliCount, t2.framesDecodeCount = e9.framesDecoded, t2.framesDroppedCount = e9.framesDropped, t2.totalInterFrameDelay = e9.totalInterFrameDelay, t2.totalSquaredInterFrameDelay = e9.totalSquaredInterFrameDelay, t2.totalFreezesDuration = e9.totalFreezesDuration;
    const i2 = this.lastDecodeVideoReceiverStats.get(t2.ssrc), n2 = this.lastVideoFramesDecode.get(t2.ssrc), r2 = this.lastVideoFramesOutput.get(t2.ssrc), o2 = Date.now();
    if (t2.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t2.ssrc]) {
      const e10 = t2.decodedFrame ? t2.decodedFrame.width : 0, i3 = t2.decodedFrame ? t2.decodedFrame.height : 0;
      this.onFirstVideoDecoded && this.onFirstVideoDecoded(t2.ssrc, e10, i3), this.isFirstVideoDecoded[t2.ssrc] = true;
    }
    if (i2) {
      const n3 = i2.stats, r3 = o2 - i2.lts;
      t2.framesDecodeFreezeTime = n3.framesDecodeFreezeTime, t2.framesDecodeInterval = n3.framesDecodeInterval, !this.isFirstVideoDecoded[t2.ssrc] && r3 > this.options.firstVideoDecodedTimeout && !this.isFirstVideoDecodedTimeout[t2.ssrc] && (this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t2.ssrc), this.isFirstVideoDecodedTimeout[t2.ssrc] = true), t2.framesDecodeCount > n3.framesDecodeCount && this.isFirstVideoDecoded[t2.ssrc] ? (i2.lts = Date.now(), t2.framesDecodeInterval = r3, t2.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e9.ssrc)) ? t2.framesDecodeFreezeTime += t2.framesDecodeInterval : this.setVideoIsReady2(parseInt(e9.ssrc, 10), true))) : t2.framesDecodeCount < n3.framesDecodeCount && (t2.framesDecodeInterval = 0), e9.framesDecoded && e9.qpSum && (i2.stats.framesDecodeCount > e9.framesDecoded ? t2.qpSumPerFrame = e9.qpSum / e9.framesDecoded : t2.qpSumPerFrame = (e9.qpSum - i2.qpSum) / (e9.framesDecoded - i2.stats.framesDecodeCount));
    }
    n2 && o2 - n2.lts >= 800 ? (t2.decodeFrameRate = Math.round((t2.framesDecodeCount - n2.count) / ((o2 - n2.lts) / 1e3)), this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: o2, rate: t2.decodeFrameRate })) : n2 ? t2.decodeFrameRate = n2.rate : this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: o2, rate: 0 }), t2.framesDroppedCount && e9.framesReceived && (r2 && o2 - r2.lts >= 800 ? (t2.outputFrameRate = Math.round((e9.framesReceived - t2.framesDroppedCount - r2.count) / ((o2 - r2.lts) / 1e3)), this.lastVideoFramesOutput.set(t2.ssrc, { count: e9.framesReceived - t2.framesDroppedCount, lts: o2, rate: Math.max(t2.outputFrameRate, 0) })) : r2 ? t2.outputFrameRate = r2.rate : this.lastVideoFramesOutput.set(t2.ssrc, { count: e9.framesReceived - t2.framesDroppedCount, lts: o2, rate: 0 })), e9.totalDecodeTime && (t2.decodeMs = 1e3 * e9.totalDecodeTime), this.processVideoTrackReceiverStats(e9, e9.trackId, t2), e9.codecId && (t2.codec = this.getCodecFromCodecStats(e9.codecId)), e9.framerateMean && (t2.framesRateFirefox = e9.framerateMean), t2.packets > 0 && !this.isFirstVideoReceived[t2.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t2.ssrc), this.isFirstVideoReceived[t2.ssrc] = true), this.lastDecodeVideoReceiverStats.set(t2.ssrc, { stats: kV({}, t2), lts: i2 ? i2.lts : Date.now(), qpSum: e9.qpSum });
  }
  processVideoOutboundStats(e9) {
    let t2 = this._stats.videoSend.find((t3) => t3.ssrc === e9.ssrc);
    t2 || (t2 = TV(vV), this._stats.videoSend.push(t2));
    const i2 = this.mediaBytesSent.get(e9.ssrc);
    if (i2) i2.add(e9.bytesSent);
    else {
      const t3 = new gV(10);
      t3.add(e9.bytesSent), this.mediaBytesSent.set(e9.ssrc, t3);
    }
    if (void 0 !== e9.retransmittedBytesSent) {
      const t3 = this.mediaBytesRetransmit.get(e9.ssrc);
      if (t3) t3.add(e9.retransmittedBytesSent);
      else {
        const t4 = new gV(10);
        t4.add(e9.retransmittedBytesSent), this.mediaBytesRetransmit.set(e9.ssrc, t4);
      }
    }
    if (e9.totalEncodedBytesTarget) {
      const t3 = this.mediaBytesTargetEncode.get(e9.ssrc);
      if (t3) t3.add(e9.totalEncodedBytesTarget);
      else {
        const t4 = new gV(10);
        t4.add(e9.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e9.ssrc, t4);
      }
    }
    if (t2.ssrc = e9.ssrc, t2.bytes = e9.bytesSent, t2.packets = e9.packetsSent, t2.firsCount = e9.firCount, t2.nacksCount = e9.nackCount, t2.plisCount = e9.pliCount, t2.frameCount = e9.framesEncoded, t2.adaptionChangeReason = e9.qualityLimitationReason, t2.scalabilityMode = e9.scalabilityMode, e9.totalEncodeTime && e9.framesEncoded) {
      const i3 = this.lastEncoderMs.get(e9.ssrc);
      if (!i3 || i3.lastFrameCount > e9.framesEncoded) t2.avgEncodeMs = 1e3 * e9.totalEncodeTime / e9.framesEncoded;
      else {
        const n2 = e9.framesEncoded - i3.lastFrameCount, r2 = e9.totalEncodeTime - i3.lastEncoderTime;
        t2.avgEncodeMs = 1e3 * r2 / n2;
      }
    }
    if (e9.framesEncoded && e9.qpSum) {
      const i3 = this.lastEncoderMs.get(e9.ssrc);
      !i3 || i3.lastFrameCount > e9.framesEncoded ? t2.qpSumPerFrame = e9.qpSum / e9.framesEncoded : t2.qpSumPerFrame = (e9.qpSum - i3.lastQpSum) / (e9.framesEncoded - i3.lastFrameCount);
    }
    if (this.lastEncoderMs.set(e9.ssrc, { lastFrameCount: e9.framesEncoded, lastEncoderTime: e9.totalEncodeTime, lastQpSum: e9.qpSum, lts: Date.now() }), e9.codecId && (t2.codec = this.getCodecFromCodecStats(e9.codecId)), e9.mediaSourceId && this.processVideoMediaSource(e9.mediaSourceId, t2), this.processVideoTrackSenderStats(e9, e9.trackId, t2), e9.remoteId) this.processRemoteInboundStats(e9.remoteId, t2);
    else {
      const i3 = this.findRemoteStatsId(e9.ssrc, vw.REMOTE_INBOUND);
      i3 && this.processRemoteInboundStats(i3, t2);
    }
  }
  processAudioOutboundStats(e9) {
    let t2 = this._stats.audioSend.find((t3) => t3.ssrc === e9.ssrc);
    if (t2 || (t2 = TV(yV), this._stats.audioSend.push(t2)), t2.ssrc = e9.ssrc, t2.packets = e9.packetsSent, t2.bytes = e9.bytesSent, e9.mediaSourceId && this.processAudioMediaSource(e9.mediaSourceId, t2), e9.codecId && (t2.codec = this.getCodecFromCodecStats(e9.codecId)), this.processAudioTrackSenderStats(e9, e9.trackId, t2), e9.remoteId) this.processRemoteInboundStats(e9.remoteId, t2);
    else {
      const i2 = this.findRemoteStatsId(e9.ssrc, vw.REMOTE_INBOUND);
      i2 && this.processRemoteInboundStats(i2, t2);
    }
  }
  findRemoteStatsId(e9, t2) {
    var i2;
    const n2 = Array.from(_N(i2 = this.report).call(i2)).find((i3) => i3.type === t2 && i3.ssrc === e9);
    return n2 ? n2.id : null;
  }
  processVideoMediaSource(e9, t2) {
    const i2 = this.report.get(e9);
    i2 && i2.width && i2.height && i2.framesPerSecond && (t2.inputFrame = { width: i2.width, height: i2.height, frameRate: i2.framesPerSecond });
  }
  processAudioMediaSource(e9, t2) {
    const i2 = this.report.get(e9);
    i2 && (t2.inputLevel = i2.audioLevel);
  }
  processVideoTrackSenderStats(e9, t2, i2) {
    var n2, r2, o2, s2;
    const a2 = t2 ? this.report.get(t2) : void 0, c2 = null !== (n2 = null == a2 ? void 0 : a2.framesSent) && void 0 !== n2 ? n2 : e9.framesSent;
    if ("number" != typeof c2) return;
    let d2 = null !== (r2 = null == a2 ? void 0 : a2.frameWidth) && void 0 !== r2 ? r2 : e9.frameWidth, l2 = null !== (o2 = null == a2 ? void 0 : a2.frameHeight) && void 0 !== o2 ? o2 : e9.frameHeight, u2 = null !== (s2 = null == a2 ? void 0 : a2.framesPerSecond) && void 0 !== s2 ? s2 : e9.framesPerSecond;
    if ("number" == typeof d2 && "number" == typeof l2 || (d2 = 0, l2 = 0), null == u2) {
      const e10 = Date.now(), t3 = this.lastVideoFramesSent.get(i2.ssrc);
      t3 && e10 - t3.lts >= 800 ? (u2 = Math.round((c2 - t3.count) / ((e10 - t3.lts) / 1e3)), this.lastVideoFramesSent.set(i2.ssrc, { count: c2, lts: e10, rate: u2 })) : t3 ? u2 = t3.rate : this.lastVideoFramesSent.set(i2.ssrc, { count: c2, lts: e10, rate: 0 });
    }
    i2.sentFrame = { width: d2, height: l2, frameRate: Math.max(0, u2) };
  }
  processVideoTrackReceiverStats(e9, t2, i2) {
    var n2, r2, o2, s2, a2;
    const c2 = t2 ? this.report.get(t2) : void 0, d2 = null !== (n2 = null == c2 ? void 0 : c2.framesReceived) && void 0 !== n2 ? n2 : e9.framesReceived, l2 = null !== (r2 = null == c2 ? void 0 : c2.frameWidth) && void 0 !== r2 ? r2 : e9.frameWidth, u2 = null !== (o2 = null == c2 ? void 0 : c2.frameHeight) && void 0 !== o2 ? o2 : e9.frameHeight, h2 = null !== (s2 = null == c2 ? void 0 : c2.jitterBufferDelay) && void 0 !== s2 ? s2 : e9.jitterBufferDelay, p2 = null !== (a2 = null == c2 ? void 0 : c2.jitterBufferEmittedCount) && void 0 !== a2 ? a2 : e9.jitterBufferEmittedCount;
    if ("number" == typeof d2) {
      const e10 = this.lastVideoFramesRecv.get(i2.ssrc), t3 = Date.now();
      i2.framesReceivedCount = d2;
      let n3 = 0;
      e10 && t3 - e10.lts >= 800 ? (n3 = Math.round((d2 - e10.count) / ((t3 - e10.lts) / 1e3)), this.lastVideoFramesRecv.set(i2.ssrc, { count: d2, lts: t3, rate: n3 })) : e10 ? n3 = e10.rate : this.lastVideoFramesRecv.set(i2.ssrc, { count: d2, lts: t3, rate: 0 }), i2.receivedFrame = { width: l2 || 0, height: u2 || 0, frameRate: n3 || 0 }, i2.decodedFrame = { width: l2 || 0, height: u2 || 0, frameRate: i2.decodeFrameRate || 0 }, i2.outputFrame = { width: l2 || 0, height: u2 || 0, frameRate: i2.outputFrameRate || i2.decodeFrameRate || 0 };
    }
    if (h2 && p2) {
      const e10 = this.lastVideoJBDelay.get(i2.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 };
      let t3 = e10.jitterBufferMs;
      const n3 = p2 - e10.jitterBufferEmittedCount;
      n3 > 0 && (t3 = 1e3 * (h2 - e10.jitterBufferDelay) / n3), i2.jitterBufferMs = t3, i2.currentDelayMs = Math.round(t3), this.lastVideoJBDelay.set(i2.ssrc, { jitterBufferDelay: h2, jitterBufferEmittedCount: p2, jitterBufferMs: i2.currentDelayMs });
    }
  }
  processAudioTrackSenderStats(e9, t2, i2) {
    var n2, r2, o2, s2;
    const a2 = t2 ? this.report.get(t2) : void 0, c2 = null !== (n2 = null !== (r2 = null == a2 ? void 0 : a2.echoReturnLoss) && void 0 !== r2 ? r2 : e9.echoReturnLoss) && void 0 !== n2 ? n2 : 0, d2 = null !== (o2 = null !== (s2 = null == a2 ? void 0 : a2.echoReturnLossEnhancement) && void 0 !== s2 ? s2 : e9.echoReturnLossEnhancement) && void 0 !== o2 ? o2 : 0;
    i2.aecReturnLoss = c2, i2.aecReturnLossEnhancement = d2;
  }
  processAudioTrackReceiverStats(e9, t2, i2) {
    var n2, r2, o2, s2, a2, c2, d2;
    const l2 = t2 ? this.report.get(t2) : void 0, u2 = null !== (n2 = null == l2 ? void 0 : l2.removedSamplesForAcceleration) && void 0 !== n2 ? n2 : e9.removedSamplesForAcceleration, h2 = null !== (r2 = null == l2 ? void 0 : l2.totalSamplesReceived) && void 0 !== r2 ? r2 : e9.totalSamplesReceived, p2 = null !== (o2 = null == l2 ? void 0 : l2.jitterBufferDelay) && void 0 !== o2 ? o2 : e9.jitterBufferDelay, _2 = null !== (s2 = null == l2 ? void 0 : l2.jitterBufferEmittedCount) && void 0 !== s2 ? s2 : e9.jitterBufferEmittedCount, E2 = null !== (a2 = null == l2 ? void 0 : l2.audioLevel) && void 0 !== a2 ? a2 : null == e9 ? void 0 : e9.audioLevel, f2 = null !== (c2 = null == l2 ? void 0 : l2.totalSamplesDuration) && void 0 !== c2 ? c2 : null == e9 ? void 0 : e9.totalSamplesDuration, m2 = null !== (d2 = null == l2 ? void 0 : l2.concealedSamples) && void 0 !== d2 ? d2 : e9.concealedSamples;
    if (u2 && h2 && (i2.accelerateRate = u2 / h2), p2 && _2) {
      const e10 = this.lastAudioJBDelay.get(i2.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 };
      let t3 = e10.jitterBufferMs;
      const n3 = _2 - e10.jitterBufferEmittedCount;
      n3 > 0 && (t3 = 1e3 * (p2 - e10.jitterBufferDelay) / n3), i2.jitterBufferMs = Math.round(t3), this.lastAudioJBDelay.set(i2.ssrc, { jitterBufferDelay: p2, jitterBufferEmittedCount: _2, jitterBufferMs: i2.jitterBufferMs });
    }
    i2.outputLevel = E2;
    let T2 = 1920;
    f2 && h2 && (T2 = h2 / f2 / 50, i2.receivedFrames = Math.round(h2 / T2)), m2 && (i2.droppedFrames = Math.round(m2 / T2));
  }
  processRemoteInboundStats(e9, t2) {
    const i2 = this.report.get(e9);
    i2 && (t2.packetsLost = i2.packetsLost, i2.roundTripTime && (t2.rttMs = 1e3 * i2.roundTripTime), i2.jitter && (t2.jitterMs = 1e3 * i2.jitter), i2.timestamp && (t2.timestamp = i2.timestamp));
  }
  getCodecFromCodecStats(e9) {
    const t2 = this.report.get(e9);
    if (!t2) return "";
    const i2 = t2.mimeType.match(/\/(.*)$/);
    return i2 && i2[1] ? i2[1] : "";
  }
  updateSendBitrate() {
    let e9 = 0, t2 = null, i2 = null;
    this.mediaBytesSent.forEach((t3) => {
      e9 += t3.diffMean();
    }), this.mediaBytesRetransmit.forEach((e10) => {
      t2 = null === t2 ? e10.diffMean() : t2 + e10.diffMean();
    }), this.mediaBytesTargetEncode.forEach((e10) => {
      i2 = null === i2 ? e10.diffMean() : i2 + e10.diffMean();
    });
    const n2 = null !== t2 ? e9 - t2 : e9;
    this._stats.bitrate = { actualEncoded: 8 * n2 / (this.options.updateInterval / 1e3), transmit: 8 * e9 / (this.options.updateInterval / 1e3) }, null !== t2 && (this._stats.bitrate.retransmit = 8 * t2 / (this.options.updateInterval / 1e3)), null !== i2 && (this._stats.bitrate.targetEncoded = 8 * i2 / (this.options.updateInterval / 1e3));
  }
};
var UV = class extends OV {
  updateStats() {
    return Gh.resolve();
  }
};
function xV(e9) {
  let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 250, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 500, r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e4;
  const o2 = function() {
    const e10 = navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i);
    return e10 && e10[0] ? Number(e10[0].split("/")[1]) : null;
  }();
  return o2 ? o2 < 76 ? new PV(e9, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new MV(e9, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : function(e10) {
    if (!window.RTCStatsReport) return false;
    const t3 = e10.getStats();
    return !!(t3 instanceof Gh || function(e11) {
      return !!e11 && ("object" == typeof e11 || "function" == typeof e11) && "function" == typeof e11.then;
    }(t3));
  }(e9) ? new MV(e9, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new UV(e9, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 });
}
var VV = class {
  get localCapabilities() {
    return sA(this._localCapabilities);
  }
  get rtpCapabilities() {
    return sA(this._rtpCapabilities);
  }
  get candidates() {
    return sA(this._candidates);
  }
  get iceParameters() {
    return sA(this._iceParameters);
  }
  get dtlsParameters() {
    return sA(this._dtlsParameters);
  }
  constructor(e9) {
    Fg(this, "sessionDesc", void 0), Fg(this, "_localCapabilities", void 0), Fg(this, "_rtpCapabilities", void 0), Fg(this, "_candidates", void 0), Fg(this, "_iceParameters", void 0), Fg(this, "_dtlsParameters", void 0), Fg(this, "setup", void 0), Fg(this, "currentMidIndex", void 0), Fg(this, "cname", "o/i14u9pJrxRKAsu"), Fg(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e9 = sA(e9);
    const { remoteIceParameters: t2, remoteDtlsParameters: i2, candidates: n2, remoteRTPCapabilities: r2, localCapabilities: o2, direction: s2, setup: a2, videoCodec: c2, audioCodec: d2 } = e9;
    let l2;
    this.setup = a2, l2 = s2 === Mw.RECEIVE_ONLY ? FU.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=extmap-allow-mixed\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n") : FU.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=extmap-allow-mixed\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=recvonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=recvonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n"), this._rtpCapabilities = r2, this._candidates = n2, this._iceParameters = t2, this._dtlsParameters = i2, this._localCapabilities = o2;
    const u2 = s2 === Mw.RECEIVE_ONLY ? this.rtpCapabilities.send : this.rtpCapabilities.recv, h2 = s2 === Mw.RECEIVE_ONLY ? this._localCapabilities.recv : this._localCapabilities.send, p2 = s2 === Mw.RECEIVE_ONLY ? r2.send.videoCodecs : sx(dO.VIDEO, u2, h2, c2), _2 = s2 === Mw.RECEIVE_ONLY ? r2.send.audioCodecs : sx(dO.AUDIO, u2, h2, d2);
    for (const e10 of l2.mediaDescriptions) e10.attributes.iceUfrag = t2.iceUfrag, e10.attributes.icePwd = t2.icePwd, e10.attributes.fingerprints = i2.fingerprints, e10.attributes.candidates = n2, e10.attributes.setup = this.setup, "application" === e10.media.mediaType && (e10.attributes.sctpPort = "5000"), "video" === e10.media.mediaType && (e10.media.fmts = p2.map((e11) => e11.payloadType.toString(10)), e10.attributes.payloads = p2, e10.attributes.extmaps = u2.videoExtensions), "audio" === e10.media.mediaType && (e10.media.fmts = _2.map((e11) => e11.payloadType.toString(10)), e10.attributes.payloads = _2, e10.attributes.extmaps = u2.audioExtensions, ox(e10));
    this.sessionDesc = l2, this.currentMidIndex = l2.mediaDescriptions.length - 1;
  }
  toString() {
    return FU.print(this.sessionDesc);
  }
  hasMid(e9) {
    return Array.isArray(e9) ? e9.every((e10) => this.hasMid(e10)) : this.sessionDesc.mediaDescriptions.some((t2) => t2.attributes.mid === e9);
  }
  send(e9, t2, i2, n2, r2) {
    i2 = i2.replace(/ /g, "-");
    const { ssrcs: o2, ssrcGroups: s2 } = zU(t2, this.cname, XA("SYNC_GROUP") ? i2 : void 0), a2 = this.findPreloadMediaDesc(o2);
    if (a2) {
      if (Zv() && this.firefoxSsrcMidMap.set(o2[0].ssrcId, a2.attributes.mid), r2 && (r2.twcc || r2.remb)) {
        const e10 = this.sessionDesc.mediaDescriptions.indexOf(a2);
        return this.sessionDesc.mediaDescriptions[e10] = this.mungSendMediaDesc(a2, r2), { mid: a2.attributes.mid, needExchangeSDP: true };
      }
      return { mid: a2.attributes.mid, needExchangeSDP: false };
    }
    {
      const t3 = this.findAvailableMediaIndex(e9, o2, n2);
      let i3;
      return -1 === t3 ? (i3 = this.createOrRecycleSendMedia(e9, o2, s2, "sendonly", n2, r2), this.updateBundleMids()) : (i3 = sA(this.sessionDesc.mediaDescriptions[t3]), i3.attributes.direction = "sendonly", i3.attributes.ssrcs = o2, i3.attributes.ssrcGroups = s2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(i3, r2)), Zv() && this.firefoxSsrcMidMap.set(o2[0].ssrcId, i3.attributes.mid), { needExchangeSDP: true, mid: i3.attributes.mid };
    }
  }
  stopSending(e9) {
    const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && -1 !== e9.indexOf(t3.attributes.mid));
    if (t2.length !== e9.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
    t2.forEach((e10) => {
      e10.attributes.ssrcs = [];
    }), this.updateBundleMids();
  }
  receive(e9, t2, i2) {
    const n2 = [];
    return e9.forEach((e10) => {
      const r2 = e10._mediaStreamTrack.kind, o2 = this.findAvailableRecvMediaIndex(r2);
      let s2, a2 = false;
      -1 === o2 ? (a2 = true, s2 = this.createOrRecycleRecvMedia(e10, [], "recvonly", t2, i2), this.updateBundleMids()) : (s2 = sA(this.sessionDesc.mediaDescriptions[o2]), s2.attributes.direction = "recvonly"), n2.push({ mid: s2.attributes.mid, needCreateTransceiver: a2 });
    }), n2;
  }
  stopReceiving(e9) {
    const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => -1 !== e9.indexOf(t3.attributes.mid));
    if (t2.length !== e9.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
    t2.forEach((e10) => {
      e10.media.port = "0", e10.attributes.direction = "inactive";
    }), this.updateBundleMids();
  }
  addRemoteCandidate(e9) {
    const { foundation: t2, protocol: i2, address: n2, port: r2, type: o2, relatedAddress: s2, relatedPort: a2, priority: c2 } = new RTCIceCandidate(e9), d2 = { foundation: null != t2 ? t2 : "", componentId: "1", transport: null != i2 ? i2 : "", priority: c2 ? c2 + "" : "", connectionAddress: null != n2 ? n2 : "", port: r2 ? r2 + "" : "", type: o2 ? o2 + "" : "", relAddr: null != s2 ? s2 : "", relPort: a2 ? a2 + "" : "", extension: {} };
    this.candidates.some((e10) => e10.priority === d2.priority && e10.connectionAddress === d2.connectionAddress && e10.port === d2.port) || (this._candidates.push(d2), this.sessionDesc.mediaDescriptions.forEach((e10) => {
      e10.attributes.candidates = this.candidates;
    }));
  }
  clearRemoteCandidate() {
    this._candidates = [], this.sessionDesc.mediaDescriptions[0].attributes.candidates = this._candidates;
  }
  createOrRecycleRecvMedia(e9, t2, i2, n2, r2) {
    const o2 = e9._mediaStreamTrack.kind, s2 = this.rtpCapabilities.recv, a2 = sx(o2, s2, this.localCapabilities.send, o2 === dO.AUDIO ? r2 : n2), c2 = o2 === dO.VIDEO ? s2.videoExtensions : s2.audioExtensions, d2 = "".concat(++this.currentMidIndex);
    let l2 = { media: { mediaType: o2, port: "9", protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a2.map((e10) => e10.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: [], extmaps: c2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: a2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i2, rtcpMux: true, rtcpRsize: true, mid: "".concat(d2) } };
    l2 = this.mungRecvMediaDsec(l2, e9);
    const u2 = this.findFirstClosedMedia(o2);
    if (u2) {
      const e10 = this.sessionDesc.mediaDescriptions.indexOf(u2);
      this.sessionDesc.mediaDescriptions[e10] = l2;
    } else this.sessionDesc.mediaDescriptions.push(l2);
    return l2;
  }
  muteRemote(e9) {
    const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => Dn(e9).call(e9, t3.attributes.mid || ""));
    if (t2.length !== e9.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
    t2.forEach((e10) => {
      e10.attributes.direction = "inactive";
    });
  }
  unmuteRemote(e9) {
    const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => Dn(e9).call(e9, t3.attributes.mid || ""));
    if (t2.length !== e9.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
    t2.forEach((e10) => {
      e10.attributes.direction = "recvonly";
    });
  }
  findAvailableMediaIndex(e9, t2, i2) {
    return this.sessionDesc.mediaDescriptions.findIndex((n2) => {
      const r2 = n2.media.mediaType === e9 && "0" !== n2.media.port && ("sendonly" === n2.attributes.direction || "sendrecv" === n2.attributes.direction) && 0 === n2.attributes.ssrcs.length;
      if (Zv()) {
        if (r2) {
          const e10 = this.firefoxSsrcMidMap.get(t2[0].ssrcId);
          return !(e10 || "0" !== n2.attributes.mid && "1" !== n2.attributes.mid) || !(!e10 || e10 !== n2.attributes.mid);
        }
        return false;
      }
      return r2 && n2.attributes.mid === i2;
    });
  }
  findAvailableRecvMediaIndex(e9) {
    return this.sessionDesc.mediaDescriptions.findIndex((t2) => {
      const i2 = t2.media.mediaType === e9 && "0" !== t2.media.port && ("recvonly" === t2.attributes.direction || "sendrecv" === t2.attributes.direction);
      return "0" !== t2.attributes.mid && "1" !== t2.attributes.mid && i2;
    });
  }
  predictReceivingMids(e9) {
    const t2 = [];
    for (let i2 = 0; i2 < e9; i2++) t2.push((this.currentMidIndex + i2 + 1).toString(10));
    return t2;
  }
  restartICE(e9) {
    e9 = sA(e9), this._iceParameters = e9, this.sessionDesc.mediaDescriptions.forEach((t2) => {
      t2.attributes.iceUfrag = e9.iceUfrag, t2.attributes.icePwd = e9.icePwd;
    });
  }
  createOrRecycleSendMedia(e9, t2, i2, n2, r2, o2) {
    const s2 = this.rtpCapabilities.send, a2 = e9 === dO.VIDEO ? s2.videoCodecs : s2.audioCodecs, c2 = e9 === dO.VIDEO ? s2.videoExtensions : s2.audioExtensions;
    Zv() && (r2 = "".concat(++this.currentMidIndex));
    let d2 = { media: { mediaType: e9, port: "9", protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a2.map((e10) => e10.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: [], extmaps: c2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: i2, rtcpFeedbackWildcards: [], payloads: a2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n2, rtcpMux: true, rtcpRsize: true, mid: r2 } };
    d2 = this.mungSendMediaDesc(d2, o2);
    const l2 = this.findFirstClosedMedia(e9);
    if (l2) {
      const e10 = this.sessionDesc.mediaDescriptions.indexOf(l2);
      this.sessionDesc.mediaDescriptions[e10] = d2;
    } else this.sessionDesc.mediaDescriptions.push(d2);
    return d2;
  }
  mungRecvMediaDsec(e9, t2, i2) {
    const n2 = sA(e9);
    return XU(n2), JU(n2, t2), QU(n2, t2), ZU(n2), $U(n2, i2, this.localCapabilities.send), n2;
  }
  mungSendMediaDesc(e9, t2) {
    const i2 = sA(e9);
    return $U(i2, t2, this.localCapabilities.recv), ox(i2), i2;
  }
  updateRecvMedia(e9, t2) {
    const i2 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e9);
    if (-1 !== i2) {
      const e10 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t2);
      this.sessionDesc.mediaDescriptions[i2] = e10;
    }
  }
  updateBundleMids() {
    this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e9) => "0" !== e9.media.port).map((e9) => e9.attributes.mid);
  }
  findPreloadMediaDesc(e9) {
    return this.sessionDesc.mediaDescriptions.find((t2) => {
      var i2;
      return (null === (i2 = t2.attributes) || void 0 === i2 || null === (i2 = i2.ssrcs[0]) || void 0 === i2 ? void 0 : i2.ssrcId) === e9[0].ssrcId;
    });
  }
  findFirstClosedMedia(e9) {
    return this.sessionDesc.mediaDescriptions.find((t2) => Zv() ? "0" === t2.media.port && t2.media.mediaType === e9 : "0" === t2.media.port);
  }
};
var FV = ["sdp"];
var BV;
function jV(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function GV(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? jV(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : jV(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var WV = (BV = class e6 extends aO {
  get currentLocalDescription() {
    return this.peerConnection.currentLocalDescription;
  }
  get currentRemoteDescription() {
    return this.peerConnection.currentRemoteDescription;
  }
  get peerConnectionState() {
    return this.peerConnection.connectionState;
  }
  get iceConnectionState() {
    return this.peerConnection.iceConnectionState;
  }
  get dtlsTransportState() {
    var e9, t2;
    return null !== (e9 = null === (t2 = this.peerConnection.getReceivers()[0]) || void 0 === t2 || null === (t2 = t2.transport) || void 0 === t2 ? void 0 : t2.state) && void 0 !== e9 ? e9 : null;
  }
  get localCodecs() {
    return [];
  }
  set isInRestartIce(e9) {
    this._isInRestartIce = e9;
  }
  get isInRestartIce() {
    return this._isInRestartIce;
  }
  constructor(t2, i2, n2) {
    super(t2, i2), Fg(this, "direction", void 0), Fg(this, "name", void 0), Fg(this, "store", void 0), Fg(this, "spec", void 0), Fg(this, "peerConnection", void 0), Fg(this, "initialOffer", void 0), Fg(this, "transport", void 0), Fg(this, "statsFilter", void 0), Fg(this, "localCandidateCount", 0), Fg(this, "_isInRestartIce", false), Fg(this, "mutex", new NA("P2PConnection-mutex")), Fg(this, "onLocalCandidate", void 0), Fg(this, "remoteSDP", void 0), Fg(this, "pendingCandidates", []), Fg(this, "localCapabilities", void 0), Fg(this, "isReady", false), Fg(this, "restartCnt", 0), Fg(this, "curTurnServerIndex", 0), this.store = i2, this.spec = t2, this.peerConnection = new RTCPeerConnection(e6.resolvePCConfiguration(t2, i2.p2pTransport), { optional: [{ googDscp: true }] }), this.direction = null != n2 ? n2 : Mw.SEND_ONLY, this.name = this.direction === Mw.SEND_ONLY ? "sendP2PConnection" : "recvP2PConnection", this.statsFilter = xV(this.peerConnection, XA("STATS_UPDATE_INTERVAL"), void 0, Zv() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;
  }
  async establish(e9) {
    try {
      const t2 = await tx();
      if (this.localCapabilities = rx(t2), e9) {
        const { sdp: t3 } = e9, i2 = mV(e9, FV), n2 = function() {
          const e10 = { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, t4 = WU(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, "sendonly"), i3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, n3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
          if (nx(t4, e10, "videoExtensions", i3, n3, r3), nx(t4, e10, "videoCodecs", i3, n3, r3), nx(t4, e10, "audioExtensions", i3, n3, r3), nx(t4, e10, "audioCodecs", i3, n3, r3), XA("RAISE_H264_BASELINE_PRIORITY")) {
            const e11 = r3.videoCodecs.findIndex((e12) => e12.rtpMap && "h264" === e12.rtpMap.encodingName.toLocaleLowerCase() && e12.fmtp && "42001f" === e12.fmtp.parameters["profile-level-id"]);
            if (-1 !== e11) {
              const t5 = r3.videoCodecs.findIndex((e12) => e12.rtpMap && "h264" === e12.rtpMap.encodingName.toLocaleLowerCase());
              if (t5 < e11) {
                fb.debug("raising H264 baseline profile priority");
                const i4 = r3.videoCodecs[e11];
                r3.videoCodecs.splice(e11, 1), r3.videoCodecs.splice(t5, 0, i4);
              }
              -1 !== t5 && XA("FILTER_SEND_H264_BASELINE") && (i3.videoCodecs = i3.videoCodecs.filter((e12) => !(e12.rtpMap && "h264" === e12.rtpMap.encodingName.toLocaleLowerCase() && e12.fmtp && "42001f" !== e12.fmtp.parameters["profile-level-id"])));
            }
          }
          return { send: i3, recv: n3, sendrecv: r3 };
        }({}, {}, t3);
        this.remoteSDP = new VV({ remoteIceParameters: i2.iceParameters, remoteDtlsParameters: i2.dtlsParameters, candidates: [], remoteRTPCapabilities: n2, localCapabilities: this.localCapabilities, direction: this.direction, setup: "actpass", videoCodec: this.store.codec, audioCodec: this.store.audioCodec }), await this.setRemoteDescription({ type: "offer", sdp: this.remoteSDP.toString() }), this.isReady = true;
        const r2 = await this.peerConnection.createAnswer();
        if (!r2.sdp) throw new Error("Cannot get answer sdp when trying to establish PeerConnection.");
        const o2 = HU(r2.sdp);
        await this.peerConnection.setLocalDescription(r2);
        const s2 = await ix({}, {}, r2.sdp);
        this.localCapabilities = rx(s2);
        const a2 = this.peerConnection.getTransceivers()[0];
        return null != a2 && a2.receiver && a2.receiver.transport && this.tryBindTransportEvents(a2.receiver.transport), GV(GV({}, o2), {}, { sdp: r2.sdp });
      }
      {
        this.peerConnection.addTransceiver("video", { direction: "sendonly" }), this.peerConnection.addTransceiver("audio", { direction: "sendonly" });
        const e10 = await this.peerConnection.createOffer();
        if (!e10.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
        const t3 = HU(e10.sdp);
        return this.initialOffer = e10, GV(GV({}, t3), {}, { sdp: e10.sdp });
      }
    } catch (e10) {
      throw new Cy(Ry.GET_LOCAL_CONNECTION_PARAMS_FAILED, e10.toString());
    }
  }
  async connect(e9) {
    try {
      if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
      await this.peerConnection.setLocalDescription(this.initialOffer);
      const { sdp: t2, iceParameters: i2, dtlsParameters: n2 } = e9, r2 = await ix({}, {}, t2);
      this.remoteSDP = new VV({ remoteIceParameters: i2, remoteDtlsParameters: n2, candidates: [], remoteRTPCapabilities: r2, localCapabilities: this.localCapabilities, direction: this.direction, setup: "active", videoCodec: this.store.codec, audioCodec: this.store.audioCodec }), await this.setRemoteDescription({ type: "answer", sdp: this.remoteSDP.toString() });
      const o2 = this.peerConnection.getTransceivers()[0];
      null != o2 && o2.sender && o2.sender.transport && this.tryBindTransportEvents(o2.sender.transport);
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e10.toString()));
    }
  }
  async addRemoteCandidate(e9) {
    try {
      e9 && this.pendingCandidates.push(e9), this.peerConnection.remoteDescription && this.isReady && (this.pendingCandidates.forEach((e10) => {
        this.peerConnection.addIceCandidate(e10);
      }), this.pendingCandidates = []);
    } catch (e10) {
      throw new Cy(Ry.ADD_CANDIDATE_FAILED, "P2PConnection.addRemoteCandidate failed; ".concat(e10.toString()));
    }
  }
  send(e9, t2, i2) {
    var n2 = this;
    return YI(function* () {
      const r2 = yield qI(n2.mutex.lock("From P2PConnection.send"));
      try {
        if (!n2.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
        const o2 = [], s2 = n2.remoteSDP.receive(e9, t2, i2);
        e9.forEach((e10, t3) => {
          if (s2[t3].needCreateTransceiver) {
            const t4 = n2.peerConnection.addTransceiver(e10._mediaStreamTrack, { direction: "sendonly" });
            o2.push(t4), e10._updateRtpTransceiver(t4);
          } else {
            const i3 = n2.peerConnection.getTransceivers().find((e11) => e11.mid === s2[t3].mid);
            if (!i3) throw new Error("cannot find transceiver when sendPeerconnection send, mid is ".concat(s2[t3].mid));
            o2.push(i3), e10._updateRtpTransceiver(i3);
          }
        }), Zv() && true === XA("SIMULCAST") && (yield qI(n2.applySimulcastForFirefox(o2, e9)));
        const a2 = s2.map((e10) => e10.mid), c2 = yield qI(n2.peerConnection.createOffer()), d2 = n2.mungSendOfferSDP(c2.sdp, e9, a2), l2 = FU.parse(d2), u2 = a2.map((e10) => {
          const t3 = l2.mediaDescriptions.find((t4) => t4.attributes.mid === e10);
          if (!t3) throw new Error("Cannot extract ssrc from mediaDescription.");
          return KU(t3, XA("USE_PUB_RTX"));
        }), h2 = o2.map((e10, t3) => {
          const i3 = a2[t3];
          return { localSSRC: u2[t3], id: i3 };
        });
        yield qI(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 }));
        try {
          yield h2;
        } catch (e10) {
          const t3 = n2.remoteSDP.toString();
          throw yield qI(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield qI(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: t3 })), yield qI(n2.stopSending(a2, true)), e10;
        }
        yield qI(n2.applySimulcastEncodings(o2, e9)), yield qI(n2.applySendEncodings(o2, e9));
        const p2 = n2.remoteSDP.toString(), _2 = n2.logSDPExchange(d2, "offer", "local", "send");
        return null == _2 || _2(p2), yield qI(n2.setRemoteDescription({ type: "answer", sdp: p2 })), o2.map((e10, t3) => {
          const i3 = a2[t3];
          return { localSSRC: u2[t3], id: i3 };
        });
      } catch (e10) {
        throw e10 instanceof Cy ? e10 : new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e10.toString()));
      } finally {
        r2();
      }
    })();
  }
  async stopSending(e9, t2) {
    const i2 = t2 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
      const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e9.indexOf(t4.mid));
      if (t3.length !== e9.length) throw new Error("Transceivers' length (".concat(t3.length, ") doesn't match mids' length (").concat(e9.length, ") when trying to call P2PConnection.stopSending."));
      t3.map((e10) => {
        var t4;
        e10.direction = "inactive", null === (t4 = e10.stop) || void 0 === t4 || t4.call(e10);
      });
      const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
      await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e9);
      const o2 = this.remoteSDP.toString();
      null == r2 || r2(o2), await this.setRemoteDescription({ type: "answer", sdp: o2 });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e10.toString()));
    } finally {
      i2 && i2();
    }
  }
  async receive(e9, t2, i2, n2) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e9, " before remoteSDP created."));
      const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e9, t2, i2, n2);
      if (o2) {
        const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "receive");
        await this.setRemoteDescription({ type: "offer", sdp: t3 });
        const n3 = await this.peerConnection.createAnswer(), o3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e9);
        null == i3 || i3(o3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o3 }), fb.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e9, " by exchanging SDP."));
      } else fb.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e9, " no need to exchange SDP."));
      const s2 = this.peerConnection.getTransceivers().find((e10) => e10.mid === r2);
      if (!s2 || null === s2.mid) throw new Error("Cannot get transceiver after setLocalDescription.");
      return { track: s2.receiver.track, mid: s2.mid, transceiver: s2 };
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e10.toString()));
    }
  }
  async mockReceive(e9, t2, i2, n2) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e9, " before remoteSDP created."));
      const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e9, t2, i2, n2);
      if (o2) {
        const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "receive");
        await this.setRemoteDescription({ type: "offer", sdp: t3 });
        const n3 = await this.peerConnection.createAnswer(), o3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e9);
        null == i3 || i3(o3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o3 }), fb.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e9, " by exchanging SDP."));
      } else fb.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e9, " no need to exchange SDP."));
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e10.toString()));
    }
  }
  async stopReceiving(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
      this.remoteSDP.stopSending(e9);
      const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
      await this.setRemoteDescription({ type: "offer", sdp: t2 });
      const n2 = await this.peerConnection.createAnswer();
      null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e10.toString()));
    }
  }
  async restartICE(t2) {
    try {
      if (this.store.p2pTransport === HA.Auto && (this.store.p2pTransport = HA.SdRtn, ZP().supportPCSetConfiguration && this.peerConnection.setConfiguration(e6.resolvePCConfiguration(this.spec, this.store.p2pTransport))), this.restartCnt > 3 && (this.restartCnt = 0, ZP().supportPCSetConfiguration && this.peerConnection.setConfiguration(e6.resolvePCConfiguration(this.spec, this.store.p2pTransport, ++this.curTurnServerIndex))), !t2) {
        this.restartCnt++, this.isReady = false;
        const e9 = await this.peerConnection.createOffer({ iceRestart: true });
        if (!e9.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
        const { iceParameters: t3 } = HU(e9.sdp);
        return this.store.descriptionStart(), this.direction === Mw.SEND_ONLY && await this.peerConnection.setLocalDescription(e9), t3;
      }
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
      if (this.remoteSDP.restartICE(t2), this.store.descriptionStart(), this.direction === Mw.RECEIVE_ONLY) {
        this.restartCnt++, await this.setRemoteDescription({ type: "offer", sdp: this.remoteSDP.toString() });
        const e9 = await this.peerConnection.createAnswer();
        if (!e9.sdp) throw new Error("Cannot get answer sdp when trying to iceRestart.");
        const { iceParameters: t3 } = HU(e9.sdp);
        return await this.peerConnection.setLocalDescription(e9), t3;
      }
      await this.setRemoteDescription({ type: "answer", sdp: this.remoteSDP.toString() }), this.isReady = true;
    } catch (e9) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e9.toString()));
    }
  }
  close() {
    var e9;
    this.peerConnection.close(), this.peerConnection.onicecandidate = null, null === (e9 = this.onConnectionStateChange) || void 0 === e9 || e9.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.transport = void 0, this.statsFilter.destroy();
  }
  getStats() {
    return this.statsFilter.getStats();
  }
  getRemoteVideoIsReady(e9) {
    return this.statsFilter.getVideoIsReady(e9);
  }
  async updateEncoderConfig(e9, t2) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
      const i2 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i2.sdp, [t2], [e9]);
      this.remoteSDP.updateRecvMedia(e9, t2);
      const r2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
      await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == o2 || o2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, e10.toString());
    }
  }
  async updateSendParameters(e9, t2) {
    const i2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e9);
    1 === i2.length && (this.isVP8Simulcast(t2) ? Zv() || await this.applySimulcastEncodings(i2, [t2]) : await this.applySendEncodings(i2, [t2]));
  }
  setStatsRemoteVideoIsReady(e9, t2) {
    this.statsFilter.setVideoIsReady2(e9, t2);
  }
  async replaceTrack(e9, t2) {
    const i2 = this.peerConnection.getTransceivers().find((e10) => e10.mid === t2);
    i2 && await i2.sender.replaceTrack(e9._mediaStreamTrack);
  }
  async getSelectedCandidatePair() {
    const e9 = this.peerConnection.getReceivers();
    if (e9.length > 0 && e9[0].transport && e9[0].transport.iceTransport && e9[0].transport.iceTransport.getSelectedCandidatePair && e9[0].transport.iceTransport.getSelectedCandidatePair()) {
      const t2 = e9[0].transport.iceTransport, { local: i2, remote: n2 } = t2.getSelectedCandidatePair();
      return { local: GV(GV({}, RV), {}, { candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), remote: GV(GV({}, RV), {}, { candidateType: n2.type, protocol: n2.protocol, address: n2.address, port: n2.port }) };
    }
    return this.statsFilter.getSelectedCandidatePair();
  }
  bindPCEvents() {
    this.peerConnection.oniceconnectionstatechange = () => {
      var e9, t2;
      Dn(e9 = ["connected", "completed"]).call(e9, this.peerConnection.iceConnectionState) && (this.isReady = false), null === (t2 = this.onICEConnectionStateChange) || void 0 === t2 || t2.call(this, this.peerConnection.iceConnectionState);
    }, this.peerConnection.onconnectionstatechange = () => {
      var e9;
      "connected" === this.peerConnection.connectionState && (this.restartCnt = 0), null === (e9 = this.onConnectionStateChange) || void 0 === e9 || e9.call(this, this.peerConnection.connectionState);
    }, this.startICECandidate();
  }
  startICECandidate() {
    this.peerConnection.onicecandidate || (this.localCandidateCount = 0, this.peerConnection.onicecandidate = (e9) => {
      if (e9.candidate) {
        var t2;
        if (e9.candidate.candidate) null === (t2 = this.onLocalCandidate) || void 0 === t2 || t2.call(this, e9.candidate.toJSON());
        this.localCandidateCount += 1;
      } else fb.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount);
    });
  }
  unbindPCEvents() {
    this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
  }
  static resolvePCConfiguration(t2, i2) {
    let n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    const r2 = { iceServers: [] };
    var o2;
    t2.iceServers ? r2.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Ky(t2.turnServer.servers) ? r2.iceServers = t2.turnServer.servers : (r2.iceServers && r2.iceServers.push(...e6.turnServerConfigToIceServers(t2.turnServer.servers, i2, n2)), XA("USE_TURN_SERVER_OF_GATEWAY") && r2.iceServers && t2.turnServer.serversFromGateway && r2.iceServers.push(...e6.turnServerConfigToIceServers(t2.turnServer.serversFromGateway, i2, n2)), Dn(o2 = [HA.Relay, HA.SdRtn]).call(o2, i2) && (r2.iceTransportPolicy = "relay"), XA("FORCE_TURN_TCP") ? r2.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e9) => {
      e9.forceturn && (r2.iceTransportPolicy = "relay");
    })));
    return XA("ENABLE_ENCODED_TRANSFORM") && ZP().supportWebRTCEncodedTransform && (r2.encodedInsertableStreams = true), fb.debug("P2PConnection p2pTransport is ".concat(i2)), r2;
  }
  static turnServerConfigToIceServers(e9, t2) {
    let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    const n2 = [], r2 = e9.filter((e10) => e10.tcpport);
    fb.debug("P2PConnection turnServers is ".concat(r2, ", current index is ").concat(i2));
    const o2 = r2.length > i2 ? r2[i2] : r2[0];
    switch (t2) {
      case HA.SdRtn:
        const t3 = e9.filter((e10) => {
          var t4;
          return Dn(t4 = e10.username).call(t4, "glb:") && e10.turnServerURL == e10.turnServerURL;
        }), r3 = t3.length > i2 ? t3[i2] : t3[0];
        r3 && (n2.push({ username: r3.username, credential: r3.password, credentialType: "password", urls: "turn:".concat(JO(r3.turnServerURL), ":").concat(r3.tcpport, "?transport=udp") }), n2.push({ username: r3.username, credential: r3.password, credentialType: "password", urls: "turns:".concat(JO(r3.turnServerURL), ":").concat(r3.tcpport, "?transport=tcp") }));
        break;
      case HA.Relay:
        o2 && (n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turn:".concat(o2.turnServerURL, ":").concat(o2.tcpport, "?transport=udp") }), n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turns:".concat(JO(o2.turnServerURL), ":").concat(o2.tcpport, "?transport=tcp") }));
        break;
      default:
        o2 && (n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turn:".concat(o2.turnServerURL, ":").concat(o2.tcpport, "?transport=udp") }), n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turns:".concat(JO(o2.turnServerURL), ":").concat(o2.tcpport, "?transport=tcp") }), n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "stun:".concat(o2.turnServerURL, ":").concat(o2.tcpport) }));
    }
    return n2;
  }
  tryBindTransportEvents(e9) {
    if (e9) {
      this.transport = e9, e9.onstatechange = () => {
        var t3;
        null != e9 && e9.state && (null === (t3 = this.onDTLSTransportStateChange) || void 0 === t3 || t3.call(this, e9.state));
      }, e9.onerror = (e10) => {
        var t3;
        null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, "error" in e10 ? e10.error : e10);
      };
      const t2 = e9.iceTransport;
      t2 && (t2.onstatechange = () => {
        const t3 = null == e9 ? void 0 : e9.iceTransport.state;
        var i2;
        t3 && (null === (i2 = this.onICETransportStateChange) || void 0 === i2 || i2.call(this, t3));
      }, t2.getSelectedCandidatePair && (t2.onselectedcandidatepairchange = () => {
        if (t2.getSelectedCandidatePair()) {
          const { local: e10, remote: i2 } = t2.getSelectedCandidatePair();
          fb.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify({ candidateType: e10.type, protocol: e10.protocol }), ", remote ").concat(JSON.stringify({ candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), " )"));
        }
      }));
    }
  }
  tryUnbindTransportEvents() {
    this.transport && (this.transport.onstatechange = null, this.transport.onerror = null, this.transport.iceTransport && (this.transport.iceTransport.onstatechange = null));
  }
  async updateRtpSenderEncodings(e9, t2) {
    var i2;
    if (!t2) {
      t2 = this.peerConnection.getSenders().find((t3) => t3.track === e9._mediaStreamTrack);
    }
    if (!t2) return fb.warn("[".concat(e9.getTrackId(), "] no rtpSender found}"));
    if (this.isVP8Simulcast(e9)) return fb.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
    if (!ZP().supportSetRtpSenderParameters) return fb.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
    const n2 = {}, r2 = {};
    switch (e9._optimizationMode) {
      case "motion":
        n2.degradationPreference = "maintain-framerate";
        break;
      case "detail":
        n2.degradationPreference = "maintain-resolution";
        break;
      default:
        n2.degradationPreference = "balanced";
    }
    if (e9._encoderConfig) {
      var o2;
      const { bitrateMax: t3, frameRate: i3, scaleResolutionDownBy: n3 } = e9._encoderConfig;
      t3 && (r2.maxBitrate = 1e3 * t3), Dn(o2 = e9._hints).call(o2, mL.LOW_STREAM) && (i3 && (r2.maxFramerate = QO(i3)), n3 && n3 >= 1 && (r2.scaleResolutionDownBy = n3));
    }
    if (XA("DSCP_TYPE") && Ey()) {
      var s2;
      const e10 = XA("DSCP_TYPE");
      Dn(s2 = ["very-low", "low", "medium", "high"]).call(s2, e10) && (r2.networkPriority = e10);
    }
    const a2 = t2.getParameters(), c2 = null === (i2 = a2.encodings) || void 0 === i2 ? void 0 : i2[0];
    Zv() && !c2 && (n2.encodings = [r2]), c2 && Object.assign(c2, r2), Object.assign(a2, n2), fb.debug("[".concat(e9.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(a2.encodings))), await t2.setParameters(a2);
  }
  async applySendEncodings(e9, t2) {
    try {
      if (!ZP().supportSetRtpSenderParameters) return;
      if (e9.length !== t2.length) return;
      for (let i2 = 0; i2 < e9.length; i2++) {
        const n2 = e9[i2], r2 = t2[i2];
        r2 instanceof aU && !this.isVP8Simulcast(r2) && await this.updateRtpSenderEncodings(r2, n2.sender);
      }
    } catch (e10) {
      fb.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
    }
  }
  mungSendOfferSDP(e9, t2, i2) {
    const n2 = FU.parse(e9);
    return t2.forEach((e10, t3) => {
      const r2 = i2[t3], o2 = n2.mediaDescriptions.find((e11) => e11.attributes.mid === r2);
      o2 && (JU(o2, e10), ex(o2, e10, this.store.codec));
    }), FU.print(n2);
  }
  bindStatsEvents() {
    this.statsFilter.onFirstAudioReceived = (e9) => {
      var t2;
      null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e9);
    }, this.statsFilter.onFirstVideoReceived = (e9) => {
      var t2;
      null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e9);
    }, this.statsFilter.onFirstAudioDecoded = (e9) => {
      var t2;
      null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e9);
    }, this.statsFilter.onFirstVideoDecoded = (e9, t2, i2) => {
      var n2;
      null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e9, t2, i2);
    }, this.statsFilter.onSelectedLocalCandidateChanged = (e9, t2) => {
      var i2;
      null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e9, t2);
    }, this.statsFilter.onSelectedRemoteCandidateChanged = (e9, t2) => {
      var i2;
      null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e9, t2);
    }, this.statsFilter.onFirstVideoDecodedTimeout = (e9) => {
      var t2;
      null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e9);
    };
  }
  unbindStatsEvents() {
    this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
  }
  async applySimulcastForFirefox(e9, t2) {
    if (e9.length === t2.length) for (let a2 = 0; a2 < e9.length; a2++) {
      var i2, n2, r2, o2, s2;
      const c2 = e9[a2], d2 = t2[a2];
      if (d2 instanceof aU && !Dn(i2 = d2._hints).call(i2, mL.LOW_STREAM) && null !== (n2 = d2._encoderConfig) && void 0 !== n2 && n2.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (o2 = d2._scalabilityMode) && void 0 !== o2 && o2.numSpatialLayers && (null === (s2 = d2._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
        const e10 = {}, t3 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
        e10.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
        const i3 = c2.sender.getParameters();
        await c2.sender.setParameters(Object.assign(i3, e10));
      }
    }
  }
  async applySimulcastEncodings(e9, t2) {
    if (!Zv() && e9.length === t2.length) for (let i2 = 0; i2 < e9.length; i2++) {
      const n2 = t2[i2];
      if (n2 instanceof aU && this.isVP8Simulcast(n2)) {
        const t3 = e9[i2], r2 = {}, o2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
        r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
        const s2 = t3.sender.getParameters();
        await t3.sender.setParameters(Object.assign(s2, r2));
      }
    }
  }
  isVP8Simulcast(e9) {
    var t2, i2, n2, r2, o2;
    return !!(e9 instanceof aU && XA("SIMULCAST") && "vp8" === this.store.codec && !Dn(t2 = e9._hints).call(t2, mL.LOW_STREAM) && null !== (i2 = e9._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n2 = e9._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = e9._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (o2 = e9._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1);
  }
  logSDPExchange(e9, t2, i2, n2) {
    if (XA("SDP_LOGGING")) return fb.upload("[".concat(this.store.clientId, "] exchanging ").concat(i2, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e9), "offer" === t2 ? (e10) => {
      this.logSDPExchange(e10, "answer", "local" === i2 ? "remote" : "local", n2);
    } : void 0;
  }
  async muteLocal(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
      const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e9.indexOf(t3.mid));
      if (t2.length !== e9.length) throw new Error("Transceivers' length doesn't match mids' length.");
      t2.map((e10) => {
        e10.direction = "inactive";
      });
      const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
      await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e9);
      const r2 = this.remoteSDP.toString();
      null == n2 || n2(r2), await this.setRemoteDescription({ type: "answer", sdp: r2 });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e10.toString()));
    }
  }
  async unmuteLocal(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
      const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e9.indexOf(t3.mid));
      if (t2.length !== e9.length) throw new Error("Transceivers' length doesn't match mids' length.");
      t2.map(async (e10) => {
        e10.direction = "sendonly";
      });
      const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
      await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e9);
      const r2 = this.remoteSDP.toString();
      null == n2 || n2(r2), await this.setRemoteDescription({ type: "answer", sdp: r2 });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e10.toString()));
    }
  }
  async getRemoteSSRC(e9, t2) {
    var i2, n2;
    if (t2 = null !== (i2 = t2) && void 0 !== i2 ? i2 : null === (n2 = this.currentRemoteDescription) || void 0 === n2 ? void 0 : n2.sdp) {
      var r2;
      const i3 = null === (r2 = FU.parse(t2).mediaDescriptions.find((t3) => t3.attributes.mid === e9)) || void 0 === r2 ? void 0 : r2.attributes.ssrcs;
      return null == i3 ? void 0 : i3[0].ssrcId;
    }
  }
  async setRemoteDescription(e9) {
    var t2;
    await this.peerConnection.setRemoteDescription(e9), Dn(t2 = ["connected", "completed"]).call(t2, this.peerConnection.iceConnectionState) || (this.isReady = true, this.addRemoteCandidate());
  }
  mungReceiveAnswerSDP(e9, t2, i2) {
    const n2 = FU.parse(e9), r2 = n2.mediaDescriptions.find((e10) => e10.attributes.mid === t2);
    return r2 && i2 === dO.AUDIO && "audio" === r2.media.mediaType && ox(r2), FU.print(n2);
  }
}, Cw(BV.prototype, "establish", [HV], Object.getOwnPropertyDescriptor(BV.prototype, "establish"), BV.prototype), Cw(BV.prototype, "connect", [HV], Object.getOwnPropertyDescriptor(BV.prototype, "connect"), BV.prototype), Cw(BV.prototype, "receive", [HV], Object.getOwnPropertyDescriptor(BV.prototype, "receive"), BV.prototype), Cw(BV.prototype, "mockReceive", [HV], Object.getOwnPropertyDescriptor(BV.prototype, "mockReceive"), BV.prototype), Cw(BV.prototype, "stopReceiving", [HV], Object.getOwnPropertyDescriptor(BV.prototype, "stopReceiving"), BV.prototype), Cw(BV.prototype, "restartICE", [HV], Object.getOwnPropertyDescriptor(BV.prototype, "restartICE"), BV.prototype), Cw(BV.prototype, "close", [HV], Object.getOwnPropertyDescriptor(BV.prototype, "close"), BV.prototype), Cw(BV.prototype, "updateEncoderConfig", [HV], Object.getOwnPropertyDescriptor(BV.prototype, "updateEncoderConfig"), BV.prototype), Cw(BV.prototype, "updateSendParameters", [HV], Object.getOwnPropertyDescriptor(BV.prototype, "updateSendParameters"), BV.prototype), Cw(BV.prototype, "replaceTrack", [HV], Object.getOwnPropertyDescriptor(BV.prototype, "replaceTrack"), BV.prototype), Cw(BV.prototype, "muteLocal", [HV], Object.getOwnPropertyDescriptor(BV.prototype, "muteLocal"), BV.prototype), Cw(BV.prototype, "unmuteLocal", [HV], Object.getOwnPropertyDescriptor(BV.prototype, "unmuteLocal"), BV.prototype), BV);
function HV(e9, t2, i2) {
  const n2 = e9[t2];
  if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
  return i2.value = async function() {
    const e10 = this.mutex, i3 = await e10.lock("From P2PConnection.".concat(t2));
    try {
      for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
      return await n2.apply(this, o2);
    } finally {
      i3();
    }
  }, i2;
}
function KV(e9, t2) {
  let i2 = document.createElement("video"), n2 = document.createElement("canvas");
  i2.setAttribute("style", "display:none"), n2.setAttribute("style", "display:none"), i2.setAttribute("muted", ""), i2.muted = true, i2.setAttribute("autoplay", ""), i2.autoplay = true, i2.setAttribute("playsinline", ""), n2.width = QO(t2.width), n2.height = QO(t2.height);
  const r2 = QO(t2.framerate || 15);
  document.body.append(i2), document.body.append(n2);
  let o2 = e9._mediaStreamTrack;
  i2.srcObject = new MediaStream([o2]), i2.play();
  const s2 = n2.getContext("2d");
  if (!s2) throw new yb(Ry.UNEXPECTED_ERROR, "can not get canvas context");
  const a2 = ZP(), c2 = n2.captureStream(a2.supportRequestFrame ? 0 : r2).getVideoTracks()[0];
  c2.canvas || (c2.canvas = n2), n2.startCapture = () => {
    if (!i2) return n2.stopCapture && n2.stopCapture();
    if (i2.paused && i2.play(), i2.videoHeight > 2 && i2.videoWidth > 2) {
      const e10 = i2.videoWidth, t3 = i2.videoHeight / e10, r3 = n2.width * t3;
      Math.abs(r3 - n2.height) >= 2 && (fb.debug("adjust low stream resolution", "".concat(n2.width, "x").concat(n2.height, " -> ").concat(n2.width, "x").concat(r3)), n2.height = r3);
    }
    s2.drawImage(i2, 0, 0, n2.width, n2.height), c2.requestFrame && c2.requestFrame(), o2 !== e9._mediaStreamTrack && (o2 = e9._mediaStreamTrack, i2.srcObject = new MediaStream([o2]));
  }, n2.stopCapture = QL(() => n2.startCapture && n2.startCapture(), r2);
  const d2 = c2.stop;
  return c2.stop = () => {
    d2.call(c2), i2 && (i2.remove(), i2.srcObject = null, i2 = null), n2 && (n2.width = 0, n2.remove(), n2.stopCapture && n2.stopCapture(), n2.startCapture = void 0, n2.stopCapture = void 0, n2 = null), fb.debug("clean low stream renderer");
  }, c2;
}
var YV = function(e9) {
  return e9[e9.HEIGHT = 2033] = "HEIGHT", e9[e9.FRAME_RATE = 2034] = "FRAME_RATE", e9[e9.WIDTH = 2035] = "WIDTH", e9;
}(YV || {});
var qV = function(e9) {
  return e9[e9.FRAME_RATE = 2002] = "FRAME_RATE", e9[e9.WIDTH = 2003] = "WIDTH", e9[e9.HEIGHT = 2004] = "HEIGHT", e9[e9.PACKAGE_LOST = 2005] = "PACKAGE_LOST", e9[e9.AVG_ENCODE = 2007] = "AVG_ENCODE", e9[e9.NACKS = 2009] = "NACKS", e9[e9.PLIS = 2010] = "PLIS", e9[e9.FIRS = 2011] = "FIRS", e9[e9.BITRATE = 2012] = "BITRATE", e9[e9.PACKAGE_RATE = 2031] = "PACKAGE_RATE", e9[e9.ADAPTATION = 2032] = "ADAPTATION", e9[e9.ACTUAL_ENCODED = 2060] = "ACTUAL_ENCODED", e9[e9.BANDWIDTH = 2061] = "BANDWIDTH", e9[e9.RETRANSMIT = 2062] = "RETRANSMIT", e9[e9.TARGET_ENCODED = 2064] = "TARGET_ENCODED", e9[e9.TRANSMIT = 2066] = "TRANSMIT", e9[e9.FREEZE = 2082] = "FREEZE", e9[e9.DISABLED = 2095] = "DISABLED", e9[e9.PLAYER_STATUS = 2128] = "PLAYER_STATUS", e9[e9.QP_SUM = 2143] = "QP_SUM", e9;
}(qV || {});
var zV = function(e9) {
  return e9[e9.BITRATE = 2069] = "BITRATE", e9[e9.PACKAGE_LOST = 2070] = "PACKAGE_LOST", e9[e9.PACKAGE_RATE = 2071] = "PACKAGE_RATE", e9[e9.HEIGHT = 2073] = "HEIGHT", e9[e9.FRAME_RATE = 2075] = "FRAME_RATE", e9[e9.WIDTH = 2077] = "WIDTH", e9;
}(zV || {});
var JV = function(e9) {
  return e9[e9.JITTER = -1] = "JITTER", e9[e9.PACKAGE_LOST = 2014] = "PACKAGE_LOST", e9[e9.WIDTH = 2018] = "WIDTH", e9[e9.HEIGHT = 2019] = "HEIGHT", e9[e9.FRAME_RATE = 2020] = "FRAME_RATE", e9[e9.JITTER_BUFFER = 2023] = "JITTER_BUFFER", e9[e9.CURRENT_DELAY = 2024] = "CURRENT_DELAY", e9[e9.NACKS = 2026] = "NACKS", e9[e9.PLIS = 2027] = "PLIS", e9[e9.FIRS = 2028] = "FIRS", e9[e9.BITRATE = 2029] = "BITRATE", e9[e9.PACKAGE_RATE = 2078] = "PACKAGE_RATE", e9[e9.FREEZE = 2084] = "FREEZE", e9[e9.DISABLED = 2101] = "DISABLED", e9[e9.PLAYER_STATUS = 2129] = "PLAYER_STATUS", e9[e9.QP_SUM = 2144] = "QP_SUM", e9[e9.I_FRAME_DELAY = 2149] = "I_FRAME_DELAY", e9;
}(JV || {});
var XV = function(e9) {
  return e9[e9.FRAME_RATE_DECODE = 2021] = "FRAME_RATE_DECODE", e9[e9.FRAME_RATE_RENDER = 2022] = "FRAME_RATE_RENDER", e9[e9.FRAME_RATE_OUTPUT = 2155] = "FRAME_RATE_OUTPUT", e9[e9.FREEZE_TIME = 2109] = "FREEZE_TIME", e9[e9.FREEZE_TIME_RENDER = 2147] = "FREEZE_TIME_RENDER", e9[e9.FREEZE_DURATION = 2156] = "FREEZE_DURATION", e9;
}(XV || {});
var QV = function(e9) {
  return e9[e9.PCM_LEVEL = 2104] = "PCM_LEVEL", e9;
}(QV || {});
var ZV = function(e9) {
  return e9[e9.PACKAGE_LOST = -1] = "PACKAGE_LOST", e9[e9.LEVEL = 2038] = "LEVEL", e9[e9.BITRATE = 2039] = "BITRATE", e9[e9.PACKAGE_RATE = 2040] = "PACKAGE_RATE", e9[e9.AEC_RETURN_LOSS = 2041] = "AEC_RETURN_LOSS", e9[e9.AEC_RETURN_LOSS_ENH = 2042] = "AEC_RETURN_LOSS_ENH", e9[e9.FREEZE = 2081] = "FREEZE", e9[e9.DISABLED = 2096] = "DISABLED", e9;
}(ZV || {});
var $V = function(e9) {
  return e9[e9.BITRATE = 2044] = "BITRATE", e9[e9.PACKAGE_LOST = 2045] = "PACKAGE_LOST", e9[e9.PACKAGE_RATE = 2046] = "PACKAGE_RATE", e9[e9.CURRENT_DELAY = 2047] = "CURRENT_DELAY", e9[e9.JITTER_BUFFER = 2054] = "JITTER_BUFFER", e9[e9.JITTER = 2055] = "JITTER", e9[e9.FREEZE = 2083] = "FREEZE", e9[e9.DISABLED = 2102] = "DISABLED", e9[e9.PCM_LEVEL = 2105] = "PCM_LEVEL", e9[e9.PLAYER_STATUS = 2130] = "PLAYER_STATUS", e9[e9.CONCEALED_SAMPLES = 2148] = "CONCEALED_SAMPLES", e9;
}($V || {});
var eF = function(e9) {
  return e9[e9.FREEZE_TIME = -1] = "FREEZE_TIME", e9[e9.LEVEL = 2043] = "LEVEL", e9;
}(eF || {});
var tF = function(e9) {
  return e9[e9.RTT = 2006] = "RTT", e9[e9.CONN_TYPE = 801] = "CONN_TYPE", e9;
}(tF || {});
var iF = 1e3;
var nF = 3;
function rF(e9, t2, i2) {
  null != i2 && Number.isFinite(i2) && (e9[t2] = Math.round(Math.max(0, i2)));
}
function oF(e9) {
  const t2 = { [tF.CONN_TYPE]: 0, [tF.RTT]: e9.rtt };
  switch (e9.selectedCandidatePair.localCandidate.candidateType) {
    case "relay": {
      const i2 = e9.selectedCandidatePair.localCandidate.relayProtocol;
      "udp" === i2 && (t2[tF.CONN_TYPE] = 1), "tcp" === i2 && (t2[tF.CONN_TYPE] = 3), "tls" === i2 && (t2[tF.CONN_TYPE] = 4);
      break;
    }
    case "srflx":
      t2[tF.CONN_TYPE] = 2;
  }
  return t2;
}
function sF(e9) {
  let t2 = 0;
  switch (e9) {
    case "none":
      t2 = 0;
      break;
    case "cpu":
      t2 = 1;
      break;
    case "bandwidth":
      t2 = 2;
      break;
    case "other":
      t2 = 3;
  }
  return t2;
}
var aF = class extends xy {
  constructor(e9) {
    super(), Fg(this, "store", void 0), Fg(this, "uploadWRTCStatsTimer", void 0), Fg(this, "uploadOutboundDenoiserStatsTimer", void 0), Fg(this, "uploadExtStatsTimer", void 0), Fg(this, "uploadExtUsageStatsTimer", void 0), Fg(this, "uploadInboundExtStatsTimer", void 0), Fg(this, "requestStats", void 0), Fg(this, "requestTransportStats", void 0), Fg(this, "requestLocalMedia", void 0), Fg(this, "requestRemoteMedia", void 0), Fg(this, "requestAllTracks", void 0), Fg(this, "requestVideoIsReady", void 0), Fg(this, "requestUploadStats", void 0), Fg(this, "requestUpload", void 0), Fg(this, "uploadOutboundStarted", false), Fg(this, "uploadInboundStarted", false), Fg(this, "uploadTransportStarted", false), Fg(this, "uploadExtensionUsageStarted", false), Fg(this, "lastRecvStats", void 0), Fg(this, "lastSendStats", void 0), Fg(this, "lastFullRecvStats", void 0), Fg(this, "lastFullSendStats", void 0), Fg(this, "needUploadRenderFreezeTime", true), this.store = e9;
  }
  uploadWRTCStats(e9) {
    if (!this.requestStats || !this.requestUploadStats) return;
    let t2, i2;
    if (this.uploadTransportStarted && (t2 = this.requestStats(), this.store.useP2P && (i2 = this.requestStats(true))), !t2 && this.uploadOutboundStarted && (t2 = this.requestStats()), !i2 && this.uploadInboundStarted && (i2 = this.requestStats(true)), t2 || i2) {
      const n2 = {};
      if (this.uploadTransportStarted && t2) {
        const r2 = this.getTransportStats(t2, i2, e9);
        r2 && (n2.misc = [r2]);
      }
      if (this.uploadOutboundStarted && t2) {
        const i3 = this.getOutboundStats(t2, e9 ? this.lastSendStats : this.lastFullSendStats, e9);
        i3 && (n2.outbound = [i3]);
      }
      if (this.uploadInboundStarted && i2) {
        const t3 = this.getInboundStats(i2, e9 ? this.lastRecvStats : this.lastFullRecvStats, e9);
        t3 && (n2.inbound = t3);
      }
      this.requestUploadStats(n2);
    }
    this.lastRecvStats = i2, this.lastSendStats = t2, e9 || (this.lastFullRecvStats = i2, this.lastFullSendStats = t2);
  }
  startUploadWRTCStats() {
    if (this.uploadWRTCStatsTimer) return;
    let e9 = 1;
    this.uploadWRTCStatsTimer = window.setInterval(() => {
      if (!this.uploadTransportStarted && !this.uploadInboundStarted && !this.uploadOutboundStarted) return this.stopUploadWRTCStats();
      this.uploadWRTCStats(e9 !== nF), ++e9 === nF + 1 && (e9 = 1);
    }, iF);
  }
  stopUploadWRTCStats() {
    window.clearInterval(this.uploadWRTCStatsTimer), this.uploadWRTCStatsTimer = void 0, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0);
  }
  getTransportStats(e9, t2, i2) {
    if (!this.requestStats) return;
    if (i2) return null == e9.rtt ? void 0 : { addition: { [tF.RTT]: e9.rtt, [tF.CONN_TYPE]: void 0 } };
    const n2 = oF(e9);
    if (this.store.useP2P) {
      if (t2) {
        const e10 = oF(t2);
        n2[tF.CONN_TYPE] += e10[tF.CONN_TYPE] << 3;
      }
      n2[tF.CONN_TYPE] += 110;
    } else n2[tF.CONN_TYPE] += 100;
    return { addition: n2 };
  }
  getOutboundStats(e9, t2, i2) {
    if (!this.requestUploadStats || !this.requestLocalMedia) return;
    const n2 = this.requestLocalMedia();
    if (!n2 || 0 === n2.length) return;
    let r2, o2, s2;
    return n2.forEach((n3) => {
      let [a2, { track: c2, ssrcs: d2 }] = n3;
      switch (a2) {
        case hO.LocalVideoLowTrack:
        case hO.LocalVideoTrack:
          if (a2 === hO.LocalVideoTrack) {
            const n4 = function(e10, t3, i3, n5, r4) {
              const o3 = t3.videoSend.find((t4) => t4.ssrc === e10);
              if (!o3) return;
              const s4 = {}, { sentFrame: a3, inputFrame: c3 } = o3;
              if (c3 && a3) {
                const e11 = c3.frameRate, t4 = a3.frameRate;
                s4[qV.FREEZE] = function(e12, t5) {
                  let i4 = true;
                  return i4 = !(e12 <= 5) && (e12 <= 10 ? t5 < 3 : e12 <= 20 ? t5 < 4 : t5 < 5), i4;
                }(e11, t4) ? 1 : 0;
              }
              if (rF(s4, qV.QP_SUM, o3.qpSumPerFrame), r4) return s4;
              switch (a3 && (rF(s4, qV.HEIGHT, a3.height), rF(s4, qV.WIDTH, a3.width), rF(s4, qV.FRAME_RATE, a3.frameRate)), s4[qV.DISABLED] = n5._originMediaStreamTrack && !n5._originMediaStreamTrack.enabled || n5._mediaStreamTrack && !n5._mediaStreamTrack.enabled ? 1 : 0, o3.adaptionChangeReason) {
                case "none":
                  s4[qV.ADAPTATION] = 0;
                  break;
                case "cpu":
                  s4[qV.ADAPTATION] = 1;
                  break;
                case "bandwidth":
                  s4[qV.ADAPTATION] = 2;
                  break;
                case "other":
                  s4[qV.ADAPTATION] = 3;
              }
              let d3 = 0;
              o3.adaptionChangeReason && (d3 += sF(o3.adaptionChangeReason)), t3.qualityLimitationReason && (d3 += sF(t3.qualityLimitationReason) << 3), s4[qV.ADAPTATION] = d3, s4[qV.PLAYER_STATUS] = xL[n5._player ? n5._player.videoElementStatus : "uninit"], rF(s4, qV.NACKS, o3.nacksCount), rF(s4, qV.PLIS, o3.plisCount), rF(s4, qV.FIRS, o3.firsCount), rF(s4, qV.AVG_ENCODE, o3.avgEncodeMs);
              const l2 = i3 && i3.videoSend.find((t4) => t4.ssrc === e10);
              if (l2) {
                let e11 = r4 ? iF : iF * nF;
                l2.timestamp && o3.timestamp && (e11 = o3.timestamp - l2.timestamp), null != l2.packets && null != o3.packets && rF(s4, qV.PACKAGE_RATE, 1e3 * (o3.packets - l2.packets) / e11), null != o3.packetsLost && null != l2.packetsLost && rF(s4, qV.PACKAGE_LOST, o3.packetsLost - l2.packetsLost), null != l2.bytes && null != o3.bytes && rF(s4, qV.BITRATE, 8 * (o3.bytes - l2.bytes) / e11);
              }
              return s4;
            }(d2[0].ssrcId, e9, t2, c2, i2), r3 = i2 ? null : function(e10, t3, i3) {
              const n5 = t3.videoSend.find((t4) => t4.ssrc === e10);
              if (!n5) return null;
              const r4 = {}, o3 = n5.inputFrame, s4 = o3 && o3.height || i3 && i3.videoHeight || 0, a3 = o3 && o3.width || i3 && i3.videoWidth || 0, c3 = o3 && o3.frameRate || 0;
              return rF(r4, YV.HEIGHT, s4), rF(r4, YV.WIDTH, a3), rF(r4, YV.FRAME_RATE, c3), r4;
            }(d2[0].ssrcId, e9, c2), s3 = i2 ? null : function(e10) {
              const t3 = {};
              return rF(t3, qV.RETRANSMIT, e10.bitrate.retransmit), rF(t3, qV.TARGET_ENCODED, e10.bitrate.targetEncoded), rF(t3, qV.ACTUAL_ENCODED, e10.bitrate.actualEncoded), rF(t3, qV.TRANSMIT, e10.bitrate.transmit), rF(t3, qV.BANDWIDTH, e10.sendBandwidth), t3;
            }(e9);
            o2 = Object.assign({}, n4, r3, s3);
          } else s2 = i2 ? void 0 : function(e10, t3, i3) {
            const n4 = t3.videoSend.find((t4) => t4.ssrc === e10);
            if (!n4) return;
            const r3 = {}, o3 = n4.sentFrame;
            if (o3 && (rF(r3, zV.HEIGHT, o3.height), rF(r3, zV.WIDTH, o3.width), rF(r3, zV.FRAME_RATE, o3.frameRate)), i3) {
              const t4 = i3.videoSend.find((t5) => t5.ssrc === e10);
              if (t4) {
                let e11 = iF * nF;
                t4.timestamp && n4.timestamp && (e11 = n4.timestamp - t4.timestamp), null != t4.packets && null != n4.packets && rF(r3, zV.PACKAGE_RATE, 1e3 * (n4.packets - t4.packets) / e11), null != n4.packetsLost && null != t4.packetsLost && rF(r3, zV.PACKAGE_LOST, n4.packetsLost - t4.packetsLost), null != t4.bytes && null != n4.bytes && rF(r3, zV.BITRATE, 8 * (n4.bytes - t4.bytes) / e11);
              }
            }
            return r3;
          }(d2[0].ssrcId, e9, t2);
          break;
        case hO.LocalAudioTrack:
          r2 = i2 ? void 0 : function(e10, t3, i3, n4) {
            const r3 = t3.audioSend.find((t4) => t4.ssrc === e10);
            if (!r3) return;
            const o3 = {};
            o3[ZV.DISABLED] = n4._originMediaStreamTrack && !n4._originMediaStreamTrack.enabled || n4._mediaStreamTrack && !n4._mediaStreamTrack.enabled ? 1 : 0;
            const s3 = 100 * n4._source.getAccurateVolumeLevel(), a3 = r3.inputLevel;
            if (null != a3) {
              const e11 = Math.ceil(50 * Math.log10(100 * a3 + 1));
              rF(o3, ZV.LEVEL, e11);
            } else rF(o3, ZV.LEVEL, s3);
            rF(o3, QV.PCM_LEVEL, s3), rF(o3, ZV.AEC_RETURN_LOSS, r3.aecReturnLoss), rF(o3, ZV.AEC_RETURN_LOSS_ENH, r3.aecReturnLossEnhancement), o3[ZV.FREEZE] = 0;
            const c3 = i3 && i3.audioSend.find((t4) => t4.ssrc === e10);
            if (c3) {
              let e11 = iF * nF;
              c3.timestamp && r3.timestamp && (e11 = r3.timestamp - c3.timestamp), null != c3.bytes && null != r3.bytes && rF(o3, ZV.BITRATE, 8 * (r3.bytes - c3.bytes) / e11), null != c3.packets && null != r3.packets && rF(o3, ZV.PACKAGE_RATE, 1e3 * (r3.packets - c3.packets) / e11);
            }
            return o3;
          }(d2[0].ssrcId, e9, t2, c2);
      }
    }), { high: o2, low: s2, audio: r2 };
  }
  getInboundStats(e9, t2, i2) {
    if (!this.requestRemoteMedia) return;
    const n2 = this.requestRemoteMedia() || [], r2 = [];
    return n2.forEach((n3) => {
      let [o2, s2] = n3;
      const a2 = { peer: o2.uid };
      if (s2.has(dO.VIDEO) && o2.videoTrack) {
        const n4 = o2._videoSSRC && this.requestVideoIsReady && this.requestVideoIsReady(o2._videoSSRC) || false, r3 = o2.videoTrack ? function(e10, t3, i3, n5, r4, o3, s3) {
          var a3;
          const c2 = t3.videoRecv.find((t4) => t4.ssrc === e10);
          if (!c2) return;
          const d2 = {}, { receivedFrame: l2, outputFrame: u2, decodeFrameRate: h2 } = c2, p2 = i3 && i3.videoRecv.find((t4) => t4.ssrc === e10);
          if (d2[JV.FREEZE] = r4 && DF.isRemoteVideoFreeze(n5, c2, p2) ? 1 : 0, rF(d2, XV.FRAME_RATE_DECODE, h2), rF(d2, JV.QP_SUM, c2.qpSumPerFrame), c2.framesRateFirefox && rF(d2, JV.FRAME_RATE, c2.framesRateFirefox), l2 && rF(d2, JV.FRAME_RATE, l2.frameRate), p2) {
            const e11 = t3.timestamp - i3.timestamp || (s3 ? iF : nF * iF);
            null != c2.packetsLost && null != p2.packetsLost && rF(d2, JV.PACKAGE_LOST, c2.packetsLost - p2.packetsLost), null != p2.bytes && null != c2.bytes && rF(d2, JV.BITRATE, 8 * (c2.bytes - p2.bytes) / e11), null != p2.packets && null != c2.packets && rF(d2, JV.PACKAGE_RATE, 1e3 * (c2.packets - p2.packets) / e11);
          }
          if (s3) return d2;
          l2 ? (rF(d2, JV.HEIGHT, l2.height), rF(d2, JV.WIDTH, l2.width)) : n5 && (rF(d2, JV.HEIGHT, n5._videoHeight || 0), rF(d2, JV.WIDTH, n5._videoWidth || 0)), u2 && rF(d2, XV.FRAME_RATE_OUTPUT, u2.frameRate);
          const _2 = null === (a3 = n5._player) || void 0 === a3 ? void 0 : a3.rendFrameRate.toFixed(0);
          if (_2 && rF(d2, XV.FRAME_RATE_RENDER, +_2), rF(d2, JV.JITTER_BUFFER, c2.jitterBufferMs), rF(d2, JV.CURRENT_DELAY, c2.currentDelayMs), rF(d2, JV.FIRS, c2.firsCount), rF(d2, JV.NACKS, c2.nacksCount), rF(d2, JV.PLIS, c2.plisCount), n5) {
            d2[JV.DISABLED] = n5._originMediaStreamTrack.enabled && n5._mediaStreamTrack.enabled ? 0 : 1;
            const e11 = n5._player;
            if (e11) {
              const { freezeTimeCounterList: t4, renderFreezeAccTime: i4, videoElementStatus: n6 } = e11;
              if (t4 && t4.length > 0 && rF(d2, XV.FREEZE_TIME, t4.splice(0, 1)[0]), o3 && "visible" === yU.visibility && n6 === ML.PLAYING && ZP().supportRequestVideoFrameCallback) {
                const t5 = Math.min(6e3, i4);
                e11.renderFreezeAccTime = Math.max(0, i4 - t5), rF(d2, XV.FREEZE_TIME_RENDER, t5);
              }
              if ("number" == typeof c2.totalFreezesDuration) {
                const e12 = p2 && p2.totalFreezesDuration ? c2.totalFreezesDuration - p2.totalFreezesDuration : c2.totalFreezesDuration;
                rF(d2, XV.FREEZE_DURATION, 1e3 * e12);
              }
            }
          }
          if (d2[JV.PLAYER_STATUS] = xL[n5._player ? n5._player.videoElementStatus : "uninit"], p2 && void 0 !== c2.totalInterFrameDelay && void 0 !== c2.totalSquaredInterFrameDelay && void 0 !== p2.totalInterFrameDelay && void 0 !== p2.totalSquaredInterFrameDelay) {
            const e11 = c2.totalInterFrameDelay - p2.totalInterFrameDelay, t4 = c2.totalSquaredInterFrameDelay - p2.totalSquaredInterFrameDelay, i4 = c2.framesDecodeCount - p2.framesDecodeCount, n6 = e11 / i4 * 1e3, r5 = Math.round(1e3 * Math.sqrt((t4 - Math.pow(e11, 2) / i4) / i4));
            !isNaN(r5) && n6 + r5 > Math.max(3 * n6, n6 + 150) && (d2[JV.I_FRAME_DELAY] = r5);
          }
          return d2;
        }(o2._videoSSRC, e9, t2, o2.videoTrack, true === n4, this.needUploadRenderFreezeTime, i2) : void 0;
        r3 && (a2.video = r3);
      }
      if (s2.has(dO.AUDIO) && o2.audioTrack) {
        const n4 = o2.audioTrack ? function(e10, t3, i3, n5, r3) {
          const o3 = t3.audioRecv.find((t4) => t4.ssrc === e10);
          if (!o3) return;
          const s3 = {}, a3 = i3 && i3.audioRecv.find((t4) => t4.ssrc === e10), { receivedFrames: c2, droppedFrames: d2 } = o3;
          var l2, u2;
          if (rF(s3, $V.JITTER, o3.jitterMs), null != c2 && null != d2 && (s3[$V.FREEZE] = (u2 = d2, 0 === (l2 = c2) || 100 * u2 / l2 > 20 ? 1 : 0)), a3) {
            const e11 = t3.timestamp - i3.timestamp || (r3 ? iF : iF * nF);
            null != o3.packets && null != a3.packets && rF(s3, $V.PACKAGE_RATE, 1e3 * (o3.packets - a3.packets) / e11), null != a3.bytes && null != o3.bytes && rF(s3, $V.BITRATE, 8 * (o3.bytes - a3.bytes) / e11), null != o3.packetsLost && null != a3.packetsLost && rF(s3, $V.PACKAGE_LOST, o3.packetsLost - a3.packetsLost);
          }
          if (r3) return s3;
          const h2 = 100 * n5._source.getAccurateVolumeLevel(), p2 = o3.outputLevel;
          if (null != p2) {
            const e11 = Math.ceil(50 * Math.log10(100 * p2 + 1));
            rF(s3, eF.LEVEL, e11);
          }
          if (rF(s3, $V.PCM_LEVEL, h2), n5 && (s3[$V.DISABLED] = n5._originMediaStreamTrack.enabled && n5._mediaStreamTrack.enabled ? 0 : 1), rF(s3, $V.JITTER_BUFFER, o3.jitterBufferMs), rF(s3, $V.CURRENT_DELAY, o3.jitterBufferMs), s3[$V.PLAYER_STATUS] = xL[mk.getPlayerState(n5.getTrackId())], a3) {
            const e11 = o3.concealedSamples - a3.concealedSamples;
            e11 > 0 && rF(s3, $V.CONCEALED_SAMPLES, e11);
          }
          return s3;
        }(o2._audioSSRC, e9, t2, o2.audioTrack, i2) : void 0;
        n4 && (a2.audio = n4);
      }
      (a2.video || a2.audio) && r2.push(a2);
    }), this.needUploadRenderFreezeTime = !this.needUploadRenderFreezeTime, r2;
  }
  startUploadTransportStats() {
    this.uploadTransportStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats();
  }
  stopUploadTransportStats() {
    this.uploadTransportStarted = false;
  }
  startUploadOutboundStats() {
    this.uploadOutboundStarted || (this.uploadOutboundStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = window.setInterval(() => {
      if (!this.requestAllTracks || !this.requestUpload) return;
      const e9 = (this.requestAllTracks() || []).find((e10) => e10 instanceof SM);
      if (e9 && e9._external.getDenoiserStats) {
        const t2 = e9._external.getDenoiserStats();
        t2 && this.requestUpload(Lw.DENOISER_STATS, t2);
      }
    }, 2e3), this.uploadExtStatsTimer && window.clearInterval(this.uploadExtStatsTimer), this.uploadExtStatsTimer = window.setInterval(() => {
      if (!this.requestAllTracks || !this.requestUpload) return;
      this.requestAllTracks().forEach((e9) => {
        e9.getProcessorStats().forEach((e10) => {
          this.requestUpload && this.requestUpload(e10.type, e10.stats);
        });
      });
    }, 2e3));
  }
  stopUploadOutboundStats() {
    this.uploadOutboundStarted && (this.uploadOutboundStarted = false, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = void 0);
  }
  startUploadInboundStats() {
    this.uploadInboundStarted || (this.uploadInboundStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadInboundExtStatsTimer && window.clearInterval(this.uploadInboundExtStatsTimer), this.uploadInboundExtStatsTimer = window.setInterval(() => {
      if (!this.requestUpload || !this.requestRemoteMedia) return;
      (this.requestRemoteMedia() || []).forEach((e9) => {
        let [t2, i2] = e9;
        if (i2.has(dO.VIDEO) && t2.videoTrack) {
          t2.videoTrack.getProcessorStats().forEach((e10) => {
            this.requestUpload && this.requestUpload(e10.type, e10.stats);
          });
        }
        if (i2.has(dO.AUDIO) && t2.audioTrack) {
          t2.audioTrack.getProcessorStats().forEach((e10) => {
            this.requestUpload && this.requestUpload(e10.type, e10.stats);
          });
        }
      });
    }, 2e3));
  }
  stopUploadInboundStats() {
    this.uploadInboundStarted && (this.uploadInboundStarted = false, this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0));
  }
  startUploadExtensionUsageStats() {
    if (this.uploadExtensionUsageStarted) return;
    this.uploadExtensionUsageStarted = true, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer);
    const e9 = /* @__PURE__ */ new Map();
    this.uploadExtUsageStatsTimer = window.setInterval(async () => {
      const t2 = Date.now(), i2 = { connectionInterval: XA("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3, details: [], lts: t2 };
      let n2 = [];
      const r2 = this.requestAllTracks && this.requestAllTracks() || [];
      for (const e10 of r2) !e10.muted && e10.enabled && (n2 = n2.concat(await e10.getProcessorUsage()));
      const o2 = this.requestRemoteMedia && this.requestRemoteMedia() || [];
      for (const [e10, t3] of o2) t3.has(dO.VIDEO) && e10.videoTrack && (n2 = n2.concat(await e10.videoTrack.getProcessorUsage())), t3.has(dO.AUDIO) && e10.audioTrack && (n2 = n2.concat(await e10.audioTrack.getProcessorUsage()));
      if (0 === n2.length) return;
      i2.details = function(e10, t3) {
        const i3 = {};
        for (const { id: s3, value: a3, level: c2, direction: d2 } of e10) {
          var n3;
          const e11 = null !== (n3 = t3.get(s3)) && void 0 !== n3 ? n3 : 0, l2 = 2 === a3 ? e11 + XA("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3 : e11;
          var r3, o3;
          t3.set(s3, l2), i3[s3] ? (2 === a3 && (i3[s3].value = a3), c2 > i3[s3].level && (i3[s3].level = c2), "remote" === d2 && (i3[s3].remoteUidCount += 1), i3[s3].totalTs = null !== (r3 = t3.get(s3)) && void 0 !== r3 ? r3 : 0) : i3[s3] = { value: a3, level: c2, remoteUidCount: "local" === d2 ? 0 : 1, totalTs: null !== (o3 = t3.get(s3)) && void 0 !== o3 ? o3 : 0 };
        }
        return Object.keys(i3).map((e11) => {
          const { level: t4, value: n4, totalTs: r4 } = i3[e11];
          return { id: e11, level: t4, value: n4, totalTs: r4 };
        });
      }(n2, e9);
      const s2 = Date.now(), a2 = s2 > t2 ? s2 : t2 + 1;
      this.requestUpload && this.requestUpload(Lw.EXTENSION_USAGE_STATS, { usageStats: i2, sendTs: a2 });
    }, XA("EXTENSION_USAGE_UPLOAD_INTERVAL"));
  }
  stopUploadExtensionUsageStats() {
    this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = false, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer), this.uploadExtUsageStatsTimer = void 0);
  }
};
var cF = class {
  get hasVideo() {
    return this._video_enabled_ && !this._video_muted_ && this._video_added_;
  }
  get hasAudio() {
    return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;
  }
  get audioTrack() {
    if (this.hasAudio || this._audio_pre_subscribed) return this._audioTrack;
  }
  get videoTrack() {
    if (this.hasVideo || this._video_pre_subscribed) return this._videoTrack;
  }
  get dataChannels() {
    return this._dataChannels;
  }
  constructor(e9, t2) {
    Fg(this, "uid", void 0), Fg(this, "_uintid", void 0), Fg(this, "_trust_in_room_", true), Fg(this, "_trust_audio_enabled_state_", true), Fg(this, "_trust_video_enabled_state_", true), Fg(this, "_trust_audio_mute_state_", true), Fg(this, "_trust_video_mute_state_", true), Fg(this, "_audio_muted_", false), Fg(this, "_video_muted_", false), Fg(this, "_audio_enabled_", true), Fg(this, "_video_enabled_", true), Fg(this, "_audio_added_", false), Fg(this, "_video_added_", false), Fg(this, "_is_pre_created", false), Fg(this, "_video_pre_subscribed", false), Fg(this, "_audio_pre_subscribed", false), Fg(this, "_trust_video_stream_added_state_", true), Fg(this, "_trust_audio_stream_added_state_", true), Fg(this, "_audioTrack", void 0), Fg(this, "_videoTrack", void 0), Fg(this, "_dataChannels", []), Fg(this, "_audioSSRC", void 0), Fg(this, "_videoSSRC", void 0), Fg(this, "_audioOrtc", void 0), Fg(this, "_videoOrtc", void 0), Fg(this, "_cname", void 0), Fg(this, "_rtxSsrcId", void 0), Fg(this, "_videoMid", void 0), Fg(this, "_audioMid", void 0), this.uid = e9, this._uintid = t2;
  }
};
var dF = function(e9) {
  return e9.SEND_ONLY = "SEND_ONLY", e9.RECEIVE_ONLY = "RECEIVE_ONLY", e9;
}({});
function lF(e9, t2) {
  var i2;
  let n2;
  switch (t2) {
    case hO.LocalAudioTrack:
      n2 = Zw.Audio;
      break;
    case hO.LocalVideoTrack:
      n2 = Dn(i2 = e9._hints).call(i2, mL.SCREEN_TRACK) ? Zw.Screen : Zw.High;
      break;
    case hO.LocalVideoLowTrack:
      n2 = Zw.Low;
  }
  return n2;
}
function uF(e9) {
  const t2 = ZP();
  if (e9.some((e10) => e10._bypassWebAudio)) throw new Cy(Ry.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
  if (!t2.webAudioMediaStreamDest) throw new Cy(Ry.NOT_SUPPORTED, "cannot publish multiple tracks because your browser does not support audio mixing");
}
function hF(e9, t2) {
  uF(e9);
  const i2 = t2 || new RM();
  return e9.forEach((e10) => i2.addAudioTrack(e10)), i2;
}
var pF;
var _F;
var EF;
var fF;
var mF;
var TF;
var SF;
var gF;
var RF;
var CF;
var IF;
var vF;
function yF(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function AF(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? yF(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : yF(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var bF = (pF = wF(dF.SEND_ONLY), _F = wF(dF.SEND_ONLY), EF = wF(), fF = wF(dF.RECEIVE_ONLY), mF = wF(dF.RECEIVE_ONLY), TF = wF(dF.RECEIVE_ONLY), SF = wF(dF.RECEIVE_ONLY), gF = wF(dF.RECEIVE_ONLY), RF = wF(dF.RECEIVE_ONLY), CF = wF(), IF = wF(dF.RECEIVE_ONLY), vF = class extends xy {
  get state() {
    return this._state;
  }
  set state(e9) {
    const t2 = this._state;
    this._state = e9, this.emit(_O.StateChange, t2, this._state);
  }
  constructor(e9, t2) {
    super(), Fg(this, "isPlanB", false), Fg(this, "store", void 0), Fg(this, "statsUploader", void 0), Fg(this, "sendConnection", void 0), Fg(this, "recvConnection", void 0), Fg(this, "localTrackMap", /* @__PURE__ */ new Map()), Fg(this, "remoteUserMap", /* @__PURE__ */ new Map()), Fg(this, "localDataChannels", []), Fg(this, "pendingLocalTracks", []), Fg(this, "pendingRemoteTracks", []), Fg(this, "statsCollector", void 0), Fg(this, "dtlsFailedCount", 0), Fg(this, "sendMutex", new NA("P2PChannel2-send-mutex")), Fg(this, "recvMutex", new NA("P2PChannel2-recv-mutex")), Fg(this, "_state", pO.Disconnected), Fg(this, "_restartStates", ["disconnected", "failed"]), Fg(this, "reconnectInterval", void 0), Fg(this, "uploadUnplinkStarted", false), Fg(this, "uploadDownlinkStarted", false), Fg(this, "uplinkStateUploadInterval", void 0), Fg(this, "downlinkStatsUploadInterval", void 0), Fg(this, "handleMuteLocalTrack", async (e10, t3, i2) => {
      const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleMuteLocalTrack");
      try {
        if (!this.sendConnection || this.state !== pO.Connected) return void i2(new Cy(Ry.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established."));
        const s2 = this.filterTobeMutedTracks(e10);
        if (0 === s2.length) return void t3();
        const a2 = s2.find((e11) => "videoLowTrack" === e11[0]);
        if (a2) {
          a2[1].track._originMediaStreamTrack.stop();
        }
        await this.sendConnection.muteLocal(s2.map((e11) => {
          let [, { id: t4 }] = e11;
          return t4;
        }));
        let c2 = false;
        var r2, o2;
        if ("video" === e10.trackMediaType) c2 = !(null === (r2 = this.localTrackMap.get(hO.LocalAudioTrack)) || void 0 === r2 || !r2.track._muted);
        else c2 = void 0 === (null === (o2 = this.localTrackMap.get(hO.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.id);
        const d2 = this.createMuteMessage(s2);
        await $y(this, _O.RequestMuteLocal, d2);
        const l2 = "video" === e10.trackMediaType ? yO.MUTE_LOCAL_VIDEO : yO.MUTE_LOCAL_AUDIO;
        await $y(this, _O.RequestP2PMuteLocal, { action: l2, message: d2, isMuteAll: c2 }), t3();
      } catch (e11) {
        i2(e11);
      } finally {
        n2();
      }
    }), Fg(this, "handleUnmuteLocalTrack", async (e10, t3, i2) => {
      const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleUnmuteLocalTrack");
      try {
        if (!this.sendConnection || this.state !== pO.Connected) return void i2(new Cy(Ry.INVALID_OPERATION, "Cannot call P2PChannel2.handleUnmuteLocalTrack before sendConnection established."));
        const r2 = this.filterTobeUnmutedTracks(e10);
        if (0 === r2.length) return void t3();
        await this.sendConnection.unmuteLocal(r2.map((e11) => {
          let [, { id: t4 }] = e11;
          return t4;
        }));
        const o2 = this.createUnmuteMessage(r2), s2 = "video" === e10.trackMediaType ? yO.UNMUTE_LOCAL_VIDEO : yO.UNMUTE_LOCAL_AUDIO;
        await $y(this, _O.RequestP2PMuteLocal, { action: s2, message: o2 }), t3();
      } catch (e11) {
        i2(e11);
      } finally {
        n2();
      }
    }), Fg(this, "handleUpdateVideoEncoder", async (e10, t3, i2) => {
      const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleSetVideoEncoder");
      try {
        const i3 = this.localTrackMap.get(hO.LocalVideoTrack);
        if (!this.sendConnection || !i3 || i3.track !== e10 || this.state !== pO.Connected) return void t3();
        const { id: r2, track: o2 } = i3;
        r2 && (await this.sendConnection.updateSendParameters(r2, o2), await this.sendConnection.updateEncoderConfig(r2, o2), this.emit(_O.UpdateVideoEncoder, o2)), t3();
      } catch (e11) {
        i2(e11);
      } finally {
        n2();
      }
    }), Fg(this, "handleUpdateVideoSendParameters", async (e10, t3, i2) => {
      const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleUpdateVideoSendParameters");
      try {
        const i3 = this.localTrackMap.get(hO.LocalVideoTrack);
        if (!this.sendConnection || !i3 || i3.track !== e10 || this.state !== pO.Connected) return void t3();
        const { id: r2, track: o2 } = i3;
        r2 && await this.sendConnection.updateSendParameters(r2, o2), t3();
      } catch (e11) {
        i2(e11);
      } finally {
        n2();
      }
    }), Fg(this, "handleReplaceTrack", async (e10, t3, i2, n2) => {
      let r2;
      fb.debug("[".concat(this.store.clientId, "] P2PChannel2 handleReplaceTrack for [track-id-").concat(e10.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (r2 = await this.sendMutex.lock("From P2PChannel2.handleReplaceTrack"));
      try {
        var o2;
        const i3 = Array.from(this.localTrackMap.entries()).find((t4) => {
          let [, { track: i4 }] = t4;
          return e10 === i4;
        });
        if (!this.sendConnection || !i3 || void 0 === i3[1].id || this.state !== pO.Connected) return void t3();
        if (await (null === (o2 = this.sendConnection) || void 0 === o2 ? void 0 : o2.replaceTrack(e10, i3[1].id)), i3[0] === hO.LocalVideoTrack && ZP().supportDualStreamEncoding) {
          const t4 = this.localTrackMap.get(hO.LocalVideoLowTrack);
          if (t4) {
            const i4 = e10._mediaStreamTrack.clone();
            t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = i4, t4.track._originMediaStreamTrack = i4, await new Gh((e11, i5) => {
              this.handleReplaceTrack(t4.track, e11, i5, true);
            });
          }
        }
        t3();
      } catch (e11) {
        i2(e11);
      } finally {
        var s2;
        null === (s2 = r2) || void 0 === s2 || s2();
      }
    }), Fg(this, "handleGetLocalVideoStats", (e10) => {
      e10(this.statsCollector.getLocalVideoTrackStats());
    }), Fg(this, "handleGetLocalAudioStats", (e10) => {
      e10(this.statsCollector.getLocalAudioTrackStats());
    }), Fg(this, "handleGetRemoteVideoStats", (e10) => this.statsCollector.getRemoteVideoTrackStats(e10.uid)[e10.uid]), Fg(this, "handleGetRemoteAudioStats", (e10) => this.statsCollector.getRemoteAudioTrackStats(e10.uid)[e10.uid]), this.store = e9, this.statsCollector = t2, this.statsCollector.addP2PChannel(this), this.statsUploader = new aF(e9), this.bindStatsUploaderEvents(), this.reconnectInterval = window.setInterval(() => {
      [this.sendConnection, this.recvConnection].forEach((e10) => {
        e10 && ("disconnected" !== e10.iceConnectionState && "failed" !== e10.iceConnectionState || this.handleDisconnect(e10.direction));
      });
    }, XA("ICE_RESTART_INTERVAL"));
  }
  async startP2PConnection(e9, t2) {
    throw new Cy(Ry.NOT_SUPPORTED, "p2p mode does not support startP2PConnection.");
  }
  async connect(e9) {
    throw new Cy(Ry.NOT_SUPPORTED, "p2p mode does not support connect.");
  }
  async startP2P(e9, t2) {
    let i2;
    try {
      if (t2) {
        this.recvConnection && (fb.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset recvConnection.")), this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection)), i2 = await this.recvMutex.lock("From P2PChannel.startP2P"), this.recvConnection = new WV(e9, this.store, Mw.RECEIVE_ONLY), this.bindConnectionEvents(this.recvConnection);
        const n2 = await this.recvConnection.establish(t2);
        return { iceParameters: n2.iceParameters, dtlsParameters: n2.dtlsParameters, sdp: n2.sdp };
      }
      {
        this.state = pO.New, this.sendConnection && (fb.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset sendConnection.")), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection)), i2 = await this.sendMutex.lock("From P2PChannel.startP2P"), this.sendConnection = new WV(e9, this.store), this.store.peerConnectionStart(), this.bindConnectionEvents(this.sendConnection);
        const t3 = await this.sendConnection.establish();
        return { iceParameters: t3.iceParameters, dtlsParameters: t3.dtlsParameters, sdp: t3.sdp };
      }
    } finally {
      i2 && i2();
    }
  }
  async p2pConnect(e9) {
    if (!this.sendConnection) throw new Cy(Ry.UNEXPECTED_ERROR, "Cannot P2PChannel2.p2pConnect before P2PChannel2.startP2PConnection .");
    this.store.peerConnectionStart(), await this.sendConnection.connect(e9), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = pO.Connected;
  }
  async addRemoteCandidate(e9, t2) {
    if (t2 === Mw.RECEIVE_ONLY) {
      if (!this.sendConnection) throw new Cy(Ry.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");
      await this.sendConnection.addRemoteCandidate(e9);
    } else {
      if (!this.recvConnection) throw new Cy(Ry.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");
      await this.recvConnection.addRemoteCandidate(e9);
    }
  }
  publish(e9, t2, i2) {
    var n2 = this;
    return YI(function* () {
      const r2 = yield qI(n2.sendMutex.lock("From P2PChannel.publish"));
      try {
        if (!n2.sendConnection || n2.state !== pO.Connected) {
          n2.throwIfTrackTypeNotMatch(e9);
          const t3 = e9.filter((e10) => -1 === n2.pendingLocalTracks.indexOf(e10));
          return void (n2.pendingLocalTracks = n2.pendingLocalTracks.concat(t3));
        }
        n2.store.pubId = n2.store.pubId + 1, rV.markPublishStart(n2.store.clientId, n2.store.pubId);
        const o2 = n2.filterTobePublishedTracks(e9, t2, i2);
        if (0 === o2.length) return void (yield qI(n2.tryToUnmuteAudio(e9)));
        o2.forEach((e10) => {
          let { track: t3, type: i3 } = e10;
          const r3 = Date.now();
          n2.store.publish(t3.getTrackId(), i3 === hO.LocalAudioTrack ? "audio" : "video", r3);
        }), n2.bindLocalTrackEvents(o2);
        const s2 = yield qI(n2.sendConnection.send(o2.map((e10) => {
          let { track: t3 } = e10;
          return t3;
        }), n2.store.codec, n2.store.audioCodec)), a2 = (yield qI(s2.next())).value, c2 = n2.createGatewayPublishMessage(o2, a2);
        try {
          yield c2;
        } catch (e10) {
          throw s2.throw(e10), (null == e10 ? void 0 : e10.code) === Ry.WS_ABORT && o2.forEach((e11) => {
            let { track: t3 } = e11;
            -1 === n2.pendingLocalTracks.indexOf(t3) && n2.pendingLocalTracks.push(t3);
          }), n2.unbindLocalTrackEvents(o2), e10;
        }
        yield qI(s2.next()), o2.forEach((e10) => {
          let { type: t3 } = e10;
          n2.statsCollector.addLocalStats(t3);
        }), n2.statsUploader.startUploadOutboundStats(), n2.assignLocalTracks(o2, a2), o2.forEach((e10) => {
          let { track: t3, type: i3 } = e10;
          const r3 = Date.now();
          n2.store.publish(t3.getTrackId(), i3 === hO.LocalAudioTrack ? "audio" : "video", void 0, r3);
        }), n2.startUploadUplinkState();
      } finally {
        r2();
      }
    })();
  }
  async unpublish(e9) {
    if (!this.sendConnection || this.state !== pO.Connected) return void (0 === e9.length ? this.pendingLocalTracks.length = 0 : this.pendingLocalTracks = this.pendingLocalTracks.filter((t3) => !Dn(e9).call(e9, t3)));
    const t2 = this.filterTobeUnpublishedTracks(e9);
    if (0 === t2.length) return;
    const i2 = t2.find((e10) => "videoLowTrack" === e10[0]);
    if (i2) {
      i2[1].track.close();
    }
    const n2 = this.createGatewayUnpublishMessage(t2);
    if (await this.sendConnection.stopSending(t2.map((e10) => {
      let [, { id: t3 }] = e10;
      return t3;
    })), this.withdrawLocalTracks(t2), this.unbindLocalTrackEvents(t2.map((e10) => {
      let [t3, { track: i3 }] = e10;
      return { type: t3, track: i3 };
    })), t2.forEach((e10) => {
      let [t3] = e10;
      this.statsCollector.removeLocalStats(t3);
    }), 0 === this.localTrackMap.size && (this.statsUploader.stopUploadOutboundStats(), this.stopUploadUplinkState()), this.sendConnection && this.state === pO.Connected) {
      if (i2) {
        i2[1].track.close();
      }
      return n2;
    }
    e9.forEach((e10) => {
      const t3 = this.pendingLocalTracks.indexOf(e10);
      -1 !== t3 && this.pendingLocalTracks.splice(t3, 1);
    });
  }
  startUploadUplinkState() {
    if (this.uploadUnplinkStarted) return;
    this.uploadUnplinkStarted = true, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval);
    const e9 = () => {
      const e10 = [], t2 = [];
      Array.from(this.localTrackMap.entries()).forEach((i2) => {
        let [n2, { track: r2, ssrcs: o2 }] = i2;
        const s2 = { stream_type: lF(r2, n2), ssrcs: o2 };
        r2._muted || !r2._enabled ? e10.push(s2) : t2.push(s2);
      }), e10.length > 0 && e10.forEach((e11) => {
        $y(this, _O.RequestMuteLocal, [e11]);
      }), t2.length > 0 && t2.forEach((e11) => {
        $y(this, _O.RequestUnmuteLocal, [e11]);
      });
    };
    e9(), this.uplinkStateUploadInterval = window.setInterval(() => {
      e9();
    }, 3e3);
  }
  stopUploadUplinkState() {
    this.uploadUnplinkStarted && (this.uploadUnplinkStarted = false, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval));
  }
  publishLowStream(e9) {
    return YI(function* () {
      throw new Cy(Ry.NOT_SUPPORTED, "p2p mode does not support publishLowStream.");
    })();
  }
  async republish() {
    this.pendingLocalTracks.length > 0 && (fb.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await Zy(this, _O.RequestRePublish, this.pendingLocalTracks), this.emit(_O.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []);
  }
  async unpublishLowStream() {
    throw new Cy(Ry.NOT_SUPPORTED, "p2p mode does not support unpublishLowStream.");
  }
  async subscribe(e9, t2, i2, n2) {
    var r2;
    if (!this.recvConnection) throw new Cy(Ry.INVALID_OPERATION, "Cannot subscribe remote user when recvConnection disconnected.");
    if (null !== (r2 = this.remoteUserMap.get(e9)) && void 0 !== r2 && r2.has(t2)) return;
    const { track: o2, mid: s2, transceiver: a2 } = await this.recvConnection.receive(t2, [{ ssrcId: i2 }], String(e9.uid), n2);
    t2 === dO.AUDIO ? (e9._audioTrack ? e9._audioTrack._updateOriginMediaStreamTrack(o2) : (e9._audioTrack = new vU(o2, e9.uid, e9._uintid, this.store), fb.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e9._audioTrack.getTrackId()))), a2 && e9._audioTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(e9, e9._audioTrack)) : (e9._videoSSRC = i2, e9._videoTrack ? e9._videoTrack._updateOriginMediaStreamTrack(o2) : (e9._videoTrack = new IU(o2, e9.uid, e9._uintid, this.store), fb.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e9._videoTrack.getTrackId()))), a2 && e9._videoTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(e9, e9._videoTrack));
    const c2 = this.remoteUserMap.get(e9);
    c2 ? c2.set(t2, s2) : this.remoteUserMap.set(e9, /* @__PURE__ */ new Map([[t2, s2]])), this.statsCollector.addRemoteStats(e9.uid), this.statsUploader.startUploadInboundStats(), this.startUploadDownlinkState();
    const d2 = this.pendingRemoteTracks.findIndex((i3) => {
      let { user: n3, kind: r3 } = i3;
      return n3.uid === e9.uid && t2 === r3;
    });
    -1 !== d2 && (this.pendingRemoteTracks.splice(d2, 1), this.emit(_O.MediaReconnectEnd, e9.uid));
  }
  async mockSubscribe(e9, t2, i2, n2) {
    if (!this.recvConnection) throw new Cy(Ry.INVALID_OPERATION, "Cannot subscribe remote user when recvConnection disconnected.");
    await this.recvConnection.mockReceive(t2, [{ ssrcId: i2 }], String(e9.uid), n2);
  }
  async unsubscribe(e9, t2, i2) {
    const n2 = this.pendingRemoteTracks.filter((i3) => {
      let { user: n3, kind: r3 } = i3;
      return void 0 !== t2 ? n3.uid === e9.uid && t2 === r3 : n3.uid === e9.uid;
    });
    if (n2.forEach((e10) => {
      const t3 = this.pendingRemoteTracks.indexOf(e10);
      this.pendingRemoteTracks.splice(t3, 1);
    }), this.recvConnection || i2 || n2.forEach((t3) => {
      let { kind: i3 } = t3;
      var n3;
      if (i3 === dO.AUDIO) null === (n3 = e9._audioTrack) || void 0 === n3 || n3._destroy(), e9._audioTrack = void 0;
      else if (i3 === dO.VIDEO) {
        var r3;
        null === (r3 = e9._videoTrack) || void 0 === r3 || r3._destroy(), e9._videoTrack = void 0;
      }
    }), !this.recvConnection) return;
    const r2 = this.filterTobeUnSubscribedTracks(e9, t2);
    0 !== r2.length && (await this.recvConnection.stopReceiving(r2.map((e10) => {
      let [, { id: t3 }] = e10;
      return t3;
    })), this.withdrawRemoteTracks(r2), 0 === this.remoteUserMap.size && (this.statsUploader.stopUploadInboundStats(), this.stopUploadDownlinkState()), r2.forEach((e10) => {
      let [t3, { kind: n3 }] = e10;
      var r3, o2;
      n3 === dO.VIDEO && t3._videoSSRC && (null === (r3 = this.recvConnection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
      if (n3 === dO.VIDEO) this.unbindRemoteTrackEvents(t3._videoTrack), i2 || (null === (o2 = t3._videoTrack) || void 0 === o2 || o2._destroy(), t3._videoTrack = void 0);
      else if (n3 === dO.AUDIO) {
        var s2;
        if (this.unbindRemoteTrackEvents(t3._audioTrack), !i2) null === (s2 = t3._audioTrack) || void 0 === s2 || s2._destroy(), t3._audioTrack = void 0;
      }
    }), r2.forEach((e10) => {
      let [, { kind: t3 }] = e10;
      $y(this, _O.RequestP2PMuteRemote, t3);
    }));
  }
  startUploadDownlinkState() {
    if (this.uploadDownlinkStarted) return;
    this.uploadDownlinkStarted = true, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval);
    const e9 = () => Array.from(this.remoteUserMap.entries()).forEach((e10) => {
      let [, t2] = e10;
      [dO.VIDEO, dO.AUDIO].forEach((e11) => {
        t2.has(e11) ? $y(this, _O.RequestP2PUnmuteRemote, e11) : $y(this, _O.RequestP2PMuteRemote, e11);
      });
    });
    e9(), this.downlinkStatsUploadInterval = window.setInterval(() => {
      e9();
    }, 3e3);
  }
  stopUploadDownlinkState() {
    this.uploadDownlinkStarted && (this.uploadDownlinkStarted = false, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval));
  }
  getAllDataChannels() {
    return this.localDataChannels;
  }
  async massSubscribe(e9) {
    throw new Cy(Ry.NOT_SUPPORTED, "p2p mode does not support massSubscribe.");
  }
  async massSubscribeNoLock(e9) {
    throw new Cy(Ry.NOT_SUPPORTED, "p2p mode does not support massSubscribeNoLock.");
  }
  async massUnsubscribe(e9) {
    throw new Cy(Ry.NOT_SUPPORTED, "p2p mode does not support massUnsubscribe.");
  }
  async massUnsubscribeNoLock(e9) {
    throw new Cy(Ry.NOT_SUPPORTED, "p2p mode does not support massUnsubscribeNoLock.");
  }
  async muteRemote(e9, t2) {
    if (!this.recvConnection) return;
    const i2 = this.remoteUserMap.get(e9);
    if (!i2) return void fb.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(e9.uid, "."));
    if (!i2.get(t2)) return void fb.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(e9.uid, " media type ").concat(t2, "."));
    const n2 = t2 === dO.VIDEO ? e9._videoSSRC : e9._audioSSRC;
    void 0 !== n2 && this.recvConnection.setStatsRemoteVideoIsReady(n2, false);
  }
  async unmuteRemote(e9, t2) {
    return this.unmuteRemoteNoLock(e9, t2);
  }
  async unmuteRemoteNoLock(e9, t2) {
    if (!this.recvConnection) return;
    const i2 = this.remoteUserMap.get(e9);
    if (!i2) return void fb.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(e9.uid, "."));
    i2.get(t2) || fb.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(e9.uid, " media type ").concat(t2, "."));
  }
  getAllTracks(e9) {
    const t2 = this.localTrackMap.get(hO.LocalAudioTrack);
    if ((null == t2 ? void 0 : t2.track) instanceof RM) {
      const i2 = t2.track;
      return Array.from(this.localTrackMap.entries()).filter((e10) => {
        let [t3] = e10;
        return t3 !== hO.LocalAudioTrack;
      }).filter((t3) => {
        let [i3] = t3;
        return !(e9 && i3 === hO.LocalVideoLowTrack);
      }).map((e10) => {
        let [, { track: t3 }] = e10;
        return t3;
      }).concat(i2.trackList);
    }
    return Array.from(this.localTrackMap.entries()).filter((t3) => {
      let [i2] = t3;
      return !(e9 && i2 === hO.LocalVideoLowTrack);
    }).map((e10) => {
      let [, { track: t3 }] = e10;
      return t3;
    });
  }
  reportPublishEvent(e9, t2, i2, n2, r2) {
    if (e9) {
      const i3 = this.localTrackMap.get(hO.LocalAudioTrack), o3 = n2 ? this.localTrackMap.get(hO.LocalVideoLowTrack) : this.localTrackMap.get(hO.LocalVideoTrack);
      vb.publish(this.store.sessionId, { eventElapse: rV.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e9, ec: t2, audioName: null == i3 ? void 0 : i3.track.getTrackLabel(), videoName: null == o3 ? void 0 : o3.track.getTrackLabel(), screenshare: -1 !== (null == o3 ? void 0 : o3.track._hints.indexOf(mL.SCREEN_TRACK)), audio: !!i3, video: !!o3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
    } else {
      var o2;
      i2 || (i2 = []);
      const s2 = i2.find((e10) => e10 instanceof TM), a2 = n2 ? null === (o2 = this.localTrackMap.get(hO.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.track : i2.find((e10) => e10 instanceof aU);
      vb.publish(this.store.sessionId, { eventElapse: rV.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e9, ec: t2, audioName: null == s2 ? void 0 : s2.getTrackLabel(), videoName: null == a2 ? void 0 : a2.getTrackLabel(), screenshare: -1 !== (null == a2 ? void 0 : a2._hints.indexOf(mL.SCREEN_TRACK)), audio: !!s2, video: !!a2, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
    }
  }
  reportSubscribeEvent(e9, t2, i2, n2) {
    const r2 = n2 === dO.VIDEO ? i2._videoSSRC : i2._audioSSRC;
    r2 && vb.subscribe(this.store.sessionId, { succ: e9, ec: t2, video: n2 === dO.VIDEO, audio: n2 === dO.AUDIO, peerid: i2.uid, subscribeRequestid: n2 === dO.VIDEO ? i2._videoSSRC : i2._audioSSRC, p2pid: this.store.p2pId, eventElapse: rV.measureFromSubscribeStart(this.store.clientId, r2) });
  }
  reset() {
    fb.debug("[".concat(this.store.clientId, "] P2PChannel2.reset")), this.sendMutex = new NA("P2PChannel2-send-mutex"), this.sendMutex = new NA("P2PChannel2-recv-mutex"), this.sendConnection && (this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0), this.recvConnection && (this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
    const e9 = this.localTrackMap.get(hO.LocalAudioTrack);
    if ((null == e9 ? void 0 : e9.track) instanceof RM) {
      if (e9.track.trackList.length > 0) {
        const t2 = e9.track;
        e9.track.trackList.forEach((e10) => {
          t2.removeAudioTrack(e10);
        });
      }
      e9.track.close();
    }
    this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.reconnectInterval && (window.clearInterval(this.reconnectInterval), this.reconnectInterval = void 0), this.state = pO.Disconnected;
  }
  getStats(e9) {
    var t2, i2;
    return e9 ? null === (i2 = this.recvConnection) || void 0 === i2 ? void 0 : i2.getStats() : null === (t2 = this.sendConnection) || void 0 === t2 ? void 0 : t2.getStats();
  }
  getRemoteVideoIsReady(e9) {
    var t2;
    return (null === (t2 = this.recvConnection) || void 0 === t2 ? void 0 : t2.getRemoteVideoIsReady(e9)) || false;
  }
  getLocalAudioVolume() {
    const e9 = this.localTrackMap.get(hO.LocalAudioTrack);
    if (e9) return e9.track.getVolumeLevel();
  }
  getLocalVideoSize() {
    const e9 = this.localTrackMap.get(hO.LocalVideoTrack);
    if (e9) return { width: e9.track.videoWidth || 0, height: e9.track.videoHeight || 0 };
  }
  getEncoderConfig(e9) {
    const t2 = this.localTrackMap.get(e9);
    return t2 && t2.track instanceof aU || t2 && t2.track instanceof TM ? t2.track._encoderConfig : void 0;
  }
  getLocalMedia(e9) {
    return this.localTrackMap.get(e9);
  }
  hasLocalMedia() {
    return this.localTrackMap.size > 0;
  }
  hasRemoteMedia(e9, t2) {
    if (!e9) return this.remoteUserMap.size > 0;
    const i2 = this.remoteUserMap.get(e9);
    return !!i2 && (!t2 || i2.has(t2));
  }
  async hasRemoteMediaWithLock(e9, t2) {
    if (!e9) return this.remoteUserMap.size > 0;
    const i2 = this.remoteUserMap.get(e9);
    return !!i2 && (!t2 || i2.has(t2));
  }
  getRemoteMedia(e9) {
    var t2;
    const i2 = Array.from(d_(t2 = this.remoteUserMap).call(t2)).find((t3) => t3.uid === e9);
    return i2 ? { audioTrack: i2.audioTrack, audioSSRC: i2._audioSSRC, videoTrack: i2.videoTrack, videoSSRC: i2._videoSSRC } : {};
  }
  getAudioLevels() {
    let e9 = Array.from(this.remoteUserMap.entries()).map((e10) => {
      let [t3] = e10;
      return { uid: t3.uid, level: t3.audioTrack ? 100 * t3.audioTrack._source.getAccurateVolumeLevel() : 0 };
    });
    const t2 = this.localTrackMap.get(hO.LocalAudioTrack);
    return t2 && e9.push({ level: 100 * t2.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e9 = aE(e9).call(e9, (e10, t3) => e10.level - t3.level), e9;
  }
  async disconnectForReconnect() {
    this.sendConnection && this.recvConnection && (fb.debug("[".concat(this.store.clientId, "] P2PChannel2.disconnectForReconnect closing P2PConnection")), this.state = pO.Reconnecting, XA("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e9) => {
      let [t2] = e9;
      var i2;
      t2._videoTrack && t2._videoTrack._player && (null === (i2 = t2._videoTrack._player.getVideoElement()) || void 0 === i2 || i2.pause(), t2._videoTrack._player.isKeepLastFrame = true, t2._videoTrack._originMediaStreamTrack.stop());
    }), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0, this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0, 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e9) => {
      var t2;
      let [i2, { track: n2 }] = e9;
      switch (i2) {
        case hO.LocalVideoTrack:
          Dn(t2 = n2._hints).call(t2, mL.LOW_STREAM) ? n2.close() : this.pendingLocalTracks.push(n2);
          break;
        case hO.LocalAudioTrack:
          n2 instanceof RM ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n2.trackList) : this.pendingLocalTracks.push(n2);
        case hO.LocalVideoLowTrack:
      }
    }), this.emit(_O.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e9) => {
      let [t2, i2] = e9;
      Array.from(d_(i2).call(i2)).forEach((e10) => {
        this.setPendingRemoteMedia(t2, e10);
      }), this.emit(_O.MediaReconnectStart, t2.uid);
    }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), fb.debug("[".concat(this.store.clientId, "] P2PChannel2 disconnected, waiting to reconnect.")));
  }
  hasPendingRemoteMedia(e9, t2) {
    for (const i2 of this.pendingRemoteTracks) {
      const { user: n2, kind: r2 } = i2;
      if ((e9 instanceof cF ? e9.uid : e9) === n2.uid && t2 === r2) return true;
    }
    return false;
  }
  setPendingRemoteMedia(e9, t2) {
    this.hasPendingRemoteMedia(e9, t2) || this.pendingRemoteTracks.push({ user: e9, kind: t2 });
  }
  async restartICE(e9, t2) {
    let i2, n2;
    if (e9 === Mw.SEND_ONLY) {
      if (!this.sendConnection) throw new Cy(Ry.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established.");
      i2 = await this.sendMutex.lock("From P2PChannel.restartICE"), n2 = this.sendConnection;
    } else {
      if (!this.recvConnection) throw new Cy(Ry.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before recvConnection established.");
      i2 = await this.recvMutex.lock("From P2PChannel.restartICE"), n2 = this.recvConnection;
    }
    try {
      if (t2) {
        const e10 = await n2.restartICE(t2);
        return n2.isInRestartIce = false, e10;
      }
      {
        const e10 = await n2.restartICE();
        if (e10) {
          const t3 = await Zy(this, _O.RequestP2PRestartICE, { direction: Mw.RECEIVE_ONLY, iceParameter: e10 });
          await n2.restartICE(t3), n2.isInRestartIce = false;
        }
      }
    } finally {
      i2();
    }
  }
  getUplinkNetworkQuality() {
    if (!this.sendConnection) return 0;
    const e9 = this.sendConnection.getStats(), t2 = this.localTrackMap.get(hO.LocalVideoTrack), i2 = this.localTrackMap.get(hO.LocalAudioTrack), n2 = e9.videoSend.find((e10) => {
      var i3;
      return e10.ssrc === (null == t2 || null === (i3 = t2.ssrcs) || void 0 === i3 ? void 0 : i3[0].ssrcId);
    }), r2 = e9.audioSend.find((e10) => {
      var t3;
      return e10.ssrc === (null == i2 || null === (t3 = i2.ssrcs) || void 0 === t3 ? void 0 : t3[0].ssrcId);
    });
    if (!n2 || !r2) return 1;
    const o2 = eA(this, _O.NeedSignalRTT), s2 = n2 ? n2.rttMs : void 0, a2 = r2 ? r2.rttMs : void 0, c2 = s2 && a2 ? (s2 + a2) / 2 : s2 || a2, d2 = (c2 && o2 ? (c2 + o2) / 2 : c2 || o2) || 0, l2 = 100 * e9.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, u2 = l2 < 0.17 ? 1 : l2 < 0.36 ? 2 : l2 < 0.59 ? 3 : l2 < 0.1 ? 4 : 5, h2 = null == t2 ? void 0 : t2.track;
    if (h2 && h2._encoderConfig && -1 === h2._hints.indexOf(mL.SCREEN_TRACK)) {
      const t3 = h2._encoderConfig.bitrateMax, i3 = e9.bitrate.actualEncoded;
      if (t3 && i3) {
        const e10 = (1e3 * t3 - i3) / (1e3 * t3);
        return bb[e10 < 0.15 ? 0 : e10 < 0.3 ? 1 : e10 < 0.45 ? 2 : e10 < 0.6 ? 3 : 4][u2];
      }
    }
    return u2;
  }
  getDownlinkNetworkQuality() {
    if (!this.recvConnection) return 0;
    const e9 = this.recvConnection.getStats();
    let t2 = 0;
    return Array.from(this.remoteUserMap.entries()).forEach((i2) => {
      let [n2] = i2;
      const r2 = n2._audioSSRC, o2 = n2._videoSSRC, s2 = e9.audioRecv.find((e10) => e10.ssrc === r2), a2 = e9.videoRecv.find((e10) => e10.ssrc === o2);
      if (!s2 && !a2) return void (t2 += 1);
      const c2 = eA(this, _O.NeedSignalRTT), d2 = e9.rtt, l2 = (d2 && c2 ? (d2 + c2) / 2 : d2 || c2) || 0, u2 = s2 ? s2.jitterMs : void 0, h2 = e9.recvPacketLossRate;
      let p2 = 0.7 * h2 * 100 / 50 + 0.3 * l2 / 1500;
      u2 && (p2 = 0.6 * h2 * 100 / 50 + 0.2 * l2 / 1500 + 0.2 * u2 / 400);
      t2 += p2 < 0.1 ? 1 : p2 < 0.17 ? 2 : p2 < 0.36 ? 3 : p2 < 0.59 ? 4 : 5;
    }), this.remoteUserMap.size > 0 ? Math.round(t2 / this.remoteUserMap.size) : t2;
  }
  async muteLocalTrack(e9) {
    return new Gh((t2, i2) => {
      this.handleMuteLocalTrack(e9, t2, i2);
    });
  }
  filterTobePublishedTracks(e9, t2, i2) {
    const n2 = [], r2 = ZP(), o2 = this.getAllTracks();
    e9 = rA(e9 = e9.filter((e10) => -1 === o2.indexOf(e10)));
    let s2 = false, a2 = false;
    for (const o3 of e9) {
      if (o3 instanceof aU && (this.localTrackMap.has(hO.LocalVideoTrack) || s2 ? new Cy(Ry.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n2.push({ track: o3, type: hO.LocalVideoTrack }), s2 = true), t2)) {
        const e10 = this.getLowVideoTrack(o3, i2);
        n2.push({ track: e10, type: hO.LocalVideoLowTrack });
      }
      if (o3 instanceof TM) {
        const e10 = this.localTrackMap.get(hO.LocalAudioTrack);
        if (e10) {
          if (!(e10.track instanceof RM)) throw new Cy(Ry.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
          if (o3._bypassWebAudio) throw new Cy(Ry.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
          e10.track.addAudioTrack(o3), this.bindLocalAudioTrackEvents(o3, true);
        } else if (a2) {
          const e11 = n2.find((e12) => {
            let { type: t3 } = e12;
            return t3 === hO.LocalAudioTrack;
          });
          if (!(e11.track instanceof RM)) throw new Cy(Ry.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
          if (o3._bypassWebAudio) throw new Cy(Ry.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
          e11.track.addAudioTrack(o3);
        } else {
          if (!r2.webAudioMediaStreamDest || o3 instanceof RM || o3._bypassWebAudio) n2.push({ track: o3, type: hO.LocalAudioTrack });
          else {
            const e11 = new RM();
            e11.addAudioTrack(o3), n2.push({ track: e11, type: hO.LocalAudioTrack });
          }
          a2 = true;
        }
      }
    }
    return n2;
  }
  filterTobeUnpublishedTracks(e9) {
    const t2 = [], i2 = this.getAllTracks();
    e9 = rA(e9 = e9.filter((e10) => -1 !== i2.indexOf(e10)));
    for (const i3 of e9) {
      if (i3 instanceof TM) {
        const e10 = this.localTrackMap.get(hO.LocalAudioTrack);
        if (!e10) continue;
        e10.track instanceof RM ? (e10.track.removeAudioTrack(i3), this.unbindLocalAudioTrackEvents(i3), 0 === e10.track.trackList.length && (t2.push([hO.LocalAudioTrack, e10]), e10.track.close())) : t2.push([hO.LocalAudioTrack, e10]);
      }
      if (i3 instanceof aU) {
        const e10 = this.localTrackMap.get(hO.LocalVideoTrack);
        if (!e10) continue;
        t2.push([hO.LocalVideoTrack, e10]);
        const i4 = this.localTrackMap.get(hO.LocalVideoLowTrack);
        i4 && t2.push([hO.LocalVideoLowTrack, i4]);
      }
    }
    return t2;
  }
  bindLocalTrackEvents(e9) {
    e9.forEach((e10) => {
      let { track: t2, type: i2 } = e10;
      switch (i2) {
        case hO.LocalVideoTrack:
          t2.addListener(fL.GET_STATS, this.handleGetLocalVideoStats), t2.addListener(fL.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.addListener(fL.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.addListener(fL.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.addListener(fL.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t2.addListener(fL.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.addListener(fL.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.addListener(fL.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          break;
        case hO.LocalAudioTrack:
          this.bindLocalAudioTrackEvents(t2);
        case hO.LocalVideoLowTrack:
      }
    });
  }
  bindLocalAudioTrackEvents(e9, t2) {
    e9 instanceof RM ? e9.trackList.forEach((e10) => {
      e10.addListener(fL.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e10.addListener(fL.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e10.addListener(fL.GET_STATS, this.handleGetLocalAudioStats), e10.addListener(fL.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e10.addListener(fL.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
    }) : (e9.addListener(fL.GET_STATS, this.handleGetLocalAudioStats), e9.addListener(fL.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e9.addListener(fL.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e9.addListener(fL.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e9.addListener(fL.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t2 || e9.addListener(fL.NEED_REPLACE_TRACK, this.handleReplaceTrack));
  }
  unbindLocalTrackEvents(e9) {
    e9 || (e9 = Array.from(this.localTrackMap.entries()).map((e10) => {
      let [t2, { track: i2 }] = e10;
      return { track: i2, type: t2 };
    })), e9.forEach((e10) => {
      let { track: t2, type: i2 } = e10;
      switch (i2) {
        case hO.LocalVideoTrack:
          t2.off(fL.GET_STATS, this.handleGetLocalVideoStats), t2.off(fL.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.off(fL.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.off(fL.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.off(fL.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t2.off(fL.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.off(fL.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.off(fL.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          break;
        case hO.LocalAudioTrack:
          this.unbindLocalAudioTrackEvents(t2);
        case hO.LocalVideoLowTrack:
      }
    });
  }
  unbindLocalAudioTrackEvents(e9) {
    e9 instanceof RM ? e9.trackList.forEach((e10) => {
      e10.off(fL.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e10.off(fL.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e10.off(fL.GET_STATS, this.handleGetLocalAudioStats), e10.off(fL.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e10.off(fL.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
    }) : (e9.off(fL.GET_STATS, this.handleGetLocalAudioStats), e9.off(fL.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e9.off(fL.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e9.off(fL.NEED_REPLACE_TRACK, this.handleReplaceTrack), e9.off(fL.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e9.off(fL.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
  }
  bindRemoteTrackEvents(e9, t2) {
    t2 instanceof IU && t2.addListener(fL.GET_STATS, (t3) => {
      t3(this.handleGetRemoteVideoStats(e9));
    }), t2 instanceof vU && t2.addListener(fL.GET_STATS, (t3) => {
      t3(this.handleGetRemoteAudioStats(e9));
    });
  }
  unbindRemoteTrackEvents(e9) {
    e9 && e9.removeAllListeners(fL.GET_STATS);
  }
  unbindAllRemoteTrackEvents() {
    Array.from(this.remoteUserMap.entries()).forEach((e9) => {
      let [t2, i2] = e9;
      i2.has(dO.AUDIO) && this.unbindRemoteTrackEvents(t2._audioTrack), i2.has(dO.VIDEO) && this.unbindRemoteTrackEvents(t2._videoTrack);
    });
  }
  createGatewayPublishMessage(e9, t2) {
    return e9.map((e10, i2) => {
      var n2;
      let r2, { track: o2, type: s2 } = e10;
      switch (s2) {
        case hO.LocalAudioTrack:
          r2 = Zw.Audio;
          break;
        case hO.LocalVideoTrack:
          r2 = Dn(n2 = o2._hints).call(n2, mL.SCREEN_TRACK) ? Zw.Screen : Zw.High;
          break;
        case hO.LocalVideoLowTrack:
          r2 = Zw.Low;
      }
      return { kind: s2 === hO.LocalAudioTrack ? dO.AUDIO : dO.VIDEO, stream_type: r2, mid: t2[i2].id, ssrcs: t2[i2].localSSRC, isMuted: o2.muted || !o2.enabled };
    });
  }
  createGatewayUnpublishMessage(e9) {
    return e9.map((e10) => {
      var t2;
      let i2, [n2, { track: r2, ssrcs: o2, id: s2 }] = e10;
      switch (n2) {
        case hO.LocalVideoTrack:
          i2 = Dn(t2 = r2._hints).call(t2, mL.SCREEN_TRACK) ? Zw.Screen : Zw.High;
          break;
        case hO.LocalAudioTrack:
          i2 = Zw.Audio;
          break;
        case hO.LocalVideoLowTrack:
          i2 = Zw.Low;
      }
      return { stream_type: i2, ssrcs: o2, mid: s2 };
    });
  }
  assignLocalTracks(e9, t2) {
    e9.forEach((e10, i2) => {
      let { track: n2, type: r2 } = e10;
      this.localTrackMap.set(r2, { track: n2, id: t2[i2].id, ssrcs: t2[i2].localSSRC });
    });
  }
  withdrawLocalTracks(e9) {
    e9.forEach((e10) => {
      let [t2] = e10;
      this.localTrackMap.delete(t2);
    });
  }
  bindConnectionEvents(e9) {
    e9.onConnectionStateChange = async (t2) => {
      var i2;
      fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: ").concat(e9.name, ".onConnectionStateChange(").concat(t2, ")")), this.emit(_O.PeerConnectionStateChange, t2), "connected" !== t2 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t2 && (e9.isInRestartIce = false), Dn(i2 = this._restartStates).call(i2, t2) && !e9.isInRestartIce && ("disconnected" === t2 && await mA(800), "disconnected" !== e9.iceConnectionState && "failed" !== e9.iceConnectionState || this.handleDisconnect(e9.direction));
    }, e9.onICEConnectionStateChange = (e10) => {
      "connected" !== e10 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e10, ")")), vb.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e10, tag: jy.TRACER }).onSuccess(), this.emit(_O.IceConnectionStateChange, e10);
    }, e9.onICETransportStateChange = (e10) => {
      fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e10, ")"));
    }, e9.onDTLSTransportStateChange = (e10) => {
      fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e10, ")"));
    }, e9.onDTLSTransportError = (e10) => {
      fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e10, ")"));
    }, e9.onFirstAudioDecoded = (e10) => {
      var t2;
      const i2 = Array.from(d_(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e10);
      var n2;
      i2 && (this.store.subscribe(i2.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n2 = i2.audioTrack) || void 0 === n2 || n2.emit(IL.FIRST_FRAME_DECODED), vb.firstRemoteFrame(this.store.sessionId, gb.FIRST_AUDIO_DECODE, Rb.FIRST_AUDIO_DECODE, { peer: i2._uintid, subscribeElapse: rV.measureFromSubscribeStart(this.store.clientId, e10), subscribeRequestid: e10, p2pid: this.store.p2pId }));
    }, e9.onFirstAudioReceived = (e10) => {
      var t2;
      const i2 = Array.from(d_(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e10);
      i2 && vb.firstRemoteFrame(this.store.sessionId, gb.FIRST_AUDIO_RECEIVED, Rb.FIRST_AUDIO_RECEIVED, { peer: i2._uintid, subscribeElapse: rV.measureFromSubscribeStart(this.store.clientId, e10), subscribeRequestid: e10, p2pid: this.store.p2pId });
    }, e9.onFirstVideoDecoded = (e10, t2, i2) => {
      this.reportVideoFirstFrameDecoded(e10, t2, i2);
    }, e9.onFirstVideoReceived = (e10) => {
      var t2;
      const i2 = Array.from(d_(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._videoSSRC === e10);
      i2 && vb.firstRemoteFrame(this.store.sessionId, gb.FIRST_VIDEO_RECEIVED, Rb.FIRST_VIDEO_RECEIVED, { peer: i2._uintid, subscribeElapse: rV.measureFromSubscribeStart(this.store.clientId, e10), subscribeRequestid: e10, p2pid: this.store.p2pId });
    }, e9.onSelectedLocalCandidateChanged = (e10, t2) => {
      const i2 = "relay" === e10.candidateType, n2 = "relay" === t2.candidateType;
      "unknown" !== t2.candidateType && i2 === n2 || this.emit(_O.ConnectionTypeChange, i2), fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(nN(t2)), " -> ").concat(JSON.stringify(nN(e10)), ")"));
    }, e9.onSelectedRemoteCandidateChanged = (e10, t2) => {
      fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(nN(t2)), " -> ").concat(JSON.stringify(nN(e10)), ")"));
    }, e9.onFirstVideoDecodedTimeout = (e10) => {
      this.reportVideoFirstFrameDecoded(e10, void 0, void 0, true);
    }, e9.onLocalCandidate = (t2) => {
      this.emit(_O.LocalCandidate, { candidate: t2, direction: e9.direction });
    };
  }
  unbindConnectionEvents(e9) {
    e9.onConnectionStateChange = void 0, e9.onICEConnectionStateChange = void 0, e9.onICETransportStateChange = void 0, e9.onDTLSTransportStateChange = void 0, e9.onDTLSTransportError = void 0, e9.onFirstAudioDecoded = void 0, e9.onFirstAudioReceived = void 0, e9.onFirstVideoDecoded = void 0, e9.onFirstVideoReceived = void 0, e9.onSelectedLocalCandidateChanged = void 0, e9.onSelectedRemoteCandidateChanged = void 0, e9.onFirstVideoDecodedTimeout = void 0, e9.onLocalCandidate = void 0;
  }
  async handleDisconnect(e9) {
    const t2 = e9 === Mw.SEND_ONLY ? this.sendConnection : this.recvConnection;
    t2 && !t2.isInRestartIce && (t2.isInRestartIce = true, fb.debug("[".concat(this.store.clientId, "] [P2PChannel-").concat(t2.name, "] start use restartICE")), e9 === Mw.SEND_ONLY ? this.restartICE(e9) : Zy(this, _O.RequestP2PRestartICE, { direction: Mw.SEND_ONLY }));
  }
  filterTobeMutedTracks(e9) {
    const t2 = [];
    if (-1 === this.getAllTracks().indexOf(e9)) return t2;
    const i2 = this.localTrackMap.get(hO.LocalAudioTrack);
    if (e9 instanceof TM && (null == i2 ? void 0 : i2.track) instanceof RM) return i2.track.isActive || t2.push([hO.LocalAudioTrack, i2]), t2;
    const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
      let [, { track: i3 }] = t3;
      return e9 === i3;
    });
    if (n2 && (t2.push(n2), n2[0] === hO.LocalVideoTrack)) {
      const e10 = this.localTrackMap.get(hO.LocalVideoLowTrack);
      e10 && t2.push([hO.LocalVideoLowTrack, e10]);
    }
    return t2;
  }
  filterTobeUnmutedTracks(e9) {
    const t2 = [], i2 = this.localTrackMap.get(hO.LocalAudioTrack);
    if (e9 instanceof TM && (null == i2 ? void 0 : i2.track) instanceof RM) return i2.track.isActive && t2.push([hO.LocalAudioTrack, i2]), t2;
    const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
      let [, { track: i3 }] = t3;
      return e9 === i3;
    });
    if (n2) if (n2[0] === hO.LocalVideoTrack) {
      t2.push(n2);
      const e10 = this.localTrackMap.get(hO.LocalVideoLowTrack);
      e10 && t2.push([hO.LocalVideoLowTrack, e10]);
    } else t2.push(n2);
    return t2;
  }
  createMuteMessage(e9) {
    return e9.map((e10) => {
      var t2;
      let i2, [n2, { track: r2, ssrcs: o2, id: s2 }] = e10;
      switch (n2) {
        case hO.LocalAudioTrack:
          i2 = Zw.Audio;
          break;
        case hO.LocalVideoTrack:
          i2 = Dn(t2 = r2._hints).call(t2, mL.SCREEN_TRACK) ? Zw.Screen : Zw.High;
          break;
        case hO.LocalVideoLowTrack:
          i2 = Zw.Low;
      }
      return { stream_type: i2, ssrcs: o2, mid: s2 };
    });
  }
  createUnmuteMessage(e9) {
    return e9.map((e10) => {
      var t2;
      let i2, [n2, { track: r2, ssrcs: o2, id: s2 }] = e10;
      switch (n2) {
        case hO.LocalAudioTrack:
          i2 = Zw.Audio;
          break;
        case hO.LocalVideoTrack:
          i2 = Dn(t2 = r2._hints).call(t2, mL.SCREEN_TRACK) ? Zw.Screen : Zw.High;
          break;
        case hO.LocalVideoLowTrack:
          i2 = Zw.Low;
      }
      return { stream_type: i2, ssrcs: o2, mid: s2 };
    });
  }
  filterTobeUnSubscribedTracks(e9, t2) {
    const i2 = [], n2 = this.remoteUserMap.get(e9);
    if (!n2) return i2;
    if (t2) {
      const r2 = n2.get(t2);
      if (!r2) return i2;
      i2.push([e9, { kind: t2, id: r2 }]);
    } else Array.from(n2.entries()).forEach((t3) => {
      let [n3, r2] = t3;
      i2.push([e9, { kind: n3, id: r2 }]);
    });
    return i2;
  }
  createUnsubscribeMessage(e9) {
    const t2 = [];
    return e9.forEach((e10) => {
      let [i2, { kind: n2, id: r2 }] = e10;
      switch (n2) {
        case dO.VIDEO:
          return void (i2._videoSSRC && t2.push({ stream_type: dO.VIDEO, ssrcId: i2._videoSSRC }));
        case dO.AUDIO:
          return void (i2._audioSSRC && t2.push({ stream_type: dO.AUDIO, ssrcId: i2._audioSSRC }));
      }
    }), t2;
  }
  withdrawRemoteTracks(e9) {
    e9.forEach((e10) => {
      let [t2, { kind: i2 }] = e10;
      const n2 = this.remoteUserMap.get(t2);
      n2 && (n2.delete(i2), 0 === Array.from(n2.entries()).length && this.remoteUserMap.delete(t2));
    });
  }
  async updateBitrateLimit(e9) {
    const t2 = this.localTrackMap.get(hO.LocalVideoTrack), i2 = this.localTrackMap.get(hO.LocalVideoLowTrack);
    t2 && await t2.track.setBitrateLimit(e9.uplink), i2 && e9.low_stream_uplink && await i2.track.setBitrateLimit({ max_bitrate: e9.low_stream_uplink.bitrate, min_bitrate: e9.low_stream_uplink.bitrate || 0 });
  }
  isP2PDisconnected() {
    if (this.sendConnection && this.recvConnection) {
      const e9 = this.sendConnection.peerConnectionState, t2 = this.recvConnection.peerConnectionState;
      return "connected" !== e9 && "connected" !== t2;
    }
    return true;
  }
  async tryToUnmuteAudio(e9) {
    for (let t2 = 0; t2 < e9.length; t2++) if (e9[t2] instanceof TM) {
      const i2 = this.filterTobeUnmutedTracks(e9[t2]);
      if (0 === i2.length) continue;
      const n2 = this.createUnmuteMessage(i2);
      return void await $y(this, _O.RequestUnmuteLocal, n2);
    }
  }
  bindStatsUploaderEvents() {
    this.statsUploader.requestStats = (e9) => this.getStats(e9), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()).filter((e9) => {
      let [, { ssrcs: t2 }] = e9;
      return !!t2;
    }), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e9) => {
      var t2;
      return !(null === (t2 = this.recvConnection) || void 0 === t2 || !t2.getRemoteVideoIsReady(e9));
    }, this.statsUploader.requestUpload = (e9, t2) => this.emit(_O.RequestUpload, e9, t2), this.statsUploader.requestUploadStats = (e9) => this.emit(_O.RequestUploadStats, e9), this.statsUploader.requestAllTracks = () => this.getAllTracks();
  }
  unbindStatsUploaderEvents() {
    this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
  }
  async requestReconnect() {
    this.dtlsFailedCount += 1, await mA(LA(this.dtlsFailedCount, PA)), this.emit(_O.RequestReconnect);
  }
  async reconnectP2P() {
  }
  canPublishLowStream() {
    return this.localTrackMap.has(hO.LocalVideoTrack) || this.pendingLocalTracks.some((e9) => e9 instanceof aU);
  }
  throwIfTrackTypeNotMatch(e9) {
    if (e9.filter((e10) => e10 instanceof aU).length > 1) throw new Cy(Ry.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
    if (e9.filter((e10) => e10 instanceof TM).length > 1 && (e9.some((e10) => e10 instanceof TM && e10._bypassWebAudio) || !ZP().webAudioMediaStreamDest)) throw new Cy(Ry.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
    for (const t2 of e9) {
      if (t2 instanceof aU && this.pendingLocalTracks.some((e10) => e10 instanceof aU)) throw new Cy(Ry.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
      if (t2 instanceof TM && this.pendingLocalTracks.some((e10) => e10 instanceof TM) && (!ZP().webAudioMediaStreamDest || t2._bypassWebAudio || this.pendingLocalTracks.some((e10) => e10 instanceof TM && e10._bypassWebAudio))) throw new Cy(Ry.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
    }
  }
  getLowVideoTrack(e9, t2) {
    const i2 = !XA("DISABLE_DUAL_STREAM_USE_ENCODING") && ZP().supportDualStreamEncoding, n2 = AF(AF({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t2);
    let r2;
    r2 = i2 ? e9._mediaStreamTrack.clone() : KV(e9, n2);
    const o2 = TA(8, "track-low-"), s2 = new aU(r2, AF(AF({}, i2 && { scaleResolutionDownBy: iN(n2, e9) }), {}, { frameRate: n2.framerate, bitrateMax: n2.bitrate, bitrateMin: n2.bitrate }), void 0, void 0, o2);
    return s2.on(RL.TRANSCEIVER_UPDATED, (t3) => {
      e9._updateRtpTransceiver(t3, TL.LOW_STREAM);
    }), s2._hints.push(mL.LOW_STREAM), e9.addListener(fL.NEED_CLOSE, () => {
      s2.close();
    }), s2;
  }
  async globalLock() {
    return this.recvMutex.lock("From P2PChannel2.globalLock");
  }
  reportVideoFirstFrameDecoded(e9, t2, i2, n2) {
    var r2;
    const o2 = Array.from(d_(r2 = this.remoteUserMap).call(r2)).find((t3) => t3._videoSSRC === e9);
    if (o2) {
      n2 || this.store.subscribe(o2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
      const r3 = this.store.keyMetrics, s2 = r3.subscribe.find((e10) => e10.userId === o2.uid && "video" === e10.type);
      vb.firstRemoteVideoDecode(this.store.sessionId, gb.FIRST_VIDEO_DECODE, Rb.FIRST_VIDEO_DECODE, { peer: o2._uintid, videowidth: t2, videoheight: i2, subscribeElapse: rV.measureFromSubscribeStart(this.store.clientId, e9), subscribeRequestid: e9, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == s2 ? void 0 : s2.subscribeEnd) || 0, subscriberStart: (null == s2 ? void 0 : s2.subscribeStart) || 0, videoAddNotify: (null == s2 ? void 0 : s2.streamAdded) || 0, state: n2 ? 1 : 0 });
    }
  }
  async remoteMediaSsrcChanged(e9, t2, i2) {
    if (!this.recvConnection) return false;
    const n2 = this.remoteUserMap.get(e9);
    if (!n2) return false;
    const r2 = n2.get(t2);
    if (!r2) return false;
    const o2 = await this.recvConnection.getRemoteSSRC(r2);
    return void 0 !== o2 && o2 !== i2;
  }
  isPreSubScribe(e9) {
    return false;
  }
  async publishDataChannel(e9) {
    throw new Cy(Ry.NOT_SUPPORTED);
  }
  async unpublishDataChannel(e9) {
    throw new Cy(Ry.NOT_SUPPORTED);
  }
  async subscribeDataChannel(e9, t2) {
    throw new Cy(Ry.NOT_SUPPORTED);
  }
  async unsubscribeDataChannel(e9, t2) {
    throw new Cy(Ry.NOT_SUPPORTED);
  }
  hasPendingRemoteDataChannel(e9, t2) {
    throw new Cy(Ry.NOT_SUPPORTED);
  }
  setPendingRemoteDataChannel(e9, t2) {
    throw new Cy(Ry.NOT_SUPPORTED);
  }
  async preConnect(e9) {
    throw new Cy(Ry.NOT_SUPPORTED);
  }
  getEstablishParams() {
    throw new Cy(Ry.NOT_SUPPORTED);
  }
  async reSubscribe(e9) {
    throw new Cy(Ry.NOT_SUPPORTED);
  }
  async updateVideoStreamParameter(e9, t2) {
    throw new Cy(Ry.NOT_SUPPORTED);
  }
  unbindRtpTransceiver() {
    0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach((e9) => {
      let [t2, { track: i2 }] = e9;
      t2 === hO.LocalVideoLowTrack ? i2._updateRtpTransceiver(void 0, TL.LOW_STREAM) : i2._updateRtpTransceiver(void 0);
    });
  }
}, Cw(vF.prototype, "p2pConnect", [pF], Object.getOwnPropertyDescriptor(vF.prototype, "p2pConnect"), vF.prototype), Cw(vF.prototype, "unpublish", [_F], Object.getOwnPropertyDescriptor(vF.prototype, "unpublish"), vF.prototype), Cw(vF.prototype, "unpublishLowStream", [EF], Object.getOwnPropertyDescriptor(vF.prototype, "unpublishLowStream"), vF.prototype), Cw(vF.prototype, "subscribe", [fF], Object.getOwnPropertyDescriptor(vF.prototype, "subscribe"), vF.prototype), Cw(vF.prototype, "mockSubscribe", [mF], Object.getOwnPropertyDescriptor(vF.prototype, "mockSubscribe"), vF.prototype), Cw(vF.prototype, "unsubscribe", [TF], Object.getOwnPropertyDescriptor(vF.prototype, "unsubscribe"), vF.prototype), Cw(vF.prototype, "muteRemote", [SF], Object.getOwnPropertyDescriptor(vF.prototype, "muteRemote"), vF.prototype), Cw(vF.prototype, "unmuteRemote", [gF], Object.getOwnPropertyDescriptor(vF.prototype, "unmuteRemote"), vF.prototype), Cw(vF.prototype, "hasRemoteMediaWithLock", [RF], Object.getOwnPropertyDescriptor(vF.prototype, "hasRemoteMediaWithLock"), vF.prototype), Cw(vF.prototype, "disconnectForReconnect", [CF], Object.getOwnPropertyDescriptor(vF.prototype, "disconnectForReconnect"), vF.prototype), Cw(vF.prototype, "remoteMediaSsrcChanged", [IF], Object.getOwnPropertyDescriptor(vF.prototype, "remoteMediaSsrcChanged"), vF.prototype), vF);
function wF(e9) {
  return function(t2, i2, n2) {
    const r2 = t2[i2];
    if ("function" != typeof r2) throw new Error("Cannot use mutex on object property.");
    return n2.value = async function() {
      for (var t3 = arguments.length, n3 = new Array(t3), o2 = 0; o2 < t3; o2++) n3[o2] = arguments[o2];
      switch (e9) {
        case dF.SEND_ONLY: {
          const e10 = await this.sendMutex.lock("From P2PChannel2.".concat(i2));
          try {
            return await r2.apply(this, n3);
          } finally {
            e10();
          }
        }
        case dF.RECEIVE_ONLY: {
          const e10 = await this.recvMutex.lock("From P2PChannel2.".concat(i2));
          try {
            return await r2.apply(this, n3);
          } finally {
            e10();
          }
        }
        default: {
          const e10 = await this.sendMutex.lock("From P2PChannel2.".concat(i2)), t4 = await this.recvMutex.lock("From P2PChannel2.".concat(i2));
          try {
            return await r2.apply(this, n3);
          } finally {
            e10(), t4();
          }
        }
      }
    }, n2;
  };
}
function OF(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function NF(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? OF(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : OF(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var DF = class _DF {
  constructor(e9) {
    Fg(this, "store", void 0), Fg(this, "onStatsException", void 0), Fg(this, "onUploadPublishDuration", void 0), Fg(this, "onStatsChanged", void 0), Fg(this, "localStats", /* @__PURE__ */ new Map()), Fg(this, "remoteStats", /* @__PURE__ */ new Map()), Fg(this, "updateStatsInterval", void 0), Fg(this, "trafficStats", void 0), Fg(this, "trafficStatsPeerList", []), Fg(this, "uplinkStats", void 0), Fg(this, "exceptionMonitor", void 0), Fg(this, "p2pChannel", void 0), Fg(this, "scalabilityMode", Iw.L1T1), Fg(this, "updateStats", () => {
      this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));
    }), this.store = e9, this.exceptionMonitor = new iV(), this.exceptionMonitor.on("exception", (e10, t2, i2) => {
      this.onStatsException && this.onStatsException(e10, t2, i2);
    });
  }
  startUpdateStats() {
    this.updateStatsInterval || (this.updateStatsInterval = window.setInterval(this.updateStats, 1e3));
  }
  stopUpdateStats() {
    this.updateStatsInterval && (window.clearInterval(this.updateStatsInterval), this.updateStatsInterval = void 0);
  }
  reset() {
    this.localStats = /* @__PURE__ */ new Map(), this.remoteStats = /* @__PURE__ */ new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;
  }
  getLocalAudioTrackStats() {
    return this.localStats.get(hO.LocalAudioTrack) || NF({}, AL);
  }
  getLocalVideoTrackStats() {
    return this.localStats.get(hO.LocalVideoTrack) || NF({}, bL);
  }
  getRemoteAudioTrackStats(e9) {
    const t2 = (e10, t3) => {
      if (!this.trafficStats) return t3;
      const i3 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e10);
      return i3 && (t3.publishDuration = i3.B_ppad + (Date.now() - this.trafficStats.timestamp)), t3;
    }, i2 = {};
    if (e9) {
      var n2;
      const r2 = null === (n2 = this.remoteStats.get(e9)) || void 0 === n2 ? void 0 : n2.audioStats;
      r2 && (i2[e9] = t2(e9, r2));
    } else Array.from(this.remoteStats.entries()).forEach((e10) => {
      let [n3, { audioStats: r2 }] = e10;
      r2 && (i2[n3] = t2(n3, r2));
    });
    return i2;
  }
  getRemoteNetworkQualityStats(e9) {
    const t2 = {};
    if (e9) {
      var i2;
      const n2 = null === (i2 = this.remoteStats.get(e9)) || void 0 === i2 ? void 0 : i2.networkStats;
      n2 && (t2[e9] = n2);
    } else Array.from(this.remoteStats.entries()).forEach((e10) => {
      let [i3, { networkStats: n2 }] = e10;
      n2 && (t2[i3] = n2);
    });
    return t2;
  }
  getRemoteVideoTrackStats(e9) {
    const t2 = (e10, t3) => {
      if (!this.trafficStats) return t3;
      const i3 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e10);
      return i3 && (t3.publishDuration = i3.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t3;
    }, i2 = {};
    if (e9) {
      var n2;
      const r2 = null === (n2 = this.remoteStats.get(e9)) || void 0 === n2 ? void 0 : n2.videoStats;
      r2 && (i2[e9] = t2(e9, r2));
    } else Array.from(this.remoteStats.entries()).forEach((e10) => {
      let [n3, { videoStats: r2 }] = e10;
      r2 && (i2[n3] = t2(n3, r2));
    });
    return i2;
  }
  getRTCStats() {
    let e9 = 0, t2 = 0, i2 = 0, n2 = 0;
    const r2 = this.localStats.get(hO.LocalAudioTrack);
    r2 && (e9 += r2.sendBytes, t2 += r2.sendBitrate);
    const o2 = this.localStats.get(hO.LocalVideoTrack);
    o2 && (e9 += o2.sendBytes, t2 += o2.sendBitrate);
    const s2 = this.localStats.get(hO.LocalVideoLowTrack);
    s2 && (e9 += s2.sendBytes, t2 += s2.sendBitrate), this.remoteStats.forEach((e10) => {
      let { audioStats: t3, videoStats: r3 } = e10;
      t3 && (i2 += t3.receiveBytes, n2 += t3.receiveBitrate), r3 && (i2 += r3.receiveBytes, n2 += r3.receiveBitrate);
    });
    let a2 = 1;
    return this.trafficStats && (a2 += this.trafficStats.peer_delay.length), { Duration: 0, UserCount: a2, SendBitrate: t2, SendBytes: e9, RecvBytes: i2, RecvBitrate: n2, OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0, RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0 };
  }
  addLocalStats(e9) {
    this.localStats.set(e9, void 0);
  }
  removeLocalStats(e9) {
    e9 ? this.localStats.delete(e9) : this.localStats.clear();
  }
  addRemoteStats(e9) {
    this.remoteStats.set(e9, {});
  }
  removeRemoteStats(e9) {
    e9 ? this.remoteStats.delete(e9) : this.remoteStats.clear();
  }
  addP2PChannel(e9) {
    this.p2pChannel = e9;
  }
  updateTrafficStats(e9) {
    e9.peer_delay = e9.peer_delay.filter((e10) => void 0 !== e10.B_ppad || void 0 !== e10.B_ppvd);
    e9.peer_delay.filter((e10) => -1 === this.trafficStatsPeerList.indexOf(e10.peer_uid)).forEach((e10) => {
      var t2;
      const i2 = null === (t2 = this.p2pChannel) || void 0 === t2 ? void 0 : t2.getRemoteMedia(e10.peer_uid), n2 = null != i2 && i2.videoSSRC ? rV.measureFromSubscribeStart(this.store.clientId, i2.videoSSRC) : 0, r2 = null != i2 && i2.audioSSRC ? rV.measureFromSubscribeStart(this.store.clientId, i2.audioSSRC) : 0;
      void 0 !== e10.B_ppad && void 0 !== e10.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(e10.peer_uid, e10.B_ppad, e10.B_ppvd, n2 > r2 ? n2 : r2), this.trafficStatsPeerList.push(e10.peer_uid));
    }), this.trafficStats = e9;
  }
  updateUplinkStats(e9) {
    this.uplinkStats && this.uplinkStats.B_fir !== e9.B_fir && fb.debug("[".concat(this.store.clientId, "]: Period fir changes to ").concat(e9.B_fir)), this.uplinkStats = e9;
  }
  static isRemoteVideoFreeze(e9, t2, i2) {
    if (!e9) return false;
    const n2 = !!i2 && t2.framesDecodeFreezeTime > i2.framesDecodeFreezeTime, r2 = !i2 || t2.framesDecodeCount > i2.framesDecodeCount;
    return n2 || !r2;
  }
  static isRemoteAudioFreeze(e9) {
    return !!e9 && e9._isFreeze();
  }
  isLocalVideoFreeze(e9) {
    return !(!e9.inputFrame || !e9.sentFrame) && (e9.inputFrame.frameRate > 5 && e9.sentFrame.frameRate < 3);
  }
  updateLocalStats(e9) {
    Array.from(this.localStats.entries()).forEach((t2) => {
      let [i2, n2] = t2;
      switch (i2) {
        case hO.LocalVideoTrack:
        case hO.LocalVideoLowTrack: {
          const t3 = n2, o2 = NF({}, bL), s2 = e9.getStats(), a2 = e9.getLocalMedia(i2);
          if (s2) {
            const i3 = s2.videoSend.find((e10) => e10.ssrc === (null == a2 ? void 0 : a2.ssrcs[0].ssrcId));
            if (i3) {
              const n3 = e9.getLocalVideoSize(), r3 = e9.getEncoderConfig(hO.LocalVideoTrack);
              "H264" !== i3.codec && "H265" !== i3.codec && "VP8" !== i3.codec && "VP9" !== i3.codec && "AV1X" !== i3.codec && "AV1" !== i3.codec || (o2.codecType = i3.codec), o2.sendBytes = i3.bytes, o2.sendBitrate = t3 ? 8 * Math.max(0, o2.sendBytes - t3.sendBytes) : 0, i3.inputFrame ? (o2.captureFrameRate = i3.inputFrame.frameRate, o2.captureResolutionHeight = i3.inputFrame.height, o2.captureResolutionWidth = i3.inputFrame.width) : n3 && (o2.captureResolutionWidth = n3.width, o2.captureResolutionHeight = n3.height), i3.sentFrame ? (o2.sendFrameRate = i3.sentFrame.frameRate, o2.sendResolutionHeight = i3.sentFrame.height, o2.sendResolutionWidth = i3.sentFrame.width) : n3 && (o2.sendResolutionWidth = n3.width, o2.sendResolutionHeight = n3.height), i3.avgEncodeMs && (o2.encodeDelay = i3.avgEncodeMs), r3 && r3.bitrateMax && (o2.targetSendBitrate = 1e3 * r3.bitrateMax), o2.sendPackets = i3.packets, o2.sendPacketsLost = i3.packetsLost, o2.sendJitterMs = i3.jitterMs, o2.sendRttMs = i3.rttMs, o2.totalDuration = t3 ? t3.totalDuration + 1 : 1, o2.totalFreezeTime = t3 ? t3.totalFreezeTime : 0, this.isLocalVideoFreeze(i3) && (o2.totalFreezeTime += 1), i3.scalabilityMode && this.scalabilityMode !== i3.scalabilityMode && (fb.debug("[".concat(this.store.clientId, "]: The scalabilityMode of the video sending stream is ").concat(i3.scalabilityMode)), this.scalabilityMode = i3.scalabilityMode);
            }
            this.trafficStats && (o2.currentPacketLossRate = (this.trafficStats.B_pvlr4 || 0) / 100);
          }
          var r2;
          if (this.localStats.set(i2, o2), (null == t3 ? void 0 : t3.sendResolutionWidth) !== o2.sendResolutionWidth || (null == t3 ? void 0 : t3.sendResolutionHeight) !== o2.sendResolutionHeight) null === (r2 = this.onStatsChanged) || void 0 === r2 || r2.call(this, "resolution", { width: o2.sendResolutionWidth, height: o2.sendResolutionHeight });
          o2 && a2 && this.exceptionMonitor.setLocalVideoStats(this.store.uid, a2.track, o2);
          break;
        }
        case hO.LocalAudioTrack: {
          const t3 = n2, r3 = NF({}, AL), o2 = e9.getStats(), s2 = e9.getLocalMedia(i2);
          if (o2) {
            const i3 = o2.audioSend.find((e10) => e10.ssrc === (null == s2 ? void 0 : s2.ssrcs[0].ssrcId));
            if (i3) {
              if ("opus" !== i3.codec && "aac" !== i3.codec && "PCMU" !== i3.codec && "PCMA" !== i3.codec && "G722" !== i3.codec || (r3.codecType = i3.codec), i3.inputLevel) r3.sendVolumeLevel = Math.round(32767 * i3.inputLevel);
              else {
                const t4 = e9.getLocalAudioVolume();
                t4 && (r3.sendVolumeLevel = Math.round(32767 * t4));
              }
              r3.sendBytes = i3.bytes, r3.sendPackets = i3.packets, r3.sendPacketsLost = i3.packetsLost, r3.sendJitterMs = i3.jitterMs, r3.sendRttMs = i3.rttMs, r3.sendBitrate = t3 ? 8 * Math.max(0, r3.sendBytes - t3.sendBytes) : 0;
            }
          }
          this.trafficStats && (r3.currentPacketLossRate = (this.trafficStats.B_palr4 || 0) / 100), this.localStats.set(hO.LocalAudioTrack, r3), r3 && s2 && this.exceptionMonitor.setLocalAudioStats(this.store.uid, s2.track, r3);
          break;
        }
      }
    });
  }
  updateRemoteStats(e9) {
    Array.from(this.remoteStats.entries()).forEach((t2) => {
      var i2, n2;
      let [r2, { videoStats: o2, audioStats: s2, videoPcStats: a2 }] = t2;
      const c2 = s2, d2 = o2, l2 = a2, u2 = NF({}, wL), h2 = NF({}, NL), p2 = NF({}, OL), { audioTrack: _2, videoTrack: E2, audioSSRC: f2, videoSSRC: m2 } = e9.getRemoteMedia(r2);
      let T2;
      T2 = e9 instanceof bF ? e9.getStats(true) : e9.getStats();
      const S2 = null === (i2 = T2) || void 0 === i2 ? void 0 : i2.audioRecv.find((e10) => e10.ssrc === f2), g2 = null === (n2 = T2) || void 0 === n2 ? void 0 : n2.videoRecv.find((e10) => e10.ssrc === m2), R2 = this.trafficStats && this.trafficStats.peer_delay.find((e10) => e10.peer_uid === r2);
      if (S2 && ("opus" !== S2.codec && "aac" !== S2.codec && "PCMU" !== S2.codec && "PCMA" !== S2.codec && "G722" !== S2.codec || (u2.codecType = S2.codec), S2.outputLevel ? u2.receiveLevel = Math.round(32767 * S2.outputLevel) : _2 && (u2.receiveLevel = Math.round(32767 * _2.getVolumeLevel())), u2.receiveBytes = S2.bytes, u2.receivePackets = S2.packets, u2.receivePacketsLost = S2.packetsLost, u2.receivePacketsDiscarded = S2.packetsDiscarded, u2.packetLossRate = u2.receivePacketsLost / (u2.receivePackets + u2.receivePacketsLost), u2.receiveBitrate = c2 ? 8 * Math.max(0, u2.receiveBytes - c2.receiveBytes) : 0, u2.totalDuration = c2 ? c2.totalDuration + 1 : 1, u2.totalFreezeTime = c2 ? c2.totalFreezeTime : 0, u2.freezeRate = u2.totalFreezeTime / u2.totalDuration, u2.receiveDelay = S2.jitterBufferMs, u2.totalDuration > 10 && _DF.isRemoteAudioFreeze(_2) && (u2.totalFreezeTime += 1)), g2) {
        "H264" !== g2.codec && "H265" !== g2.codec && "VP8" !== g2.codec && "VP9" !== g2.codec && "AV1X" !== g2.codec && "AV1" !== g2.codec || (h2.codecType = g2.codec), h2.receiveBytes = g2.bytes, h2.receiveBitrate = d2 ? 8 * Math.max(0, h2.receiveBytes - d2.receiveBytes) : 0, h2.decodeFrameRate = g2.decodeFrameRate < 0 ? 0 : g2.decodeFrameRate, h2.renderFrameRate = g2.decodeFrameRate < 0 ? 0 : g2.decodeFrameRate, g2.outputFrame && (h2.renderFrameRate = g2.outputFrame.frameRate), g2.receivedFrame ? (h2.receiveFrameRate = g2.receivedFrame.frameRate, h2.receiveResolutionHeight = g2.receivedFrame.height, h2.receiveResolutionWidth = g2.receivedFrame.width) : E2 && (h2.receiveResolutionHeight = E2._videoHeight || 0, h2.receiveResolutionWidth = E2._videoWidth || 0), void 0 !== g2.framesRateFirefox && (h2.receiveFrameRate = Math.round(g2.framesRateFirefox)), h2.receivePackets = g2.packets, h2.receivePacketsLost = g2.packetsLost, h2.packetLossRate = h2.receivePacketsLost / (h2.receivePackets + h2.receivePacketsLost), h2.totalDuration = d2 ? d2.totalDuration + 1 : 1, h2.totalFreezeTime = d2 ? d2.totalFreezeTime : 0, h2.receiveDelay = g2.jitterBufferMs || 0;
        const t3 = !!m2 && e9.getRemoteVideoIsReady(m2);
        E2 && t3 && _DF.isRemoteVideoFreeze(E2, g2, l2) && (h2.totalFreezeTime += 1), h2.freezeRate = h2.totalFreezeTime / h2.totalDuration;
      }
      R2 && (u2.end2EndDelay = R2.B_ad, h2.end2EndDelay = R2.B_vd, u2.transportDelay = R2.B_ed, h2.transportDelay = R2.B_ed, u2.currentPacketLossRate = R2.B_ealr4 / 100, h2.currentPacketLossRate = R2.B_evlr4 / 100, p2.uplinkNetworkQuality = R2.B_punq ? R2.B_punq : 0, p2.downlinkNetworkQuality = R2.B_pdnq ? R2.B_pdnq : 0), this.remoteStats.set(r2, { audioStats: u2, videoStats: h2, videoPcStats: g2, networkStats: p2 }), _2 && this.exceptionMonitor.setRemoteAudioStats(_2, u2), E2 && this.exceptionMonitor.setRemoteVideoStats(E2, h2);
    });
  }
};
var PF = class {
  constructor() {
    Fg(this, "destChannelMediaInfos", /* @__PURE__ */ new Map()), Fg(this, "srcChannelMediaInfo", void 0);
  }
  setSrcChannelInfo(e9) {
    qw(e9), this.srcChannelMediaInfo = e9;
  }
  addDestChannelInfo(e9) {
    qw(e9), this.destChannelMediaInfos.set(e9.channelName, e9);
  }
  removeDestChannelInfo(e9) {
    xw(e9), this.destChannelMediaInfos.delete(e9);
  }
  getSrcChannelMediaInfo() {
    return this.srcChannelMediaInfo;
  }
  getDestChannelMediaInfo() {
    return this.destChannelMediaInfos;
  }
};
function LF(e9) {
  if (!(e9 instanceof PF)) {
    return new yb(Ry.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]").throw();
  }
  const t2 = e9.getSrcChannelMediaInfo(), i2 = e9.getDestChannelMediaInfo();
  if (!t2) {
    return new yb(Ry.INVALID_PARAMS, "srcChannelMediaInfo should not be empty").throw();
  }
  if (0 === i2.size) {
    return new yb(Ry.INVALID_PARAMS, "destChannelMediaInfo should not be empty").throw();
  }
}
function kF(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function MF(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? kF(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : kF(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var UF;
function xF(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function VF(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? xF(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : xF(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var FF = (UF = class e7 extends cO {
  get peerConnectionState() {
    return this.peerConnection.connectionState;
  }
  get iceConnectionState() {
    return this.peerConnection.iceConnectionState;
  }
  get currentLocalDescription() {
    return this.peerConnection.currentLocalDescription;
  }
  get currentRemoteDescription() {
    return this.peerConnection.currentRemoteDescription;
  }
  get localCodecs() {
    return [...new Set(this.localCapabilities && this.localCapabilities.videoCodecs.map((e9) => e9.rtpMap && e9.rtpMap.encodingName.toLowerCase() || "").filter((e9) => {
      var t2;
      return Dn(t2 = Object.keys(eb)).call(t2, e9);
    }))];
  }
  constructor(t2, i2) {
    super(t2, i2), Fg(this, "store", void 0), Fg(this, "peerConnection", void 0), Fg(this, "remoteSDP", void 0), Fg(this, "initialOffer", void 0), Fg(this, "statsFilter", void 0), Fg(this, "useRTX", false), Fg(this, "localCapabilities", void 0), Fg(this, "localCandidateCount", 0), Fg(this, "allCandidatesReceived", false), Fg(this, "establishPromise", void 0), Fg(this, "mutex", new NA("P2PConnection-mutex")), this.store = i2, this.peerConnection = new RTCPeerConnection(e7.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.statsFilter = xV(this.peerConnection, XA("STATS_UPDATE_INTERVAL"), void 0, Zv() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
  }
  async establish() {
    try {
      const e9 = await this.peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
      if (!e9.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
      const t2 = HU(e9.sdp), i2 = WU(e9.sdp, { filterRTX: !this.useRTX, filterVideoFec: XA("FILTER_VIDEO_FEC"), filterAudioFec: XA("FILTER_AUDIO_FEC"), filterAudioCodec: ["opus"] });
      return this.localCapabilities = i2, this.initialOffer = e9, VF(VF({}, t2), {}, { rtpCapabilities: { send: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, recv: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, sendrecv: i2 }, offerSDP: e9.sdp });
    } catch (e9) {
      throw new Cy(Ry.GET_LOCAL_CONNECTION_PARAMS_FAILED, e9.toString());
    }
  }
  async updateRemoteConnect() {
  }
  async connect(e9) {
    try {
      if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
      this.remoteSDP = new class {
        constructor(e10) {
          Fg(this, "sessionDesc", void 0), Fg(this, "localCapabilities", void 0), Fg(this, "rtpCapabilities", void 0), Fg(this, "candidates", void 0), Fg(this, "iceParameters", void 0), Fg(this, "dtlsParameters", void 0), Fg(this, "setup", void 0), Fg(this, "currentMidIndex", void 0), Fg(this, "cname", void 0), e10 = sA(e10);
          const { iceParameters: t3, dtlsParameters: i2, candidates: n2, rtpCapabilities: r2, setup: o2, localCapabilities: s2, sdkCodec: a2, cname: c2 } = e10, d2 = FU.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n");
          this.rtpCapabilities = r2, this.candidates = n2, this.iceParameters = t3, this.dtlsParameters = i2, this.setup = o2, this.localCapabilities = s2, this.cname = c2;
          for (let e11 = 0; e11 < d2.mediaDescriptions.length; e11++) {
            const s3 = d2.mediaDescriptions[e11];
            if (s3.attributes.iceUfrag = t3.iceUfrag, s3.attributes.icePwd = t3.icePwd, s3.attributes.fingerprints = i2.fingerprints, s3.attributes.candidates = n2, s3.attributes.setup = o2, "video" === s3.media.mediaType) {
              s3.media.fmts = r2.videoCodecs.map((e13) => e13.payloadType.toString(10));
              let e12 = r2.videoCodecs.filter((e13) => {
                var t4, i3;
                return null === (t4 = e13.rtpMap) || void 0 === t4 ? void 0 : Dn(i3 = t4.encodingName.toLowerCase()).call(i3, a2);
              });
              0 === e12.length && (e12 = r2.videoCodecs), s3.attributes.payloads = e12, s3.attributes.extmaps = r2.videoExtensions;
            }
            "audio" === s3.media.mediaType && (s3.media.fmts = r2.audioCodecs.map((e12) => e12.payloadType.toString(10)), s3.attributes.payloads = r2.audioCodecs, s3.attributes.extmaps = r2.audioExtensions), d2.mediaDescriptions[e11] = this.mungMediaDesc(s3);
          }
          this.sessionDesc = d2, this.currentMidIndex = d2.mediaDescriptions.length - 1;
        }
        toString() {
          return FU.print(this.sessionDesc);
        }
        send(e10, t3, i2) {
          const { ssrcs: n2, ssrcGroups: r2 } = zU(t3, this.cname), o2 = this.sessionDesc.mediaDescriptions.find((t4) => e10 === dO.VIDEO ? "video" === t4.media.mediaType : "audio" === t4.media.mediaType), s2 = n2[0].attributes.label, a2 = n2[0].attributes.mslabel;
          return o2.attributes.ssrcs = o2.attributes.ssrcs.concat(n2), o2.attributes.ssrcGroups = o2.attributes.ssrcGroups.concat(r2), { id: s2, mslabel: a2 };
        }
        batchSend(e10) {
          return e10.map((e11) => {
            let { kind: t3, ssrcMsg: i2 } = e11;
            return this.send(t3, i2, void 0);
          });
        }
        stopSending(e10) {
          this.sessionDesc.mediaDescriptions.forEach((t3) => {
            const i2 = [], n2 = [], r2 = [];
            t3.attributes.ssrcs.forEach((t4) => {
              Dn(e10).call(e10, t4.attributes.label || "") ? r2.push(t4) : i2.push(t4);
            }), t3.attributes.ssrcGroups.forEach((e11) => {
              var t4;
              Dn(t4 = r2.map((e12) => e12.ssrcId)).call(t4, e11.ssrcIds[0]) || n2.push(e11);
            }), t3.attributes.ssrcs = i2, t3.attributes.ssrcGroups = n2;
          });
        }
        mute(e10) {
          const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e10);
          if (!t3) throw new Error("mediaDescription not found with ".concat(e10, " in remote SDP when calling RemoteSDP.mute."));
          t3.attributes.direction = "inactive";
        }
        unmute(e10) {
          const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e10);
          if (!t3) throw new Error("mediaDescription not found with ".concat(e10, " in remote SDP when calling RemoteSDP.unmute."));
          t3.attributes.direction = "sendonly";
        }
        receive(e10, t3, i2) {
          e10.forEach((e11, t4) => {
            const i3 = e11._mediaStreamTrack, n2 = this.sessionDesc.mediaDescriptions.findIndex((e12) => e12.attributes.mid === i3.kind), r2 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n2], e11);
            this.sessionDesc.mediaDescriptions[n2] = r2;
          });
        }
        stopReceiving(e10) {
        }
        updateCandidates(e10) {
          e10 === lO.TCP ? this.candidates.forEach((e11) => {
            -1 === this.candidates.findIndex((t3) => "tcp" === t3.transport && t3.connectionAddress === e11.connectionAddress && t3.port === e11.port) && this.candidates.push(MF(MF({}, e11), {}, { foundation: "tcpcandidate", priority: Number(e11.priority) - 1 + "", transport: "tcp", port: Number(e11.port) + 90 + "" }));
          }) : this.candidates = this.candidates.filter((e11) => "tcp" !== e11.transport);
          for (const e11 of this.sessionDesc.mediaDescriptions) e11.attributes.candidates = this.candidates;
        }
        restartICE(e10) {
          e10 = sA(e10), this.iceParameters = e10, this.sessionDesc.mediaDescriptions.forEach((t3) => {
            t3.attributes.iceUfrag = e10.iceUfrag, t3.attributes.icePwd = e10.icePwd;
          });
        }
        predictReceivingMids(e10) {
          const t3 = [];
          for (let i2 = 0; i2 < e10; i2++) t3.push((this.currentMidIndex + i2 + 1).toString(10));
          return t3;
        }
        mungRecvMediaDsec(e10, t3) {
          const i2 = sA(e10);
          return JU(i2, t3), QU(i2, t3), i2;
        }
        updateRecvMedia(e10, t3) {
          const i2 = this.sessionDesc.mediaDescriptions.findIndex((t4) => t4.attributes.mid === e10);
          if (-1 !== i2) {
            const e11 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t3);
            this.sessionDesc.mediaDescriptions[i2] = e11;
          }
        }
        bumpMid(e10) {
          this.currentMidIndex += e10;
        }
        updateTrackLabel(e10, t3, i2) {
          const n2 = this.sessionDesc.mediaDescriptions.find((t4) => e10 === dO.VIDEO ? "video" === t4.attributes.mid : "audio" === t4.attributes.mid);
          if (n2) {
            const e11 = n2.attributes.ssrcs.find((e12) => e12.attributes.label === t3);
            var r2;
            e11 && (e11.attributes.label = i2, null === (r2 = e11.attributes.msid) || void 0 === r2 || r2.replace(t3, i2));
          }
        }
        mungMediaDesc(e10) {
          const t3 = sA(e10);
          return XU(t3), function(e11) {
            const t4 = e11.attributes.extmaps.find((e12) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e12.extensionName);
            t4 && e11.attributes.extmaps.splice(e11.attributes.extmaps.indexOf(t4), 1), e11.attributes.payloads.forEach((e12) => {
              const t5 = e12.rtcpFeedbacks.findIndex((e13) => "transport-cc" === e13.type);
              -1 !== t5 && e12.rtcpFeedbacks.splice(t5, 1);
            });
          }(t3), t3;
        }
        getSSRC(e10) {
          for (const t3 of this.sessionDesc.mediaDescriptions) for (const i2 of t3.attributes.ssrcs) if (i2.attributes.label === e10) return [i2];
        }
      }(VF(VF({}, e9), {}, { rtpCapabilities: e9.rtpCapabilities.send, localCapabilities: this.localCapabilities, sdkCodec: this.store.codec }));
      const t2 = this.remoteSDP.toString();
      await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: t2 });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e10.toString()));
    }
  }
  async updateRemoteRTPCapabilities(e9, t2) {
    throw new Cy(Ry.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
  }
  getPreMedia(e9) {
  }
  send(e9, t2) {
    var i2 = this;
    return YI(function* () {
      const n2 = yield qI(i2.mutex.lock());
      try {
        if (!i2.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
        const r2 = e9.map((e10) => i2.peerConnection.addTrack(e10._mediaStreamTrack)), o2 = yield qI(i2.peerConnection.createOffer()), s2 = FU.parse(o2.sdp), a2 = e9.map((e10) => {
          const t3 = e10._mediaStreamTrack, n3 = s2.mediaDescriptions.find((e11) => e11.attributes.mid === t3.kind);
          if (!n3) throw new Error("Cannot extract ssrc from mediaDescription.");
          return function(e11, t4, i3) {
            const n4 = e11.attributes.ssrcs.filter((e12) => e12.attributes.label === t4), r3 = e11.attributes.ssrcGroups;
            if (0 === n4.length) throw new Error("Cannot extract ssrc from plan-b SDP.");
            if (r3 && n4.length > 1) {
              const e12 = r3.find((e13) => -1 !== e13.ssrcIds.indexOf(n4[0].ssrcId));
              return e12 ? [{ ssrcId: e12.ssrcIds[0], rtx: i3 ? e12.ssrcIds[1] : void 0 }] : [{ ssrcId: n4[0].ssrcId }];
            }
            return [{ ssrcId: n4[0].ssrcId }];
          }(n3, t3.id, i2.useRTX);
        });
        let c2;
        try {
          c2 = yield a2;
        } catch (e10) {
          throw r2.forEach((e11) => {
            Xv() && e11.replaceTrack(null), i2.peerConnection.removeTrack(e11);
          }), e10;
        }
        const d2 = i2.mungSendOfferSDP(o2.sdp, e9);
        i2.remoteSDP.receive(e9, t2, c2);
        const l2 = i2.remoteSDP.toString();
        return yield qI(i2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield qI(i2.applySendEncodings(r2, e9)), yield qI(i2.peerConnection.setRemoteDescription({ type: "answer", sdp: l2 })), e9.map((e10, t3) => {
          const i3 = e10._mediaStreamTrack.id;
          return { localSSRC: a2[t3], id: i3 };
        });
      } catch (e10) {
        throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e10.toString()));
      } finally {
        n2();
      }
    })();
  }
  async stopSending(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
      const t2 = this.peerConnection.getSenders().filter((t3) => {
        var i3;
        return -1 !== e9.indexOf((null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) || "");
      });
      if (t2.length !== e9.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
      t2.map((e10) => {
        Xv() && e10.replaceTrack(null), this.peerConnection.removeTrack(e10);
      });
      const i2 = await this.peerConnection.createOffer();
      await this.peerConnection.setLocalDescription(i2), this.remoteSDP.stopReceiving(e9);
      const n2 = this.remoteSDP.toString();
      await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e10.toString()));
    }
  }
  async receive(e9, t2, i2, n2) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e9, " before remoteSDP created."));
      const { id: i3, mslabel: r2 } = this.remoteSDP.send(e9, t2, n2), o2 = new Gh((t3, n3) => {
        const o3 = setTimeout(() => {
          n3(new Error("Cannot receive track, id: ".concat(i3)));
        }, 1e4), s3 = (n4) => {
          const a3 = Hv();
          if (("Safari" === a3.name && 11 === Number(a3.version) || $v()) && n4.track.id !== i3 && n4.streams[0].id === r2) {
            var c2;
            const r3 = n4.streams[0].getTracks()[0];
            return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(e9, i3, n4.track.id), this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t3(r3);
          }
          if (n4.track.id === i3) return this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t3(n4.track);
        };
        this.peerConnection.addEventListener("track", s3);
      }), s2 = this.remoteSDP.toString();
      await this.peerConnection.setRemoteDescription({ type: "offer", sdp: s2 });
      const a2 = await this.peerConnection.createAnswer();
      await this.peerConnection.setLocalDescription(a2);
      return { track: await o2, id: i3 };
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e10.toString()));
    }
  }
  async stopReceiving(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
      this.remoteSDP.stopSending(e9);
      const t2 = this.remoteSDP.toString();
      await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
      const i2 = await this.peerConnection.createAnswer();
      await this.peerConnection.setLocalDescription(i2);
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e10.toString()));
    }
  }
  async muteRemote(e9) {
  }
  async unmuteRemote(e9) {
  }
  async muteLocal(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
      const t2 = this.peerConnection.getSenders().filter((t3) => {
        var i2;
        return -1 !== e9.indexOf((null === (i2 = t3.track) || void 0 === i2 ? void 0 : i2.id) || "");
      });
      if (t2.length !== e9.length) throw new Error("sender' length doesn't match mids' length.");
      t2.map((e10) => {
        if (Xv() && e10.track) e10.track.enabled = false;
        else {
          const t3 = e10.getParameters();
          t3.encodings.forEach((e11) => e11.active = false), e10.setParameters(t3);
        }
      });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e10.toString()));
    }
  }
  async unmuteLocal(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
      const t2 = this.peerConnection.getSenders().filter((t3) => {
        var i3;
        return -1 !== e9.indexOf((null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) || "");
      });
      if (t2.length !== e9.length) throw new Error("Senders' length doesn't match mids' length.");
      t2.map(async (e10) => {
        if (Xv() && e10.track) e10.track.enabled = true;
        else {
          const t3 = e10.getParameters();
          t3.encodings.forEach((e11) => e11.active = true), await e10.setParameters(t3);
        }
      });
      const i2 = await this.peerConnection.createOffer();
      await this.peerConnection.setLocalDescription(i2);
      const n2 = this.remoteSDP.toString();
      await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e10.toString()));
    }
  }
  restartICE(e9) {
    var t2 = this;
    return YI(function* () {
      const i2 = yield qI(t2.mutex.lock("From P2PConnection.restartICE"));
      try {
        if (!t2.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
        if (ZP().supportPCSetConfiguration) {
          const i3 = t2.peerConnection.getConfiguration(), n3 = e9 === lO.RELAY ? "relay" : "all";
          i3.iceTransportPolicy !== n3 && (fb.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(i3.iceTransportPolicy, "] to [").concat(n3, "]")), i3.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i3));
        } else if (e9 === lO.RELAY) return;
        e9 !== lO.RELAY && t2.remoteSDP.updateCandidates(e9);
        const n2 = yield qI(t2.peerConnection.createOffer({ iceRestart: true }));
        if (!n2.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
        const r2 = HU(n2.sdp), { remoteIceParameters: o2 } = yield r2.iceParameters;
        t2.remoteSDP.restartICE(o2);
        const s2 = t2.remoteSDP.toString();
        yield qI(t2.peerConnection.setLocalDescription(n2)), yield qI(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 }));
      } catch (e10) {
        fb.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e10);
      } finally {
        i2();
      }
    })();
  }
  close() {
    var e9;
    this.peerConnection.close(), null === (e9 = this.onConnectionStateChange) || void 0 === e9 || e9.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy();
  }
  getStats() {
    return this.statsFilter.getStats();
  }
  getRemoteVideoIsReady(e9) {
    return this.statsFilter.getVideoIsReady(e9);
  }
  async updateEncoderConfig(e9, t2) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
      const e10 = await this.peerConnection.createOffer(), i2 = this.mungSendOfferSDP(e10.sdp, [t2]);
      this.remoteSDP.updateRecvMedia(t2._mediaStreamTrack.kind, t2);
      const n2 = this.remoteSDP.toString();
      await this.peerConnection.setLocalDescription({ type: "offer", sdp: i2 }), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, e10.toString());
    }
  }
  async updateSendParameters(e9, t2) {
    const i2 = this.peerConnection.getSenders().filter((t3) => {
      var i3;
      return (null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) === e9;
    });
    1 === i2.length && await this.applySendEncodings(i2, [t2]);
  }
  setStatsRemoteVideoIsReady(e9, t2) {
    this.statsFilter.setVideoIsReady2(e9, t2);
  }
  async replaceTrack(e9, t2) {
    const i2 = this.peerConnection.getSenders().find((e10) => {
      var i3;
      return (null === (i3 = e10.track) || void 0 === i3 ? void 0 : i3.id) === t2;
    });
    i2 && await i2.replaceTrack(e9._mediaStreamTrack);
  }
  createDataChannels(e9, t2) {
    throw new Cy(Ry.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
  }
  stopDataChannels(e9) {
    throw new Cy(Ry.NOT_SUPPORTED, "Planb mode does not support stopDataChannels.");
  }
  bindPCEvents() {
    this.peerConnection.oniceconnectionstatechange = () => {
      var e9;
      null === (e9 = this.onICEConnectionStateChange) || void 0 === e9 || e9.call(this, this.peerConnection.iceConnectionState);
    }, this.peerConnection.onconnectionstatechange = () => {
      var e9;
      null === (e9 = this.onConnectionStateChange) || void 0 === e9 || e9.call(this, this.peerConnection.connectionState);
    }, this.peerConnection.onicecandidate = (e9) => {
      e9.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, fb.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
    }, setTimeout(() => {
      this.allCandidatesReceived || (this.allCandidatesReceived = true, fb.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
    }, XA("CANDIDATE_TIMEOUT"));
  }
  unbindPCEvents() {
    this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
  }
  static resolvePCConfiguration(t2) {
    const i2 = { iceServers: [], sdpSemantics: "plan-b" };
    return t2.iceServers ? i2.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Ky(t2.turnServer.servers) ? i2.iceServers = t2.turnServer.servers : (i2.iceServers && i2.iceServers.push(...e7.turnServerConfigToIceServers(t2.turnServer.servers)), XA("USE_TURN_SERVER_OF_GATEWAY") && i2.iceServers && t2.turnServer.serversFromGateway && i2.iceServers.push(...e7.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e9) => {
      e9.forceturn && (i2.iceTransportPolicy = "relay");
    }))), i2;
  }
  static turnServerConfigToIceServers(e9) {
    const t2 = [];
    return e9.forEach((e10) => {
      e10.security ? e10.tcpport && t2.push({ username: e10.username, credential: e10.password, credentialType: "password", urls: "turns:".concat(e10.turnServerURL, ":").concat(e10.tcpport, "?transport=tcp") }) : (e10.udpport && t2.push({ username: e10.username, credential: e10.password, credentialType: "password", urls: "turn:".concat(e10.turnServerURL, ":").concat(e10.udpport, "?transport=udp") }), e10.tcpport && t2.push({ username: e10.username, credential: e10.password, credentialType: "password", urls: "turn:".concat(e10.turnServerURL, ":").concat(e10.tcpport, "?transport=tcp") }));
    }), t2;
  }
  async updateRtpSenderEncodings(e9, t2) {
    var i2;
    if (!t2) {
      t2 = this.peerConnection.getSenders().find((t3) => {
        var i3;
        return (null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) === e9._mediaStreamTrack.id;
      });
    }
    if (!t2) return fb.warn("[".concat(e9.getTrackId(), "] no rtpSender found}"));
    if (!ZP().supportSetRtpSenderParameters) return fb.warn("Browser not support set rtp-sender parameters");
    const n2 = {}, r2 = {};
    if (e9 instanceof aU) switch (e9._optimizationMode) {
      case "motion":
        n2.degradationPreference = "maintain-framerate";
        break;
      case "detail":
        n2.degradationPreference = "maintain-resolution";
        break;
      default:
        n2.degradationPreference = "balanced";
    }
    if (XA("DSCP_TYPE") && Ey()) {
      var o2;
      const e10 = XA("DSCP_TYPE");
      Dn(o2 = ["very-low", "low", "medium", "high"]).call(o2, e10) && (r2.networkPriority = e10);
    }
    const s2 = t2.getParameters(), a2 = null === (i2 = s2.encodings) || void 0 === i2 ? void 0 : i2[0];
    a2 && Object.assign(a2, r2), Object.assign(s2, n2), fb.debug("[".concat(e9.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(s2.encodings))), await t2.setParameters(s2);
  }
  async applySendEncodings(e9, t2) {
    try {
      if (!ZP().supportSetRtpSenderParameters) return;
      if (e9.length !== t2.length) return;
      for (let i2 = 0; i2 < e9.length; i2++) {
        const n2 = e9[i2], r2 = t2[i2];
        n2 && r2 && await this.updateRtpSenderEncodings(r2, n2);
      }
    } catch (e10) {
      fb.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
    }
  }
  mungSendOfferSDP(e9, t2) {
    const i2 = FU.parse(e9);
    return t2.forEach((e10, t3) => {
      const n2 = e10._mediaStreamTrack, r2 = i2.mediaDescriptions.find((e11) => e11.attributes.mid === n2.kind);
      r2 && JU(r2, e10);
    }), FU.print(i2);
  }
  bindStatsEvents() {
    this.statsFilter.onFirstAudioReceived = (e9) => {
      var t2;
      null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e9);
    }, this.statsFilter.onFirstVideoReceived = (e9) => {
      var t2;
      null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e9);
    }, this.statsFilter.onFirstAudioDecoded = (e9) => {
      var t2;
      null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e9);
    }, this.statsFilter.onFirstVideoDecoded = (e9, t2, i2) => {
      var n2;
      null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e9, t2, i2);
    }, this.statsFilter.onSelectedLocalCandidateChanged = (e9, t2) => {
      var i2;
      null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e9, t2);
    }, this.statsFilter.onSelectedRemoteCandidateChanged = (e9, t2) => {
      var i2;
      null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e9, t2);
    };
  }
  unbindStatsEvents() {
    this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;
  }
  async batchReceive(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
      const t2 = this.remoteSDP.batchSend(e9).map((t3, i3) => {
        let { id: n3, mslabel: r2 } = t3;
        const { kind: o2 } = e9[i3];
        return new Gh((e10, t4) => {
          const i4 = setTimeout(() => {
            t4(new Error("Cannot receive track, id: ".concat(n3)));
          }, 1e4), s2 = (t5) => {
            const a2 = Hv();
            if ("Safari" === a2.name && 11 === Number(a2.version) && t5.track.id !== n3 && t5.streams[0].id === r2) {
              var c2;
              const r3 = t5.streams[0].getTracks()[0];
              return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(o2, n3, t5.track.id), this.peerConnection.removeEventListener("track", s2), clearTimeout(i4), void e10({ track: r3, id: n3 });
            }
            if (t5.track.id === n3) return this.peerConnection.removeEventListener("track", s2), clearTimeout(i4), void e10({ track: t5.track, id: n3 });
          };
          this.peerConnection.addEventListener("track", s2);
        });
      }), i2 = this.remoteSDP.toString();
      await this.peerConnection.setRemoteDescription({ type: "offer", sdp: i2 });
      const n2 = await this.peerConnection.createAnswer();
      return await this.peerConnection.setLocalDescription(n2), await Gh.all(t2);
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e10.toString()));
    }
  }
  async getRemoteSSRC(e9) {
    if (!this.remoteSDP) return;
    const t2 = this.remoteSDP.getSSRC(e9);
    return null == t2 ? void 0 : t2[0].ssrcId;
  }
  setConfiguration(t2) {
    if (ZP().supportPCSetConfiguration) {
      const i2 = e7.resolvePCConfiguration(t2);
      this.peerConnection.setConfiguration(i2);
    }
  }
}, Cw(UF.prototype, "connect", [BF], Object.getOwnPropertyDescriptor(UF.prototype, "connect"), UF.prototype), Cw(UF.prototype, "stopSending", [BF], Object.getOwnPropertyDescriptor(UF.prototype, "stopSending"), UF.prototype), Cw(UF.prototype, "receive", [BF], Object.getOwnPropertyDescriptor(UF.prototype, "receive"), UF.prototype), Cw(UF.prototype, "stopReceiving", [BF], Object.getOwnPropertyDescriptor(UF.prototype, "stopReceiving"), UF.prototype), Cw(UF.prototype, "muteRemote", [BF], Object.getOwnPropertyDescriptor(UF.prototype, "muteRemote"), UF.prototype), Cw(UF.prototype, "unmuteRemote", [BF], Object.getOwnPropertyDescriptor(UF.prototype, "unmuteRemote"), UF.prototype), Cw(UF.prototype, "muteLocal", [BF], Object.getOwnPropertyDescriptor(UF.prototype, "muteLocal"), UF.prototype), Cw(UF.prototype, "unmuteLocal", [BF], Object.getOwnPropertyDescriptor(UF.prototype, "unmuteLocal"), UF.prototype), Cw(UF.prototype, "close", [BF], Object.getOwnPropertyDescriptor(UF.prototype, "close"), UF.prototype), Cw(UF.prototype, "updateEncoderConfig", [BF], Object.getOwnPropertyDescriptor(UF.prototype, "updateEncoderConfig"), UF.prototype), Cw(UF.prototype, "updateSendParameters", [BF], Object.getOwnPropertyDescriptor(UF.prototype, "updateSendParameters"), UF.prototype), Cw(UF.prototype, "replaceTrack", [BF], Object.getOwnPropertyDescriptor(UF.prototype, "replaceTrack"), UF.prototype), Cw(UF.prototype, "getRemoteSSRC", [BF], Object.getOwnPropertyDescriptor(UF.prototype, "getRemoteSSRC"), UF.prototype), UF);
function BF(e9, t2, i2) {
  const n2 = e9[t2];
  if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
  return i2.value = async function() {
    const e10 = this.mutex, i3 = await e10.lock("Locking from P2PConnection.".concat(t2));
    try {
      for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
      return await n2.apply(this, o2);
    } finally {
      i3();
    }
  }, i2;
}
function jF(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function GF(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? jF(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : jF(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var WF = "9";
var HF = 4e4;
var KF = class {
  get localCapabilities() {
    return sA(this._localCapabilities);
  }
  get rtpCapabilities() {
    return sA(this._rtpCapabilities);
  }
  get candidates() {
    return sA(this._candidates);
  }
  get iceParameters() {
    return sA(this._iceParameters);
  }
  get dtlsParameters() {
    return sA(this._dtlsParameters);
  }
  constructor(e9) {
    Fg(this, "sessionDesc", void 0), Fg(this, "_localCapabilities", void 0), Fg(this, "_rtpCapabilities", void 0), Fg(this, "_candidates", void 0), Fg(this, "_iceParameters", void 0), Fg(this, "_dtlsParameters", void 0), Fg(this, "setup", void 0), Fg(this, "currentMidIndex", void 0), Fg(this, "cname", void 0), Fg(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e9 = sA(e9);
    const { iceParameters: t2, dtlsParameters: i2, candidates: n2, rtpCapabilities: r2, setup: o2, localCapabilities: s2, cname: a2 } = e9;
    this._rtpCapabilities = r2, this._candidates = n2, this._iceParameters = t2, this._dtlsParameters = i2, this._localCapabilities = s2, this.setup = o2, this.cname = a2, this.sessionDesc = this.updateRemoteRTPCapabilities(r2), this.currentMidIndex = this.sessionDesc.mediaDescriptions.length - 1;
  }
  preloadRemoteMedia(e9) {
    const t2 = this.candidates, i2 = this.dtlsParameters, n2 = this.iceParameters, r2 = this.rtpCapabilities.send;
    let o2 = this.sessionDesc.mediaDescriptions.length - 1;
    for (let s2 = 1; s2 < e9; s2++) {
      const e10 = 2 * s2 + 2e4, a2 = 2 * s2 + HF, { ssrcs: c2, ssrcGroups: d2 } = zU([{ ssrcId: e10 }], this.cname), { ssrcs: l2, ssrcGroups: u2 } = zU([{ ssrcId: a2, rtx: XA("USE_SUB_RTX") ? a2 + 1 : void 0 }], this.cname);
      this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: WF, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.videoCodecs.map((e11) => e11.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.videoExtensions, fingerprints: i2.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: l2, ssrcGroups: u2, rtcpFeedbackWildcards: [], payloads: r2.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(++o2) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: WF, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.audioCodecs.map((e11) => e11.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.audioExtensions, fingerprints: i2.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: c2, ssrcGroups: d2, rtcpFeedbackWildcards: [], payloads: r2.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(++o2) } }), this.currentMidIndex += 2;
    }
    this.updateBundleMids();
  }
  toString() {
    return FU.print(this.sessionDesc);
  }
  send(e9, t2, i2, n2) {
    const { ssrcs: r2, ssrcGroups: o2 } = zU(t2, this.cname, XA("SYNC_GROUP") ? i2 : void 0), s2 = this.findPreloadMediaDesc(r2);
    if (s2) {
      if (Zv() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, s2.attributes.mid), n2 && (n2.twcc || n2.remb)) {
        const e10 = this.sessionDesc.mediaDescriptions.indexOf(s2);
        return this.sessionDesc.mediaDescriptions[e10] = this.mungSendMediaDesc(s2, n2), { mid: s2.attributes.mid, needExchangeSDP: true };
      }
      return { mid: s2.attributes.mid, needExchangeSDP: false };
    }
    {
      const t3 = this.findAvailableMediaIndex(e9, r2);
      let i3;
      return -1 === t3 || 1 === t3 && (Xv() || function() {
        const e10 = Hv();
        return !(e10.name !== Bv.CHROME || !e10.osVersion) && Number(e10.version) <= 90;
      }()) || 0 === t3 && XA("USE_SUB_RTX") || ay() ? (i3 = this.createOrRecycleSendMedia(e9, r2, o2, "sendonly", n2), this.updateBundleMids()) : (i3 = sA(this.sessionDesc.mediaDescriptions[t3]), i3.attributes.direction = "sendonly", i3.attributes.ssrcs = r2, i3.attributes.ssrcGroups = o2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(i3, n2)), Zv() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, i3.attributes.mid), { mid: i3.attributes.mid, needExchangeSDP: true };
    }
  }
  sendDataChannel() {
    const { mediaDesc: e9, needExchangeSDP: t2 } = this.createOrRecycleDataChannel();
    return this.updateBundleMids(), { mid: e9.attributes.mid, needExchangeSDP: t2 };
  }
  batchSend(e9) {
    const t2 = e9.map((e10) => {
      let { kind: t3, ssrcMsg: i3, mslabel: n3 } = e10;
      return this.send(t3, i3, n3);
    }), i2 = [];
    let n2 = false;
    return t2.forEach((e10) => {
      let { mid: t3, needExchangeSDP: r2 } = e10;
      r2 && (n2 = true), i2.push(t3);
    }), { mids: i2, needExchangeSDP: n2 };
  }
  stopSending(e9) {
    const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && -1 !== e9.indexOf(t3.attributes.mid));
    if (t2.length !== e9.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
    t2.forEach((e10) => {
      "0" === e10.attributes.mid || Zv() || ay() ? e10.attributes.ssrcs = [] : (e10.attributes.ssrcs = [], e10.attributes.direction = "inactive", e10.media.port = "0");
    }), this.updateBundleMids();
  }
  mute(e9) {
    const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e9);
    if (!t2) throw new Error("mediaDescription not found with ".concat(e9, " in remote SDP when calling RemoteSDP.mute."));
    t2.attributes.direction = "inactive";
  }
  unmute(e9) {
    const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e9);
    if (!t2) throw new Error("mediaDescription not found with ".concat(e9, " in remote SDP when calling RemoteSDP.unmute."));
    t2.attributes.direction = "sendonly";
  }
  muteRemote(e9) {
    const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => Dn(e9).call(e9, t3.attributes.mid || ""));
    if (t2.length !== e9.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
    t2.forEach((e10) => {
      e10.attributes.direction = "inactive";
    });
  }
  unmuteRemote(e9) {
    const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => Dn(e9).call(e9, t3.attributes.mid || ""));
    if (t2.length !== e9.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
    t2.forEach((e10) => {
      e10.attributes.direction = "recvonly";
    });
  }
  receive(e9, t2, i2, n2) {
    e9.forEach((e10, r2) => {
      this.createOrRecycleRecvMedia(e10, [], "recvonly", t2, i2, n2[r2]);
    }), this.updateBundleMids();
  }
  stopReceiving(e9) {
    const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => -1 !== e9.indexOf(t3.attributes.mid));
    if (t2.length !== e9.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
    t2.forEach((e10) => {
      e10.media.port = "0", e10.attributes.direction = "inactive";
    }), this.updateBundleMids();
  }
  updateRemoteRTPCapabilities(e9) {
    const t2 = this.sessionDesc || FU.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n");
    this._rtpCapabilities = e9;
    const i2 = this.rtpCapabilities.send, n2 = this.localCapabilities.send;
    for (const e10 of t2.mediaDescriptions) {
      if (e10.attributes.iceUfrag = this._iceParameters.iceUfrag, e10.attributes.icePwd = this._iceParameters.icePwd, e10.attributes.fingerprints = this._dtlsParameters.fingerprints, e10.attributes.candidates = this._candidates, e10.attributes.setup = this.setup, "application" === e10.media.mediaType && (e10.attributes.sctpPort = "5000"), "video" === e10.media.mediaType) {
        if (0 === i2.videoCodecs.length) {
          const t3 = n2.videoCodecs.filter((e11) => {
            var t4, i3;
            return null === (t4 = e11.rtpMap) || void 0 === t4 ? void 0 : Dn(i3 = t4.encodingName.toLowerCase()).call(i3, "vp8");
          }) || [n2.videoCodecs[0]];
          e10.media.fmts = t3.map((e11) => e11.payloadType.toString(10)), e10.attributes.payloads = t3, e10.attributes.extmaps = [];
        } else if (e10.media.fmts = i2.videoCodecs.map((e11) => e11.payloadType.toString(10)), e10.attributes.payloads = i2.videoCodecs, e10.attributes.extmaps = i2.videoExtensions, XA("PRELOAD_MEDIA_COUNT") > 0) {
          const { ssrcs: t3, ssrcGroups: i3 } = zU([{ ssrcId: HF, rtx: XA("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
          e10.attributes.ssrcs = t3, e10.attributes.ssrcGroups = i3;
        }
      }
      if ("audio" === e10.media.mediaType) {
        if (0 === i2.audioCodecs.length) {
          const t3 = n2.audioCodecs.filter((e11) => {
            var t4, i3;
            return null === (t4 = e11.rtpMap) || void 0 === t4 ? void 0 : Dn(i3 = t4.encodingName.toLowerCase()).call(i3, "opus");
          }) || [n2.audioCodecs[0]];
          e10.media.fmts = t3.map((e11) => e11.payloadType.toString(10)), e10.attributes.payloads = t3, e10.attributes.extmaps = [];
        } else if (e10.media.fmts = i2.audioCodecs.map((e11) => e11.payloadType.toString(10)), e10.attributes.payloads = i2.audioCodecs, e10.attributes.extmaps = i2.audioExtensions, ox(e10), XA("PRELOAD_MEDIA_COUNT") > 0) {
          const { ssrcs: t3, ssrcGroups: i3 } = zU([{ ssrcId: 2e4 }], this.cname);
          e10.attributes.ssrcs = t3, e10.attributes.ssrcGroups = i3;
        }
      }
    }
    return this.sessionDesc = t2, this.currentMidIndex = t2.mediaDescriptions.length - 1, this.sessionDesc;
  }
  updateCandidates(e9) {
    const t2 = this._candidates.filter((e10) => "udp" === e10.transport);
    if (e9 === lO.TCP) {
      if (0 === t2.length) return;
      if (XA("TCP_CANDIDATE_ONLY")) {
        const e10 = this._candidates.filter((e11) => "tcp" === e11.transport);
        t2.forEach((t3) => {
          -1 === e10.findIndex((e11) => e11.connectionAddress === t3.connectionAddress) && e10.push(GF(GF({}, t3), {}, { foundation: "tcpcandidate", priority: Number(t3.priority) - 1 + "", transport: "tcp", port: Number(t3.port) + 90 + "" }));
        }), this._candidates = e10;
      } else {
        const e10 = [];
        t2.forEach((t3) => {
          e10.push(GF(GF({}, t3), {}, { foundation: "tcpcandidate", priority: Number(t3.priority) - 1 + "", transport: "tcp", port: Number(t3.port) + 90 + "" }));
        }), this._candidates = [...t2, ...e10];
      }
    } else if (e9 === lO.RELAY) {
      if (0 !== t2.length) return;
      {
        const e10 = this._candidates.filter((e11) => "tcp" === e11.transport);
        e10.forEach((e11) => {
          t2.push(GF(GF({}, e11), {}, { foundation: "udpcandidate", priority: Number(e11.priority) + 1 + "", transport: "udp", port: Number(e11.port) - 90 + "" }));
        }), this._candidates = [...t2, ...e10];
      }
    } else if (0 === t2.length) {
      this._candidates.filter((e10) => "tcp" === e10.transport).forEach((e10) => {
        t2.push(GF(GF({}, e10), {}, { foundation: "udpcandidate", priority: Number(e10.priority) + 1 + "", transport: "udp", port: Number(e10.port) - 90 + "" }));
      }), this._candidates = t2;
    } else this._candidates = this._candidates.filter((e10) => "tcp" !== e10.transport);
    for (const e10 of this.sessionDesc.mediaDescriptions) e10.attributes.candidates = this.candidates;
  }
  restartICE(e9) {
    e9 = sA(e9), this._iceParameters = e9, this.sessionDesc.mediaDescriptions.forEach((t2) => {
      t2.attributes.iceUfrag = e9.iceUfrag, t2.attributes.icePwd = e9.icePwd;
    });
  }
  predictReceivingMids(e9) {
    const t2 = [];
    for (let i2 = 0; i2 < e9; i2++) t2.push((this.currentMidIndex + i2 + 1).toString(10));
    return t2;
  }
  findAvailableMediaIndex(e9, t2) {
    return this.sessionDesc.mediaDescriptions.findIndex((i2) => {
      const n2 = i2.media.mediaType === e9 && "0" !== i2.media.port && ("sendonly" === i2.attributes.direction || "sendrecv" === i2.attributes.direction) && 0 === i2.attributes.ssrcs.length;
      if (Zv()) {
        if (n2) {
          const e10 = this.firefoxSsrcMidMap.get(t2[0].ssrcId);
          return !(e10 || "0" !== i2.attributes.mid && "1" !== i2.attributes.mid) || !(!e10 || e10 !== i2.attributes.mid);
        }
        return false;
      }
      return n2;
    });
  }
  createOrRecycleDataChannel() {
    for (const e10 of this.sessionDesc.mediaDescriptions) if ("application" === e10.media.mediaType) return { mediaDesc: e10, needExchangeSDP: false };
    this.currentMidIndex += 1;
    const e9 = "".concat(this.currentMidIndex), t2 = { media: { mediaType: "application", port: WF, protos: ["UDP", "DTLS", "SCTP"], fmts: ["webrtc-datachannel"] }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: [], fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [], rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, mid: "".concat(e9), sctpPort: "5000" } };
    return this.sessionDesc.mediaDescriptions.push(t2), { mediaDesc: t2, needExchangeSDP: true };
  }
  createOrRecycleRecvMedia(e9, t2, i2, n2, r2, o2) {
    const s2 = e9._mediaStreamTrack.kind, a2 = this.rtpCapabilities.recv, c2 = sx(s2, a2, this.localCapabilities.send, s2 === dO.VIDEO ? n2 : r2), d2 = s2 === dO.VIDEO ? a2.videoExtensions : a2.audioExtensions;
    this.currentMidIndex += 1;
    const l2 = "".concat(this.currentMidIndex);
    let u2 = { media: { mediaType: s2, port: WF, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: c2.map((e10) => e10.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: d2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: c2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i2, rtcpMux: true, rtcpRsize: true, mid: "".concat(l2) } };
    u2 = this.mungRecvMediaDsec(u2, e9, o2);
    const h2 = this.findFirstClosedMedia(s2);
    if (h2) {
      const e10 = this.sessionDesc.mediaDescriptions.indexOf(h2);
      this.sessionDesc.mediaDescriptions[e10] = u2;
    } else this.sessionDesc.mediaDescriptions.push(u2);
    return u2;
  }
  updateRemoteCodec(e9, t2, i2) {
    const n2 = [...new Set(this._rtpCapabilities.recv.videoCodecs.map((e10) => e10.rtpMap && e10.rtpMap.encodingName.toLowerCase() || "").filter((e10) => {
      var t3;
      return Dn(t3 = Object.keys(eb)).call(t3, e10);
    }))], r2 = new Set(t2);
    if (n2.every((e10) => r2.has(e10))) return fb.debug("codecs has not changed, no need to updateRemoteCodec, codecs: ".concat(t2)), false;
    const o2 = this._rtpCapabilities.recv.videoCodecs.filter((e10) => t2.some((t3) => {
      var i3;
      return Dn(i3 = e10.rtpMap && e10.rtpMap.encodingName.toLowerCase() || "").call(i3, t3);
    }));
    if (0 === o2.length) return fb.debug("updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: ".concat(n2, " codecs: ").concat(t2)), false;
    const s2 = [...new Set(o2.map((e10) => e10.rtpMap && e10.rtpMap.encodingName.toLowerCase() || ""))];
    let a2;
    if (fb.debug("updateRemoteCodec, from ".concat(n2, " to ").concat(s2)), 0 === e9.length) a2 = this.sessionDesc.mediaDescriptions.filter((e10) => "video" === e10.media.mediaType && "recvonly" === e10.attributes.direction);
    else if (a2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && Dn(e9).call(e9, t3.attributes.mid) && "recvonly" === t3.attributes.direction), a2.length !== e9.length) return fb.debug("updateRemoteCodec failed, because cannot find mids, mids: ".concat(e9, ", codecs: ").concat(t2)), false;
    if (XA("USE_PUB_RTX") || XA("USE_SUB_RTX")) {
      const e10 = ax(o2, this.rtpCapabilities.recv.videoCodecs);
      o2.push(...e10);
    }
    this._rtpCapabilities.recv.videoCodecs = o2;
    const c2 = this.localCapabilities.send, d2 = this.rtpCapabilities.recv, l2 = sx(dO.VIDEO, d2, c2, i2);
    return a2.forEach((e10) => {
      const t3 = l2.map((e11) => e11.payloadType.toString(10));
      fb.debug("updateRemoteCodec mid: ".concat(e10.attributes.mid, ", from ").concat(e10.attributes.payloads, " to ").concat(l2)), e10.attributes.payloads = l2, e10.media.fmts = t3;
    }), true;
  }
  createOrRecycleSendMedia(e9, t2, i2, n2, r2) {
    const o2 = this.rtpCapabilities.send, s2 = e9 === dO.VIDEO ? o2.videoCodecs : o2.audioCodecs, a2 = e9 === dO.VIDEO ? o2.videoExtensions : o2.audioExtensions;
    this.currentMidIndex += 1;
    const c2 = "".concat(this.currentMidIndex);
    let d2 = { media: { mediaType: e9, port: WF, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: s2.map((e10) => e10.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: i2, rtcpFeedbackWildcards: [], payloads: s2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n2, rtcpMux: true, rtcpRsize: true, mid: "".concat(c2) } };
    d2 = this.mungSendMediaDesc(d2, r2);
    const l2 = this.findFirstClosedMedia(e9);
    if (l2) {
      const e10 = this.sessionDesc.mediaDescriptions.indexOf(l2);
      this.sessionDesc.mediaDescriptions[e10] = d2;
    } else this.sessionDesc.mediaDescriptions.push(d2);
    return d2;
  }
  updateBundleMids() {
    this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e9) => "0" !== e9.media.port).map((e9) => e9.attributes.mid);
  }
  mungRecvMediaDsec(e9, t2, i2) {
    const n2 = sA(e9);
    return XU(n2), JU(n2, t2), QU(n2, t2), ZU(n2), $U(n2, i2, this.localCapabilities.send), n2;
  }
  mungSendMediaDesc(e9, t2) {
    const i2 = sA(e9);
    return $U(i2, t2, this.localCapabilities.recv), ox(i2), i2;
  }
  updateRecvMedia(e9, t2) {
    const i2 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e9);
    if (-1 !== i2) {
      const e10 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t2);
      this.sessionDesc.mediaDescriptions[i2] = e10;
    }
  }
  bumpMid(e9) {
    this.currentMidIndex += e9;
  }
  findFirstClosedMedia(e9) {
    return this.sessionDesc.mediaDescriptions.find((t2) => Zv() ? "0" === t2.media.port && t2.media.mediaType === e9 : "0" === t2.media.port);
  }
  findPreloadMediaDesc(e9) {
    return this.sessionDesc.mediaDescriptions.find((t2) => {
      var i2;
      return (null === (i2 = t2.attributes) || void 0 === i2 || null === (i2 = i2.ssrcs[0]) || void 0 === i2 ? void 0 : i2.ssrcId) === e9[0].ssrcId;
    });
  }
  getSSRC(e9) {
    var t2;
    return null === (t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e9)) || void 0 === t2 ? void 0 : t2.attributes.ssrcs;
  }
};
function YF(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function qF(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? YF(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : YF(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var zF = function(e9) {
  return e9.BANDWIDTH = "bandwidth", e9.CPU = "cpu", e9.NONE = "none", e9.OTHER = "other", e9;
}({});
var JF = function(e9) {
  return e9[e9.DOWN = 0] = "DOWN", e9[e9.UP = 1] = "UP", e9;
}(JF || {});
var XF = /* @__PURE__ */ new Map();
function QF(e9, t2, i2, n2) {
  let { scale: r2 } = e9;
  if (0 === r2 && n2 === JF.UP || r2 >= t2.length - 1 && n2 === JF.DOWN) return e9;
  let o2 = qF(qF({}, e9), {}, { scale: n2 === JF.DOWN ? ++r2 : --r2 });
  switch (i2) {
    case "maintain-framerate":
      o2 = qF(qF({}, o2), t2[r2].motion);
      break;
    case "maintain-resolution":
      o2 = qF(qF({}, o2), t2[r2].detail);
      break;
    case "balanced":
      o2 = qF(qF({}, o2), t2[r2].balanced);
  }
  return o2;
}
function ZF(e9, t2) {
  if (t2) {
    const i2 = { overUse: 0, underUse: 0, adaptationList: $F(t2) };
    XF.set(e9, i2);
  } else XF.delete(e9);
}
function $F(e9) {
  const t2 = qF({}, e9), { bitrateMax: i2, frameRate: n2, scaleResolutionDownBy: r2, bitrateMin: o2 } = t2, { MIN_FRAME_RATE: s2, MAX_THRESHOLD_FRAMERATE: a2, MAX_SCALE: c2, BITRATE_MIN_THRESHOLD: d2, BITRATE_MAX_THRESHOLD: l2, BWE_SCALE_UP_THRESHOLD: u2, BWE_SCALE_DOWN_THRESHOLD: h2, PERF_SCALE_DOWN_THRESHOLD: p2, PERF_SCALE_UP_THRESHOLD: _2, BALANCE_BITRATE_FACTOR: E2, BALANCE_FRAMERATE_FACTOR: f2, BALANCE_RESOLUTION_FACTOR: m2, MOTION_RESOLUTION_FACTOR: T2, MOTION_BITRATE_FACTOR: S2, DETAIL_FRAMERATE_FACTOR: g2, DETAIL_BITRATE_FACTOR: R2 } = YA, C2 = Math.min(t2.frameRate, a2), I2 = [{ scale: 0, threshold: { bwe_down: Math.round(Math.pow(h2, 1) * i2), bwe_up: i2, fps_down: Math.round(Math.pow(p2, 1) * C2), fps_up: n2 }, balanced: { scaleResolutionDownBy: 1, frameRate: n2, bitrateMax: i2, bitrateMin: o2 }, motion: { scaleResolutionDownBy: 1, frameRate: n2, bitrateMax: i2, bitrateMin: o2 }, detail: { scaleResolutionDownBy: 1, frameRate: n2, bitrateMax: i2, bitrateMin: o2 } }];
  for (let e10 = 1; e10 <= c2; e10++) {
    const t3 = { bwe_up: Math.round(Math.pow(u2, e10) * i2), bwe_down: Math.round(Math.pow(h2, e10 + 1) * i2), fps_up: Math.round(Math.pow(_2, e10) * C2), fps_down: Math.round(Math.pow(p2, e10 + 1) * C2) }, a3 = { scaleResolutionDownBy: r2 / Math.pow(m2, e10), frameRate: Math.max(Math.round(Math.pow(f2, e10) * n2), s2), bitrateMax: Math.max(Math.round(Math.pow(E2, e10) * i2), l2), bitrateMin: Math.max(Math.round(Math.pow(E2, e10) * o2), d2) }, c3 = { scaleResolutionDownBy: r2 / Math.pow(T2, e10), frameRate: n2, bitrateMax: Math.max(Math.round(Math.pow(S2, e10) * i2), l2), bitrateMin: Math.max(Math.round(Math.pow(S2, e10) * o2), d2) }, v2 = { scaleResolutionDownBy: 1, frameRate: Math.max(Math.round(Math.pow(g2, e10) * n2), s2), bitrateMax: Math.max(Math.round(Math.pow(R2, e10) * i2), l2), bitrateMin: Math.max(Math.round(Math.pow(R2, e10) * o2), d2) };
    I2.push({ scale: e10, threshold: t3, balanced: a3, motion: c3, detail: v2 });
  }
  return I2;
}
function eB(e9, t2, i2, n2, r2, o2) {
  const s2 = XF.get(e9) || { overUse: 0, underUse: 0, adaptationList: $F(r2) }, { adaptationList: a2 } = s2;
  XF.set(e9, s2);
  const { OVERUSE_TIMES_THRESHOLD: c2, UNDERUSE_TIMES_THRESHOLD: d2 } = YA, { scale: l2 } = n2;
  let u2, h2;
  return "number" == typeof t2 && t2 > 0 && function(e10, t3, i3, n3) {
    if (t3 >= i3.length) return false;
    let { threshold: { fps_down: r3 } } = i3[t3];
    return XA("FORCE_AG_HIGH_FRAMERATE") && "maintain-framerate" === n3 && (r3 = i3[0].threshold.fps_down), e10 < r3;
  }(t2, l2, a2, o2) && (s2.overUse++, h2 = zF.CPU, s2.overUse > c2) || "number" == typeof i2 && i2 > 0 && function(e10, t3, i3) {
    if (t3 >= i3.length) return false;
    const { threshold: { bwe_down: n3 } } = i3[t3];
    return e10 < n3;
  }(i2, l2, a2) && (s2.overUse++, h2 = zF.BANDWIDTH, s2.overUse > c2) ? (s2.overUse = 0, s2.underUse = 0, u2 = QF(n2, a2, o2, JF.DOWN), [u2, h2]) : ("number" == typeof t2 && t2 > 0 && "number" == typeof i2 && i2 > 0 && function(e10, t3, i3, n3) {
    if (0 === t3) return;
    let { threshold: { fps_up: r3 } } = i3[t3];
    return XA("FORCE_AG_HIGH_FRAMERATE") && "maintain-framerate" === n3 && (r3 = i3[1].threshold.fps_up), e10 > r3;
  }(t2, l2, a2, o2) && function(e10, t3, i3) {
    if (0 === t3) return;
    const { threshold: { bwe_up: n3 } } = i3[t3];
    return e10 > n3;
  }(i2, l2, a2) && (s2.underUse++, s2.underUse > d2 && (s2.overUse = 0, s2.underUse = 0, u2 = QF(n2, a2, o2, JF.UP), 0 === u2.scale && (h2 = zF.NONE))), [u2, h2]);
}
function tB(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function iB(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? tB(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : tB(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
function nB(e9) {
  var t2;
  return !!XA("ENABLE_AG_ADAPTATION") && (!!(e9 instanceof cU || Dn(t2 = e9._hints).call(t2, mL.CUSTOM_TRACK)) && (!!XA("FORCE_SUPPORT_AG_ADAPTATION") || !!(function(e10) {
    const t3 = Hv();
    if (t3.os !== Fv.IOS || !t3.osVersion) return false;
    const i2 = t3.osVersion.split(".");
    return Number(i2[0]) >= e10;
  }(14) && ry(17, 4, true) || ny(14) && oy(17, 4, true))));
}
var rB = /* @__PURE__ */ new Map();
function oB(e9, t2) {
  const i2 = rB.get(e9);
  if (i2) {
    const { timer: t3 } = i2;
    window.clearTimeout(t3), rB.delete(e9);
  }
  t2.qualityLimitationReason = zF.NONE, ZF(e9);
}
var sB;
function aB(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function cB(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? aB(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : aB(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var dB = (sB = class e8 extends cO {
  get currentLocalDescription() {
    return this.peerConnection.currentLocalDescription;
  }
  get currentRemoteDescription() {
    return this.peerConnection.currentRemoteDescription;
  }
  get peerConnectionState() {
    return this.peerConnection.connectionState;
  }
  get iceConnectionState() {
    return this.peerConnection.iceConnectionState;
  }
  get dtlsTransportState() {
    var e9, t2;
    return null !== (e9 = null === (t2 = this.peerConnection.getReceivers()[0]) || void 0 === t2 || null === (t2 = t2.transport) || void 0 === t2 ? void 0 : t2.state) && void 0 !== e9 ? e9 : null;
  }
  get localCodecs() {
    return [...new Set(this.localCapabilities && this.localCapabilities.send.videoCodecs.map((e9) => e9.rtpMap && e9.rtpMap.encodingName.toLowerCase() || "").filter((e9) => {
      var t2;
      return Dn(t2 = Object.keys(eb)).call(t2, e9);
    }))];
  }
  constructor(t2, i2) {
    super(t2, i2), Fg(this, "store", void 0), Fg(this, "peerConnection", void 0), Fg(this, "id", TA(5, "connection-")), Fg(this, "remoteSDP", void 0), Fg(this, "initialOffer", void 0), Fg(this, "transportEventReceiver", void 0), Fg(this, "statsFilter", void 0), Fg(this, "extension", { useXR: XA("USE_XR") }), Fg(this, "localCapabilities", void 0), Fg(this, "remoteCodecs", void 0), Fg(this, "localCandidateCount", 0), Fg(this, "allCandidatesReceived", false), Fg(this, "isPreallocation", false), Fg(this, "preSSRCMap", /* @__PURE__ */ new Map()), Fg(this, "dataStreamChannelMap", /* @__PURE__ */ new Map()), Fg(this, "establishPromise", void 0), Fg(this, "recoveredDataChannelIds", []), Fg(this, "currentDataChannelId", 1), Fg(this, "mutex", new NA("P2PConnection-mutex")), Fg(this, "qualityLimitationReason", zF.NONE), this.store = i2, this.peerConnection = new RTCPeerConnection(e8.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.statsFilter = xV(this.peerConnection, XA("STATS_UPDATE_INTERVAL"), void 0, Zv() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
  }
  getPreMedia(e9) {
    const t2 = this.preSSRCMap.get(e9);
    if (void 0 !== t2) {
      const e10 = this.peerConnection.getTransceivers().find((e11) => e11.mid === t2);
      if (e10) return { transceiver: e10, track: e10.receiver.track, id: t2 };
    }
  }
  async updateRemoteRTPCapabilities(e9, t2) {
    if (this.remoteCodecs = t2, !this.remoteSDP) return void fb.debug("[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: ".concat(this.localCodecs, ", codecs: ").concat(t2));
    if (this.remoteSDP.updateRemoteCodec(e9, t2, this.store.codec)) {
      const e10 = await this.peerConnection.createOffer(), t3 = this.logSDPExchange(e10.sdp || "", "offer", "local", "muteLocal");
      await this.peerConnection.setLocalDescription(e10);
      const i2 = this.remoteSDP.toString();
      null == t3 || t3(i2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i2 });
    } else fb.debug("[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP.");
  }
  async establish() {
    try {
      this.peerConnection.addTransceiver("video", { direction: "recvonly" }), this.peerConnection.addTransceiver("audio", { direction: "recvonly" });
      const e9 = await this.peerConnection.createOffer();
      if (!e9.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
      const t2 = HU(e9.sdp), i2 = await tx({ filterRTX: !XA("USE_PUB_RTX") && !XA("USE_SUB_RTX"), filterVideoFec: XA("FILTER_VIDEO_FEC"), filterAudioFec: XA("FILTER_AUDIO_FEC"), filterVideoCodec: XA("FILTER_VIDEO_CODEC") }, this.extension);
      return this.localCapabilities = rx(i2), this.initialOffer = e9, cB(cB({}, t2), {}, { rtpCapabilities: i2, offerSDP: e9.sdp });
    } catch (e9) {
      throw new Cy(Ry.GET_LOCAL_CONNECTION_PARAMS_FAILED, e9.toString());
    }
  }
  async connect(e9) {
    try {
      if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
      this.remoteSDP = new KF(cB(cB({}, e9), {}, { localCapabilities: this.localCapabilities })), e9.preallocation && (this.isPreallocation = true), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
      const t2 = this.remoteSDP.toString(), i2 = dx(this.initialOffer.sdp, this.extension), n2 = this.logSDPExchange(i2 || "", "offer", "local", "connect");
      this.store.descriptionStart(), await this.peerConnection.setLocalDescription({ type: "offer", sdp: i2 }), null == n2 || n2(t2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: t2 });
      const r2 = this.peerConnection.getTransceivers()[0];
      if (null != r2 && r2.receiver && this.tryBindTransportEvents(r2.receiver), XA("PRELOAD_MEDIA_COUNT") > 0) {
        this.remoteSDP.preloadRemoteMedia(XA("PRELOAD_MEDIA_COUNT"));
        const e10 = this.remoteSDP.toString();
        await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e10 });
        const t3 = await this.peerConnection.createAnswer();
        await this.peerConnection.setLocalDescription(t3);
      }
      const { preSSRCs: o2 } = e9;
      if (Array.isArray(o2) && o2.length > 0) {
        const { mids: e10 } = this.remoteSDP.batchSend(o2.map((e11) => ({ kind: e11.kind, ssrcMsg: [{ ssrcId: e11.ssrcId, rtx: e11.rtx }], mslabel: e11.mslabel })));
        e10.forEach((e11, t3) => {
          this.preSSRCMap.set(o2[t3].ssrcId, e11);
        }), await cx(this.peerConnection, this.remoteSDP, this.extension), fb.debug("[".concat(this.store.clientId, "] [P2PConnection] pre-batchReceive exchange SDP."));
      }
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e10.toString()));
    }
  }
  async updateRemoteConnect(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateRemoteConnect before remote SDP created");
      const { rtpCapabilities: t2 } = e9;
      this.remoteSDP.updateRemoteRTPCapabilities(t2), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
      const { preSSRCs: i2 } = e9;
      if (Array.isArray(i2) && i2.length > 0) {
        const { mids: e10 } = this.remoteSDP.batchSend(i2.map((e11) => Object.assign({}, { kind: e11.kind, ssrcMsg: [{ ssrcId: e11.ssrcId, rtx: e11.rtx }], mslabel: e11.mslabel })));
        e10.forEach((e11, t3) => {
          this.preSSRCMap.set(i2[t3].ssrcId, e11);
        });
      }
      await cx(this.peerConnection, this.remoteSDP, this.extension), fb.debug("[P2PConnection] updateRemoteRTPCapabilities by exchanging SDP.");
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.updateRemoteConnect failed; ".concat(e10.toString()));
    }
  }
  send(e9, t2, i2) {
    var n2 = this;
    return YI(function* () {
      const r2 = yield qI(n2.mutex.lock("From P2PConnection.send"));
      try {
        if (!n2.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
        const o2 = [];
        e9.forEach((e10) => {
          const t3 = n2.peerConnection.addTransceiver(e10._mediaStreamTrack, { direction: "sendonly" });
          o2.push(t3), e10._updateRtpTransceiver(t3);
        }), Zv() && true === XA("SIMULCAST") && (yield qI(n2.applySimulcastForFirefox(o2, e9)));
        const s2 = yield qI(n2.peerConnection.createOffer()), a2 = n2.remoteSDP.predictReceivingMids(e9.length), c2 = n2.mungSendOfferSDP(s2.sdp, e9, a2), d2 = FU.parse(c2), l2 = a2.map((e10) => {
          const t3 = d2.mediaDescriptions.find((t4) => t4.attributes.mid === e10);
          if (!t3) throw new Error("Cannot extract ssrc from mediaDescription.");
          return KU(t3, XA("USE_PUB_RTX"));
        });
        let u2;
        try {
          u2 = yield l2;
        } catch (r3) {
          u2 = [], n2.remoteSDP.receive(e9, t2, i2, u2);
          const o3 = n2.remoteSDP.toString();
          throw yield qI(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield qI(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 })), yield qI(n2.stopSending(a2, true)), r3;
        }
        n2.remoteSDP.receive(e9, t2, i2, u2);
        const h2 = n2.remoteSDP.toString(), p2 = n2.logSDPExchange(c2, "offer", "local", "send");
        return yield qI(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield qI(n2.applySimulcastEncodings(o2, e9)), yield qI(n2.applySendEncodings(o2, e9)), null == p2 || p2(h2), yield qI(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: h2 })), o2.map((e10, t3) => {
          const i3 = a2[t3];
          return { localSSRC: l2[t3], id: i3, transceiver: e10 };
        });
      } catch (e10) {
        throw e10 instanceof Cy ? e10 : new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e10.toString()));
      } finally {
        r2();
      }
    })();
  }
  async createDataChannels(e9, t2) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.createDataChannels before remote SDP created");
      let i2 = this.dataStreamChannelMap.get(e9);
      if (i2 && "open" === i2.readyState) fb.debug("[P2PConnection] Channels are already available and can be reused directly.");
      else {
        const t3 = this.currentDataChannelId < 1023 ? this.currentDataChannelId++ : this.recoveredDataChannelIds.shift();
        if ("number" != typeof t3) throw new Error("create DataChannel error, because cannot get dc id");
        i2 = this.peerConnection.createDataChannel("datastream-channel", { id: t3, negotiated: true, ordered: false, maxRetransmits: XA("DATASTREAM_MAX_RETRANSMITS") }), i2.binaryType = "arraybuffer", this.dataStreamChannelMap.set(e9, i2);
      }
      t2.forEach((e10) => {
        e10._updateOriginDataChannel(i2);
      });
      const { needExchangeSDP: n2 } = this.remoteSDP.sendDataChannel();
      if (n2) {
        const e10 = this.remoteSDP.toString();
        await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e10 });
        const t3 = await this.peerConnection.createAnswer();
        await this.peerConnection.setLocalDescription(t3), fb.debug("[P2PConnection] createDataChannels by exchanging SDP.");
      } else fb.debug("[P2PConnection] createDataChannels no need to exchange SDP.");
      return;
    } catch (e10) {
      throw e10 instanceof Cy ? e10 : new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.createDataChannels failed; ".concat(e10.toString()));
    }
  }
  async stopDataChannels(e9) {
    try {
      const t2 = this.dataStreamChannelMap.get(e9);
      return t2 && (t2.id && this.recoveredDataChannelIds.push(t2.id), t2.close()), void this.dataStreamChannelMap.delete(e9);
    } catch (e10) {
      throw e10 instanceof Cy ? e10 : new Cy(Ry.DATACHANNEL_FAILED, "P2PConnection.stopDataChannels failed; ".concat(e10.toString()));
    }
  }
  async stopSending(e9, t2) {
    const i2 = t2 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
      const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e9.indexOf(t4.mid));
      if (t3.length !== e9.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
      t3.map((e10) => {
        var t4;
        oB(this.id + e10.mid, this), e10.direction = "inactive", null === (t4 = e10.stop) || void 0 === t4 || t4.call(e10);
      });
      const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
      await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e9);
      const o2 = this.remoteSDP.toString();
      null == r2 || r2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e10.toString()));
    } finally {
      i2 && i2();
    }
  }
  async receive(e9, t2, i2, n2) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e9, " before remoteSDP created."));
      const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e9, t2, i2, n2);
      o2 && (await cx(this.peerConnection, this.remoteSDP, this.extension), fb.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e9, " by exchanging SDP.")));
      const s2 = this.peerConnection.getTransceivers().find((e10) => e10.mid === r2);
      if (!s2) throw new Error("Cannot get transceiver after setLocalDescription.");
      return { track: s2.receiver.track, id: r2, transceiver: s2 };
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e10.toString()));
    }
  }
  async batchReceive(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
      const { mids: t2, needExchangeSDP: i2 } = this.remoteSDP.batchSend(e9);
      return i2 && (await cx(this.peerConnection, this.remoteSDP, this.extension), fb.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive by exchanging SDP."))), t2.map((e10) => {
        const t3 = this.peerConnection.getTransceivers().find((t4) => t4.mid === e10);
        if (!t3) throw new Error("Cannot get transceiver after setLocalDescription.");
        return { track: t3.receiver.track, id: e10, transceiver: t3 };
      });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e10.toString()));
    }
  }
  async stopReceiving(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
      e9.forEach((e10) => {
        Array.from(this.preSSRCMap.entries()).some((t3) => {
          let [i3, n3] = t3;
          if (n3 === e10) return this.preSSRCMap.delete(i3), true;
        });
      }), this.remoteSDP.stopSending(e9);
      const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
      await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
      const n2 = await this.peerConnection.createAnswer();
      null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e10.toString()));
    }
  }
  async muteRemote(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e9, " before remote SDP created."));
      this.remoteSDP.mute(e9);
      const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "muteRemote");
      await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
      const n2 = await this.peerConnection.createAnswer();
      null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.muteRemote failed; ".concat(e10.toString()));
    }
  }
  async unmuteRemote(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e9, " before remote SDP created."));
      this.remoteSDP.unmute(e9);
      const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "unmuteRemote");
      await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
      const n2 = await this.peerConnection.createAnswer();
      null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteRemote failed; ".concat(e10.toString()));
    }
  }
  async muteLocal(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
      const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e9.indexOf(t3.mid));
      if (t2.length !== e9.length) throw new Error("Transceivers' length doesn't match mids' length.");
      t2.map((e10) => {
        e10.direction = "inactive";
      });
      const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
      await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e9);
      const r2 = this.remoteSDP.toString();
      null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e10.toString()));
    }
  }
  async unmuteLocal(e9) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
      const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e9.indexOf(t3.mid));
      if (t2.length !== e9.length) throw new Error("Transceivers' length doesn't match mids' length.");
      t2.map(async (e10, t3) => {
        e10.direction = "sendonly";
      });
      const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
      await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e9);
      const r2 = this.remoteSDP.toString();
      null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e10.toString()));
    }
  }
  restartICE(e9) {
    var t2 = this;
    return YI(function* () {
      const i2 = yield qI(t2.mutex.lock("From P2PConnection.restartICE"));
      try {
        if (!t2.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
        if (ZP().supportPCSetConfiguration) {
          const i3 = t2.peerConnection.getConfiguration(), n3 = e9 === lO.RELAY ? "relay" : "all";
          i3.iceTransportPolicy !== n3 && (fb.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(i3.iceTransportPolicy, "] to [").concat(n3, "]")), i3.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i3));
        } else if (e9 === lO.RELAY) return;
        t2.remoteSDP.updateCandidates(e9);
        const n2 = yield qI(t2.peerConnection.createOffer({ iceRestart: true }));
        if (!n2.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
        const r2 = HU(n2.sdp), { remoteIceParameters: o2 } = yield r2.iceParameters;
        t2.remoteSDP.restartICE(o2);
        const s2 = t2.remoteSDP.toString(), a2 = t2.logSDPExchange(n2.sdp || "", "offer", "local", "restartICE");
        t2.store.descriptionStart(), yield qI(t2.peerConnection.setLocalDescription(n2)), null == a2 || a2(s2), yield qI(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 }));
      } catch (e10) {
        fb.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e10);
      } finally {
        i2();
      }
    })();
  }
  close() {
    var e9;
    this.peerConnection.getTransceivers().forEach((e10) => {
      oB(this.id + e10.mid, this);
    }), this.preSSRCMap.clear(), this.peerConnection.close(), null === (e9 = this.onConnectionStateChange) || void 0 === e9 || e9.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy(), this.dataStreamChannelMap.clear(), this.recoveredDataChannelIds = [], this.currentDataChannelId = 1;
  }
  getStats() {
    return cB(cB({}, this.statsFilter.getStats()), {}, { qualityLimitationReason: this.qualityLimitationReason });
  }
  getRemoteVideoIsReady(e9) {
    return this.statsFilter.getVideoIsReady(e9);
  }
  async updateEncoderConfig(e9, t2) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
      const i2 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i2.sdp, [t2], [e9]);
      this.remoteSDP.updateRecvMedia(e9, t2);
      const r2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
      await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == o2 || o2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
    } catch (e10) {
      throw new Cy(Ry.EXCHANGE_SDP_FAILED, e10.toString());
    }
  }
  async updateSendParameters(e9, t2) {
    const i2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e9);
    1 === i2.length && (this.isVP8Simulcast(t2) ? Zv() || await this.applySimulcastEncodings(i2, [t2]) : await this.applySendEncodings(i2, [t2]));
  }
  setStatsRemoteVideoIsReady(e9, t2) {
    this.statsFilter.setVideoIsReady2(e9, t2);
  }
  async replaceTrack(e9, t2) {
    const i2 = this.peerConnection.getTransceivers().find((e10) => e10.mid === t2);
    i2 && await i2.sender.replaceTrack(e9._mediaStreamTrack);
  }
  async getSelectedCandidatePair() {
    const e9 = this.peerConnection.getReceivers();
    if (e9.length > 0 && e9[0].transport && e9[0].transport.iceTransport && e9[0].transport.iceTransport.getSelectedCandidatePair && e9[0].transport.iceTransport.getSelectedCandidatePair()) {
      const t2 = e9[0].transport.iceTransport, { local: i2, remote: n2 } = t2.getSelectedCandidatePair();
      return { local: cB(cB({}, RV), {}, { candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), remote: cB(cB({}, RV), {}, { candidateType: n2.type, protocol: n2.protocol, address: n2.address, port: n2.port }) };
    }
    return this.statsFilter.getSelectedCandidatePair();
  }
  bindPCEvents() {
    this.peerConnection.oniceconnectionstatechange = () => {
      var e9;
      null === (e9 = this.onICEConnectionStateChange) || void 0 === e9 || e9.call(this, this.peerConnection.iceConnectionState);
    }, this.peerConnection.onconnectionstatechange = () => {
      var e9;
      null === (e9 = this.onConnectionStateChange) || void 0 === e9 || e9.call(this, this.peerConnection.connectionState);
    }, this.peerConnection.onicecandidate = (e9) => {
      e9.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, fb.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
    }, setTimeout(() => {
      this.allCandidatesReceived || (this.allCandidatesReceived = true, fb.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
    }, XA("CANDIDATE_TIMEOUT"));
  }
  unbindPCEvents() {
    this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
  }
  static resolvePCConfiguration(t2) {
    const i2 = { iceServers: [] };
    return t2.iceServers ? i2.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Ky(t2.turnServer.servers) ? i2.iceServers = t2.turnServer.servers : (i2.iceServers && i2.iceServers.push(...e8.turnServerConfigToIceServers(t2.turnServer.servers)), XA("USE_TURN_SERVER_OF_GATEWAY") && i2.iceServers && t2.turnServer.serversFromGateway && i2.iceServers.push(...e8.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), XA("FORCE_TURN_TCP") ? i2.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e9) => {
      e9.forceturn && (i2.iceTransportPolicy = "relay");
    }))), XA("ENABLE_ENCODED_TRANSFORM") && ZP().supportWebRTCEncodedTransform && (i2.encodedInsertableStreams = true), i2;
  }
  static turnServerConfigToIceServers(e9) {
    const t2 = [];
    return e9.forEach((e10) => {
      e10.security ? e10.tcpport && t2.push({ username: e10.username, credential: e10.password, credentialType: "password", urls: "turns:".concat(JO(e10.turnServerURL), ":").concat(e10.tcpport, "?transport=tcp") }) : (e10.udpport && !XA("FORCE_TURN_TCP") && t2.push({ username: e10.username, credential: e10.password, credentialType: "password", urls: "turn:".concat(e10.turnServerURL, ":").concat(e10.udpport, "?transport=udp") }), e10.tcpport && t2.push({ username: e10.username, credential: e10.password, credentialType: "password", urls: "turn:".concat(e10.turnServerURL, ":").concat(e10.tcpport, "?transport=tcp") }));
    }), t2;
  }
  tryBindTransportEvents(e9) {
    const t2 = e9.transport;
    if (t2) {
      this.transportEventReceiver = e9, t2.onstatechange = () => {
        var e10;
        null != t2 && t2.state && (null === (e10 = this.onDTLSTransportStateChange) || void 0 === e10 || e10.call(this, t2.state));
      }, t2.onerror = (e10) => {
        var t3;
        null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, "error" in e10 ? e10.error : e10);
      };
      const i2 = t2.iceTransport;
      i2 && (i2.onstatechange = () => {
        const e10 = null == t2 ? void 0 : t2.iceTransport.state;
        var i3;
        e10 && (null === (i3 = this.onICETransportStateChange) || void 0 === i3 || i3.call(this, e10));
      }, i2.getSelectedCandidatePair && (i2.onselectedcandidatepairchange = () => {
        if (i2.getSelectedCandidatePair()) {
          const { local: e10, remote: t3 } = i2.getSelectedCandidatePair();
          fb.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify({ candidateType: e10.type, protocol: e10.protocol }), ", remote ").concat(JSON.stringify({ candidateType: t3.type, protocol: t3.protocol, address: t3.address, port: t3.port }), " )"));
        }
      }));
    }
  }
  tryUnbindTransportEvents() {
    this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
  }
  async updateRtpSenderEncodings(e9, t2) {
    var i2, n2;
    if (!t2) {
      const i3 = this.peerConnection.getSenders();
      t2 = i3.find((t3) => t3.track === e9._mediaStreamTrack);
    }
    if (!t2) return fb.warn("[".concat(e9.getTrackId(), "] no rtpSender found}"));
    if (this.isVP8Simulcast(e9)) return fb.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
    if (!ZP().supportSetRtpSenderParameters) return fb.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
    const r2 = {}, o2 = {};
    switch (e9._optimizationMode) {
      case "motion":
        r2.degradationPreference = "maintain-framerate";
        break;
      case "detail":
        r2.degradationPreference = "maintain-resolution";
        break;
      case "balanced":
        r2.degradationPreference = "balanced";
    }
    const s2 = function(e10, t3) {
      return e10.getTransceivers().find((e11) => e11.sender.track === t3 || e11.receiver.track === t3);
    }(this.peerConnection, e9._mediaStreamTrack), a2 = wk(e9);
    if (nB(e9) && s2 && t2 && a2 && this.getLocalVideoStats && Dn(i2 = ["vp8", "vp9"]).call(i2, this.store.codec)) {
      var c2;
      const i3 = r2.degradationPreference || (Dn(c2 = e9._hints).call(c2, mL.CUSTOM_TRACK) ? XA("CUSTOM_ADAPTATION_DEFAULT_MODE") : "maintain-framerate");
      !function(e10, t3, i4, n3, r3, o3) {
        if (oB(e10, i4), r3(t3), "balanced" !== n3 && "maintain-framerate" !== n3 && "maintain-resolution" !== n3) return;
        let s3 = -1;
        ZF(e10, t3);
        const a3 = window.setInterval(() => {
          const a4 = rB.get(e10);
          if (!XA("ENABLE_AG_ADAPTATION") || !a4) return oB(e10, i4), void r3(t3);
          const c4 = o3();
          if (c4.sendPackets > 0 && c4.OutgoingAvailableBandwidth > 0) {
            if (-1 === s3) return void (s3 = Date.now());
            if (Date.now() - s3 < 1e3) return;
            const o4 = c4.sendFrameRate, d3 = c4.OutgoingAvailableBandwidth, [l3, u3] = eB(e10, o4, d3, a4.adaptationConfig, t3, n3);
            u3 && (i4.qualityLimitationReason = u3), l3 && a4.adaptationConfig.scale !== l3.scale && (fb.debug("[".concat(e10, "] applyAdaptation: ").concat(i4.qualityLimitationReason, "\n           sendFps ").concat(o4, ", bwe ").concat(d3, ", switch from ").concat(a4.adaptationConfig.scale, " to ").concat(l3.scale, " ")), a4.adaptationConfig = iB(iB({}, a4.adaptationConfig), l3), r3(l3));
          }
        }, XA("CHECK_LOCAL_STATS_INTERVAL")), c3 = iB({}, t3);
        rB.set(e10, { timer: a3, adaptationConfig: c3, originConfig: t3, adaptationFunc: r3 }), fb.debug("[".concat(e10, "] start adaptation, originConfig: ").concat(JSON.stringify(t3), ", degradationPreference: ").concat(n3));
      }(this.id + s2.mid, a2, this, i3, (e10) => {
        t2 && this.updateAdaptation(t2, e10);
      }, this.getLocalVideoStats.bind(this));
    }
    if (e9._encoderConfig) {
      var d2;
      const { bitrateMax: t3, frameRate: i3, scaleResolutionDownBy: n3 } = e9._encoderConfig;
      t3 && (o2.maxBitrate = 1e3 * t3), (Dn(d2 = e9._hints).call(d2, mL.LOW_STREAM) || e9.isUseScaleResolutionDownBy) && (i3 && (o2.maxFramerate = QO(i3)), n3 && n3 >= 1 && (o2.scaleResolutionDownBy = n3));
    }
    const { maxFramerate: l2 } = XA("ENCODER_CONFIG_LIMIT");
    if (l2 && "number" == typeof l2 && (o2.maxFramerate = o2.maxFramerate ? Math.min(o2.maxFramerate, l2) : l2), XA("DSCP_TYPE") && Ey()) {
      var u2;
      const e10 = XA("DSCP_TYPE");
      Dn(u2 = ["very-low", "low", "medium", "high"]).call(u2, e10) && (o2.networkPriority = e10);
    }
    const h2 = t2.getParameters(), p2 = null === (n2 = h2.encodings) || void 0 === n2 ? void 0 : n2[0];
    Zv() && !p2 && (r2.encodings = [o2]), p2 && Object.assign(p2, o2), Object.assign(h2, r2), fb.debug("[".concat(e9.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(h2.encodings))), await t2.setParameters(h2), await async function(e10, t3, i3) {
      try {
        var n3;
        if (!ZP().supportSetRtpSenderParameters) return;
        if (!/* @__PURE__ */ function(e11) {
          return "vp9" === e11;
        }(e10) || !XA("ENABLE_SVC")) return;
        const r3 = {}, o3 = {}, s3 = t3.getParameters(), a3 = null === (n3 = s3.encodings) || void 0 === n3 ? void 0 : n3[0];
        o3.scalabilityMode = BU(i3), a3 && Object.assign(a3, o3), Object.assign(s3, r3), await t3.setParameters(s3), fb.debug("[updateAdaptation] updateRtpSenderEncodings scalabilityMode success: ".concat(JSON.stringify(s3.encodings)));
      } catch (e11) {
        fb.debug("[updateAdaptation] updateRtpSenderEncodings scalabilityMode failed", e11);
      }
    }(this.store.codec, t2, XA("SVC_MODE"));
  }
  async updateAdaptation(e9, t2) {
    var i2, n2;
    if (!e9) return fb.debug("[updateAdaptation] no rtpSender found");
    if (!ZP().supportSetRtpSenderParameters) return fb.debug("[updateAdaptation] Browser not support set rtp-sender parameters");
    const r2 = {}, { bitrateMax: o2, frameRate: s2, scaleResolutionDownBy: a2 } = t2;
    o2 && (r2.maxBitrate = 1e3 * o2), s2 && (r2.maxFramerate = QO(s2)), a2 && a2 >= 1 && Dn(i2 = ["vp8", "vp9"]).call(i2, this.store.codec) && (r2.scaleResolutionDownBy = a2);
    const c2 = e9.getParameters(), d2 = null === (n2 = c2.encodings) || void 0 === n2 ? void 0 : n2[0];
    d2 && Object.assign(d2, r2), Object.assign(c2, {});
    try {
      await e9.setParameters(c2), fb.debug("[updateAdaptation] updateRtpSenderEncodings: ".concat(JSON.stringify(c2.encodings)));
    } catch (t3) {
      !("transport" in e9) || e9.transport && "connected" === e9.transport.state ? "connected" !== this.peerConnectionState ? fb.debug("[updateAdaptation] peerConnection not connected}") : fb.debug("[updateAdaptation] updateRtpSenderEncodings failed", t3) : fb.debug("[updateAdaptation] rtpSender transport not connected}");
    }
  }
  async applySendEncodings(e9, t2) {
    try {
      if (!ZP().supportSetRtpSenderParameters) return;
      if (e9.length !== t2.length) return;
      for (let i2 = 0; i2 < e9.length; i2++) {
        const n2 = e9[i2], r2 = t2[i2];
        r2 instanceof aU && !this.isVP8Simulcast(r2) && await this.updateRtpSenderEncodings(r2, n2.sender);
      }
    } catch (e10) {
      fb.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
    }
  }
  mungSendOfferSDP(e9, t2, i2) {
    const n2 = FU.parse(e9);
    return t2.forEach((e10, t3) => {
      const r2 = i2[t3], o2 = n2.mediaDescriptions.find((e11) => e11.attributes.mid === r2);
      o2 && (JU(o2, e10), ex(o2, e10, this.store.codec));
    }), FU.print(n2);
  }
  bindStatsEvents() {
    this.statsFilter.onFirstAudioReceived = (e9) => {
      var t2;
      null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e9);
    }, this.statsFilter.onFirstVideoReceived = (e9) => {
      var t2;
      null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e9);
    }, this.statsFilter.onFirstAudioDecoded = (e9) => {
      var t2;
      null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e9);
    }, this.statsFilter.onFirstVideoDecoded = (e9, t2, i2) => {
      var n2;
      null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e9, t2, i2);
    }, this.statsFilter.onSelectedLocalCandidateChanged = (e9, t2) => {
      var i2;
      null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e9, t2);
    }, this.statsFilter.onSelectedRemoteCandidateChanged = (e9, t2) => {
      var i2;
      null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e9, t2);
    }, this.statsFilter.onFirstVideoDecodedTimeout = (e9) => {
      var t2;
      null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e9);
    };
  }
  unbindStatsEvents() {
    this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
  }
  async applySimulcastForFirefox(e9, t2) {
    if (e9.length === t2.length) for (let a2 = 0; a2 < e9.length; a2++) {
      var i2, n2, r2, o2, s2;
      const c2 = e9[a2], d2 = t2[a2];
      if (d2 instanceof aU && !Dn(i2 = d2._hints).call(i2, mL.LOW_STREAM) && null !== (n2 = d2._encoderConfig) && void 0 !== n2 && n2.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (o2 = d2._scalabilityMode) && void 0 !== o2 && o2.numSpatialLayers && (null === (s2 = d2._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
        const e10 = {}, t3 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
        e10.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
        const i3 = c2.sender.getParameters();
        await c2.sender.setParameters(Object.assign(i3, e10));
      }
    }
  }
  async applySimulcastEncodings(e9, t2) {
    if (!Zv() && e9.length === t2.length) for (let i2 = 0; i2 < e9.length; i2++) {
      const n2 = t2[i2];
      if (n2 instanceof aU && this.isVP8Simulcast(n2)) {
        const t3 = e9[i2], r2 = {}, o2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
        r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
        const s2 = t3.sender.getParameters();
        await t3.sender.setParameters(Object.assign(s2, r2));
      }
    }
  }
  isVP8Simulcast(e9) {
    var t2, i2, n2, r2, o2;
    return !!(e9 instanceof aU && XA("SIMULCAST") && "vp8" === this.store.codec && !Dn(t2 = e9._hints).call(t2, mL.LOW_STREAM) && null !== (i2 = e9._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n2 = e9._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = e9._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (o2 = e9._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1);
  }
  logSDPExchange(e9, t2, i2, n2) {
    if (XA("SDP_LOGGING")) return fb.upload("[".concat(this.store.clientId, "] exchanging ").concat(i2, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e9), "offer" === t2 ? (e10) => {
      this.logSDPExchange(e10, "answer", "local" === i2 ? "remote" : "local", n2);
    } : void 0;
  }
  async getRemoteSSRC(e9) {
    if (!this.remoteSDP) return;
    const t2 = this.remoteSDP.getSSRC(e9);
    return t2 && 0 !== t2.length ? t2[0].ssrcId : void 0;
  }
  setConfiguration(t2) {
    if (ZP().supportPCSetConfiguration) {
      const i2 = e8.resolvePCConfiguration(t2);
      this.peerConnection.setConfiguration(i2);
    }
  }
}, Cw(sB.prototype, "updateRemoteRTPCapabilities", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "updateRemoteRTPCapabilities"), sB.prototype), Cw(sB.prototype, "connect", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "connect"), sB.prototype), Cw(sB.prototype, "updateRemoteConnect", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "updateRemoteConnect"), sB.prototype), Cw(sB.prototype, "createDataChannels", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "createDataChannels"), sB.prototype), Cw(sB.prototype, "receive", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "receive"), sB.prototype), Cw(sB.prototype, "batchReceive", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "batchReceive"), sB.prototype), Cw(sB.prototype, "stopReceiving", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "stopReceiving"), sB.prototype), Cw(sB.prototype, "muteRemote", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "muteRemote"), sB.prototype), Cw(sB.prototype, "unmuteRemote", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "unmuteRemote"), sB.prototype), Cw(sB.prototype, "muteLocal", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "muteLocal"), sB.prototype), Cw(sB.prototype, "unmuteLocal", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "unmuteLocal"), sB.prototype), Cw(sB.prototype, "close", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "close"), sB.prototype), Cw(sB.prototype, "updateEncoderConfig", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "updateEncoderConfig"), sB.prototype), Cw(sB.prototype, "updateSendParameters", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "updateSendParameters"), sB.prototype), Cw(sB.prototype, "replaceTrack", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "replaceTrack"), sB.prototype), Cw(sB.prototype, "updateAdaptation", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "updateAdaptation"), sB.prototype), Cw(sB.prototype, "getRemoteSSRC", [lB], Object.getOwnPropertyDescriptor(sB.prototype, "getRemoteSSRC"), sB.prototype), sB);
function lB(e9, t2, i2) {
  const n2 = e9[t2];
  if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
  return i2.value = async function() {
    const e10 = this.mutex, i3 = await e10.lock("From P2PConnection.".concat(t2));
    try {
      for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
      return await n2.apply(this, o2);
    } finally {
      i3();
    }
  }, i2;
}
var uB;
function hB(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function pB(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? hB(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : hB(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
function _B(e9) {
  var t2, i2, n2, r2 = 2;
  for ("undefined" != typeof Symbol && (i2 = JI, n2 = Symbol.iterator); r2--; ) {
    if (i2 && null != (t2 = e9[i2])) return t2.call(e9);
    if (n2 && null != (t2 = e9[n2])) return new EB(t2.call(e9));
    i2 = "@@asyncIterator", n2 = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function EB(e9) {
  function t2(e10) {
    if (Object(e10) !== e10) return Gh.reject(new TypeError(e10 + " is not an object."));
    var t3 = e10.done;
    return Gh.resolve(e10.value).then(function(e11) {
      return { value: e11, done: t3 };
    });
  }
  return EB = function(e10) {
    this.s = e10, this.n = e10.next;
  }, EB.prototype = { s: null, n: null, next: function() {
    return t2(this.n.apply(this.s, arguments));
  }, return: function(e10) {
    var i2 = this.s.return;
    return void 0 === i2 ? Gh.resolve({ value: e10, done: true }) : t2(i2.apply(this.s, arguments));
  }, throw: function(e10) {
    var i2 = this.s.return;
    return void 0 === i2 ? Gh.reject(e10) : t2(i2.apply(this.s, arguments));
  } }, new EB(e9);
}
var fB = (uB = class extends xy {
  get state() {
    return this._state;
  }
  set state(e9) {
    const t2 = this._state;
    this._state = e9, this.emit(_O.StateChange, t2, this._state);
  }
  constructor(e9, t2) {
    super(), Fg(this, "isPlanB", void 0), Fg(this, "store", void 0), Fg(this, "statsUploader", void 0), Fg(this, "connection", void 0), Fg(this, "localTrackMap", /* @__PURE__ */ new Map()), Fg(this, "remoteUserMap", /* @__PURE__ */ new Map()), Fg(this, "localDataChannels", []), Fg(this, "remoteDataChannelMap", /* @__PURE__ */ new Map()), Fg(this, "pendingLocalTracks", []), Fg(this, "pendingRemoteTracks", []), Fg(this, "pendingLocalDataChannels", []), Fg(this, "pendingRemoteDataChannels", []), Fg(this, "statsCollector", void 0), Fg(this, "shouldForwardP2PCreation", void 0), Fg(this, "iceFailedCount", 0), Fg(this, "dtlsFailedCount", 0), Fg(this, "mutex", new NA("P2PChannel-mutex")), Fg(this, "_state", pO.Disconnected), Fg(this, "_pcStatsUploadType", XA("NEW_ICE_RESTART") ? uO.FIRST_CONNECTION : uO.OLD_FIRST_CONNECTION), Fg(this, "_isInRestartIce", false), Fg(this, "_isStartRestartIce", false), Fg(this, "_restartStates", ["disconnected", "failed"]), Fg(this, "_restartTimer", void 0), Fg(this, "_isFirstConnected", true), Fg(this, "handleMuteLocalTrack", async (e10, t3, i2) => {
      const n2 = await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");
      try {
        if (!this.connection || this.state !== pO.Connected) return void i2(new Cy(Ry.INVALID_OPERATION, "Cannot call P2PChannel.handleMuteLocalTrack before connection established."));
        const r2 = this.filterTobeMutedTracks(e10);
        if (0 === r2.length) return void t3();
        const o2 = r2.find((e11) => "videoLowTrack" === e11[0]);
        if (o2) {
          o2[1].track._originMediaStreamTrack.stop();
        }
        await this.connection.muteLocal(r2.map((e11) => {
          let [, { id: t4 }] = e11;
          return t4;
        }));
        const s2 = this.createMuteMessage(r2);
        await $y(this, _O.RequestMuteLocal, s2), t3();
      } catch (e11) {
        i2(e11);
      } finally {
        n2();
      }
    }), Fg(this, "handleUnmuteLocalTrack", async (e10, t3, i2) => {
      const n2 = await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");
      try {
        if (!this.connection || this.state !== pO.Connected) return void i2(new Cy(Ry.INVALID_OPERATION, "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));
        const r2 = this.filterTobeUnmutedTracks(e10);
        if (0 === r2.length) return void t3();
        const o2 = r2.find((e11) => "videoLowTrack" === e11[0]);
        if (o2) {
          const t4 = o2[1];
          if (t4.track._originMediaStreamTrack.stop(), !XA("DISABLE_DUAL_STREAM_USE_ENCODING") && ZP().supportDualStreamEncoding) {
            const i3 = e10._mediaStreamTrack.clone();
            t4.track._mediaStreamTrack = i3, t4.track._originMediaStreamTrack = i3;
          } else {
            const i3 = KV(e10, tA(this, _O.RequestLowStreamParameter));
            t4.track._mediaStreamTrack = i3, t4.track._originMediaStreamTrack = i3;
          }
          await new Gh((e11, i3) => {
            this.handleReplaceTrack(t4.track, e11, i3, true);
          });
        }
        await this.connection.unmuteLocal(r2.map((e11) => {
          let [, { id: t4 }] = e11;
          return t4;
        }));
        const s2 = this.createUnmuteMessage(r2);
        await $y(this, _O.RequestUnmuteLocal, s2), t3();
      } catch (e11) {
        i2(e11);
      } finally {
        n2();
      }
    }), Fg(this, "handleUpdateVideoEncoder", async (e10, t3, i2) => {
      const n2 = await this.mutex.lock("Locking from P2PChannel.handleSetVideoEncoder");
      try {
        const i3 = this.localTrackMap.get(hO.LocalVideoTrack);
        if (!this.connection || !i3 || i3.track !== e10 || this.state !== pO.Connected) return void t3();
        const { id: r2, track: o2 } = i3;
        await this.connection.updateSendParameters(r2, o2), await this.connection.updateEncoderConfig(r2, o2), this.emit(_O.UpdateVideoEncoder, o2), t3();
      } catch (e11) {
        i2(e11);
      } finally {
        n2();
      }
    }), Fg(this, "handleUpdateVideoSendParameters", async (e10, t3, i2) => {
      const n2 = await this.mutex.lock("Locking from P2PChannel.handleUpdateVideoSendParameters");
      try {
        const i3 = this.localTrackMap.get(hO.LocalVideoTrack);
        if (!this.connection || !i3 || i3.track !== e10 || this.state !== pO.Connected) return void t3();
        const { id: r2, track: o2 } = i3;
        await this.connection.updateSendParameters(r2, o2), t3();
      } catch (e11) {
        i2(e11);
      } finally {
        n2();
      }
    }), Fg(this, "handleReplaceMixingTrack", async (e10, t3, i2, n2) => {
      if (!this.connection || this.state !== pO.Connected) return void t3();
      const r2 = hF([e10]);
      let o2;
      fb.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will replace audioTrack [").concat(r2.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (o2 = await this.mutex.lock("From P2PChannel.handleReplaceMixingTrack"));
      try {
        await this.replaceTrack(e10, r2), t3();
      } catch (e11) {
        i2(e11);
      } finally {
        var s2;
        null === (s2 = o2) || void 0 === s2 || s2();
      }
    }), Fg(this, "handleReplaceTrack", async (e10, t3, i2, n2) => {
      let r2;
      fb.debug("[".concat(this.store.clientId, "] P2PChannel handleReplaceTrack for [track-id-").concat(e10.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (r2 = await this.mutex.lock("From P2PChannel.handleReplaceTrack"));
      try {
        var o2;
        const i3 = Array.from(this.localTrackMap.entries()).find((t4) => {
          let [, { track: i4 }] = t4;
          return e10 === i4;
        });
        if (!this.connection || !i3 || this.state !== pO.Connected) return void t3();
        if (await (null === (o2 = this.connection) || void 0 === o2 ? void 0 : o2.replaceTrack(e10, i3[1].id)), this.isPlanB) {
          const t4 = i3[1];
          t4.id = e10._mediaStreamTrack.id, this.localTrackMap.set(i3[0], t4);
        }
        if (i3[0] === hO.LocalVideoTrack && !XA("DISABLE_DUAL_STREAM_USE_ENCODING") && ZP().supportDualStreamEncoding) {
          const t4 = this.localTrackMap.get(hO.LocalVideoLowTrack);
          if (t4) {
            const i4 = e10._mediaStreamTrack.clone();
            t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = i4, t4.track._originMediaStreamTrack = i4, await new Gh((e11, i5) => {
              this.handleReplaceTrack(t4.track, e11, i5, true);
            });
          }
        }
        t3();
      } catch (e11) {
        i2(e11);
      } finally {
        var s2;
        null === (s2 = r2) || void 0 === s2 || s2();
      }
    }), Fg(this, "handleGetRTCStats", (e10) => {
      e10(this.statsCollector.getRTCStats());
    }), Fg(this, "handleGetLocalVideoStats", (e10) => {
      e10(this.statsCollector.getLocalVideoTrackStats());
    }), Fg(this, "handleGetLocalAudioStats", (e10) => {
      e10(this.statsCollector.getLocalAudioTrackStats());
    }), Fg(this, "handleGetRemoteVideoStats", (e10) => this.statsCollector.getRemoteVideoTrackStats(e10.uid)[e10.uid]), Fg(this, "handleGetRemoteAudioStats", (e10) => this.statsCollector.getRemoteAudioTrackStats(e10.uid)[e10.uid]), this.store = e9, this.statsCollector = t2, this.statsCollector.addP2PChannel(this), this.statsUploader = new aF(this.store), this.bindStatsUploaderEvents(), this.isPlanB = !ZP().supportUnifiedPlan || XA("CHROME_FORCE_PLAN_B") && Ey(), this.shouldForwardP2PCreation = XA("FORWARD_P2P_CREATION") && ZP().supportPCSetConfiguration && _y(), this.shouldForwardP2PCreation && (this.connection = this.isPlanB ? new FF({}, this.store) : new dB({}, this.store), this.bindConnectionEvents(this.connection));
  }
  async startP2PConnection(e9) {
    var t2;
    this.state = pO.New;
    const i2 = this.shouldForwardP2PCreation && "closed" === (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.peerConnectionState);
    if (this.shouldForwardP2PCreation && !i2 || (i2 && this.connection && (fb.warning("[".concat(this.store.clientId, "] P2PChannel.startP2PConnection ForwardP2P closed.")), this.connection.close(), this.unbindConnectionEvents(this.connection)), this.connection = this.isPlanB ? new FF(e9, this.store) : new dB(e9, this.store), this.bindConnectionEvents(this.connection)), !this.connection) throw new Cy(Ry.UNEXPECTED_ERROR, "Cannot P2PChannel.startConnection before P2PConnection initialization .");
    return this._pcStatsUploadType = XA("NEW_ICE_RESTART") ? uO.FIRST_CONNECTION : uO.OLD_FIRST_CONNECTION, this._isFirstConnected = true, this._isInRestartIce = false, this._isStartRestartIce = false, this.connection.setConfiguration(e9), this.connection.establishPromise;
  }
  async connect(e9) {
    if (!this.connection) throw new Cy(Ry.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
    XA("ENABLE_PREALLOC_PC") && this.state === pO.Connected ? await this.connection.updateRemoteConnect(e9) : (this.store.peerConnectionStart(), await this.connection.connect(e9), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = pO.Connected);
  }
  updateRemoteRTPCapabilities(e9) {
    const t2 = Array.from(this.localTrackMap.entries()).filter((e10) => {
      var t3;
      let [i3] = e10;
      return Dn(t3 = [hO.LocalVideoLowTrack, hO.LocalVideoTrack]).call(t3, i3);
    }), i2 = t2.map((e10) => {
      let [, { id: t3 }] = e10;
      return t3;
    }), n2 = t2.map((e10) => {
      let [t3] = e10;
      return t3;
    });
    if (this.connection instanceof dB) {
      if (vb.updateRemoteRTPCapabilities(this.store.sessionId, { trackTypes: JSON.stringify(n2), localCodecs: JSON.stringify(this.connection.localCodecs), remoteCodecs: JSON.stringify(e9) }), !Dn(e9).call(e9, this.store.codec)) {
        const t3 = ["vp9", "vp8", "h264"].find((t4) => Dn(e9).call(e9, t4));
        t3 && (this.store.codec = t3, fb.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, " updateRemoteRTPCapabilities] default codec is not available, hence the fallback to ").concat(t3, ".")));
      }
      this.connection.updateRemoteRTPCapabilities(i2, e9);
    }
  }
  async getEstablishParams() {
    var e9;
    if (this.connection instanceof dB && "closed" !== this.connection.peerConnectionState && Dn(e9 = [pO.New, pO.Connected]).call(e9, this.state)) return this.connection.establishPromise;
  }
  async publishDataChannel(e9) {
    if (!this.connection || this.state !== pO.Connected) {
      if (this.state === pO.Disconnected) throw new Cy(Ry.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
      return e9.forEach((e10) => {
        var t3;
        Dn(t3 = this.pendingLocalDataChannels).call(t3, e10) || this.pendingLocalDataChannels.push(e10);
      }), [];
    }
    const t2 = this.filterTobePublishedDataChannels(e9);
    return 0 === t2.length ? [] : (t2.forEach((e10) => {
      const t3 = Date.now();
      this.store.publish(e10.id.toString(), "datachannel", t3);
    }), await this.connection.createDataChannels(this.store.uid, t2), t2.forEach((e10) => {
      this.localDataChannels.push(e10);
      const t3 = Date.now();
      this.store.publish(e10.id + "", "datachannel", void 0, t3);
    }), e9.map((e10) => ({ streamId: e10.id, ordered: e10.ordered, maxRetransmits: e10.maxRetransmits, metadata: e10.metadata, channelId: e10._originDataChannelId })));
  }
  publish(e9, t2, i2) {
    var n2 = this;
    return YI(function* () {
      const r2 = yield qI(n2.mutex.lock("From P2PChannel.publish"));
      try {
        if (!n2.connection || n2.state !== pO.Connected) {
          if (n2.state === pO.Disconnected) throw new Cy(Ry.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
          n2.throwIfTrackTypeNotMatch(e9);
          const t3 = e9.filter((e10) => -1 === n2.pendingLocalTracks.indexOf(e10));
          return void (n2.pendingLocalTracks = n2.pendingLocalTracks.concat(t3));
        }
        n2.store.pubId = n2.store.pubId + 1, rV.markPublishStart(n2.store.clientId, n2.store.pubId);
        const o2 = n2.filterTobePublishedTracks(e9, t2, i2);
        if (0 === o2.length) return void (yield qI(n2.tryToUnmuteAudio(e9)));
        yield* zI(_B(n2.doPublish(n2.connection, o2)));
      } finally {
        r2();
      }
    })();
  }
  doPublish(e9, t2) {
    var i2 = this;
    return YI(function* () {
      t2.forEach((e10) => {
        let { track: t3, type: n3 } = e10;
        const r3 = Date.now();
        i2.store.publish(t3.getTrackId(), n3 === hO.LocalAudioTrack ? "audio" : "video", r3);
      }), i2.bindLocalTrackEvents(t2);
      const n2 = t2.map((e10) => {
        let { track: t3 } = e10;
        return t3;
      }), r2 = yield qI(e9.send(n2, i2.store.codec, i2.store.audioCodec)), o2 = (yield qI(r2.next())).value, s2 = i2.createGatewayPublishMessage(t2, o2);
      let a2;
      try {
        a2 = yield s2;
      } catch (e10) {
        throw r2.throw(e10), (null == e10 ? void 0 : e10.code) === Ry.WS_ABORT && t2.forEach((e11) => {
          let { track: t3 } = e11;
          -1 === i2.pendingLocalTracks.indexOf(t3) && i2.pendingLocalTracks.push(t3);
        }), i2.unbindLocalTrackEvents(t2), e10;
      }
      const c2 = i2.mapPubResToRemoteConfig(s2, a2, n2), d2 = (yield qI(r2.next(c2))).value, l2 = XA("ENABLE_VIDEO_SEI");
      n2.forEach(async (e10) => {
        const t3 = e10.getRTCRtpTransceiver();
        t3 && l2 && (e10.trackMediaType === dO.VIDEO ? await kU(t3.sender, e10) : e10.trackMediaType === dO.AUDIO && await async function(e11) {
          if (!ZP().supportWebRTCEncodedTransform) return void fb.warning("browser not support audio encoded transform");
          if (NU.has(e11)) return;
          if (!e11.track) return;
          const t4 = { track: e11.track };
          if (Jv()) {
            if (!e11.createEncodedStreams) return void fb.warning("browser not support createEncodedStreams() API");
            let n3 = null;
            try {
              n3 = e11.createEncodedStreams();
            } catch (e12) {
              return void fb.error("create audio-encoded-streams error", e12 && e12.message);
            }
            const r3 = new TransformStream({ transform(n4, r4) {
              t4.controller || (t4.controller = r4), e11.track && e11.track.id !== t4.track.id && (fb.debug("audio track changed: ".concat(t4.track.id, " => ").concat(e11.track.id)), t4.track.removeEventListener("ended", i3), t4.track = e11.track, t4.track.addEventListener("ended", i3)), r4.enqueue(n4);
            } });
            n3.readable.pipeThrough(r3).pipeTo(n3.writable);
          } else if (Xv()) {
            if ("undefined" == typeof RTCRtpScriptTransform) return void fb.warning("browser not support RTCRtpScriptTransform");
            const n3 = OU(), r3 = new MessageChannel();
            await new Gh((e12) => n3.onmessage = (t5) => {
              "registered" === t5.data && e12(void 0);
            });
            const o3 = new RTCRtpScriptTransform(n3, { name: "tx", port: r3.port2 }, [r3.port2]);
            e11.transform = o3, await new Gh((e12) => n3.onmessage = (t5) => {
              "started" === t5.data && e12(void 0);
            }), r3.port1.onmessage = (n4) => {
              var r4;
              n4.data.transformed && e11.track && (null === (r4 = e11.track) || void 0 === r4 ? void 0 : r4.id) !== t4.track.id && (fb.debug("audio track changed: ".concat(t4.track.id, " => ").concat(e11.track.id)), t4.track.removeEventListener("ended", i3), t4.track = e11.track, t4.track.addEventListener("ended", i3));
            }, t4.worker = n3;
          }
          function i3() {
            if (e11.track) {
              if (this.id !== e11.track.id) return;
              e11.track.removeEventListener("ended", i3);
            }
            const t5 = NU.get(e11);
            if (t5) {
              NU.delete(e11);
              try {
                var n3, r3;
                null === (n3 = t5.controller) || void 0 === n3 || n3.terminate(), null === (r3 = t5.worker) || void 0 === r3 || r3.terminate();
              } catch (e12) {
                fb.warning(e12 && e12.message);
              }
            }
          }
          NU.set(e11, t4), e11.track.addEventListener("ended", i3);
        }(t3.sender));
      }), t2.forEach((e10) => {
        let { type: t3 } = e10;
        i2.statsCollector.addLocalStats(t3);
      }), i2.assignLocalTracks(t2, d2), i2.statsUploader.startUploadOutboundStats(), t2.forEach((e10) => {
        let { track: t3, type: n3 } = e10;
        const r3 = Date.now();
        i2.store.publish(t3.getTrackId(), n3 === hO.LocalAudioTrack ? "audio" : "video", void 0, r3);
      });
    })();
  }
  async updateVideoStreamParameter(e9, t2) {
    const i2 = this.localTrackMap.get(t2);
    if (!i2) return;
    if (!(i2.track instanceof aU)) return fb.warn("[updateVideoStreamParameter]: track is not an instance of LocalVideoTrack");
    if (!(this.connection instanceof dB || this.connection instanceof FF)) return fb.warn("[updateVideoStreamParameter]: connection is not P2PConnection or P2PConnectionPlanB");
    const { track: n2 } = i2, r2 = function(e10, t3) {
      const i3 = {};
      return e10.height && e10.width && (i3.scaleResolutionDownBy = iN(e10, t3)), i3.maxFramerate = e10.framerate ? QO(e10.framerate) : void 0, i3.maxBitrate = e10.bitrate ? 1e3 * e10.bitrate : void 0, i3;
    }(e9, n2);
    if (n2._encoderConfig || (n2._encoderConfig = {}), t2 !== hO.LocalVideoLowTrack || !XA("DISABLE_DUAL_STREAM_USE_ENCODING") && ZP().supportDualStreamEncoding) null != r2.scaleResolutionDownBy && (n2._encoderConfig.scaleResolutionDownBy = r2.scaleResolutionDownBy);
    else {
      const t3 = n2._originMediaStreamTrack;
      if (!t3.canvas) return fb.warn("[".concat(n2.getTrackId(), "] no canvas on track"));
      !function(e10, t4) {
        const i3 = e10.canvas;
        t4.width && (i3.width = QO(t4.width)), t4.height && (i3.height = QO(t4.height)), t4.framerate && (i3.stopCapture && i3.stopCapture(), i3.stopCapture = QL(() => {
          !i3.startCapture && i3.stopCapture && i3.stopCapture(), i3.startCapture && i3.startCapture();
        }, QO(t4.framerate)));
      }(t3, e9);
    }
    null != r2.maxBitrate && (n2._encoderConfig.bitrateMax = r2.maxBitrate / 1e3), null != r2.maxFramerate && (n2._encoderConfig.frameRate && "object" == typeof n2._encoderConfig.frameRate ? n2._encoderConfig.frameRate.max = r2.maxFramerate : n2._encoderConfig.frameRate = { max: r2.maxFramerate }), fb.debug("[".concat(n2.getTrackId(), "] LowStreamEncoderConfig: , ").concat(JSON.stringify(n2._encoderConfig))), await this.connection.updateRtpSenderEncodings(n2);
  }
  publishLowStream(e9) {
    var t2 = this;
    return YI(function* () {
      if (!t2.connection || t2.state !== pO.Connected) return;
      const i2 = yield qI(t2.mutex.lock("Locking from P2PChannel.publishLowStream"));
      try {
        const r2 = t2.localTrackMap.get(hO.LocalVideoTrack);
        if (!r2) throw new Cy(Ry.UNEXPECTED_ERROR, "Could not find high stream");
        if (t2.localTrackMap.has(hO.LocalVideoLowTrack)) throw new Cy(Ry.UNEXPECTED_ERROR, "[".concat(t2.store.clientId, "] Can't publish low stream when stream already publish"));
        const o2 = [{ track: t2.getLowVideoTrack(r2.track, e9), type: hO.LocalVideoLowTrack }];
        if (yield* zI(_B(t2.doPublish(t2.connection, o2))), r2.track.muted || !r2.track.enabled) {
          var n2;
          const e10 = null === (n2 = t2.localTrackMap.get(hO.LocalVideoLowTrack)) || void 0 === n2 ? void 0 : n2.id;
          void 0 !== e10 && (yield qI(t2.connection.muteLocal([e10])));
        }
      } finally {
        i2();
      }
    })();
  }
  async republish() {
    this.pendingLocalTracks.length > 0 && (fb.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await Zy(this, _O.RequestRePublish, this.pendingLocalTracks), this.emit(_O.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []), this.pendingLocalDataChannels.length > 0 && (fb.debug("Emit P2PChannelEvents.RequestRePublishDataChannel to republish datachannels."), await Zy(this, _O.RequestRePublishDataChannel, this.pendingLocalDataChannels), this.pendingLocalDataChannels = []);
  }
  async reSubscribe(e9) {
    for (let e10 = this.pendingRemoteTracks.length - 1; e10 >= 0; e10--) {
      const { user: t2, kind: i2 } = this.pendingRemoteTracks[e10];
      (i2 !== dO.AUDIO || t2._audio_added_ && t2._audioSSRC) && (i2 !== dO.VIDEO || t2._video_added_ && t2._videoSSRC) || this.pendingRemoteTracks.splice(e10, 1);
    }
    if (e9) await Zy(this, _O.RequestReSubscribe, this.pendingRemoteTracks);
    else for (const { user: e10, kind: t2 } of this.pendingRemoteTracks) await this.subscribe(e10, t2, t2 === dO.VIDEO ? e10._videoSSRC : e10._audioSSRC);
    this.pendingRemoteTracks.forEach((e10) => {
      let { user: t2 } = e10;
      this.emit(_O.MediaReconnectEnd, t2.uid);
    }), this.pendingRemoteTracks = [];
  }
  async unpublish(e9) {
    if (!this.connection || this.state !== pO.Connected) return void e9.forEach((e10) => {
      const t3 = this.pendingLocalTracks.indexOf(e10);
      -1 !== t3 && this.pendingLocalTracks.splice(t3, 1);
    });
    const t2 = this.filterTobeUnpublishedTracks(e9);
    if (0 === t2.length) return;
    const i2 = t2.find((e10) => "videoLowTrack" === e10[0]);
    if (i2) {
      i2[1].track.close();
    }
    return this.doUnpublish(this.connection, t2);
  }
  async unpublishDataChannel(e9) {
    if (!this.connection || this.state !== pO.Connected) return void e9.forEach((e10) => {
      const t3 = this.pendingLocalDataChannels.indexOf(e10);
      -1 !== t3 && this.pendingLocalDataChannels.splice(t3, 1);
    });
    const t2 = this.filterTobeUnpublishedDataChannels(e9);
    return 0 !== t2.length ? (t2.forEach((e10) => {
      const t3 = this.localDataChannels.indexOf(e10);
      -1 !== t3 && this.localDataChannels.splice(t3, 1);
    }), 0 === this.localDataChannels.length && await this.connection.stopDataChannels(this.store.uid), t2.map((e10) => e10.id)) : void 0;
  }
  async unpublishLowStream() {
    if (!this.connection || this.state !== pO.Connected) return;
    const e9 = this.localTrackMap.get(hO.LocalVideoLowTrack);
    if (!e9) return;
    e9.track.close();
    const t2 = [[hO.LocalVideoLowTrack, e9]];
    return this.doUnpublish(this.connection, t2);
  }
  async doUnpublish(e9, t2) {
    const i2 = this.createGatewayUnpublishMessage(t2);
    return await e9.stopSending(t2.map((e10) => {
      let [, { id: t3 }] = e10;
      return t3;
    })), this.withdrawLocalTracks(t2), this.unbindLocalTrackEvents(t2.map((e10) => {
      let [t3, { track: i3 }] = e10;
      return { type: t3, track: i3 };
    })), t2.forEach((e10) => {
      let [t3] = e10;
      this.statsCollector.removeLocalStats(t3);
    }), 0 === this.localTrackMap.size && this.statsUploader.stopUploadOutboundStats(), i2;
  }
  async subscribeDataChannel(e9, t2) {
    if (!this.connection || this.state !== pO.Connected) throw new Cy(Ry.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
    const i2 = t2.filter((t3) => {
      var i3;
      return !(null !== (i3 = this.remoteDataChannelMap.get(e9)) && void 0 !== i3 && i3.get(t3.id));
    });
    if (0 !== i2.length) return await this.connection.createDataChannels(e9.uid, i2), i2.forEach((t3) => {
      var i3;
      this.remoteDataChannelMap.has(e9) ? null === (i3 = this.remoteDataChannelMap.get(e9)) || void 0 === i3 || i3.set(t3.id, t3) : this.remoteDataChannelMap.set(e9, /* @__PURE__ */ new Map([[t3.id, t3]]));
      const n2 = this.pendingRemoteDataChannels.findIndex((i4) => {
        let { user: n3, id: r2 } = i4;
        return n3.uid === e9.uid && r2 === t3.id;
      });
      -1 !== n2 && this.pendingRemoteDataChannels.splice(n2, 1);
    }), i2.map((e10) => e10.id);
  }
  async subscribe(e9, t2, i2, n2, r2) {
    var o2;
    if (!this.connection || this.state !== pO.Connected) throw new Cy(Ry.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
    if (null !== (o2 = this.remoteUserMap.get(e9)) && void 0 !== o2 && o2.has(t2)) return;
    let s2, a2, c2;
    const d2 = this.connection.getPreMedia(i2);
    if (d2) fb.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] preSSRCMap has ssrcId: ").concat(i2, ", no need to send sub to gateway.")), c2 = d2.transceiver, s2 = d2.track, a2 = d2.id;
    else if (r2) {
      const i3 = r2.find((e10) => {
        let { stream_type: i4 } = e10;
        return i4 === t2;
      });
      if (!i3) throw new Cy(Ry.UNEXPECTED_ERROR, "Cannot subscribe to remote ".concat(t2, " for user: ").concat(e9.uid, " because subscribe answer from gateway does not contain stream_type: ").concat(t2, "."));
      const n3 = await this.connection.receive(t2, i3.ssrcs, String(e9._uintid), i3.attributes);
      this.connection instanceof dB && (c2 = n3.transceiver), s2 = n3.track, a2 = n3.id;
    } else {
      const r3 = await this.connection.receive(t2, [{ ssrcId: i2, rtx: n2 }], String(e9._uintid), void 0);
      this.connection instanceof dB && (c2 = r3.transceiver), s2 = r3.track, a2 = r3.id;
    }
    t2 === dO.AUDIO ? (e9._audioTrack ? e9._audioTrack._updateOriginMediaStreamTrack(s2) : (e9._audioTrack = new vU(s2, e9.uid, e9._uintid, this.store), fb.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e9._audioTrack.getTrackId()))), c2 && e9._audioTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e9, e9._audioTrack)) : (e9._videoTrack ? e9._videoTrack._updateOriginMediaStreamTrack(s2) : (e9._videoTrack = new IU(s2, e9.uid, e9._uintid, this.store), fb.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e9._videoTrack.getTrackId()))), c2 && e9._videoTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e9, e9._videoTrack)), XA("ENABLE_VIDEO_SEI") && c2 && (t2 == dO.VIDEO ? await async function(e10) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      if (!ZP().supportWebRTCEncodedTransform) return void fb.warning("browser not support video encoded transform");
      if (!e10.track) return;
      if (MU.has(e10)) {
        const i4 = MU.get(e10);
        return void (i4 && (i4.onSei = t3.onSei));
      }
      const i3 = { track: e10.track, onSei: t3.onSei };
      if (Jv()) {
        if (!e10.createEncodedStreams) return void fb.warning("browser not support createEncodedStreams() API");
        let t4 = null;
        try {
          t4 = e10.createEncodedStreams();
        } catch (e11) {
          return void fb.error("create video-encoded-streams error", e11 && e11.message);
        }
        const r3 = new TransformStream({ transform(t5, r4) {
          i3.controller || (i3.controller = r4), e10.track && e10.track.id !== i3.track.id && (fb.debug("video track changed: ".concat(i3.track.id, " => ").concat(e10.track.id)), i3.track.removeEventListener("ended", n3), i3.track = e10.track, i3.track.addEventListener("ended", n3));
          const o3 = function(e11) {
            const t6 = new DataView(e11.data);
            let i4 = 0;
            for (; i4 + 4 < e11.data.byteLength; ) {
              if (0 === t6.getUint8(i4 + 0) && 0 === t6.getUint8(i4 + 1) && 0 === t6.getUint8(i4 + 2) && 1 === t6.getUint8(i4 + 3) && 6 === t6.getUint8(i4 + 4)) {
                let n4 = i4 + 6, r5 = 0, o4 = 0;
                for (; 255 === (o4 = t6.getUint8(n4++)); ) r5 += 255;
                r5 += o4;
                const s3 = PU(e11.data, n4, r5);
                return new Uint8Array(s3);
              }
              i4++;
            }
            return null;
          }(t5);
          o3 && i3.onSei && i3.onSei(o3), r4.enqueue(t5);
        } });
        t4.readable.pipeThrough(r3).pipeTo(t4.writable);
      } else if (Xv()) {
        if ("undefined" == typeof RTCRtpScriptTransform) return void fb.warning("browser not support RTCRtpScriptTransform");
        const t4 = OU(), r3 = new MessageChannel();
        await new Gh((e11) => t4.onmessage = (t5) => {
          "registered" === t5.data && e11(void 0);
        });
        const o3 = new RTCRtpScriptTransform(t4, { name: "rx", port: r3.port2 }, [r3.port2]);
        e10.transform = o3, await new Gh((e11) => t4.onmessage = (t5) => {
          "started" === t5.data && e11(void 0);
        }), r3.port1.onmessage = (t5) => {
          var r4;
          t5.data.transformed && e10.track && (null === (r4 = e10.track) || void 0 === r4 ? void 0 : r4.id) !== i3.track.id ? (fb.debug("video track changed: ".concat(i3.track.id, " => ").concat(e10.track.id)), i3.track.removeEventListener("ended", n3), i3.track = e10.track, i3.track.addEventListener("ended", n3)) : t5.data.sei && i3.onSei && i3.onSei(t5.data.sei);
        }, i3.worker = t4;
      }
      function n3() {
        if (e10.track) {
          if (this.id !== e10.track.id) return;
          e10.track.removeEventListener("ended", n3);
        }
        !function(e11) {
          const t4 = MU.get(e11);
          if (t4) {
            MU.delete(e11);
            try {
              var i4, n4;
              null === (i4 = t4.controller) || void 0 === i4 || i4.terminate(), null === (n4 = t4.worker) || void 0 === n4 || n4.terminate();
            } catch (e12) {
              fb.warning(e12 && e12.message);
            }
          }
        }(e10);
      }
      MU.set(e10, i3), e10.track.addEventListener("ended", n3);
    }(c2.receiver, { onSei: (t3) => {
      var i3;
      null === (i3 = e9._videoTrack) || void 0 === i3 || i3._onSei(t3);
    } }) : t2 == dO.AUDIO && await async function(e10) {
      if (!ZP().supportWebRTCEncodedTransform) return void fb.warning("browser not support audio encoded transform");
      if (DU.has(e10)) return;
      const t3 = { track: e10.track };
      if (Jv()) {
        if (!e10.createEncodedStreams) return void fb.warning("browser not support createEncodedStreams() API");
        let n3 = null;
        try {
          n3 = e10.createEncodedStreams();
        } catch (e11) {
          return void fb.error("create audio-encoded-streams error", e11 && e11.message);
        }
        const r3 = new TransformStream({ transform(n4, r4) {
          t3.controller || (t3.controller = r4), e10.track && e10.track.id !== t3.track.id && (fb.debug("audio track changed: ".concat(t3.track.id, " => ").concat(e10.track.id)), t3.track.removeEventListener("ended", i3), t3.track = e10.track, t3.track.addEventListener("ended", i3)), r4.enqueue(n4);
        } });
        n3.readable.pipeThrough(r3).pipeTo(n3.writable);
      } else if (Xv()) {
        if ("undefined" == typeof RTCRtpScriptTransform) return void fb.warning("browser not support RTCRtpScriptTransform");
        const n3 = OU(), r3 = new MessageChannel();
        await new Gh((e11) => n3.onmessage = (t4) => {
          "registered" === t4.data && e11(void 0);
        });
        const o3 = new RTCRtpScriptTransform(n3, { name: "rx", port: r3.port2 }, [r3.port2]);
        e10.transform = o3, await new Gh((e11) => n3.onmessage = (t4) => {
          "started" === t4.data && e11(void 0);
        }), r3.port1.onmessage = (n4) => {
          var r4;
          n4.data.transformed && e10.track && (null === (r4 = e10.track) || void 0 === r4 ? void 0 : r4.id) !== t3.track.id && (fb.debug("audio track changed: ".concat(t3.track.id, " => ").concat(e10.track.id)), t3.track.removeEventListener("ended", i3), t3.track = e10.track, t3.track.addEventListener("ended", i3));
        }, t3.worker = n3;
      }
      function i3() {
        e10.track.removeEventListener("ended", i3), function(e11) {
          const t4 = DU.get(e11);
          if (t4) {
            DU.delete(e11);
            try {
              var i4, n3;
              null === (i4 = t4.controller) || void 0 === i4 || i4.terminate(), null === (n3 = t4.worker) || void 0 === n3 || n3.terminate();
            } catch (e12) {
              fb.warning(e12 && e12.message);
            }
          }
        }(e10);
      }
      DU.set(e10, t3), e10.track.addEventListener("ended", i3);
    }(c2.receiver));
    const l2 = this.remoteUserMap.get(e9);
    l2 ? l2.set(t2, a2) : this.remoteUserMap.set(e9, /* @__PURE__ */ new Map([[t2, a2]])), this.statsCollector.addRemoteStats(e9.uid), this.statsUploader.startUploadInboundStats();
    const u2 = this.pendingRemoteTracks.findIndex((i3) => {
      let { user: n3, kind: r3 } = i3;
      return n3.uid === e9.uid && t2 === r3;
    });
    -1 !== u2 && (this.pendingRemoteTracks.splice(u2, 1), this.emit(_O.MediaReconnectEnd, e9.uid));
  }
  async massSubscribe(e9) {
    return this.massSubscribeNoLock(e9);
  }
  async massSubscribeNoLock(e9) {
    if (!this.connection || this.state !== pO.Connected) throw new Cy(Ry.INVALID_OPERATION, "Cannot subscribeAll remote users when peerConnection disconnected.");
    e9 = e9.filter((e10) => {
      var t3;
      let { user: i3, mediaType: n3 } = e10;
      return !(null !== (t3 = this.remoteUserMap.get(i3)) && void 0 !== t3 && t3.has(n3));
    });
    const t2 = [], i2 = /* @__PURE__ */ new Map();
    e9.forEach((e10) => {
      if (!this.connection) return;
      const n3 = this.connection.getPreMedia(e10.ssrcId);
      n3 ? i2.set(e10.ssrcId, n3) : t2.push(e10);
    });
    const n2 = await this.connection.batchReceive(t2.map((e10) => {
      let { user: t3, mediaType: i3, ssrcId: n3, rtxSsrcId: r2 } = e10;
      return { kind: i3, ssrcMsg: [{ ssrcId: n3, rtx: r2 }], mslabel: String(t3._uintid) };
    }));
    t2.forEach((e10, t3) => {
      i2.set(e10.ssrcId, n2[t3]);
    }), e9.forEach((e10) => {
      let { user: t3, mediaType: n3, ssrcId: r2 } = e10;
      const o2 = i2.get(r2);
      if (!o2) return void fb.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] cannot find ").concat(t3.uid, " subscribe data,").concat(n3, ", ").concat(r2));
      const { track: s2, id: a2, transceiver: c2 } = o2;
      n3 === dO.AUDIO ? (t3._audioTrack ? t3._audioTrack._updateOriginMediaStreamTrack(s2) : (t3._audioTrack = new vU(s2, t3.uid, t3._uintid, this.store), fb.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(t3._audioTrack.getTrackId()))), c2 && t3._audioTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(t3, t3._audioTrack)) : (t3._videoTrack ? t3._videoTrack._updateOriginMediaStreamTrack(s2) : (t3._videoTrack = new IU(s2, t3.uid, t3._uintid, this.store), fb.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(t3._videoTrack.getTrackId()))), c2 && t3._videoTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(t3, t3._videoTrack));
      const d2 = this.remoteUserMap.get(t3);
      d2 ? d2.set(n3, a2) : this.remoteUserMap.set(t3, /* @__PURE__ */ new Map([[n3, a2]])), this.statsCollector.addRemoteStats(t3.uid), this.statsUploader.startUploadInboundStats();
      const l2 = this.pendingRemoteTracks.findIndex((e11) => {
        let { user: i3, kind: r3 } = e11;
        return i3.uid === t3.uid && n3 === r3;
      });
      -1 !== l2 && (this.pendingRemoteTracks.splice(l2, 1), this.emit(_O.MediaReconnectEnd, t3.uid));
    });
  }
  async unsubscribe(e9, t2, i2) {
    const n2 = this.pendingRemoteTracks.filter((i3) => {
      let { user: n3, kind: r3 } = i3;
      return void 0 !== t2 ? n3.uid === e9.uid && t2 === r3 : n3.uid === e9.uid;
    });
    if (n2.forEach((e10) => {
      const t3 = this.pendingRemoteTracks.indexOf(e10);
      this.pendingRemoteTracks.splice(t3, 1);
    }), this.connection && this.state === pO.Connected || i2 || n2.forEach((t3) => {
      let { kind: i3 } = t3;
      var n3;
      if (i3 === dO.AUDIO) null === (n3 = e9._audioTrack) || void 0 === n3 || n3._destroy(), e9._audioTrack = void 0;
      else if (i3 === dO.VIDEO) {
        var r3;
        null === (r3 = e9._videoTrack) || void 0 === r3 || r3._destroy(), e9._videoTrack = void 0;
      }
    }), !this.connection || this.state !== pO.Connected) return;
    const r2 = this.filterTobeUnSubscribedTracks(e9, t2);
    if (0 === r2.length) return;
    await this.connection.stopReceiving(r2.map((e10) => {
      let [, { id: t3 }] = e10;
      return t3;
    }));
    const o2 = this.createUnsubscribeMessage(r2);
    return this.withdrawRemoteTracks(r2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadInboundStats(), r2.forEach((e10) => {
      let [t3, { kind: n3 }] = e10;
      var r3, o3;
      n3 === dO.VIDEO && t3._videoSSRC && (null === (r3 = this.connection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
      if (n3 === dO.VIDEO) this.unbindRemoteTrackEvents(t3._videoTrack), i2 || (null === (o3 = t3._videoTrack) || void 0 === o3 || o3._destroy(), t3._videoTrack = void 0);
      else if (n3 === dO.AUDIO) {
        var s2;
        if (this.unbindRemoteTrackEvents(t3._audioTrack), !i2) null === (s2 = t3._audioTrack) || void 0 === s2 || s2._destroy(), t3._audioTrack = void 0;
      }
    }), o2;
  }
  async unsubscribeDataChannel(e9, t2) {
    if (t2.forEach((e10) => {
      const t3 = this.pendingRemoteDataChannels.findIndex((t4) => t4.id === e10.id);
      -1 !== t3 && this.pendingRemoteDataChannels.splice(t3, 1);
    }), !this.connection) return;
    const i2 = this.filterTobeUnSubscribedDataChannels(e9, t2);
    if (0 === i2.length) return;
    t2.forEach((e10) => {
      e10._close();
    });
    const n2 = this.remoteDataChannelMap.get(e9);
    return i2.forEach((e10) => {
      n2 && n2.delete(e10.id);
    }), n2 && 0 === n2.size && (this.remoteDataChannelMap.delete(e9), await this.connection.stopDataChannels(e9.uid)), i2.map((e10) => e10.id);
  }
  async massUnsubscribe(e9) {
    return this.massUnsubscribeNoLock(e9);
  }
  async massUnsubscribeNoLock(e9) {
    let t2 = [];
    for (const { user: i3, mediaType: n3 } of e9) {
      const e10 = this.pendingRemoteTracks.filter((e11) => {
        let { user: t3, kind: r2 } = e11;
        return void 0 !== n3 ? t3.uid === i3.uid && n3 === r2 : t3.uid === i3.uid;
      });
      e10.forEach((e11) => {
        const t3 = this.pendingRemoteTracks.indexOf(e11);
        this.pendingRemoteTracks.splice(t3, 1);
      }), t2 = t2.concat(e10);
    }
    if (!this.connection || this.state !== pO.Connected) return void t2.forEach((e10) => {
      let { user: t3, kind: i3 } = e10;
      var n3;
      if (i3 === dO.AUDIO) null === (n3 = t3._audioTrack) || void 0 === n3 || n3._destroy(), t3._audioTrack = void 0;
      else if (i3 === dO.VIDEO) {
        var r2;
        null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
      }
    });
    const i2 = Jn(e9).call(e9, (e10, t3) => {
      let { user: i3, mediaType: n3 } = t3;
      const r2 = this.filterTobeUnSubscribedTracks(i3, n3);
      return e10.concat(r2);
    }, []);
    if (0 === i2.length) return;
    await this.connection.stopReceiving(i2.map((e10) => {
      let [, { id: t3 }] = e10;
      return t3;
    }));
    const n2 = this.createUnsubscribeAllMessage(i2);
    return this.withdrawRemoteTracks(i2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadInboundStats(), i2.forEach((e10) => {
      let [t3, { kind: i3 }] = e10;
      var n3, r2;
      i3 === dO.VIDEO && t3._videoSSRC && (null === (n3 = this.connection) || void 0 === n3 || n3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
      if (i3 === dO.VIDEO) this.unbindRemoteTrackEvents(t3._videoTrack), null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
      else if (i3 === dO.AUDIO) {
        var o2;
        this.unbindRemoteTrackEvents(t3._audioTrack), null === (o2 = t3._audioTrack) || void 0 === o2 || o2._destroy(), t3._audioTrack = void 0;
      }
    }), n2;
  }
  isPreSubScribe(e9) {
    if (!this.connection || this.state !== pO.Connected) return false;
    return !!this.connection.getPreMedia(e9);
  }
  async muteRemote(e9, t2) {
    if (!this.connection) return;
    const i2 = this.remoteUserMap.get(e9);
    if (!i2) return void fb.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e9.uid, "."));
    if (!i2.get(t2)) return void fb.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e9.uid, " media type ").concat(t2, "."));
    const n2 = t2 === dO.VIDEO ? e9._videoSSRC : e9._audioSSRC;
    void 0 !== n2 && this.connection.setStatsRemoteVideoIsReady(n2, false);
  }
  async unmuteRemote(e9, t2) {
    return this.unmuteRemoteNoLock(e9, t2);
  }
  async unmuteRemoteNoLock(e9, t2) {
    if (!this.connection) return;
    const i2 = this.remoteUserMap.get(e9);
    if (!i2) return void fb.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e9.uid, "."));
    i2.get(t2) || fb.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e9.uid, " media type ").concat(t2, "."));
  }
  getAllTracks(e9) {
    const t2 = this.localTrackMap.get(hO.LocalAudioTrack);
    if ((null == t2 ? void 0 : t2.track) instanceof RM) {
      const i2 = t2.track;
      return Array.from(this.localTrackMap.entries()).filter((e10) => {
        let [t3] = e10;
        return t3 !== hO.LocalAudioTrack;
      }).filter((t3) => {
        let [i3] = t3;
        return !(e9 && i3 === hO.LocalVideoLowTrack);
      }).map((e10) => {
        let [, { track: t3 }] = e10;
        return t3;
      }).concat(i2.trackList);
    }
    return Array.from(this.localTrackMap.entries()).filter((t3) => {
      let [i2] = t3;
      return !(e9 && i2 === hO.LocalVideoLowTrack);
    }).map((e10) => {
      let [, { track: t3 }] = e10;
      return t3;
    });
  }
  getAllDataChannels() {
    return this.localDataChannels;
  }
  reportPublishEvent(e9, t2, i2, n2, r2) {
    if (e9) {
      const i3 = this.localTrackMap.get(hO.LocalAudioTrack), o3 = n2 ? this.localTrackMap.get(hO.LocalVideoLowTrack) : this.localTrackMap.get(hO.LocalVideoTrack);
      vb.publish(this.store.sessionId, { eventElapse: rV.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e9, ec: t2, audioName: null == i3 ? void 0 : i3.track.getTrackLabel(), videoName: null == o3 ? void 0 : o3.track.getTrackLabel(), screenshare: -1 !== (null == o3 ? void 0 : o3.track._hints.indexOf(mL.SCREEN_TRACK)), audio: !!i3, video: !!o3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
    } else {
      var o2;
      i2 || (i2 = []);
      const s2 = i2.find((e10) => e10 instanceof TM), a2 = n2 ? null === (o2 = this.localTrackMap.get(hO.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.track : i2.find((e10) => e10 instanceof aU);
      vb.publish(this.store.sessionId, { eventElapse: rV.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e9, ec: t2, audioName: null == s2 ? void 0 : s2.getTrackLabel(), videoName: null == a2 ? void 0 : a2.getTrackLabel(), screenshare: -1 !== (null == a2 ? void 0 : a2._hints.indexOf(mL.SCREEN_TRACK)), audio: !!s2, video: !!a2, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
    }
  }
  reportSubscribeEvent(e9, t2, i2, n2) {
    const r2 = n2 === dO.VIDEO ? i2._videoSSRC : i2._audioSSRC;
    r2 && vb.subscribe(this.store.sessionId, { succ: e9, ec: t2, video: n2 === dO.VIDEO, audio: n2 === dO.AUDIO, peerid: i2.uid, subscribeRequestid: r2, p2pid: this.store.p2pId, eventElapse: rV.measureFromSubscribeStart(this.store.clientId, r2), preSsrc: this.isPreSubScribe(r2) });
  }
  reset() {
    fb.debug("[".concat(this.store.clientId, "] P2PChannel.reset")), this.mutex = new NA("P2PChannel-mutex"), this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = this.isPlanB ? new FF({}, this.store) : new dB({}, this.store), this.bindConnectionEvents(this.connection)), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
    const e9 = this.localTrackMap.get(hO.LocalAudioTrack);
    if ((null == e9 ? void 0 : e9.track) instanceof RM) {
      if (e9.track.trackList.length > 0) {
        const t2 = e9.track;
        e9.track.trackList.forEach((e10) => {
          t2.removeAudioTrack(e10);
        });
      }
      e9.track.close();
    }
    this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.localDataChannels = [], this.remoteDataChannelMap.clear(), this.pendingLocalDataChannels = [], this.pendingRemoteDataChannels = [], this.state = pO.Disconnected;
  }
  getStats() {
    var e9;
    return null === (e9 = this.connection) || void 0 === e9 ? void 0 : e9.getStats();
  }
  getRemoteVideoIsReady(e9) {
    var t2;
    return (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.getRemoteVideoIsReady(e9)) || false;
  }
  getLocalAudioVolume() {
    const e9 = this.localTrackMap.get(hO.LocalAudioTrack);
    if (e9) return e9.track.getVolumeLevel();
  }
  getLocalVideoSize() {
    const e9 = this.localTrackMap.get(hO.LocalVideoTrack);
    if (e9) return { width: e9.track.videoWidth || 0, height: e9.track.videoHeight || 0 };
  }
  getEncoderConfig(e9) {
    const t2 = this.localTrackMap.get(e9);
    return t2 && t2.track instanceof aU || t2 && t2.track instanceof TM ? t2.track._encoderConfig : void 0;
  }
  getLocalMedia(e9) {
    return this.localTrackMap.get(e9);
  }
  hasLocalMedia() {
    return this.localTrackMap.size > 0;
  }
  hasRemoteMedia(e9, t2) {
    if (!e9) return this.remoteUserMap.size > 0;
    const i2 = this.remoteUserMap.get(e9);
    return !!i2 && (!t2 || i2.has(t2));
  }
  async hasRemoteMediaWithLock(e9, t2) {
    if (!e9) return this.remoteUserMap.size > 0;
    const i2 = this.remoteUserMap.get(e9);
    return !!i2 && (!t2 || i2.has(t2));
  }
  getRemoteMedia(e9) {
    var t2;
    const i2 = Array.from(d_(t2 = this.remoteUserMap).call(t2)).find((t3) => t3.uid === e9);
    return i2 ? { audioTrack: i2.audioTrack, audioSSRC: i2._audioSSRC, videoTrack: i2.videoTrack, videoSSRC: i2._videoSSRC } : {};
  }
  getAudioLevels() {
    let e9 = Array.from(this.remoteUserMap.entries()).map((e10) => {
      let [t3] = e10;
      return { uid: t3.uid, level: t3.audioTrack ? 100 * t3.audioTrack._source.getAccurateVolumeLevel() : 0 };
    });
    const t2 = this.localTrackMap.get(hO.LocalAudioTrack);
    return t2 && e9.push({ level: 100 * t2.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e9 = aE(e9).call(e9, (e10, t3) => e10.level - t3.level), e9;
  }
  async disconnectForReconnect() {
    this.connection && (fb.debug("[".concat(this.store.clientId, "] P2PChannel.disconnectForReconnect closing P2PConnection")), this.state = pO.Reconnecting, XA("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e9) => {
      let [t2] = e9;
      var i2;
      t2._videoTrack && t2._videoTrack._player && (null === (i2 = t2._videoTrack._player.getVideoElement()) || void 0 === i2 || i2.pause(), t2._videoTrack._player.isKeepLastFrame = true, t2._videoTrack._originMediaStreamTrack.stop());
    }), this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0, this.shouldForwardP2PCreation && (this.connection = this.isPlanB ? new FF({}, this.store) : new dB({}, this.store), this.bindConnectionEvents(this.connection)), 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e9) => {
      var t2;
      let [i2, { track: n2 }] = e9;
      switch (i2) {
        case hO.LocalVideoTrack:
          Dn(t2 = n2._hints).call(t2, mL.LOW_STREAM) ? n2.close() : this.pendingLocalTracks.push(n2);
          break;
        case hO.LocalAudioTrack:
          n2 instanceof RM ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n2.trackList) : this.pendingLocalTracks.push(n2);
        case hO.LocalVideoLowTrack:
      }
    }), this.emit(_O.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e9) => {
      let [t2, i2] = e9;
      Array.from(d_(i2).call(i2)).forEach((e10) => {
        this.setPendingRemoteMedia(t2, e10);
      }), this.emit(_O.MediaReconnectStart, t2.uid);
    }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), 0 !== this.localDataChannels.length && (this.localDataChannels.forEach((e9) => {
      this.pendingLocalDataChannels.push(e9);
    }), this.localDataChannels.length = 0), 0 !== this.remoteDataChannelMap.size && (Array.from(this.remoteDataChannelMap.entries()).forEach((e9) => {
      let [t2, i2] = e9;
      Array.from(d_(i2).call(i2)).forEach((e10) => {
        this.setPendingRemoteDataChannel(t2, e10);
      });
    }), this.remoteDataChannelMap.clear()), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), fb.debug("[".concat(this.store.clientId, "] P2PChannel disconnected, waiting to reconnect.")));
  }
  hasPendingRemoteDataChannel(e9, t2) {
    for (const i2 of this.pendingRemoteDataChannels) {
      const { user: n2, id: r2 } = i2;
      if ((e9 instanceof cF ? e9.uid : e9) === n2.uid && r2 === t2) return true;
    }
    return false;
  }
  setPendingRemoteDataChannel(e9, t2) {
    this.hasPendingRemoteDataChannel(e9, t2) || this.pendingRemoteDataChannels.push({ user: e9, id: t2 });
  }
  hasPendingRemoteMedia(e9, t2) {
    for (const i2 of this.pendingRemoteTracks) {
      const { user: n2, kind: r2 } = i2;
      if ((e9 instanceof cF ? e9.uid : e9) === n2.uid && t2 === r2) return true;
    }
    return false;
  }
  setPendingRemoteMedia(e9, t2) {
    this.hasPendingRemoteMedia(e9, t2) || this.pendingRemoteTracks.push({ user: e9, kind: t2 });
  }
  restartICE(e9) {
    var t2 = this;
    return YI(function* () {
      if (!t2.connection || t2.state !== pO.Connected) return;
      const i2 = yield qI(t2.mutex.lock("From P2PChannel.restartICE"));
      let n2;
      try {
        n2 = yield qI(t2.connection.restartICE(e9));
        const r3 = yield qI(n2.next());
        if (r3.done) return;
        const o2 = r3.value, s2 = yield o2;
        switch (t2.reportPCDisconnectedOrFailed(e9), e9) {
          case lO.TCP:
            t2._pcStatsUploadType = uO.TCP_RESTART;
            break;
          case lO.RELAY:
            t2._pcStatsUploadType = uO.RELAY_RESTART;
            break;
          default:
            t2._pcStatsUploadType = uO.OLD_RESTART;
        }
        t2._isInRestartIce = true, n2.next(s2);
      } catch (e10) {
        var r2;
        null === (r2 = n2) || void 0 === r2 || r2.throw(e10);
      } finally {
        i2();
      }
    })();
  }
  getUplinkNetworkQuality() {
    if (!this.connection) return 0;
    const e9 = this.connection.getStats(), t2 = this.localTrackMap.get(hO.LocalVideoTrack), i2 = this.localTrackMap.get(hO.LocalAudioTrack), n2 = e9.videoSend.find((e10) => e10.ssrc === (null == t2 ? void 0 : t2.ssrcs[0].ssrcId)), r2 = e9.audioSend.find((e10) => e10.ssrc === (null == i2 ? void 0 : i2.ssrcs[0].ssrcId));
    if (!n2 || !r2) return 1;
    const o2 = eA(this, _O.NeedSignalRTT), s2 = n2 ? n2.rttMs : void 0, a2 = r2 ? r2.rttMs : void 0, c2 = s2 && a2 ? (s2 + a2) / 2 : s2 || a2, d2 = (c2 && o2 ? (c2 + o2) / 2 : c2 || o2) || 0, l2 = 100 * e9.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, u2 = l2 < 0.17 ? 1 : l2 < 0.36 ? 2 : l2 < 0.59 ? 3 : l2 < 0.1 ? 4 : 5, h2 = null == t2 ? void 0 : t2.track;
    if (h2 && h2._encoderConfig && -1 === h2._hints.indexOf(mL.SCREEN_TRACK)) {
      const t3 = h2._encoderConfig.bitrateMax, i3 = e9.bitrate.actualEncoded;
      if (t3 && i3) {
        const e10 = (1e3 * t3 - i3) / (1e3 * t3);
        return bb[e10 < 0.15 ? 0 : e10 < 0.3 ? 1 : e10 < 0.45 ? 2 : e10 < 0.6 ? 3 : 4][u2];
      }
    }
    return u2;
  }
  getDownlinkNetworkQuality() {
    if (!this.connection) return 0;
    const e9 = this.connection.getStats();
    let t2 = 0;
    return Array.from(this.remoteUserMap.entries()).forEach((i2) => {
      let [n2] = i2;
      const r2 = n2._audioSSRC, o2 = n2._videoSSRC, s2 = e9.audioRecv.find((e10) => e10.ssrc === r2), a2 = e9.videoRecv.find((e10) => e10.ssrc === o2);
      if (!s2 && !a2) return void (t2 += 1);
      const c2 = eA(this, _O.NeedSignalRTT), d2 = e9.rtt, l2 = (d2 && c2 ? (d2 + c2) / 2 : d2 || c2) || 0, u2 = s2 ? s2.jitterMs : void 0, h2 = e9.recvPacketLossRate;
      let p2 = 0.7 * h2 * 100 / 50 + 0.3 * l2 / 1500;
      u2 && (p2 = 0.6 * h2 * 100 / 50 + 0.2 * l2 / 1500 + 0.2 * u2 / 400);
      t2 += p2 < 0.1 ? 1 : p2 < 0.17 ? 2 : p2 < 0.36 ? 3 : p2 < 0.59 ? 4 : 5;
    }), this.remoteUserMap.size > 0 ? Math.round(t2 / this.remoteUserMap.size) : t2;
  }
  async muteLocalTrack(e9) {
    return new Gh((t2, i2) => {
      this.handleMuteLocalTrack(e9, t2, i2);
    });
  }
  async replaceTrack(e9, t2) {
    var i2;
    if (fb.debug("[".concat(this.store.clientId, "] P2PChannel replaceTrack from [").concat(e9.getTrackId(), "] to [").concat(t2.getTrackId(), "]")), !this.connection || this.state !== pO.Connected) return;
    const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
      let [, { track: i3 }] = t3;
      return e9 === i3;
    });
    if (!n2) return;
    const r2 = n2[0];
    if (e9 !== t2 && (this.unbindLocalTrackEvents([{ track: e9, type: r2 }]), this.bindLocalTrackEvents([{ track: t2, type: r2 }]), n2[1].track = t2), await (null === (i2 = this.connection) || void 0 === i2 ? void 0 : i2.replaceTrack(t2, n2[1].id)), this.isPlanB) {
      const e10 = n2[1];
      e10.id = t2._mediaStreamTrack.id, this.localTrackMap.set(r2, e10);
    }
    if (r2 === hO.LocalVideoTrack && !XA("DISABLE_DUAL_STREAM_USE_ENCODING") && ZP().supportDualStreamEncoding) {
      const t3 = this.localTrackMap.get(hO.LocalVideoLowTrack);
      if (t3) {
        const i3 = e9._mediaStreamTrack.clone();
        t3.track._originMediaStreamTrack.stop(), t3.track._mediaStreamTrack = i3, t3.track._originMediaStreamTrack = i3, await new Gh((e10, i4) => {
          this.handleReplaceTrack(t3.track, e10, i4, true);
        });
      }
    }
  }
  filterTobePublishedTracks(e9, t2, i2) {
    const n2 = [], r2 = this.getAllTracks();
    e9 = rA(e9 = e9.filter((e10) => -1 === r2.indexOf(e10)));
    let o2, s2 = false;
    const a2 = this.localTrackMap.get(hO.LocalAudioTrack);
    for (const r3 of e9) {
      if (r3 instanceof aU && (this.localTrackMap.has(hO.LocalVideoTrack) || s2 ? new Cy(Ry.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n2.push({ track: r3, type: hO.LocalVideoTrack }), s2 = true), t2)) {
        const e10 = this.getLowVideoTrack(r3, i2);
        n2.push({ track: e10, type: hO.LocalVideoLowTrack });
      }
      if (r3 instanceof TM) if (a2) {
        const e10 = a2.track;
        if (e10 instanceof RM) uF([r3]), e10.addAudioTrack(r3), this.bindLocalAudioTrackEvents(r3, true);
        else {
          const t3 = hF([e10, r3]);
          fb.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will replace audioTrack [").concat(t3.getTrackId(), "]")), this.replaceTrack(e10, t3);
        }
      } else if (o2 instanceof RM) uF([r3]), o2.addAudioTrack(r3);
      else if (o2 || !r3._useAudioElement && ZP().webAudioMediaStreamDest && !r3._bypassWebAudio) {
        o2 = hF(o2 ? [r3, o2] : [r3]);
      } else o2 = r3;
    }
    return o2 && (fb.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will send audioTrack [").concat(o2.getTrackId(), "]")), n2.push({ track: o2, type: hO.LocalAudioTrack })), n2;
  }
  filterTobeUnpublishedTracks(e9) {
    const t2 = [], i2 = this.getAllTracks();
    e9 = rA(e9 = e9.filter((e10) => -1 !== i2.indexOf(e10)));
    for (const i3 of e9) {
      if (i3 instanceof TM) {
        const e10 = this.localTrackMap.get(hO.LocalAudioTrack);
        if (!e10) continue;
        e10.track instanceof RM ? (e10.track.removeAudioTrack(i3), this.unbindLocalAudioTrackEvents(i3), 0 === e10.track.trackList.length && (t2.push([hO.LocalAudioTrack, e10]), e10.track.close())) : t2.push([hO.LocalAudioTrack, e10]);
      }
      if (i3 instanceof aU) {
        const e10 = this.localTrackMap.get(hO.LocalVideoTrack);
        if (!e10) continue;
        t2.push([hO.LocalVideoTrack, e10]);
        const i4 = this.localTrackMap.get(hO.LocalVideoLowTrack);
        i4 && t2.push([hO.LocalVideoLowTrack, i4]);
      }
    }
    return t2;
  }
  filterTobePublishedDataChannels(e9) {
    return e9 = (e9 = rA(e9)).filter((e10) => -1 === this.localDataChannels.findIndex((t2) => t2.id === e10.id));
  }
  filterTobeUnpublishedDataChannels(e9) {
    return e9 = (e9 = (e9 = rA(e9)).filter((e10) => -1 !== this.localDataChannels.indexOf(e10))).filter((e10) => e10._originDataChannel);
  }
  bindLocalTrackEvents(e9) {
    e9.forEach((e10) => {
      let { track: t2, type: i2 } = e10;
      switch (i2) {
        case hO.LocalVideoTrack:
          t2.addListener(fL.GET_STATS, this.handleGetLocalVideoStats), t2.addListener(fL.GET_RTC_STATS, this.handleGetRTCStats), t2.addListener(fL.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.addListener(fL.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.addListener(fL.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.addListener(fL.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t2.addListener(fL.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.addListener(fL.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.addListener(fL.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          break;
        case hO.LocalAudioTrack:
          this.bindLocalAudioTrackEvents(t2);
        case hO.LocalVideoLowTrack:
      }
    });
  }
  bindLocalAudioTrackEvents(e9, t2) {
    e9 instanceof RM ? e9.trackList.forEach((e10) => {
      e10.addListener(fL.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e10.addListener(fL.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e10.addListener(fL.GET_STATS, this.handleGetLocalAudioStats), e10.addListener(fL.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e10.addListener(fL.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
    }) : (e9.addListener(fL.GET_STATS, this.handleGetLocalAudioStats), e9.addListener(fL.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e9.addListener(fL.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e9.addListener(fL.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e9.addListener(fL.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t2 || (e9.addListener(fL.NEED_REPLACE_TRACK, this.handleReplaceTrack), e9.addListener(fL.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack)));
  }
  unbindLocalTrackEvents(e9) {
    e9 || (e9 = Array.from(this.localTrackMap.entries()).map((e10) => {
      let [t2, { track: i2 }] = e10;
      return { track: i2, type: t2 };
    })), e9.forEach((e10) => {
      let { track: t2, type: i2 } = e10;
      switch (i2) {
        case hO.LocalVideoTrack:
          t2.off(fL.GET_STATS, this.handleGetLocalVideoStats), t2.off(fL.GET_RTC_STATS, this.handleGetRTCStats), t2.off(fL.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.off(fL.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.off(fL.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.off(fL.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t2.off(fL.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.off(fL.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.off(fL.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          break;
        case hO.LocalAudioTrack:
          this.unbindLocalAudioTrackEvents(t2);
        case hO.LocalVideoLowTrack:
      }
    });
  }
  unbindLocalAudioTrackEvents(e9) {
    e9 instanceof RM ? e9.trackList.forEach((e10) => {
      e10.off(fL.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e10.off(fL.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e10.off(fL.GET_STATS, this.handleGetLocalAudioStats), e10.off(fL.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e10.off(fL.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
    }) : (e9.off(fL.GET_STATS, this.handleGetLocalAudioStats), e9.off(fL.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e9.off(fL.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e9.off(fL.NEED_REPLACE_TRACK, this.handleReplaceTrack), e9.off(fL.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack), e9.off(fL.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e9.off(fL.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
  }
  bindRemoteTrackEvents(e9, t2) {
    t2 instanceof IU && t2.addListener(fL.GET_STATS, (t3) => {
      t3(this.handleGetRemoteVideoStats(e9));
    }), t2 instanceof vU && t2.addListener(fL.GET_STATS, (t3) => {
      t3(this.handleGetRemoteAudioStats(e9));
    });
  }
  unbindRemoteTrackEvents(e9) {
    e9 && e9.removeAllListeners(fL.GET_STATS);
  }
  unbindAllRemoteTrackEvents() {
    Array.from(this.remoteUserMap.entries()).forEach((e9) => {
      let [t2, i2] = e9;
      i2.has(dO.AUDIO) && this.unbindRemoteTrackEvents(t2._audioTrack), i2.has(dO.VIDEO) && this.unbindRemoteTrackEvents(t2._videoTrack);
    });
  }
  createGatewayPublishMessage(e9, t2) {
    return e9.map((e10, i2) => {
      var n2;
      let r2, o2, { track: s2, type: a2 } = e10;
      switch (a2) {
        case hO.LocalAudioTrack:
          r2 = Zw.Audio, o2 = { dtx: s2 instanceof SM && s2._config.DTX, hq: false, lq: false, stereo: false, speech: false };
          break;
        case hO.LocalVideoTrack:
          r2 = Dn(n2 = s2._hints).call(n2, mL.SCREEN_TRACK) ? Zw.Screen : Zw.High, o2 = pB(pB({}, ZO(s2)), {}, { codec: this.store.codec, svc_mode: BU() });
          break;
        case hO.LocalVideoLowTrack:
          r2 = Zw.Low, o2 = pB(pB({}, ZO(s2)), {}, { codec: this.store.codec, svc_mode: BU() });
      }
      return { stream_type: r2, attributes: o2, ssrcs: t2[i2] };
    });
  }
  createGatewayUnpublishMessage(e9) {
    return e9.map((e10) => {
      var t2;
      let i2, [n2, { track: r2, ssrcs: o2, id: s2 }] = e10;
      switch (n2) {
        case hO.LocalVideoTrack:
          i2 = Dn(t2 = r2._hints).call(t2, mL.SCREEN_TRACK) ? Zw.Screen : Zw.High;
          break;
        case hO.LocalAudioTrack:
          i2 = Zw.Audio;
          break;
        case hO.LocalVideoLowTrack:
          i2 = Zw.Low;
      }
      return { stream_type: i2, ssrcs: o2, mid: s2 };
    });
  }
  assignLocalTracks(e9, t2) {
    e9.forEach((e10, i2) => {
      let { track: n2, type: r2 } = e10;
      this.localTrackMap.set(r2, { track: n2, id: t2[i2].id, ssrcs: t2[i2].localSSRC });
    });
  }
  withdrawLocalTracks(e9) {
    e9.forEach((e10) => {
      let [t2] = e10;
      this.localTrackMap.delete(t2);
    });
  }
  bindConnectionEvents(e9) {
    e9.onConnectionStateChange = async (t2) => {
      if (fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(t2, ")")), this.emit(_O.PeerConnectionStateChange, t2), "connected" !== t2 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t2 && (this._restartTimer && (clearTimeout(this._restartTimer), this._restartTimer = void 0), (this._isFirstConnected || this._isInRestartIce) && this.reportPCStats(Date.now(), true, this._pcStatsUploadType), this._isInRestartIce = false, this._isFirstConnected = false, this._isStartRestartIce = false), XA("NEW_ICE_RESTART")) {
        var i2;
        if (Dn(i2 = this._restartStates).call(i2, t2)) {
          if (this._isStartRestartIce) return;
          this._isStartRestartIce = true;
          const t3 = (t4) => {
            if ("disconnected" === e9.iceConnectionState || "checking" === e9.iceConnectionState || "failed" === e9.iceConnectionState) {
              fb.debug("[".concat(this.store.clientId, "] [P2PChannel] start use restartICE, type is ").concat(t4));
              "CONNECTED" === eA(this, _O.QueryClientConnectionState) && this.emit(_O.RequestRestartICE, t4);
            }
          }, i3 = () => {
            "disconnected" !== e9.iceConnectionState && "checking" !== e9.iceConnectionState && "failed" !== e9.iceConnectionState || (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), fb.debug("[".concat(this.store.clientId, "] P2PConnection disconnected timeout, force reconnect")), setTimeout(() => this.emit(_O.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
          }, n2 = XA("ICE_RESTART_INTERVAL");
          return void (this._restartTimer = window.setTimeout(() => {
            if (XA("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && ZP().supportPCSetConfiguration) t3(lO.RELAY), this._restartTimer = window.setTimeout(i3, n2);
            else if (Zv()) t3(lO.UDP), this._restartTimer = window.setTimeout(i3, 4e3);
            else {
              if (t3(lO.TCP), ZP().supportPCSetConfiguration) return void (this._restartTimer = window.setTimeout(() => {
                t3(lO.RELAY), this._restartTimer = window.setTimeout(i3, n2);
              }, n2));
              this._restartTimer = window.setTimeout(i3, n2);
            }
          }, 800));
        }
      } else {
        if ("disconnected" === t2 && "disconnected" === e9.iceConnectionState) return setTimeout(() => {
          if ("disconnected" === e9.iceConnectionState && XA("ICE_RESTART")) {
            "CONNECTED" === eA(this, _O.QueryClientConnectionState) && this.emit(_O.RequestRestartICE);
          }
        }, 800), void setTimeout(() => {
          "disconnected" === e9.peerConnectionState && (fb.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection disconnected timeout 4000ms, force reconnect")), this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isInRestartIce = false, setTimeout(() => this.emit(_O.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
        }, 4e3);
        "failed" === t2 && (fb.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection state failed, force reconnect")), this.reportPCDisconnectedOrFailed(), setTimeout(() => this.emit(_O.P2PLost), 0), this.iceFailedCount += 1, await this.requestReconnect());
      }
    }, e9.onICEConnectionStateChange = (e10) => {
      "connected" !== e10 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e10, ")")), vb.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e10, tag: jy.TRACER }).onSuccess(), this.emit(_O.IceConnectionStateChange, e10);
    }, e9.onICETransportStateChange = (e10) => {
      fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e10, ")"));
    }, e9.onDTLSTransportStateChange = (e10) => {
      fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e10, ")"));
    }, e9.onDTLSTransportError = (e10) => {
      fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e10, ")"));
    }, e9.onFirstAudioDecoded = (e10) => {
      var t2;
      const i2 = Array.from(d_(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e10);
      var n2;
      i2 && (this.store.subscribe(i2.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n2 = i2.audioTrack) || void 0 === n2 || n2.emit(IL.FIRST_FRAME_DECODED), vb.firstRemoteFrame(this.store.sessionId, gb.FIRST_AUDIO_DECODE, Rb.FIRST_AUDIO_DECODE, { peer: i2._uintid, subscribeElapse: rV.measureFromSubscribeStart(this.store.clientId, e10), subscribeRequestid: e10, p2pid: this.store.p2pId }));
    }, e9.onFirstAudioReceived = (e10) => {
      var t2;
      const i2 = Array.from(d_(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e10);
      i2 && vb.firstRemoteFrame(this.store.sessionId, gb.FIRST_AUDIO_RECEIVED, Rb.FIRST_AUDIO_RECEIVED, { peer: i2._uintid, subscribeElapse: rV.measureFromSubscribeStart(this.store.clientId, e10), subscribeRequestid: e10, p2pid: this.store.p2pId });
    }, e9.onFirstVideoDecoded = (e10, t2, i2) => {
      this.reportVideoFirstFrameDecoded(e10, t2, i2);
    }, e9.onFirstVideoReceived = (e10) => {
      var t2;
      const i2 = Array.from(d_(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._videoSSRC === e10);
      i2 && vb.firstRemoteFrame(this.store.sessionId, gb.FIRST_VIDEO_RECEIVED, Rb.FIRST_VIDEO_RECEIVED, { peer: i2._uintid, subscribeElapse: rV.measureFromSubscribeStart(this.store.clientId, e10), subscribeRequestid: e10, p2pid: this.store.p2pId });
    }, e9.onSelectedLocalCandidateChanged = (e10, t2) => {
      const i2 = "relay" === e10.candidateType, n2 = "relay" === t2.candidateType;
      "unknown" !== t2.candidateType && i2 === n2 || this.emit(_O.ConnectionTypeChange, i2), fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(nN(t2)), " -> ").concat(JSON.stringify(nN(e10)), ")"));
    }, e9.onSelectedRemoteCandidateChanged = (e10, t2) => {
      fb.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(nN(t2)), " -> ").concat(JSON.stringify(nN(e10)), ")"));
    }, e9.onFirstVideoDecodedTimeout = (e10) => {
      this.reportVideoFirstFrameDecoded(e10, void 0, void 0, true);
    }, e9.getLocalVideoStats = () => {
      const e10 = this.statsCollector.getLocalVideoTrackStats(), t2 = this.statsCollector.getRTCStats();
      return pB(pB({}, e10), t2);
    };
  }
  unbindConnectionEvents(e9) {
    e9.onConnectionStateChange = void 0, e9.onICEConnectionStateChange = void 0, e9.onICETransportStateChange = void 0, e9.onDTLSTransportStateChange = void 0, e9.onDTLSTransportError = void 0, e9.onFirstAudioDecoded = void 0, e9.onFirstAudioReceived = void 0, e9.onFirstVideoDecoded = void 0, e9.onFirstVideoReceived = void 0, e9.onSelectedLocalCandidateChanged = void 0, e9.onSelectedRemoteCandidateChanged = void 0, e9.onFirstVideoDecodedTimeout = void 0, e9.getLocalVideoStats = void 0;
  }
  filterTobeMutedTracks(e9) {
    const t2 = [];
    if (-1 === this.getAllTracks().indexOf(e9)) return t2;
    const i2 = this.localTrackMap.get(hO.LocalAudioTrack);
    if (e9 instanceof TM && (null == i2 ? void 0 : i2.track) instanceof RM) return i2.track.isActive || t2.push([hO.LocalAudioTrack, i2]), t2;
    const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
      let [, { track: i3 }] = t3;
      return e9 === i3;
    });
    if (n2 && (t2.push(n2), n2[0] === hO.LocalVideoTrack)) {
      const e10 = this.localTrackMap.get(hO.LocalVideoLowTrack);
      e10 && t2.push([hO.LocalVideoLowTrack, e10]);
    }
    return t2;
  }
  filterTobeUnmutedTracks(e9) {
    const t2 = [], i2 = this.localTrackMap.get(hO.LocalAudioTrack);
    if (e9 instanceof TM && (null == i2 ? void 0 : i2.track) instanceof RM) return i2.track.isActive && t2.push([hO.LocalAudioTrack, i2]), t2;
    const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
      let [, { track: i3 }] = t3;
      return e9 === i3;
    });
    if (n2) if (n2[0] === hO.LocalVideoTrack) {
      t2.push(n2);
      const e10 = this.localTrackMap.get(hO.LocalVideoLowTrack);
      e10 && t2.push([hO.LocalVideoLowTrack, e10]);
    } else t2.push(n2);
    return t2;
  }
  createMuteMessage(e9) {
    return e9.map((e10) => {
      var t2;
      let i2, [n2, { track: r2, ssrcs: o2, id: s2 }] = e10;
      switch (n2) {
        case hO.LocalAudioTrack:
          i2 = Zw.Audio;
          break;
        case hO.LocalVideoTrack:
          i2 = Dn(t2 = r2._hints).call(t2, mL.SCREEN_TRACK) ? Zw.Screen : Zw.High;
          break;
        case hO.LocalVideoLowTrack:
          i2 = Zw.Low;
      }
      return { stream_type: i2, ssrcs: o2, mid: s2 };
    });
  }
  createUnmuteMessage(e9) {
    return e9.map((e10) => {
      var t2;
      let i2, [n2, { track: r2, ssrcs: o2, id: s2 }] = e10;
      switch (n2) {
        case hO.LocalAudioTrack:
          i2 = Zw.Audio;
          break;
        case hO.LocalVideoTrack:
          i2 = Dn(t2 = r2._hints).call(t2, mL.SCREEN_TRACK) ? Zw.Screen : Zw.High;
          break;
        case hO.LocalVideoLowTrack:
          i2 = Zw.Low;
      }
      return { stream_type: i2, ssrcs: o2, mid: s2 };
    });
  }
  filterTobeUnSubscribedTracks(e9, t2) {
    const i2 = [], n2 = this.remoteUserMap.get(e9);
    if (!n2) return i2;
    if (t2) {
      const r2 = n2.get(t2);
      if (!r2) return i2;
      i2.push([e9, { kind: t2, id: r2 }]);
    } else Array.from(n2.entries()).forEach((t3) => {
      let [n3, r2] = t3;
      i2.push([e9, { kind: n3, id: r2 }]);
    });
    return i2;
  }
  filterTobeUnSubscribedDataChannels(e9, t2) {
    const i2 = [];
    return t2.forEach((t3) => {
      var n2;
      null !== (n2 = this.remoteDataChannelMap.get(e9)) && void 0 !== n2 && n2.has(t3.id) && i2.push(t3);
    }), i2;
  }
  createUnsubscribeMessage(e9) {
    const t2 = [];
    return e9.forEach((e10) => {
      let [i2, { kind: n2, id: r2 }] = e10;
      switch (n2) {
        case dO.VIDEO:
          return void (i2._videoSSRC && t2.push({ stream_type: dO.VIDEO, ssrcId: i2._videoSSRC }));
        case dO.AUDIO:
          return void (i2._audioSSRC && t2.push({ stream_type: dO.AUDIO, ssrcId: i2._audioSSRC }));
      }
    }), t2;
  }
  createUnsubscribeAllMessage(e9) {
    const t2 = /* @__PURE__ */ new Map();
    return e9.forEach((e10) => {
      let [i2, { kind: n2 }] = e10;
      if (t2.has(i2)) {
        let e11 = t2.get(i2);
        n2 === dO.VIDEO ? e11 |= tO.Video : e11 |= tO.Audio, t2.set(i2, e11);
      } else n2 === dO.VIDEO ? t2.set(i2, tO.Video) : t2.set(i2, tO.Audio);
    }), { users: Array.from(t2.entries()).map((e10) => {
      let [t3, i2] = e10;
      return { stream_id: t3.uid, stream_type: i2 };
    }) };
  }
  withdrawRemoteTracks(e9) {
    e9.forEach((e10) => {
      let [t2, { kind: i2 }] = e10;
      const n2 = this.remoteUserMap.get(t2);
      n2 && (n2.delete(i2), 0 === Array.from(n2.entries()).length && this.remoteUserMap.delete(t2));
    });
  }
  async updateBitrateLimit(e9) {
    const t2 = this.localTrackMap.get(hO.LocalVideoTrack), i2 = this.localTrackMap.get(hO.LocalVideoLowTrack);
    t2 && await t2.track.setBitrateLimit(e9.uplink), i2 && e9.low_stream_uplink && await i2.track.setBitrateLimit({ max_bitrate: e9.low_stream_uplink.bitrate, min_bitrate: e9.low_stream_uplink.bitrate || 0 });
  }
  isP2PDisconnected() {
    if (this.connection) {
      return "connected" !== this.connection.peerConnectionState;
    }
    return true;
  }
  mapPubResToRemoteConfig(e9, t2, i2) {
    return e9.map((e10, n2) => {
      var r2;
      let { stream_type: o2 } = e10;
      const s2 = null === (r2 = t2.find((e11) => {
        let { stream_type: t3 } = e11;
        return o2 === t3;
      })) || void 0 === r2 ? void 0 : r2.attributes;
      if (s2 && XA("DISABLE_SCREEN_SHARE_REMB")) {
        const e11 = i2[n2]._hints;
        (Dn(e11).call(e11, mL.SCREEN_TRACK) || Dn(e11).call(e11, mL.SCREEN_LOW_TRACK)) && (s2.remb = false, fb.debug("disable remb for screen share, hints:", e11));
      }
      return s2;
    });
  }
  async tryToUnmuteAudio(e9) {
    for (let i2 = 0; i2 < e9.length; i2++) if (e9[i2] instanceof TM) {
      var t2;
      const n2 = this.filterTobeUnmutedTracks(e9[i2]);
      if (0 === n2.length) continue;
      await (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.unmuteLocal(n2.map((e10) => {
        let [, { id: t3 }] = e10;
        return t3;
      })));
      const r2 = this.createUnmuteMessage(n2);
      return void await $y(this, _O.RequestUnmuteLocal, r2);
    }
  }
  bindStatsUploaderEvents() {
    this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e9) => {
      var t2;
      return !(null === (t2 = this.connection) || void 0 === t2 || !t2.getRemoteVideoIsReady(e9));
    }, this.statsUploader.requestUpload = (e9, t2) => this.emit(_O.RequestUpload, e9, t2), this.statsUploader.requestUploadStats = (e9) => this.emit(_O.RequestUploadStats, e9), this.statsUploader.requestAllTracks = () => this.getAllTracks();
  }
  unbindStatsUploaderEvents() {
    this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
  }
  async requestReconnect() {
    this.dtlsFailedCount += 1, await mA(LA(this.dtlsFailedCount, PA)), this.emit(_O.RequestReconnect);
  }
  async reconnectP2P() {
    const e9 = Array.from(this.localTrackMap.entries()), t2 = this.createGatewayUnpublishMessage(e9);
    Array.from(this.remoteUserMap.entries()), t2.length > 0 && await Zy(this, _O.RequestUnpublishForReconnectPC, t2), this.disconnectForReconnect(), this.emit(_O.RequestReconnectPC);
  }
  canPublishLowStream() {
    return this.localTrackMap.has(hO.LocalVideoTrack) || this.pendingLocalTracks.some((e9) => e9 instanceof aU);
  }
  throwIfTrackTypeNotMatch(e9) {
    if (e9.filter((e10) => e10 instanceof aU).length > 1) throw new Cy(Ry.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
    if (e9.filter((e10) => e10 instanceof TM).length > 1 && (e9.some((e10) => e10 instanceof TM && e10._bypassWebAudio) || !ZP().webAudioMediaStreamDest)) throw new Cy(Ry.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
    for (const t2 of e9) {
      if (t2 instanceof aU && this.pendingLocalTracks.some((e10) => e10 instanceof aU)) throw new Cy(Ry.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
      if (t2 instanceof TM && this.pendingLocalTracks.some((e10) => e10 instanceof TM) && (!ZP().webAudioMediaStreamDest || t2._bypassWebAudio || this.pendingLocalTracks.some((e10) => e10 instanceof TM && e10._bypassWebAudio))) throw new Cy(Ry.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
    }
  }
  getLowVideoTrack(e9, t2) {
    var i2;
    const n2 = !XA("DISABLE_DUAL_STREAM_USE_ENCODING") && ZP().supportDualStreamEncoding, r2 = pB(pB({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t2);
    let o2;
    o2 = n2 ? e9._mediaStreamTrack.clone() : KV(e9, r2);
    const s2 = TA(8, "track-low-"), a2 = new aU(o2, pB(pB({}, n2 && { scaleResolutionDownBy: iN(r2, e9) }), {}, { frameRate: r2.framerate, bitrateMax: r2.bitrate, bitrateMin: r2.bitrate }), void 0, void 0, s2);
    return a2.on(RL.TRANSCEIVER_UPDATED, (t3) => {
      e9._updateRtpTransceiver(t3, TL.LOW_STREAM);
    }), a2._hints.push(mL.LOW_STREAM), Dn(i2 = e9._hints).call(i2, mL.SCREEN_TRACK) && a2._hints.push(mL.SCREEN_LOW_TRACK), e9.on("sei-to-send", (e10) => {
      a2.emit("sei-to-send", e10);
    }), e9.addListener(fL.NEED_CLOSE, () => {
      a2.close();
    }), a2;
  }
  async globalLock() {
    return this.mutex.lock("From P2PChannel.globalLock");
  }
  async reportPCStats(e9, t2, i2) {
    let n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    if (this.connection && this.connection instanceof dB) {
      var r2, o2, s2, a2;
      const c2 = this.store.keyMetrics.descriptionStart || 0, { iceConnectionState: d2, dtlsTransportState: l2, peerConnectionState: u2 } = this.connection, { local: h2, remote: p2 } = await this.connection.getSelectedCandidatePair();
      vb.pcStats(this.store.sessionId, { startTime: c2, eventElapse: e9 - c2 || 0, iceconnectionsate: d2, dtlsstate: l2, connectionstate: u2, intSucc: t2 ? 1 : 2, error: n2, selectedLocalCandidateProtocol: null !== (r2 = null == h2 ? void 0 : h2.protocol) && void 0 !== r2 ? r2 : "", selectedLocalCandidateType: null !== (o2 = h2.candidateType) && void 0 !== o2 ? o2 : "", selectedLocalCandidateAddress: "".concat(h2.address, ":").concat(h2.port), selectedRemoteCandidateProtocol: null !== (s2 = p2.protocol) && void 0 !== s2 ? s2 : "", selectedRemoteCandidateType: null !== (a2 = p2.candidateType) && void 0 !== a2 ? a2 : "", selectedRemoteCandidateAddress: "".concat(p2.address, ":").concat(p2.port), restartCnt: i2, preallocation: this.connection.isPreallocation });
    }
  }
  reportVideoFirstFrameDecoded(e9, t2, i2, n2) {
    var r2;
    const o2 = Array.from(d_(r2 = this.remoteUserMap).call(r2)).find((t3) => t3._videoSSRC === e9);
    if (o2) {
      n2 || this.store.subscribe(o2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
      const r3 = this.store.keyMetrics, s2 = r3.subscribe.find((e10) => e10.userId === o2.uid && "video" === e10.type);
      vb.firstRemoteVideoDecode(this.store.sessionId, gb.FIRST_VIDEO_DECODE, Rb.FIRST_VIDEO_DECODE, { peer: o2._uintid, videowidth: t2, videoheight: i2, subscribeElapse: rV.measureFromSubscribeStart(this.store.clientId, e9), subscribeRequestid: e9, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == s2 ? void 0 : s2.subscribeEnd) || 0, subscriberStart: (null == s2 ? void 0 : s2.subscribeStart) || 0, videoAddNotify: (null == s2 ? void 0 : s2.streamAdded) || 0, state: n2 ? 1 : 0, firstFrame: (null == s2 ? void 0 : s2.firstFrame) || 0 });
    }
  }
  async remoteMediaSsrcChanged(e9, t2, i2) {
    if (!this.connection) return false;
    const n2 = this.remoteUserMap.get(e9);
    if (!n2) return false;
    const r2 = n2.get(t2);
    if (!r2) return false;
    const o2 = await this.connection.getRemoteSSRC(r2);
    return void 0 !== o2 && o2 !== i2;
  }
  unbindRtpTransceiver() {
    0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach((e9) => {
      let [t2, { track: i2 }] = e9;
      t2 === hO.LocalVideoLowTrack ? i2._updateRtpTransceiver(void 0, TL.LOW_STREAM) : i2._updateRtpTransceiver(void 0);
    });
  }
  reportPCDisconnectedOrFailed(e9) {
    this.connection && this.connection instanceof dB && ("disconnected" !== this.connection.iceConnectionState && "checking" !== this.connection.iceConnectionState && "failed" !== this.connection.iceConnectionState || (this._isFirstConnected ? (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isFirstConnected = false) : this._pcStatsUploadType === uO.TCP_RESTART && e9 === lO.RELAY ? this.reportPCStats(Date.now(), false, this._pcStatsUploadType) : this.reportPCStats(Date.now(), false, uO.DISCONNECTED_OR_FAILED)));
  }
}, Cw(uB.prototype, "startP2PConnection", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "startP2PConnection"), uB.prototype), Cw(uB.prototype, "connect", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "connect"), uB.prototype), Cw(uB.prototype, "updateRemoteRTPCapabilities", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "updateRemoteRTPCapabilities"), uB.prototype), Cw(uB.prototype, "publishDataChannel", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "publishDataChannel"), uB.prototype), Cw(uB.prototype, "unpublish", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "unpublish"), uB.prototype), Cw(uB.prototype, "unpublishDataChannel", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "unpublishDataChannel"), uB.prototype), Cw(uB.prototype, "unpublishLowStream", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "unpublishLowStream"), uB.prototype), Cw(uB.prototype, "subscribeDataChannel", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "subscribeDataChannel"), uB.prototype), Cw(uB.prototype, "subscribe", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "subscribe"), uB.prototype), Cw(uB.prototype, "massSubscribe", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "massSubscribe"), uB.prototype), Cw(uB.prototype, "unsubscribe", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "unsubscribe"), uB.prototype), Cw(uB.prototype, "unsubscribeDataChannel", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "unsubscribeDataChannel"), uB.prototype), Cw(uB.prototype, "massUnsubscribe", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "massUnsubscribe"), uB.prototype), Cw(uB.prototype, "muteRemote", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "muteRemote"), uB.prototype), Cw(uB.prototype, "unmuteRemote", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "unmuteRemote"), uB.prototype), Cw(uB.prototype, "hasRemoteMediaWithLock", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "hasRemoteMediaWithLock"), uB.prototype), Cw(uB.prototype, "disconnectForReconnect", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "disconnectForReconnect"), uB.prototype), Cw(uB.prototype, "updateBitrateLimit", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "updateBitrateLimit"), uB.prototype), Cw(uB.prototype, "remoteMediaSsrcChanged", [mB], Object.getOwnPropertyDescriptor(uB.prototype, "remoteMediaSsrcChanged"), uB.prototype), uB);
function mB(e9, t2, i2) {
  const n2 = e9[t2];
  if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
  return i2.value = async function() {
    const e10 = this.mutex, i3 = await e10.lock("From P2PChannel.".concat(t2));
    try {
      for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
      return await n2.apply(this, o2);
    } finally {
      i3();
    }
  }, i2;
}
var TB = {};
function SB(e9) {
  (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) && fb.debug("install service ".concat(e9.name)), TB[e9.name] = e9;
}
function gB(e9) {
  const t2 = TB[e9];
  if (!t2) throw new Cy(Ry.INVALID_OPERATION, "".concat(e9, " not found, please use AgoraRTC.use(").concat(e9, "Service) to load it first"));
  return t2;
}
function RB(e9, t2) {
  return gB("DataStream").create(e9, t2);
}
function CB(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function IB(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? CB(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : CB(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var vB = Date.now();
var yB = 20;
var AB = /* @__PURE__ */ new Map();
var bB = /* @__PURE__ */ new Map();
async function wB(e9) {
  const t2 = AB.get(e9), i2 = Array.isArray(t2) && t2[t2.length - 1], n2 = bB.get(e9);
  if (!i2) return void (n2.isSyncing = false);
  const r2 = { uid: i2.uid, payload: i2.payload };
  0 === n2.firstRecvTs && (n2.firstRecvTs = i2.recvTs, n2.firstSendTs = i2.sendTs);
  const o2 = i2.sendTs - n2.firstSendTs, s2 = o2 - (Date.now() - n2.firstRecvTs);
  s2 > 0 && (n2.firstRecvTs = Date.now() - o2);
  let a2 = i2.mediaDelay + s2;
  a2 <= 0 ? (t2.pop(), OB(i2.context, r2), a2 = 0) : a2 = Math.min(a2, yB), setTimeout(() => t2.length && wB(e9), a2);
}
function OB(e9, t2) {
  e9.safeEmit(zy.STREAM_MESSAGE, t2.uid, t2.payload), e9.onStreamMessage && e9.onStreamMessage(t2);
}
function NB(e9) {
  let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i2 = arguments.length > 2 ? arguments[2] : void 0;
  if (!e9.syncWithAudio) return OB(i2, { uid: e9.uid, payload: e9.payload });
  const n2 = "".concat(i2.id, "-").concat(e9.uid), r2 = AB.get(n2) || [], o2 = r2.findIndex((t3) => e9.sendTs >= t3.sendTs), s2 = IB(IB({}, e9), {}, { context: i2, mediaDelay: t2, recvTs: Date.now() });
  -1 === o2 ? r2.push(s2) : r2.splice(o2, 0, s2), AB.set(n2, r2);
  let a2 = false;
  var c2;
  bB.has(n2) ? a2 = !(null === (c2 = bB.get(n2)) || void 0 === c2 || !c2.isSyncing) : bB.set(n2, { isSyncing: a2, firstRecvTs: 0, firstSendTs: 0 });
  a2 || wB(n2);
}
var DB = Hv().name;
function PB(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function LB(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? PB(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : PB(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var kB = "websdk_ng_cache_parameter";
var MB = XA("MAX_PRELOAD_ASYNC_LENGTH");
var UB = 1e4;
var xB = /* @__PURE__ */ new Map();
var VB = [];
var FB = null;
var BB = 0;
var jB = 0;
var GB = /* @__PURE__ */ new Map();
var WB = /* @__PURE__ */ function(e9, t2) {
  const i2 = [];
  let n2 = 0;
  const r2 = async () => {
    const e10 = i2.shift();
    e10 && await e10(), i2.length > 0 && n2 < t2 ? r2() : n2--;
  };
  return async function() {
    for (var o2 = arguments.length, s2 = new Array(o2), a2 = 0; a2 < o2; a2++) s2[a2] = arguments[a2];
    return new Gh(async (o3, a3) => {
      i2.push(async () => {
        try {
          const t3 = await e9(...s2);
          o3(t3);
        } catch (e10) {
          a3(e10);
        }
      }), n2 < t2 && (n2++, r2());
    });
  };
}(KB, MB);
var HB = Lv.CancelToken.source();
async function KB(e9, t2, i2, n2, r2, o2) {
  try {
    if (!XA("ENABLE_PRELOAD")) return;
    if (!ZP().supportWebCrypto) return void dA(() => {
      fb.warn("Your browser does not support preloading, this feature  be run in a secure environment");
    }, "preload_webcrypto_not_supported");
    if (!i2 && null !== i2) throw new Cy(Ry.INVALID_PARAMS, "Invalid token: ".concat(i2, ". If you don not use token, set it to null"));
    i2 && by(i2, "token", 1, 2047), by(e9, "appid", 1, 2047), xw(t2), n2 && Vw(n2);
    const s2 = SA();
    fb.debug("preload channel ".concat(t2, ", uid is ").concat(n2));
    const a2 = { appId: e9, cname: t2, token: i2 || e9, uid: "string" != typeof n2 ? n2 : null, sid: s2, proxyServer: r2 };
    let c2, d2;
    "string" == typeof n2 ? (a2.stringUid = n2, [d2, c2] = await Gh.all([qx(n2, { sid: s2, appId: e9 }, HB.token), Jx(LB(LB({}, a2), {}, { token: i2 || e9, uid: 0 }), HB.token)]), a2.uid = d2.uid, c2.gatewayInfo.uid = a2.uid, c2.gatewayInfo.res.uid = a2.uid) : (o2 && (a2.stringUid = o2), c2 = await Jx(a2, HB.token));
    const l2 = { sid: s2, appId: e9, cname: t2, token: i2 || e9, uid: a2.stringUid || n2, intUid: a2.uid || c2.gatewayInfo.uid, stringUid: a2.stringUid, ts: Date.now(), sua: d2, ap: c2 };
    await async function(e10) {
      let t3;
      try {
        e10.uid && qB({ appId: e10.appId, cname: e10.cname, token: e10.token, uid: e10.uid, stringUid: e10.stringUid });
        const i3 = $B(e10), n3 = await async function(e11, t4) {
          try {
            const i4 = await window.crypto.subtle.importKey("raw", hA(t4), "AES-GCM", false, ["encrypt"]), n4 = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: new Uint8Array(1) }, i4, lA(window.btoa(JSON.stringify(e11))));
            return uA(new Uint8Array(n4));
          } catch (e12) {
            return;
          }
        }(e10, e10.token || e10.appId);
        if (!n3) return;
        t3 = QB(kB);
        const r3 = t3 ? JSON.parse(t3) : [];
        r3.push({ [i3]: n3 }), r3.length > XA("AP_CACHE_NUM") && r3.shift(), ZB(kB, JSON.stringify(r3));
      } catch (e11) {
        fb.warn("Error caching server parameters:", e11.message), ZB(kB, "");
      }
    }(l2), BB++;
  } catch (e10) {
    throw jB++, function(e11) {
      FB || (FB = window.setTimeout(() => {
        let t4 = "";
        GB.forEach((e12, i3) => {
          t4 += "".concat(i3, ": ").concat(e12, " ;");
        }), vb.reportApiInvoke(null, { name: By.PRELOAD, options: { success: BB, failed: jB, err: t4 } }).onError(e11), BB = 0, jB = 0, GB.clear(), FB = null;
      }, UB));
      const t3 = GB.get(e11.code) || 0;
      GB.set(e11.code, t3 + 1);
    }(e10), e10;
  }
}
async function YB(e9) {
  try {
    if (XA("AP_REQUEST_DETAIL")) return;
    const t2 = qB(e9);
    if (!t2 || "disabled" !== e9.cloudProxyServer) return;
    const i2 = await async function(e10, t3) {
      try {
        const i3 = await window.crypto.subtle.importKey("raw", hA(t3), "AES-GCM", false, ["decrypt"]), n2 = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: new Uint8Array(1) }, i3, lA(e10));
        return JSON.parse(window.atob(uA(new Uint8Array(n2))));
      } catch (e11) {
        return;
      }
    }(t2, e9.token || e9.appId);
    if (!i2) return;
    if (!function(e10, t3) {
      const i3 = e10.cname === t3.cname && e10.appId === t3.appId && e10.token === t3.token;
      if (!i3) return false;
      return t3.stringUid ? e10.stringUid === t3.stringUid : "number" == typeof t3.uid ? e10.uid === t3.uid : e10.uid == t3.uid;
    }(i2, e9)) return;
    if (i2 && Date.now() - i2.ts < XA("AP_CACHE_LIFETIME")) return i2;
  } catch (e10) {
    fb.warn("Error get preloadInfo", e10.message);
  }
}
function qB(e9) {
  let t2;
  try {
    if (t2 = QB(kB), !t2) return;
    const i2 = JSON.parse(t2), n2 = $B(e9), r2 = function(e10, t3) {
      for (let i3 = e10.length - 1; i3 >= 0; i3--) if (t3(e10[i3])) return i3;
      return -1;
    }(i2, (e10) => n2 in e10);
    if (-1 === r2) return;
    const o2 = i2.splice(r2, 1)[0];
    return ZB(kB, JSON.stringify(i2)), o2[n2];
  } catch (e10) {
    fb.warn("Error delete preload info: ".concat(t2), e10.message), ZB(kB, "");
  }
}
function zB(e9) {
  if (e9) {
    let t2 = xB.get(e9);
    t2 && (window.clearTimeout(t2), t2 = null, xB.delete(e9)), Dn(VB).call(VB, e9) || "disabled" !== e9.cloudProxyServer || VB.push(e9);
  }
  if (xB.size < XA("AP_CACHE_NUM") && VB.length > 0) {
    const e10 = VB.shift();
    xB.set(e10, window.setTimeout(async () => {
      const { appId: t2, cname: i2, token: n2, stringUid: r2, uid: o2, proxyServer: s2 } = e10;
      try {
        await WB(t2, i2, n2, o2, s2, r2), xB.has(e10) && zB(e10);
      } catch (t3) {
        fb.warn("update preload failed", t3.message), JB(e10);
      }
    }, XA("AP_UPDATE_INTERVAL")));
  }
}
function JB(e9) {
  const t2 = VB.indexOf(e9);
  -1 !== t2 && VB.splice(t2, 1);
  let i2 = xB.get(e9);
  i2 && (window.clearTimeout(i2), i2 = null, xB.delete(e9), zB());
}
function XB(e9, t2) {
  const i2 = e9.sua, n2 = e9.ap;
  t2 && i2 && vb.reqUserAccount(e9.sid, { lts: i2.requestTime, elapse: i2.elapse, success: true, serverAddr: i2.url, stringUid: t2, uid: e9.intUid, errorCode: null, extend: i2.req }), vb.reportResourceTiming(e9.ap.url, e9.sid), vb.joinWebProxyAP(e9.sid, { lts: n2.requestTime, elapse: n2.elapse, sucess: 1, apServerAddr: n2.url, turnServerAddrList: n2.proxyInfo.addresses.map((e10) => e10.ip).join(","), eventType: "disabled", unilbsServerIds: [YO.CHOOSE_SERVER, YO.CLOUD_PROXY_FALLBACK].toString() }), vb.joinChooseServer(e9.sid, { lts: n2.requestTime, elapse: n2.elapse, succ: true, csAddr: n2.url, opid: n2.opid, serverList: n2.gatewayInfo.gatewayAddrs.map((e10) => e10.address), ec: null, cid: n2.gatewayInfo.cid.toString(), uid: n2.gatewayInfo.uid.toString(), csIp: n2.gatewayInfo.csIp, unilbsServerIds: [YO.CHOOSE_SERVER].toString(), isHttp3: n2.isHttp3 });
}
function QB(e9) {
  return window.atob(window.localStorage.getItem(e9) || "");
}
function ZB(e9, t2) {
  window.localStorage.setItem(e9, window.btoa(t2));
}
function $B(e9) {
  let t2 = "".concat(e9.appId, "_").concat(e9.cname);
  return "string" == typeof e9.uid && (t2 += "_s_".concat(e9.uid)), "number" == typeof e9.uid && (t2 += "_".concat(e9.uid)), e9.token && (t2 += "_".concat(e9.token)), bA(t2);
}
function ej(e9) {
  let t2 = function() {
    const e10 = rj.pop();
    return e10 ? (e10.offset = e10.limit = 0, e10) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
  }();
  return function(e10, t3) {
    let i2 = e10.appId;
    void 0 !== i2 && (Ej(t3, 10), uj(t3, i2));
    let n2 = e10.cid;
    void 0 !== n2 && (Ej(t3, 16), Ej(t3, n2));
    let r2 = e10.cname;
    void 0 !== r2 && (Ej(t3, 26), uj(t3, r2));
    let o2 = e10.deviceId;
    void 0 !== o2 && (Ej(t3, 34), uj(t3, o2));
    let s2 = e10.elapse;
    void 0 !== s2 && (Ej(t3, 40), mj(t3, s2));
    let a2 = e10.fileSize;
    void 0 !== a2 && (Ej(t3, 48), mj(t3, nj(a2)));
    let c2 = e10.height;
    void 0 !== c2 && (Ej(t3, 56), mj(t3, nj(c2)));
    let d2 = e10.jpg;
    void 0 !== d2 && (Ej(t3, 66), Ej(t3, d2.length), dj(t3, d2));
    let l2 = e10.networkType;
    void 0 !== l2 && (Ej(t3, 72), mj(t3, nj(l2)));
    let u2 = e10.osType;
    void 0 !== u2 && (Ej(t3, 80), mj(t3, nj(u2)));
    let h2 = e10.requestId;
    void 0 !== h2 && (Ej(t3, 90), uj(t3, h2));
    let p2 = e10.sdkVersion;
    void 0 !== p2 && (Ej(t3, 98), uj(t3, p2));
    let _2 = e10.sequence;
    void 0 !== _2 && (Ej(t3, 104), mj(t3, nj(_2)));
    let E2 = e10.sid;
    void 0 !== E2 && (Ej(t3, 114), uj(t3, E2));
    let f2 = e10.timestamp;
    void 0 !== f2 && (Ej(t3, 120), mj(t3, f2));
    let m2 = e10.uid;
    void 0 !== m2 && (Ej(t3, 128), Ej(t3, m2));
    let T2 = e10.vid;
    void 0 !== T2 && (Ej(t3, 136), Ej(t3, T2));
    let S2 = e10.width;
    void 0 !== S2 && (Ej(t3, 144), mj(t3, nj(S2)));
    let g2 = e10.service;
    void 0 !== g2 && (Ej(t3, 152), Ej(t3, g2));
    let R2 = e10.callbackData;
    void 0 !== R2 && (Ej(t3, 162), Ej(t3, R2.length), dj(t3, R2));
    let C2 = e10.ticket;
    void 0 !== C2 && (Ej(t3, 170), uj(t3, C2));
    let I2 = e10.vendorConfigs;
    void 0 !== I2 && (Ej(t3, 178), uj(t3, I2));
  }(e9, t2), function(e10) {
    let t3 = e10.bytes, i2 = e10.limit;
    return t3.length === i2 ? t3 : t3.subarray(0, i2);
  }(t2);
}
function tj(e9) {
  return function(e10) {
    let t3 = {};
    e: for (; !sj(e10); ) {
      let i2 = _j(e10);
      switch (i2 >>> 3) {
        case 0:
          break e;
        case 1:
          t3.code = _j(e10);
          break;
        case 2:
          t3.msg = lj(e10, _j(e10));
          break;
        case 3:
          t3.requestId = lj(e10, _j(e10));
          break;
        case 4:
          t3.timestamp = fj(e10, false);
          break;
        default:
          ij(e10, 7 & i2);
      }
    }
    return t3;
  }({ bytes: t2 = e9, offset: 0, limit: t2.length });
  var t2;
}
function ij(e9, t2) {
  switch (t2) {
    case 0:
      for (; 128 & hj(e9); ) ;
      break;
    case 2:
      oj(e9, _j(e9));
      break;
    case 5:
      oj(e9, 4);
      break;
    case 1:
      oj(e9, 8);
      break;
    default:
      throw new Error("Unimplemented type: " + t2);
  }
}
function nj(e9) {
  return { low: e9 |= 0, high: e9 >> 31, unsigned: e9 >= 0 };
}
var rj = [];
function oj(e9, t2) {
  if (e9.offset + t2 > e9.limit) throw new Error("Skip past limit");
  e9.offset += t2;
}
function sj(e9) {
  return e9.offset >= e9.limit;
}
function aj(e9, t2) {
  let i2 = e9.bytes, n2 = e9.offset, r2 = e9.limit, o2 = n2 + t2;
  if (o2 > i2.length) {
    let t3 = new Uint8Array(2 * o2);
    t3.set(i2), e9.bytes = t3;
  }
  return e9.offset = o2, o2 > r2 && (e9.limit = o2), n2;
}
function cj(e9, t2) {
  let i2 = e9.offset;
  if (i2 + t2 > e9.limit) throw new Error("Read past limit");
  return e9.offset += t2, i2;
}
function dj(e9, t2) {
  let i2 = aj(e9, t2.length);
  e9.bytes.set(t2, i2);
}
function lj(e9, t2) {
  let i2 = cj(e9, t2), n2 = String.fromCharCode, r2 = e9.bytes, o2 = "ï¿½", s2 = "";
  for (let e10 = 0; e10 < t2; e10++) {
    let a2, c2, d2, l2, u2 = r2[e10 + i2];
    0 == (128 & u2) ? s2 += n2(u2) : 192 == (224 & u2) ? e10 + 1 >= t2 ? s2 += o2 : (a2 = r2[e10 + i2 + 1], 128 != (192 & a2) ? s2 += o2 : (l2 = (31 & u2) << 6 | 63 & a2, l2 < 128 ? s2 += o2 : (s2 += n2(l2), e10++))) : 224 == (240 & u2) ? e10 + 2 >= t2 ? s2 += o2 : (a2 = r2[e10 + i2 + 1], c2 = r2[e10 + i2 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? s2 += o2 : (l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & c2, l2 < 2048 || l2 >= 55296 && l2 <= 57343 ? s2 += o2 : (s2 += n2(l2), e10 += 2))) : 240 == (248 & u2) ? e10 + 3 >= t2 ? s2 += o2 : (a2 = r2[e10 + i2 + 1], c2 = r2[e10 + i2 + 2], d2 = r2[e10 + i2 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? s2 += o2 : (l2 = (7 & u2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, l2 < 65536 || l2 > 1114111 ? s2 += o2 : (l2 -= 65536, s2 += n2(55296 + (l2 >> 10), 56320 + (1023 & l2)), e10 += 3))) : s2 += o2;
  }
  return s2;
}
function uj(e9, t2) {
  let i2 = t2.length, n2 = 0;
  for (let e10 = 0; e10 < i2; e10++) {
    let r3 = t2.charCodeAt(e10);
    r3 >= 55296 && r3 <= 56319 && e10 + 1 < i2 && (r3 = (r3 << 10) + t2.charCodeAt(++e10) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
  }
  Ej(e9, n2);
  let r2 = aj(e9, n2), o2 = e9.bytes;
  for (let e10 = 0; e10 < i2; e10++) {
    let n3 = t2.charCodeAt(e10);
    n3 >= 55296 && n3 <= 56319 && e10 + 1 < i2 && (n3 = (n3 << 10) + t2.charCodeAt(++e10) - 56613888), n3 < 128 ? o2[r2++] = n3 : (n3 < 2048 ? o2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? o2[r2++] = n3 >> 12 & 15 | 224 : (o2[r2++] = n3 >> 18 & 7 | 240, o2[r2++] = n3 >> 12 & 63 | 128), o2[r2++] = n3 >> 6 & 63 | 128), o2[r2++] = 63 & n3 | 128);
  }
}
function hj(e9) {
  return e9.bytes[cj(e9, 1)];
}
function pj(e9, t2) {
  let i2 = aj(e9, 1);
  e9.bytes[i2] = t2;
}
function _j(e9) {
  let t2, i2 = 0, n2 = 0;
  do {
    t2 = hj(e9), i2 < 32 && (n2 |= (127 & t2) << i2), i2 += 7;
  } while (128 & t2);
  return n2;
}
function Ej(e9, t2) {
  for (t2 >>>= 0; t2 >= 128; ) pj(e9, 127 & t2 | 128), t2 >>>= 7;
  pj(e9, t2);
}
function fj(e9, t2) {
  let i2, n2 = 0, r2 = 0, o2 = 0;
  return i2 = hj(e9), n2 = 127 & i2, 128 & i2 && (i2 = hj(e9), n2 |= (127 & i2) << 7, 128 & i2 && (i2 = hj(e9), n2 |= (127 & i2) << 14, 128 & i2 && (i2 = hj(e9), n2 |= (127 & i2) << 21, 128 & i2 && (i2 = hj(e9), r2 = 127 & i2, 128 & i2 && (i2 = hj(e9), r2 |= (127 & i2) << 7, 128 & i2 && (i2 = hj(e9), r2 |= (127 & i2) << 14, 128 & i2 && (i2 = hj(e9), r2 |= (127 & i2) << 21, 128 & i2 && (i2 = hj(e9), o2 = 127 & i2, 128 & i2 && (i2 = hj(e9), o2 |= (127 & i2) << 7))))))))), { low: n2 | r2 << 28, high: r2 >>> 4 | o2 << 24, unsigned: t2 };
}
function mj(e9, t2) {
  let i2 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, o2 = 0 === r2 ? 0 === n2 ? i2 < 16384 ? i2 < 128 ? 1 : 2 : i2 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, s2 = aj(e9, o2), a2 = e9.bytes;
  switch (o2) {
    case 10:
      a2[s2 + 9] = r2 >>> 7 & 1;
    case 9:
      a2[s2 + 8] = 9 !== o2 ? 128 | r2 : 127 & r2;
    case 8:
      a2[s2 + 7] = 8 !== o2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
    case 7:
      a2[s2 + 6] = 7 !== o2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
    case 6:
      a2[s2 + 5] = 6 !== o2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
    case 5:
      a2[s2 + 4] = 5 !== o2 ? 128 | n2 : 127 & n2;
    case 4:
      a2[s2 + 3] = 4 !== o2 ? i2 >>> 21 | 128 : i2 >>> 21 & 127;
    case 3:
      a2[s2 + 2] = 3 !== o2 ? i2 >>> 14 | 128 : i2 >>> 14 & 127;
    case 2:
      a2[s2 + 1] = 2 !== o2 ? i2 >>> 7 | 128 : i2 >>> 7 & 127;
    case 1:
      a2[s2] = 1 !== o2 ? 128 | i2 : 127 & i2;
  }
}
var Tj = {};
var Sj = {};
var gj = 4294967296;
var Rj = gj * gj;
var Cj = Rj / 2;
var Ij = wj(0, true);
var vj = wj(0);
var yj = Oj(0, -2147483648, false);
var Aj = Oj(-1, 2147483647, false);
var bj = Oj(-1, -1, true);
function wj(e9, t2) {
  let i2, n2, r2;
  return t2 ? (r2 = 0 <= (e9 >>>= 0) && e9 < 256) && (n2 = Sj[e9], n2) ? n2 : (i2 = Oj(e9, 0, true), r2 && (Sj[e9] = i2), i2) : (r2 = -128 <= (e9 |= 0) && e9 < 128) && (n2 = Tj[e9], n2) ? n2 : (i2 = Oj(e9, e9 < 0 ? -1 : 0, false), r2 && (Tj[e9] = i2), i2);
}
function Oj(e9, t2, i2) {
  return { low: 0 | e9, high: 0 | t2, unsigned: !!i2 };
}
function Nj(e9, t2) {
  if (isNaN(e9)) return t2 ? Ij : vj;
  if (t2) {
    if (e9 < 0) return Ij;
    if (e9 >= Rj) return bj;
  } else {
    if (e9 <= -Cj) return yj;
    if (e9 + 1 >= Cj) return Aj;
  }
  return e9 < 0 ? t2 ? Ij : vj : Oj(e9 % gj | 0, e9 / gj | 0, t2);
}
function Dj(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
var Pj = class _Pj extends xy {
  get connectionState() {
    return this._connectionState;
  }
  set connectionState(e9) {
    if (this._connectionState === e9) return;
    const t2 = this._connectionState;
    this._connectionState = e9, this.emit(RO.CONNECTION_STATE_CHANGE, e9, t2);
  }
  get quality() {
    return this._quality;
  }
  set quality(e9) {
    this._quality = e9 > 1 ? 1 : e9 < 0.1 ? 0.1 : e9, this._qualityTimer && (window.clearTimeout(this._qualityTimer), this._qualityTimer = null), this._quality >= 1 || (this._qualityTimer = window.setTimeout(() => {
      this.quality = this._quality / this._qualityRatio;
    }, 6e4));
  }
  constructor(e9) {
    var t2;
    super(), Fg(this, "name", "AgoraRTCImageModeration"), Fg(this, "_connectionState", gO.CONNECTING), Fg(this, "_sequence", 0), Fg(this, "_moderationStartTime", void 0), Fg(this, "_workerConnection", void 0), Fg(this, "_workerMessageLengthLimit", void 0), Fg(this, "_qualityRatio", void 0), Fg(this, "_connectInfo", void 0), Fg(this, "_cancelTokenSource", Lv.CancelToken.source()), Fg(this, "_retryConfig", void 0), Fg(this, "_moderationInterval", void 0), Fg(this, "_moderationTimer", null), Fg(this, "_moderationMode", 1), Fg(this, "_quality", 1), Fg(this, "_qualityTimer", null), Fg(this, "_ticket", void 0), Fg(this, "_moderationIntervalMinimum", void 0), Fg(this, "_uploadFailedNum", 0), Fg(this, "_uploadNum", 0), Fg(this, "_uploadTimer", null), Fg(this, "_extraInfo", void 0), Fg(this, "_vendor", ""), Fg(this, "_encoder", new TextEncoder()), Fg(this, "_moderationId", void 0), Fg(this, "inspectImage", () => {
      if (this.connectionState !== gO.CONNECTED) throw new yb(Ry.OPERATION_ABORTED, "image moderation service connection status is ".concat(this.connectionState));
      this._moderationTimer && (window.clearInterval(this._moderationTimer), this._moderationTimer = null), this._moderationTimer = window.setInterval(() => {
        this.connectionState === gO.CONNECTED ? this.requestToInspectImage() : fb.debug("[".concat(this._moderationId, "] Moderation State is not connected , "), this.connectionState);
      }, this._moderationInterval < this._moderationIntervalMinimum ? this._moderationIntervalMinimum : this._moderationInterval), this.requestToInspectImage();
    }), this._moderationId = TA(5, "image-moderation-"), this._workerMessageLengthLimit = XA("IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT"), this._moderationIntervalMinimum = XA("IMAGE_MODERATION_INTERVAL_MINIMUM"), this._moderationInterval = null !== (t2 = e9.interval) && void 0 !== t2 ? t2 : 1e3, e9.extraInfo && (this._extraInfo = this._encoder.encode(e9.extraInfo)), e9.vendor && (this._vendor = e9.vendor), this._qualityRatio = XA("IMAGE_MODERATION_QUALITY_RATIO"), this._moderationStartTime = Number(Date.now()), this._workerConnection = new HO("worker-" + this._moderationId, PA), this.on(RO.STATE_CHANGE, (e10, t3) => {
      fb.debug("[".concat(this._moderationId, "] Moderation operation :").concat(CO[e10], " ").concat(t3 || ""));
    }), this.handleWorkerEvents();
  }
  async init(e9, t2) {
    this.emit(RO.STATE_CHANGE, CO.CONNECT_AP), this._connectInfo = e9;
    const i2 = this._cancelTokenSource.token;
    return this._retryConfig = t2, new Gh((n2, r2) => {
      this.on(RO.CONNECTION_STATE_CHANGE, (e10, t3) => {
        e10 === gO.CONNECTED && n2();
      }), this.requestAP(e9, i2, t2).then((e10) => {
        this.connectWorker(e10);
      }).catch((e10) => {
        r2(e10);
      });
    });
  }
  updateConfig(e9) {
    var t2;
    this._moderationInterval = null !== (t2 = e9.interval) && void 0 !== t2 ? t2 : 1e3, e9.extraInfo && (this._extraInfo = this._encoder.encode(e9.extraInfo)), e9.vendor && (this._vendor = e9.vendor), fb.debug("[".concat(this._moderationId, "] updateConfig: ").concat(JSON.stringify(e9))), this.connectionState === gO.CONNECTED && this.inspectImage();
  }
  async requestAP(e9, t2, i2) {
    const n2 = XA("WEBCS_DOMAIN").map((e10) => "https://".concat(e10, "/api/v1")), r2 = await function(e10, t3, i3, n3) {
      let { appId: r3, areaCode: o3, cname: s3, sid: a2, token: c2, uid: d2 } = t3;
      Bx++;
      const l2 = "moderation_plugin", u2 = { service_name: l2, json_body: JSON.stringify({ appId: r3, areaCode: o3, cname: s3, command: "allocateEdge", requestId: Bx, seq: Bx, sid: a2, appToken: c2, ts: Date.now(), uid: d2 + "" }) };
      let h2, p2, _2 = e10[0];
      return kA(async () => {
        h2 = Date.now();
        const e11 = await Tx(_2, { data: u2, cancelToken: i3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
        if (p2 = Date.now() - h2, 0 !== e11.code) {
          const t5 = new yb(Ry.UNEXPECTED_RESPONSE, "moderation plugin ap error, code" + e11.code, { retry: true, responseTime: p2 });
          throw fb.error(t5.toString()), t5;
        }
        const t4 = JSON.parse(e11.json_body);
        if (200 !== t4.code) {
          const e12 = new yb(Ry.UNEXPECTED_RESPONSE, "moderation plugin ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p2 });
          throw fb.error(e12.toString()), e12;
        }
        if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
          const e12 = new yb(Ry.UNEXPECTED_RESPONSE, "moderation plugin ap empty server", { code: t4.code, responseTime: p2 });
          throw fb.error(e12.toString()), e12;
        }
        if (!t4.servers.some((e12) => !!e12.wss)) {
          const e12 = new yb(Ry.UNEXPECTED_RESPONSE, "moderation plugin ap empty port", { code: t4.code, responseTime: p2 });
          throw fb.error(e12.toString()), e12;
        }
        const n4 = XA("IMAGE_MODERATION_WORKER_HOST");
        return { addressList: t4.servers.map((e12) => {
          let { address: t5, wss: i4 } = e12;
          if (t5 && i4) return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(n4, ":").concat(i4, "/moderation");
        }).filter((e12) => !!e12), workerToken: t4.workerToken, vid: t4.vid, ticket: t4.appTicket, responseTime: p2 };
      }, (t4, i4) => (vb.apworkerEvent(a2, { success: true, sc: 200, serviceName: l2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i4, responseTime: p2, serverIp: e10[i4 % e10.length] }), false), (t4, i4) => (vb.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: l2, responseTime: p2, serverIp: e10[i4 % e10.length] }), !!(t4.code !== Ry.OPERATION_ABORTED && t4.code !== Ry.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e10[(i4 + 1) % e10.length], true)), n3);
    }(n2, e9, t2, i2);
    this.emit(RO.STATE_CHANGE, CO.AP_CONNECTED);
    const { addressList: o2, ticket: s2 } = r2;
    return this._ticket = s2, o2;
  }
  async connectWorker(e9) {
    this.emit(RO.STATE_CHANGE, CO.CONNECT_WORKER), await this._workerConnection.init(e9, 1e4);
  }
  handleWorkerEvents() {
    this._workerConnection.on(Uw.CONNECTED, async () => {
      this.emit(RO.STATE_CHANGE, CO.WORKER_CONNECTED, this._workerConnection.url), this.connectionState = gO.CONNECTED;
    }), this._workerConnection.on(Uw.CLOSED, () => {
      this.connectionState = gO.CLOSED;
    }), this._workerConnection.on(Uw.FAILED, () => {
      this.connectionState = gO.CLOSED;
    }), this._workerConnection.on(Uw.RECONNECTING, () => {
      this.connectionState = this.connectionState === gO.CONNECTED ? gO.RECONNECTING : gO.CONNECTING;
    }), this._workerConnection.on(Uw.ON_MESSAGE, async (e9) => {
      if (e9.data instanceof ArrayBuffer) {
        const t2 = tj(new Uint8Array(e9.data));
        XA("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && fb.debug("[".concat(this._moderationId, "] Response message for worker of image moderation "), JSON.stringify(t2)), this._uploadNum++, void 0 === t2.code || 0 === t2.code || (this._uploadFailedNum++, fb.error("[".concat(this._moderationId, "] Error response from worke, code is ").concat(t2.code, ", msg is ").concat(t2.msg)), this._uploadTimer || (this._uploadTimer = window.setTimeout(() => {
          vb.reportApiInvoke(this._connectInfo.sid || null, { name: By.IMAGE_MODERATION_UPLOAD, options: [this._uploadFailedNum, this._uploadNum, t2.code], tag: jy.TRACER }).onError(new yb(Ry.IMAGE_MODERATION_UPLOAD_FAILED, t2.msg)), this._uploadTimer = null;
        }, XA("IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL"))));
      } else fb.error("[".concat(this._moderationId, "] Unexpected message type from worker"));
    }), this._workerConnection.on(Uw.WILL_RECONNECT, (e9, t2, i2) => {
      "recover" === e9 && i2(e9), i2("tryNext");
    }), this._workerConnection.on(Uw.REQUEST_NEW_URLS, (e9, t2) => {
      this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e9).catch(t2);
    });
  }
  static intToLong(e9) {
    return { low: e9 |= 0, high: e9 >> 31, unsigned: e9 >= 0 };
  }
  async requestToInspectImage() {
    const e9 = eA(this, RO.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
    if (e9) {
      if (!e9.isPlaying) return void (XA("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && fb.debug("Only the track being played can be inspected"));
      this._sequence++;
      const i2 = await this.generateRequestData(e9, t2);
      this._workerConnection.sendMessage(i2, true, true);
    } else XA("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && fb.debug("Only the track being published can be inspected");
  }
  async generateRequestData(e9, t2) {
    let { appId: i2, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 } = t2;
    const c2 = Date.now(), d2 = await e9.getCurrentFrameImage("image/jpeg", this.quality), l2 = await Ok(d2, i2, n2), u2 = this._sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + TA(12, ""), h2 = { appId: i2, cid: r2, cname: n2, deviceId: "", elapse: _Pj.intToLong(Number(c2 - this._moderationStartTime)), fileSize: d2.buffer.byteLength, height: d2.height, width: d2.width, jpg: l2, networkType: 6, osType: 7, requestId: u2, sdkVersion: "4.22.1", sequence: this._sequence, sid: s2, timestamp: Nj(c2), uid: a2, vid: o2, service: this._moderationMode, ticket: this._ticket, callbackData: this._extraInfo, vendorConfigs: this._vendor };
    void 0 === this._extraInfo && delete h2.callbackData;
    const p2 = ej(h2);
    if (p2.byteLength < this._workerMessageLengthLimit) {
      if (XA("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")) {
        const e10 = function(e11) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var i3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? Dj(Object(i3), true).forEach(function(t4) {
              Fg(e11, t4, i3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e11, Object.getOwnPropertyDescriptors(i3)) : Dj(Object(i3)).forEach(function(t4) {
              Object.defineProperty(e11, t4, Object.getOwnPropertyDescriptor(i3, t4));
            });
          }
          return e11;
        }({}, h2);
        delete e10.jpg, fb.debug("[".concat(this._moderationId, "] Request message for worker of image moderation service: "), JSON.stringify(e10));
      }
      return p2;
    }
    {
      const t3 = this.quality * this._qualityRatio;
      return this.quality = t3, await this.generateRequestData(e9, { appId: i2, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 });
    }
  }
  close() {
    this._cancelTokenSource.cancel(), this._cancelTokenSource = Lv.CancelToken.source(), this._workerConnection && this._workerConnection.close(), this._moderationTimer && window.clearInterval(this._moderationTimer), this._moderationTimer = null, this._uploadTimer && window.clearTimeout(this._uploadTimer), this._uploadTimer = null, this.connectionState = gO.CLOSED, this.emit(RO.STATE_CHANGE, CO.CLOSED);
  }
};
function Lj(e9) {
  if (yy(e9.interval, "interval", 1e3, 1 / 0), e9 && e9.extraInfo && e9.extraInfo.length > 1024) throw new yb(Ry.INVALID_PARAMS, "config.extraInfo length cannot exceed 1024 bytes");
  if (e9 && e9.vendor && e9.vendor.length > 1024) throw new yb(Ry.INVALID_PARAMS, "config.vendor length cannot exceed 1024 bytes");
}
var kj = { name: "ImageModeration", create: function(e9) {
  let { config: t2 } = e9;
  return Lj(t2), new Pj(t2);
} };
var Mj;
var Uj;
var xj;
var Vj;
var Fj;
var Bj;
var jj;
var Gj;
var Wj;
var Hj;
var Kj;
var Yj;
var qj;
var zj;
var Jj;
var Xj;
var Qj;
var Zj;
var $j;
var eG;
var tG;
var iG;
var nG;
var rG;
var oG;
var sG;
var aG;
var cG;
var dG;
var lG;
var uG;
var hG;
var pG;
var _G;
var EG;
var fG;
var mG;
var TG;
var SG;
var gG;
var RG;
function CG(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function IG(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? CG(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : CG(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
NA.setLogger(fb);
var vG = (Mj = Ib(), Uj = Ib({ argsMap: (e9, t2) => {
  if (!Array.isArray(t2)) {
    if (!(t2 instanceof HL)) return [t2];
    t2 = [t2];
  }
  return t2.map((e10) => e10 ? Object(e10).toString() : "null");
} }), xj = Ib({ argsMap: (e9, t2) => (t2 || (t2 = []), Array.isArray(t2) || t2.trackMediaType !== vL.DATA ? (Array.isArray(t2) || (t2 = [t2]), t2.map((e10) => e10.getTrackId())) : [t2.getChannelId()]) }), Vj = Ib({ argsMap: (e9, t2, i2, n2) => ["object" == typeof t2 ? t2.uid : t2, i2, n2] }), Fj = Ib({ argsMap: (e9, t2, i2) => [t2, i2] }), Bj = Ib({ argsMap: (e9, t2) => t2.map((e10) => {
  let { user: t3, mediaType: i2 } = e10;
  return [null == t3 ? void 0 : t3.uid, i2];
}) }), jj = Ib({ argsMap: (e9, t2, i2, n2) => ["object" == typeof t2 ? t2.uid : t2, i2, n2] }), Gj = Ib({ argsMap: (e9, t2) => t2.map((e10) => {
  let { user: t3, mediaType: i2 } = e10;
  return { uid: null == t3 ? void 0 : t3.uid, mediaType: i2 };
}) }), Wj = Ib(), Hj = Ib(), Kj = Ib(), Yj = Ib(), qj = Ib(), zj = Ib(), Jj = Ib(), Xj = Ib(), Qj = Ib(), Zj = Ib(), $j = Ib(), eG = Ib(), tG = Ib(), iG = Ib(), nG = Ib({ argsMap: (e9, t2) => [t2] }), rG = Ib(), oG = Ib(), sG = Ib(), aG = Ib(), cG = Ib(), dG = Ib(), lG = Ib(), uG = Ib(), hG = Ib({ argsMap: (e9, t2) => (Array.isArray(t2) || (t2 = [t2]), [JSON.stringify(t2)]) }), pG = Ib(), _G = Ib(), EG = Ib(), fG = Ib(), mG = Ib(), TG = Ib(), SG = Ib({ reportResult: true }), gG = Ib(), RG = class extends xy {
  get connectionState() {
    return this._gateway.state;
  }
  get remoteUsers() {
    return this._users;
  }
  get localTracks() {
    return this._p2pChannel.getAllTracks(true);
  }
  get uid() {
    return this._uid;
  }
  get channelName() {
    return this._channelName;
  }
  get localDataChannels() {
    return this._p2pChannel.getAllDataChannels();
  }
  get mode() {
    return this._config.mode;
  }
  get role() {
    var e9;
    return (null === (e9 = this._config) || void 0 === e9 ? void 0 : e9.role) || "audience";
  }
  get codec() {
    return this._config.codec;
  }
  get audioCodec() {
    return this._config.audioCodec || "opus";
  }
  get isStringUID() {
    return !!this._joinInfo && !!this._joinInfo.stringUid;
  }
  get __className__() {
    return "Client";
  }
  constructor(e9) {
    let t2;
    if (super(), Fg(this, "store", void 0), Fg(this, "_uid", void 0), Fg(this, "_channelName", void 0), Fg(this, "_uintUid", void 0), Fg(this, "_users", []), Fg(this, "_config", void 0), Fg(this, "_clientId", void 0), Fg(this, "_appId", void 0), Fg(this, "_sessionId", null), Fg(this, "_key", void 0), Fg(this, "_rtmConfig", {}), Fg(this, "_joinInfo", void 0), Fg(this, "_gateway", void 0), Fg(this, "_statsCollector", void 0), Fg(this, "_configDistribute", void 0), Fg(this, "_leaveMutex", new NA("client-leave")), Fg(this, "_publishMutex", new NA("client-publish")), Fg(this, "_renewTokenMutex", new NA("client-renewtoken")), Fg(this, "_subscribeMutex", new NA("client-subscribe")), Fg(this, "_encryptionMode", "none"), Fg(this, "_encryptionSecret", null), Fg(this, "_encryptionSalt", null), Fg(this, "_encryptDataStream", false), Fg(this, "_encryptDataStreamKey", null), Fg(this, "_encryptDataStreamIv", null), Fg(this, "_proxyServer", void 0), Fg(this, "_turnServer", { servers: [], mode: "auto" }), Fg(this, "_cloudProxyServerMode", "disabled"), Fg(this, "_isDualStreamEnabled", false), Fg(this, "_defaultStreamFallbackType", void 0), Fg(this, "_lowStreamParameter", void 0), Fg(this, "_streamFallbackTypeCacheMap", /* @__PURE__ */ new Map()), Fg(this, "_remoteStreamTypeCacheMap", /* @__PURE__ */ new Map()), Fg(this, "_axiosCancelSource", Lv.CancelToken.source()), Fg(this, "_audioVolumeIndicationInterval", void 0), Fg(this, "_networkQualityInterval", void 0), Fg(this, "_userOfflineTimeout", void 0), Fg(this, "_streamRemovedTimeout", void 0), Fg(this, "_liveTranscodeStreamingClient", void 0), Fg(this, "_liveRawStreamingClient", void 0), Fg(this, "_channelMediaRelayClient", void 0), Fg(this, "_networkQualitySensitivity", "normal"), Fg(this, "_p2pChannel", void 0), Fg(this, "_useLocalAccessPoint", false), Fg(this, "_setLocalAPVersion", void 0), Fg(this, "_joinAndNotLeaveYet", false), Fg(this, "_numberOfJoinCount", 0), Fg(this, "_remoteDefaultVideoStreamType", void 0), Fg(this, "_inspect", void 0), Fg(this, "_moderation", void 0), Fg(this, "_license", void 0), Fg(this, "_pendingPublishedUsers", []), Fg(this, "ntpAlignErrorCount", 0), Fg(this, "remoteInboundOffset", 0), Fg(this, "_handleLocalTrackEnable", (e10, t3, i2) => {
      this.publish(e10, false).then(t3).catch(i2);
    }), Fg(this, "_handleLocalTrackDisable", (e10, t3, i2) => {
      this.unpublish(e10).then(t3).catch(i2);
    }), Fg(this, "_handleUserOnline", (e10) => {
      if (XA("BLOCK_LOCAL_CLIENT") && Ob(e10.uid, this.channelName)) return void fb.debug("[".concat(e10.uid, "] will be ignored in local"));
      this.isStringUID && "string" != typeof e10.uid && fb.error("[".concat(this._clientId, "] StringUID is Mixed with UintUID"));
      const t3 = this._users.find((t4) => t4.uid === e10.uid);
      if (t3) t3._trust_in_room_ = true, t3._is_pre_created && (t3._is_pre_created = false, this.safeEmit(zy.USER_JOINED, t3));
      else {
        const t4 = new cF(e10.uid, e10.uint_id || e10.uid);
        this._users.push(t4), fb.debug("[".concat(this._clientId, "] user online"), e10.uid), this.safeEmit(zy.USER_JOINED, t4);
      }
    }), Fg(this, "_handleUserOffline", (e10) => {
      if (XA("BLOCK_LOCAL_CLIENT") && Ob(e10.uid, this.channelName)) return;
      const t3 = this._users.find((t4) => t4.uid === e10.uid);
      t3 && (this._handleRemoveStream(e10), this._handleRemoveDataChannels(e10), t3._audio_pre_subscribed || t3._video_pre_subscribed ? t3._is_pre_created = true : nA(this._users, t3), this._remoteStreamTypeCacheMap.delete(t3.uid), this._streamFallbackTypeCacheMap.delete(t3.uid), fb.debug("[".concat(this._clientId, "] user offline"), e10.uid, "reason:", e10.reason), this.safeEmit(zy.USER_LEAVED, t3, e10.reason));
    }), Fg(this, "_handleAddAudioOrVideoStream", (e10, t3, i2, n2, r2, o2, s2) => {
      if (XA("BLOCK_LOCAL_CLIENT") && Ob(t3, this.channelName)) return;
      const a2 = this._users.find((e11) => e11.uid === t3);
      if (!a2) return void fb.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
      fb.debug("[".concat(this._clientId, "] stream added with uid ").concat(t3, ", type ").concat(e10)), this.store.subscribe(a2.uid, e10, void 0, void 0, void 0, Date.now());
      const c2 = "audio" === e10 ? a2.hasAudio : a2.hasVideo;
      a2._uintid || (a2._uintid = r2 || t3), "audio" === e10 ? a2._trust_audio_stream_added_state_ = true : a2._trust_video_stream_added_state_ = true, "audio" === e10 ? (a2._audio_added_ = true, void 0 !== i2 && (a2._audioSSRC = i2), void 0 !== n2 && (a2._cname = n2), o2 && (a2._audioOrtc = o2)) : (a2._video_added_ = true, void 0 !== i2 && (a2._videoSSRC = i2), void 0 !== n2 && (a2._cname = n2), void 0 !== s2 && (a2._rtxSsrcId = s2), o2 && (a2._videoOrtc = o2)), ("audio" === e10 ? a2.hasAudio : a2.hasVideo) && !c2 && (fb.info("[".concat(this._clientId, "] remote user ").concat(a2.uid, " published ").concat(e10)), this.safeEmit(zy.USER_PUBLISHED, a2, e10)), "video" === e10 ? vb.onGatewayStream(this._sessionId, gb.ON_ADD_VIDEO_STREAM, Rb.ON_ADD_VIDEO_STREAM, { peer: r2 || t3, ssrc: a2._videoSSRC }) : vb.onGatewayStream(this._sessionId, gb.ON_ADD_AUDIO_STREAM, Rb.ON_ADD_AUDIO_STREAM, { peer: r2 || t3, ssrc: a2._audioSSRC }), this._p2pChannel.remoteMediaSsrcChanged(a2, e10, i2).then((t4) => {
        if (t4 && (fb.debug("[".concat(this._clientId, "] resubscribe ").concat(e10, " for user ").concat(a2.uid, " after rejoin because SSRC id changed.")), this._p2pChannel instanceof fB)) return this._p2pChannel.unsubscribe(a2, e10, true).then(() => this._subscribe(a2, e10, true).catch((e11) => {
          fb.error("[".concat(this._clientId, "] resubscribe error"), e11.toString());
        }));
      }), this._p2pChannel.hasPendingRemoteMedia(a2, e10) && (fb.debug("[".concat(this._clientId, "] resubscribe ").concat(e10, " for user ").concat(a2.uid, " after reconnect.")), this._subscribe(a2, e10, true).catch((e11) => {
        fb.error("[".concat(this._clientId, "] resubscribe error"), e11.toString());
      }));
    }), Fg(this, "_handleRemoveStream", (e10) => {
      if (XA("BLOCK_LOCAL_CLIENT") && Ob(e10.uid, this.channelName)) return;
      const t3 = this._users.find((t4) => t4.uid === e10.uid);
      if (!t3) return void fb.warning("[".concat(this._clientId, "] can not find target user!(on_remove_stream)"));
      fb.debug("[".concat(this._clientId, "] stream removed with uid ").concat(e10.uid));
      let i2 = () => {
      };
      t3.hasAudio && t3.hasVideo ? i2 = () => {
        fb.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), this.safeEmit(zy.USER_UNPUBLISHED, t3, "audio"), fb.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), this.safeEmit(zy.USER_UNPUBLISHED, t3, "video");
      } : t3.hasVideo ? i2 = () => {
        fb.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), this.safeEmit(zy.USER_UNPUBLISHED, t3, "video");
      } : t3.hasAudio && (i2 = () => {
        fb.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), this.safeEmit(zy.USER_UNPUBLISHED, t3, "audio");
      }), t3._video_pre_subscribed || t3._audio_pre_subscribed || (t3._trust_audio_stream_added_state_ = true, t3._trust_video_stream_added_state_ = true, t3._audio_added_ = false, t3._video_added_ = false, this._p2pChannel instanceof fB && this._p2pChannel.unsubscribe(t3).then((e11) => {
        if (e11) return this._gateway.unsubscribe(e11, t3.uid);
      }), t3._audioSSRC = void 0, t3._videoSSRC = void 0, t3._audioOrtc = void 0, t3._videoOrtc = void 0, t3._rtxSsrcId = void 0), vb.onGatewayStream(this._sessionId, gb.ON_REMOVE_STREAM, Rb.ON_REMOVE_STREAM, { peer: e10.uint_id || e10.uid }), i2();
    }), Fg(this, "_handleSetStreamLocalEnable", (e10, t3, i2) => {
      if (XA("BLOCK_LOCAL_CLIENT") && Ob(t3, this.channelName)) return;
      const n2 = this._users.find((e11) => e11.uid === t3);
      if (!n2) return void fb.error("[".concat(this._clientId, "] can not find target user!(disable_local)"));
      fb.debug("[".concat(this._clientId, "] local ").concat(e10, " ").concat(i2 ? "enabled" : "disabled", " with uid ").concat(t3));
      const r2 = "audio" === e10 ? n2.hasAudio : n2.hasVideo;
      if ("audio" === e10) {
        n2._trust_audio_enabled_state_ = true;
        const e11 = n2._audio_enabled_;
        if (n2._audio_enabled_ = i2, n2._audio_enabled_ === e11) return;
        {
          const e12 = n2._audio_enabled_ ? "enable-local-audio" : "disable-local-audio";
          fb.debug("[".concat(this._clientId, "] user-info-updated, uid: ").concat(t3, ", msg: ").concat(e12)), this.safeEmit(zy.USER_INFO_UPDATED, t3, e12);
        }
      } else {
        n2._trust_video_enabled_state_ = true;
        const e11 = n2._video_enabled_;
        if (n2._video_enabled_ = i2, n2._video_enabled_ === e11) return;
        {
          const e12 = n2._video_enabled_ ? "enable-local-video" : "disable-local-video";
          fb.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(t3, ", msg: ").concat(e12)), this.safeEmit(zy.USER_INFO_UPDATED, t3, e12);
        }
      }
      const o2 = "audio" === e10 ? n2.hasAudio : n2.hasVideo;
      return r2 !== o2 ? !r2 && o2 ? (fb.info("[".concat(this._clientId, "] remote user ").concat(t3, " published ").concat(e10)), void this.safeEmit(zy.USER_PUBLISHED, n2, e10)) : ("video" === e10 && n2._videoTrack && n2._videoTrack._destroy(), "audio" === e10 && n2._audioTrack, this._p2pChannel.muteRemote(n2, e10), fb.info("[".concat(this._clientId, "] remote user ").concat(t3, " unpublished ").concat(e10)), void this.safeEmit(zy.USER_UNPUBLISHED, n2, e10)) : void 0;
    }), Fg(this, "_handleMuteStream", (e10, t3, i2) => {
      if (XA("BLOCK_LOCAL_CLIENT") && Ob(e10, this.channelName)) return;
      fb.debug("[".concat(this._clientId, "] receive mute message"), e10, t3, i2);
      const n2 = this._users.find((t4) => t4.uid === e10);
      if (!n2) return void fb.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(e10));
      const r2 = "audio" === t3 ? n2.hasAudio : n2.hasVideo;
      if ("audio" === t3) {
        n2._trust_audio_mute_state_ = true;
        const t4 = n2._audio_muted_;
        if (n2._audio_muted_ = i2, n2._audio_muted_ === t4) return;
        {
          const t5 = n2._audio_muted_ ? "mute-audio" : "unmute-audio";
          fb.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e10, ", msg: ").concat(t5)), this.safeEmit(zy.USER_INFO_UPDATED, e10, t5);
        }
      } else {
        n2._trust_video_mute_state_ = true;
        const t4 = n2._video_muted_;
        if (n2._video_muted_ = i2, n2._video_muted_ === t4) return;
        {
          const t5 = n2._video_muted_ ? "mute-video" : "unmute-video";
          fb.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e10, ", msg: ").concat(t5)), this.safeEmit(zy.USER_INFO_UPDATED, e10, t5);
        }
      }
      const o2 = "audio" === t3 ? n2.hasAudio : n2.hasVideo;
      if (r2 !== o2) {
        if (!r2 && o2) {
          return ("audio" === t3 ? n2._audioSSRC : n2._videoSSRC) ? (fb.info("[".concat(this._clientId, "] remote user ").concat(e10, " published ").concat(t3)), void this.safeEmit(zy.USER_PUBLISHED, n2, t3)) : void fb.warning("[".concat(this._clientId, "] remote user ").concat(e10, " receive ").concat(t3, " unmute message  before add stream message, ").concat(t3, " SSRC doesn't exist yet."));
        }
        "video" === t3 && n2._videoTrack && !n2._video_pre_subscribed && n2._videoTrack._destroy(), "audio" === t3 && n2._audioTrack, this._p2pChannel.muteRemote(n2, t3), fb.info("[".concat(this._clientId, "] remote user ").concat(e10, " unpublished ").concat(t3)), this.safeEmit(zy.USER_UNPUBLISHED, n2, t3);
      }
    }), Fg(this, "_handleP2PLost", async (e10) => {
      fb.debug("[".concat(this._clientId, "] receive p2p lost"), e10), parseInt(e10.p2pid, 10) === this.store.p2pId ? await this._p2pChannel.requestReconnect() : fb.warning("[".concat(this._clientId, "] P2PLost stream not found"), e10);
    }), Fg(this, "_handleTokenWillExpire", () => {
      fb.debug("[".concat(this._clientId, "] received message onTokenPrivilegeWillExpire")), this.safeEmit(zy.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);
    }), Fg(this, "_handleBeforeUnload", (e10) => {
      "beforeunload" === e10.type && void 0 !== e10.returnValue && "" !== e10.returnValue || (this.leave(), fb.info("[".concat(this._clientId, "] auto leave onbeforeunload or pagehide")));
    }), Fg(this, "_handleUpdateNetworkQuality", () => {
      if ("normal" === this._networkQualitySensitivity) return;
      if (navigator && void 0 !== navigator.onLine && !navigator.onLine) return void this.safeEmit(zy.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 });
      const e10 = { downlinkNetworkQuality: 0, uplinkNetworkQuality: 0 };
      e10.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e10.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.safeEmit(zy.NETWORK_QUALITY, e10);
    }), Fg(this, "_handleP2PAddAudioOrVideoStream", (e10, t3, i2, n2) => {
      const r2 = this._users.find((e11) => e11.uid === t3);
      if (!r2) return void fb.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
      fb.debug("[".concat(this._clientId, "] stream added with uid ").concat(t3, ", type ").concat(e10)), this.store.subscribe(r2.uid, e10, void 0, void 0, void 0, Date.now());
      const o2 = "audio" === e10 ? r2.hasAudio : r2.hasVideo;
      "audio" === e10 ? r2._trust_audio_stream_added_state_ = true : r2._trust_video_stream_added_state_ = true, "audio" === e10 ? (r2._audio_added_ = true, void 0 !== i2 && (r2._audioSSRC = i2), void 0 !== n2 && (r2._audioMid = n2)) : (r2._video_added_ = true, void 0 !== i2 && (r2._videoSSRC = i2), void 0 !== n2 && (r2._videoMid = n2)), ("audio" === e10 ? r2.hasAudio : r2.hasVideo) && !o2 && (fb.info("[".concat(this._clientId, "] remote user ").concat(r2.uid, " published ").concat(e10)), this.safeEmit(zy.USER_PUBLISHED, r2, e10)), this._p2pChannel.hasPendingRemoteMedia(r2, e10) && (fb.debug("[".concat(this._clientId, "] resubscribe ").concat(e10, " for user ").concat(r2.uid, " after reconnect.")), this._subscribe(r2, e10, true).catch((e11) => {
        fb.error("[".concat(this._clientId, "] resubscribe error"), e11.toString());
      }));
    }), this._config = e9, this._clientId = TA(5, "client-"), this.store = new $A(e9.codec, e9.audioCodec, e9.mode, this._clientId), this.store.clientCreated(), e9.proxyServer && this.setProxyServer(e9.proxyServer, true), e9.turnServer && this.setTurnServer(e9.turnServer, true), fb.info("[".concat(this._clientId, "] Initializing AgoraRTC client v").concat(GA, " build: ").concat(qA, ", mode: ").concat(this.mode, ", codec: ").concat(this.codec)), e9.clientRoleOptions) try {
      qy(e9.clientRoleOptions), t2 = Object.assign({}, e9.clientRoleOptions);
    } catch (e10) {
      fb.warning("[".concat(this._clientId, "] ").concat(e10.toString()));
    }
    this._statsCollector = new DF(this.store), this._statsCollector.onStatsException = (e10, t3, i2) => {
      fb.debug("[".concat(this._clientId, "] receive exception msg, code: ").concat(e10, ", msg: ").concat(t3, ", uid: ").concat(i2)), this.safeEmit(zy.EXCEPTION, { code: e10, msg: t3, uid: i2 });
    }, this._statsCollector.onUploadPublishDuration = (e10, t3, i2, n2) => {
      const r2 = this._users.find((t4) => t4.uid === e10);
      r2 && vb.peerPublishStatus(this._sessionId, { subscribeElapse: n2, audioPublishDuration: t3, videoPublishDuration: i2, peer: r2._uintid });
    }, this.store.useP2P = "p2p" === e9.mode, this._gateway = new Ex(this.store, { clientId: this._clientId, mode: this.mode, codec: this.codec, websocketRetryConfig: e9.websocketRetryConfig || PA, httpRetryConfig: e9.httpRetryConfig || PA, forceWaitGatewayResponse: void 0 === e9.forceWaitGatewayResponse || e9.forceWaitGatewayResponse, statsCollector: this._statsCollector, role: e9.role, clientRoleOptions: t2 }), this._configDistribute = new tV(), this.store.useP2P ? (this._p2pChannel = new bF(this.store, this._statsCollector), this._handleP2PEvents()) : this._p2pChannel = new fB(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents();
  }
  async joinMeta(e9, t2, i2, n2, r2) {
    let o2 = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5], s2 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
    JA("JOIN_GATEWAY_USE_443PORT_ONLY", o2), JA("JOIN_GATEWAY_USE_DUAL_DOMAIN", s2);
    const a2 = this._gateway.signal.websocket;
    return a2 instanceof WO && (a2.use443PortOnly = o2, a2.tryDoubleDomain = s2), async function(e10, t3, i3) {
      Uv.get(e10) || Uv.set(e10, []), xv.get(e10) || xv.set(e10, t3), Vv.get(e10) || Vv.set(e10, 0);
      const n3 = Uv.get(e10), r3 = xv.get(e10);
      if (!n3 || !r3) throw new Error("concurrent: deferQueue or maxConcurrency is null");
      if (Vv.get(e10) === r3) {
        const e11 = Mv();
        n3.push(e11), await e11.promise;
      }
      Vv.set(e10, Vv.get(e10) + 1);
      for (var o3 = arguments.length, s3 = new Array(o3 > 3 ? o3 - 3 : 0), a3 = 3; a3 < o3; a3++) s3[a3 - 3] = arguments[a3];
      const c2 = await i3(...s3);
      return Vv.set(e10, Vv.get(e10) - 1), Vv.get(e10) === r3 - 1 && n3.length > 0 && (n3[0].resolve(), n3.shift()), 0 === Vv.get(e10) && (Uv.set(e10, []), xv.set(e10, 0), Vv.set(e10, 0)), c2;
    }("client.join", XA("JOIN_MAX_CONCURRENCY"), this.join.bind(this), e9, t2, i2, n2, r2);
  }
  async join(e9, t2, i2, n2, r2) {
    const o2 = ++this._numberOfJoinCount;
    this.store.joinStart(), n2 && (this.store.uid = n2);
    const s2 = "HTTPS" === (UA || UA || (UA = (window.location.protocol.split(":")[0] || "").toUpperCase(), UA)), a2 = jA() ? window.isSecureContext : "Browser Not Support";
    if (!jA() && !s2 || !window.isSecureContext) {
      const e10 = "The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";
      fb.warning(e10);
    }
    "DISCONNECTED" === this.connectionState && (this.store.avoidJoinStart = Math.round(Date.now()), fb.debug("[".concat(this._clientId, "] set avoidJoinStart to ").concat(this.store.avoidJoinStart))), vb.setAppId(e9);
    try {
      if (!i2 && null !== i2) throw new yb(Ry.INVALID_PARAMS, "Invalid token: ".concat(i2, ". If you don not use token, set it to null"));
      i2 && by(i2, "token", 1, 2047), by(e9, "appid", 1, 2047), xw(t2), n2 && Vw(n2), r2 && by(r2, "optionalInfo", 1, 2047);
    } catch (r3) {
      throw vb.reportApiInvoke(SA(), { name: By.JOIN, options: [e9, t2, i2, n2], states: { isHttps: s2, isSecureContext: a2 }, tag: jy.TRACER }).onError(r3), r3;
    }
    if (this._leaveMutex.isLocked) {
      fb.debug("[".concat(this._clientId, "] join: waiting leave operation"));
      (await this._leaveMutex.lock())(), fb.debug("[".concat(this._clientId, "] join: continue"));
    }
    if (this._joinAndNotLeaveYet = true, "DISCONNECTED" !== this.connectionState) {
      const r3 = new yb(Ry.INVALID_OPERATION, "[".concat(this._clientId, "] Client already in connecting/connected state"));
      throw vb.reportApiInvoke(SA(), { name: By.JOIN, options: [e9, t2, i2, n2], states: { isHttps: s2, isSecureContext: a2 }, tag: jy.TRACER }).onError(r3), r3;
    }
    this._gateway.state = "CONNECTING";
    const c2 = await YB({ appId: e9, cname: t2, uid: n2, stringUid: "string" == typeof n2 ? n2 : void 0, token: i2 || e9, cloudProxyServer: this._cloudProxyServerMode });
    if (!this._joinAndNotLeaveYet) throw new yb(Ry.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
    const d2 = (null == c2 ? void 0 : c2.sid) || SA();
    fb.info("[".concat(this._clientId, "] start join channel ").concat(t2, ", join number: ").concat(o2)), this._sessionId || (this._sessionId = d2, this.store.sessionId = this._sessionId);
    const l2 = vb.reportApiInvoke(d2, { name: By.JOIN, options: [e9, t2, i2, n2], states: { isHttps: s2, isSecureContext: a2 }, tag: jy.TRACER }), u2 = IG(IG(IG({}, this._rtmConfig), {}, { clientId: this._clientId, appId: e9, sid: this._sessionId, cname: t2, uid: "string" != typeof n2 ? n2 : null, turnServer: this._turnServer, proxyServer: this._proxyServer, token: i2 || e9, cloudProxyServer: this._cloudProxyServerMode, optionalInfo: r2, license: this._license, useLocalAccessPoint: this._useLocalAccessPoint, preload: !!c2 }, void 0 !== this._remoteDefaultVideoStreamType && { defaultVideoStream: this._remoteDefaultVideoStreamType }), {}, { apRequestDetail: XA("AP_REQUEST_DETAIL") || void 0 });
    if (this._useLocalAccessPoint && (u2.setLocalAPVersion = this._setLocalAPVersion), "string" == typeof n2 && (u2.stringUid = n2, this._uintUid ? (u2.uid = this._uintUid, this._uintUid = void 0) : u2.uid = 0), "none" !== this._encryptionMode && this._encryptionSecret) {
      if (u2.aesmode = this._encryptionMode, u2.aespassword = await (async (e10) => {
        const t3 = function(e11) {
          const t4 = window.atob("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"), i4 = new Uint8Array(new ArrayBuffer(t4.length));
          for (let e12 = 0; e12 < t4.length; e12 += 1) i4[e12] = t4.charCodeAt(e12);
          return i4;
        }(), i3 = await window.crypto.subtle.importKey("spki", t3, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]), n3 = ky(e10), r3 = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, i3, n3);
        return function(e11) {
          let t4 = "";
          for (let i4 = 0; i4 < e11.length; i4 += 1) t4 += String.fromCharCode(e11[i4]);
          return window.btoa(t4);
        }(new Uint8Array(r3));
      })(this._encryptionSecret), !this._joinAndNotLeaveYet) throw new yb(Ry.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
      this._encryptionSalt && (u2.aessalt = this._encryptionSalt);
    }
    if (this._encryptDataStream && ("aes-128-gcm2" === this._encryptionMode || "aes-256-gcm2" === this._encryptionMode)) if (this._encryptionSalt && this._encryptionSecret) if (window.crypto.subtle) {
      const e10 = new TextEncoder(), t3 = XA("USE_PURE_ENCRYPTION_MASTER_KEY") ? e10.encode(u2.appId + this._encryptionSecret + this._encryptionSecret) : e10.encode(u2.appId + u2.cname + this._encryptionSecret);
      this._encryptDataStreamIv = await async function(e11, t4, i3) {
        const n3 = await window.crypto.subtle.importKey("raw", t4, "PBKDF2", false, ["deriveBits", "deriveKey"]), r3 = "aes-128-gcm2" === e11 ? 128 : 256, o3 = await window.crypto.subtle.deriveBits({ name: "PBKDF2", iterations: nb, hash: "SHA-256", salt: i3 }, n3, r3 + ib);
        return new Uint8Array(o3).subarray(r3 / 8);
      }(this._encryptionMode, t3, lA(this._encryptionSalt)), this._encryptDataStreamKey = await async function(e11, t4, i3) {
        const n3 = await window.crypto.subtle.importKey("raw", t4, "PBKDF2", false, ["deriveBits", "deriveKey"]), r3 = "aes-128-gcm2" === e11 ? 128 : 256;
        return await window.crypto.subtle.deriveKey({ name: "PBKDF2", iterations: nb, hash: "SHA-256", salt: i3 }, n3, { name: "AES-GCM", length: r3 }, true, ["encrypt", "decrypt"]);
      }(this._encryptionMode, t3, lA(this._encryptionSalt));
    } else a2 ? fb.warning("[".concat(this._clientId, "] encrypt datastream must be running in a secure context, fallback to plain data stream")) : fb.warning("[".concat(this._clientId, "] current browser do not support WebCrypto ,fallback to plain data stream")), this._encryptDataStream = false;
    else this._encryptDataStream = false, fb.debug("[".concat(this._clientId, "] no salt / secret, cannot support encrypt data stream, fallback to plain data stream"));
    this._startSession(this._sessionId, { channel: t2, appId: e9, stringUid: u2.stringUid });
    const h2 = this._sessionId;
    setTimeout(() => {
      "CONNECTING" === this.connectionState && h2 === this._sessionId && vb.joinChannelTimeout(this._sessionId, 5);
    }, 5e3);
    try {
      var p2;
      let n3;
      const r3 = u2.cloudProxyServer;
      if (Dn(p2 = ["proxy3", "proxy4", "proxy5"]).call(p2, r3)) {
        const e10 = XA("PROXY_SERVER_TYPE3");
        Array.isArray(e10) ? u2.proxyServer = e10[0] : u2.proxyServer = e10;
      }
      if (vb.setProxyServer(u2.proxyServer), fb.setProxyServer(u2.proxyServer), this.store.requestAPStart(), c2) {
        if (fb.debug("[".concat(this._clientId, "] get serverInfo Success from Preload Cache ").concat(u2.stringUid ? ", ".concat(u2.stringUid, " => ").concat(c2.intUid) : "", " ")), u2.stringUid && !u2.uid && (u2.uid = c2.intUid), n3 = { gatewayInfo: c2.ap.gatewayInfo }, XA("JOIN_WITH_FALLBACK_MEDIA_PROXY") && "auto" === u2.turnServer.mode) if (0 === c2.ap.proxyInfo.addresses.length) fb.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers");
        else {
          const e10 = (await tN(c2.ap.proxyInfo, c2.ap.gatewayInfo.uid)).map((e11) => ({ turnServerURL: e11.address, tcpport: e11.tcpport || KA.tcpport, udpport: e11.udpport || KA.udpport, username: e11.username || KA.username, password: e11.password || KA.password, forceturn: false, security: true }));
          u2.turnServer = { mode: "manual", servers: e10 };
        }
        XB(c2, u2.stringUid);
      } else {
        if (u2.stringUid && !u2.uid) {
          let e10;
          [e10, n3] = await Gh.all([Yx(u2.stringUid, u2, this._axiosCancelSource.token, this._config.httpRetryConfig || PA, this.store), Kx(u2, this._axiosCancelSource.token, this._config.httpRetryConfig || PA, true, this.store)]), fb.debug("[".concat(this._clientId, "] getUserAccount Success ").concat(u2.stringUid, " => ").concat(e10)), u2.uid = e10, n3.gatewayInfo.uid = e10, n3.gatewayInfo.res.uid = e10;
        } else n3 = await Kx(u2, this._axiosCancelSource.token, this._config.httpRetryConfig || PA, true, this.store);
        if (!this._joinAndNotLeaveYet) throw new yb(Ry.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
      }
      this.store.requestAPEnd(), setTimeout(() => {
        this._configDistribute.startGetConfigDistribute(u2, this._axiosCancelSource.token), this._configDistribute.on(sO.UPDATE_BITRATE_LIMIT, (e10) => {
          this._p2pChannel.updateBitrateLimit(e10);
        });
      }, 0), this._key = i2 || e9;
      const o3 = n3.gatewayInfo, s3 = u2.uid ? u2.uid : o3.uid;
      this._joinInfo = IG(IG({}, u2), {}, { cid: o3.cid, uid: s3, vid: o3.vid, apResponse: o3.res, apGatewayAddress: o3.apGatewayAddress, uni_lbs_ip: o3.uni_lbs_ip, gatewayAddrs: o3.gatewayAddrs }), this.store.intUid = s3;
      const a3 = await this._joinGateway();
      if (!this._joinAndNotLeaveYet) throw new yb(Ry.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
      l2.onSuccess(a3), this._appId = e9, this._channelName = u2.cname, this._uid = a3, this.store.uid = a3, setTimeout(() => {
        this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener(Xv() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._statsCollector.startUpdateStats();
      }, 0);
      const d3 = u2.stringUid ? "string uid: ".concat(u2.stringUid, ",uid: ").concat(u2.uid) : "uid: ".concat(this._uid);
      return fb.info("[".concat(this._clientId, "] Joining channel success: channel: ").concat(t2, ",").concat(d3)), setTimeout(() => {
        fb.startUpload();
      }, 5e3), this.store.joinEnd(), _2 = this, Dn(wb).call(wb, _2) || wb.push(_2), "disabled" === this._cloudProxyServerMode && ZP().supportWebCrypto && XA("ENABLE_PRELOAD") && zB(this._joinInfo), a3;
    } catch (e10) {
      const t3 = Array.isArray(e10) ? e10[0] : e10;
      throw t3 && t3.code === Ry.OPERATION_ABORTED ? fb.warning("[".concat(this._clientId, "] join number: ").concat(o2, ", Joining channel failed, rollback"), t3) : fb.error("[".concat(this._clientId, "] join number: ").concat(o2, ", Joining channel failed, rollback"), t3), t3.code !== Ry.OPERATION_ABORTED && this._numberOfJoinCount === o2 && (this._gateway.state = "DISCONNECTED", this._reset()), l2.onError(t3), t3;
    }
    var _2;
  }
  _joinGateway() {
    if (!this._joinInfo || !this._key) throw new yb(Ry.INVALID_OPERATION);
    return this._gateway.join(this._joinInfo, this._key, !("disabled" !== this._joinInfo.cloudProxyServer || this._joinInfo.proxyServer || !XA("JOIN_WITH_FALLBACK_SIGNAL_PROXY")));
  }
  async leave() {
    fb.info("[".concat(this._clientId, "] Leaving channel")), window.removeEventListener(Xv() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._reset(), function(e10) {
      const t2 = wb.indexOf(e10);
      -1 !== t2 && wb.splice(t2, 1);
    }(this), this._statsCollector.stopUpdateStats();
    const e9 = await this._leaveMutex.lock();
    if ("DISCONNECTED" === this.connectionState) return fb.info("[".concat(this._clientId, "] Leaving channel repeated, success")), void e9();
    await this._gateway.leave("CONNECTED" !== this.connectionState), fb.info("[".concat(this._clientId, "] Leaving channel success")), this._joinAndNotLeaveYet = false, this.store.resetJoinChannelServiceRecords(), e9();
  }
  async publish(e9) {
    let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if (!Array.isArray(e9)) {
      if (!(e9 instanceof HL)) return this._publishDataChannel(e9);
      e9 = [e9];
    }
    if (0 === e9.length) throw new yb(Ry.INVALID_PARAMS, "param list is empty");
    const i2 = e9;
    if ("audience" === this._gateway.role) throw new yb(Ry.INVALID_OPERATION, "audience can not publish stream");
    for (const e10 of i2) {
      if (!(e10 instanceof HL)) throw new yb(Ry.INVALID_PARAMS, "parameter is not local track");
      if (!e10._enabled && t2) throw new yb(Ry.TRACK_IS_DISABLED, "can not publish a disabled track: ".concat(e10.getTrackId()));
    }
    fb.info("[".concat(this._clientId, "] Publishing tracks, id ").concat(i2.map((e10) => "".concat(e10.getTrackId(), " "))));
    const n2 = await this._publishMutex.lock();
    await this._configDistribute.awaitConfigDistributeComplete(), t2 && i2.forEach((e10) => {
      const t3 = this._configDistribute.getBitrateLimit();
      e10 instanceof aU && t3 && e10.setBitrateLimit(t3.uplink);
    });
    try {
      await this._publishHighStream(i2), fb.info("[".concat(this._clientId, "] Publish success, id ").concat(i2.map((e10) => "".concat(e10.getTrackId(), " "))));
    } catch (e10) {
      throw fb.error("[".concat(this._clientId, "] publish error"), e10.toString()), e10;
    } finally {
      n2();
    }
  }
  async _publishDataChannel(e9) {
    yy(e9.id, "id", 0, 65535, true), Iy(e9.ordered, "ordered"), by(e9.metadata, "metadata", 0, 512), fb.info("[".concat(this._clientId, "] Publishing datachannels, id ").concat(e9.id));
    const t2 = await this._publishMutex.lock();
    try {
      if (-1 !== this._p2pChannel.getAllDataChannels().findIndex((t3) => t3.id === e9.id)) throw new yb(Ry.INVALID_PARAMS, "Invalid id: ".concat(e9.id, ". If you want to republish the datachannel, unpublish first"));
      if (!this._joinInfo || void 0 === this._uid) throw new yb(Ry.INVALID_OPERATION, "Can't publish datachannel, haven't joined yet!");
      if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new yb(Ry.INVALID_OPERATION, "can not publish datachannel in ".concat(this.connectionState, " state"));
      if ("auto" === this._turnServer.mode && XA("FORCE_TURN") && !XA("TURN_ENABLE_TCP") && !XA("TURN_ENABLE_UDP")) throw new yb(Ry.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
      const i2 = function(e10) {
        return RB(e10, false);
      }(e9), n2 = await this._p2pChannel.publishDataChannel([i2]);
      if (n2.length > 0) {
        if ("number" != typeof i2._originDataChannelId) throw fb.error("[".concat(this._clientId, "] can not publish with mediaType datachannel, cannot get RTCDatachannel id")), new yb(Ry.CREATE_DATACHANNEL_ERROR);
        try {
          await Gh.all(n2.map((e10) => this._uid && this._gateway.publishDataChannel(this._uid, e10, true))), await i2._waitTillOpen();
        } catch (e10) {
          if (e10.code !== Ry.DISCONNECT_P2P) throw e10;
        }
      }
      return fb.info("[".concat(this._clientId, "] Publish dataChannels success, id ").concat(i2.id)), i2;
    } catch (e10) {
      throw fb.error("[".concat(this._clientId, "] publish datachannels error"), e10.toString()), e10;
    } finally {
      t2();
    }
  }
  async unpublish(e9) {
    if (!this._joinInfo || void 0 === this._uid) throw new yb(Ry.INVALID_OPERATION, "Can't unpublish stream, haven't joined yet!");
    let t2 = [];
    if (e9) if (Array.isArray(e9)) t2 = e9;
    else {
      if (!(e9 instanceof HL)) return this._unpublishDataChannel([e9]);
      t2 = [e9];
    }
    else this.store.useP2P || await this._unpublishDataChannel(), t2 = this._p2pChannel.getAllTracks(true);
    fb.info("[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(t2.map((e10) => "".concat(e10.getTrackId(), " ")), " "));
    const i2 = await this._publishMutex.lock();
    try {
      if (this._p2pChannel instanceof bF) {
        const e10 = await this._p2pChannel.unpublish(t2);
        e10 && await this._gateway.sendExtensionMessage(IO.UNPUBLISH, { unpubMsg: e10 }, true);
      } else {
        const e10 = await this._p2pChannel.unpublish(t2);
        e10 && await this._gateway.unpublish(e10, this._uid), fb.info("[".concat(this._clientId, "] Unpublish success,tracks ").concat(t2.map((e11) => "".concat(e11.getTrackId()))));
      }
    } catch (e10) {
      throw fb.error("[".concat(this._clientId, "] unpublish error"), e10.toString()), e10;
    } finally {
      i2 && i2();
    }
  }
  async _unpublishDataChannel(e9) {
    void 0 !== e9 && 0 !== e9.length || (e9 = this._p2pChannel.getAllDataChannels()), fb.info("[".concat(this._clientId, "] Unpublish datachannels, datachannels ").concat(e9.map((e10) => "".concat(e10.id, " ")), " "));
    const t2 = await this._publishMutex.lock();
    try {
      const i2 = await this._p2pChannel.unpublishDataChannel(e9);
      i2 && await this._gateway.unpublishDataChannel(i2), fb.info("[".concat(this._clientId, "] Unpublish dataChannel success,dataChannel ").concat(e9.map((e10) => "".concat(e10.id))));
    } catch (e10) {
      throw fb.error("[".concat(this._clientId, "] unpublish dataChannel error"), e10.toString()), e10;
    } finally {
      t2 && t2();
    }
  }
  async subscribe(e9, t2, i2) {
    if (!(e9 instanceof cF)) {
      const t3 = this.remoteUsers.find((t4) => t4.uid === e9);
      if (!t3) throw new yb(Ry.INVALID_REMOTE_USER, "user is not in the channel");
      e9 = t3;
    }
    return "datachannel" === t2 ? this._subscribeDataChannel(e9, i2) : this._subscribe(e9, t2);
  }
  async presubscribe(e9, t2) {
    if (vy(t2, "mediaType", ["audio", "video"]), this._p2pChannel instanceof bF) throw new yb(Ry.INVALID_OPERATION, "can't presub at p2p mode");
    if (!this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "can't presub when not join");
    if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new yb(Ry.INVALID_OPERATION, "can't presub in ".concat(this.connectionState, " state"));
    const i2 = t2 === dO.AUDIO, n2 = t2 === dO.VIDEO, r2 = await this._subscribeMutex.lock();
    try {
      const { ssrcId: o2, ortc: s2, rtxSsrcId: a2, cname: c2, uint_id: d2 } = await this._gateway.presubscribe(e9, t2, true);
      if (null == o2) throw new yb(Ry.UNEXPECTED_RESPONSE, "no ssrc id");
      let l2 = this._users.find((t3) => t3.uid === e9);
      l2 || (l2 = new cF(e9, d2 || e9), l2._is_pre_created = true, this._users.push(l2)), c2 && (l2._cname = c2), l2._uintid || (l2._uintid = d2 || e9), i2 && (l2._audioSSRC = o2, l2._audio_pre_subscribed = true, s2 && (l2._audioOrtc = s2)), n2 && (l2._videoSSRC = o2, l2._video_pre_subscribed = true, s2 && (l2._videoOrtc = s2), null != a2 && (l2._rtxSsrcId = a2)), fb.info("[".concat(this._clientId, "] presub succeed ssrc: ").concat(o2)), await this._p2pChannel.subscribe(l2, t2, o2, a2, s2);
      const u2 = i2 ? l2._audioTrack : l2._videoTrack;
      if (!u2) throw new yb(Ry.UNEXPECTED_ERROR, "can not find remote track in user");
      return i2 && (l2._trust_audio_stream_added_state_ = true, l2._audio_added_ = true), n2 && (l2._trust_video_stream_added_state_ = true, l2._video_added_ = true), u2;
    } catch (t3) {
      throw fb.error("[".concat(this._clientId, "] presub user ").concat(e9, " error"), t3), t3;
    } finally {
      r2();
    }
  }
  async _subscribeDataChannel(e9, t2) {
    var i2;
    if (yy(t2, "channelId", 0, 65535, true), !this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "Can't subscribe datachannel, not joined");
    if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new yb(Ry.INVALID_OPERATION, "Can't subscribe datachannel in ".concat(this.connectionState, " state"));
    const n2 = this._users.find((t3) => t3 === e9);
    if (!n2) throw fb.error("[".concat(this._clientId, "] can not subscribe ").concat(e9.uid, ", this user is not in the channel")), new yb(Ry.INVALID_REMOTE_USER, "user is not in the channel");
    if (!e9.hasAudio && !e9.hasVideo && 0 === e9._dataChannels.length) throw fb.error("[".concat(this._clientId, "] can not subscribe ").concat(e9.uid, ", user is not published")), new yb(Ry.INVALID_REMOTE_USER, "user is not published");
    const r2 = null === (i2 = e9._dataChannels) || void 0 === i2 ? void 0 : i2.find((e10) => e10.id === t2);
    if (!r2) throw fb.error("[".concat(this._clientId, "] can not subscribe ").concat(e9.uid, " with mediaType datachannel, remote datachannel is not published")), new yb(Ry.REMOTE_USER_IS_NOT_PUBLISHED);
    const o2 = await this._subscribeMutex.lock();
    fb.info("[".concat(this._clientId, "] subscribe user ").concat(e9.uid, ", mediaType: datachannel"));
    try {
      const t3 = await this._p2pChannel.subscribeDataChannel(e9, [r2]);
      if (t3 && Dn(t3).call(t3, r2.id)) try {
        var s2;
        if ("number" != typeof r2._originDataChannelId) throw fb.error("[".concat(this._clientId, "] can not subscribe ").concat(e9.uid, " with mediaType datachannel, cannot get RTCDatachannel")), new yb(Ry.CREATE_DATACHANNEL_ERROR);
        const t4 = { id: r2.id, datachannelId: r2._originDataChannelId, ordered: r2.ordered, maxRetransmits: r2.maxRetransmits, metadata: null !== (s2 = r2.metadata) && void 0 !== s2 ? s2 : "" };
        await this._gateway.subscribeDataChannel(e9.uid, t4, true), await r2._waitTillOpen();
      } catch (t4) {
        if ((null == t4 ? void 0 : t4.code) !== Ry.WS_ABORT) throw await this._p2pChannel.unsubscribeDataChannel(e9, [r2]), t4;
        await this._p2pChannel.unsubscribeDataChannel(e9, [r2]), this._p2pChannel.setPendingRemoteDataChannel(e9, r2.id);
      }
      return fb.info("[".concat(this._clientId, "] subscribe success user ").concat(e9.uid, ", mediaType: datachannel")), r2;
    } finally {
      o2();
    }
  }
  async _p2pSubscribe(e9, t2, i2) {
    if (vy(t2, "mediaType", ["audio", "video"]), !this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "Can't subscribe stream, not joined");
    if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new yb(Ry.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
    const n2 = this._users.find((t3) => t3 === e9);
    if (!n2) {
      const t3 = new yb(Ry.INVALID_REMOTE_USER, "user is not in the channel");
      throw fb.error("[".concat(this._clientId, "] can not subscribe ").concat(e9.uid, ", this user is not in the channel")), t3;
    }
    if (!e9.hasAudio && !e9.hasVideo) {
      const t3 = new yb(Ry.INVALID_REMOTE_USER, "user is not published");
      throw fb.error("[".concat(this._clientId, "] can not subscribe ").concat(e9.uid, ", user is not published")), t3;
    }
    if (!i2 && ("audio" === t2 && !e9.hasAudio || "video" === t2 && !e9.hasVideo)) {
      const i3 = new yb(Ry.REMOTE_USER_IS_NOT_PUBLISHED);
      throw fb.error("[".concat(this._clientId, "] can not subscribe ").concat(e9.uid, " with mediaType ").concat(t2, ", remote track is not published")), i3;
    }
    const r2 = await this._subscribeMutex.lock();
    fb.info("[".concat(this._clientId, "] subscribe user ").concat(e9.uid, ", mediaType: ").concat(t2));
    try {
      if (await this._p2pChannel.hasRemoteMediaWithLock(e9, t2)) await this._p2pChannel.unmuteRemote(e9, t2);
      else try {
        const i4 = "audio" === t2 ? e9._audioSSRC : e9._videoSSRC, n3 = "audio" === t2 ? e9._audioMid : e9._videoMid;
        this.store.subscribe(e9.uid, t2, Date.now()), this._p2pChannel instanceof bF && await this._p2pChannel.subscribe(e9, t2, i4, n3);
      } catch (e10) {
        throw e10;
      }
      fb.info("[".concat(this._clientId, "] subscribe success user ").concat(e9.uid, ", mediaType: ").concat(t2)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e9.uid, this._defaultStreamFallbackType).catch((e10) => {
        fb.warning("[".concat(this._clientId, "] auto set fallback failed"), e10);
      });
      const i3 = "audio" === t2 ? e9._audioTrack : e9._videoTrack;
      if (!i3) throw new yb(Ry.UNEXPECTED_ERROR, "can not find remote track in user object");
      return i3;
    } catch (t3) {
      throw fb.error("[".concat(this._clientId, "] subscribe user ").concat(e9.uid, " error"), t3), t3;
    } finally {
      r2();
    }
  }
  async _subscribe(e9, t2, i2) {
    if (this._p2pChannel instanceof bF) return this._p2pSubscribe(e9, t2);
    if (vy(t2, "mediaType", ["audio", "video"]), !this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "Can't subscribe stream, not joined");
    if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new yb(Ry.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
    const n2 = this._users.find((t3) => t3 === e9);
    if (!n2) {
      const t3 = new yb(Ry.INVALID_REMOTE_USER, "user is not in the channel");
      throw fb.error("[".concat(this._clientId, "] can not subscribe ").concat(e9.uid, ", this user is not in the channel")), t3;
    }
    if (!e9.hasAudio && !e9.hasVideo) {
      const t3 = new yb(Ry.INVALID_REMOTE_USER, "user is not published");
      throw fb.error("[".concat(this._clientId, "] can not subscribe ").concat(e9.uid, ", user is not published")), t3;
    }
    if (!(i2 || ("audio" !== t2 || e9.hasAudio && void 0 !== e9._audioSSRC) && ("video" !== t2 || e9.hasVideo && void 0 !== e9._videoSSRC))) {
      const i3 = new yb(Ry.REMOTE_USER_IS_NOT_PUBLISHED);
      throw fb.error("[".concat(this._clientId, "] can not subscribe ").concat(e9.uid, " with mediaType ").concat(t2, ", remote track is not published")), i3;
    }
    let r2 = "audio" === t2 ? e9._audioSSRC : e9._videoSSRC, o2 = "audio" === t2 ? e9._audioOrtc : e9._videoOrtc, s2 = "video" === t2 ? e9._rtxSsrcId : void 0, a2 = { stream_type: "audio" === t2 ? dO.AUDIO : dO.VIDEO, ssrcId: r2 };
    const c2 = await this._subscribeMutex.lock();
    fb.info("[".concat(this._clientId, "] subscribe user ").concat(e9.uid, ", mediaType: ").concat(t2));
    try {
      if (await this._p2pChannel.hasRemoteMediaWithLock(e9, t2)) await this._p2pChannel.unmuteRemote(e9, t2);
      else try {
        const i4 = "audio" === t2 ? e9._audioSSRC : e9._videoSSRC;
        void 0 !== i4 && i4 !== r2 && (r2 = i4, o2 = "audio" === t2 ? e9._audioOrtc : e9._videoOrtc, s2 = "video" === t2 ? e9._rtxSsrcId : void 0, a2 = { stream_type: "audio" === t2 ? dO.AUDIO : dO.VIDEO, ssrcId: r2 }), rV.markSubscribeStart(this.store.clientId, r2), this.store.subscribe(e9.uid, t2, Date.now()), await this._p2pChannel.subscribe(e9, t2, r2, s2, o2);
        try {
          this._p2pChannel.isPreSubScribe(r2) || await this._gateway.subscribe(e9.uid, a2, true);
        } catch (i5) {
          if ((null == i5 ? void 0 : i5.code) !== Ry.WS_ABORT) throw await this._p2pChannel.unsubscribe(e9, t2), i5;
          await this._p2pChannel.unsubscribe(e9, t2, true), this._p2pChannel.setPendingRemoteMedia(e9, t2);
        }
        this.store.subscribe(e9.uid, t2, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(true, null, e9, t2);
      } catch (i4) {
        throw this._p2pChannel.reportSubscribeEvent(false, null == i4 ? void 0 : i4.code, e9, t2), i4;
      }
      fb.info("[".concat(this._clientId, "] subscribe success user ").concat(e9.uid, ", mediaType: ").concat(t2)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e9.uid, this._defaultStreamFallbackType).catch((e10) => {
        fb.warning("[".concat(this._clientId, "] auto set fallback failed"), e10);
      });
      const i3 = "audio" === t2 ? e9._audioTrack : e9._videoTrack;
      if (!i3) throw new yb(Ry.UNEXPECTED_ERROR, "can not find remote track in user object");
      return i3;
    } catch (t3) {
      throw fb.error("[".concat(this._clientId, "] subscribe user ").concat(e9.uid, " error"), t3), t3;
    } finally {
      c2();
    }
  }
  async massSubscribe(e9) {
    if (wy(e9, "subscribeList"), !this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "Can't subscribe stream, not joined");
    if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new yb(Ry.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
    const t2 = Date.now(), i2 = /* @__PURE__ */ new Map(), n2 = await this._subscribeMutex.lock();
    fb.info("[".concat(this._clientId, "]start massSubscribe user ").concat(e9.map((e10) => {
      let { user: t3, mediaType: i3 } = e10;
      return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i3);
    }).join("; ")));
    const r2 = (e9 = [...e9]).map((e10) => {
      let { user: t3, mediaType: i3 } = e10;
      return { user: t3, mediaType: i3 };
    }), o2 = await this._p2pChannel.globalLock();
    try {
      var s2;
      for (let t3 = e9.length - 1; t3 >= 0; t3--) {
        const n3 = e9[t3], { user: o3, mediaType: s3 } = n3;
        if (vy(s3, "mediaType", ["audio", "video"]), !o3) {
          const e10 = new yb(Ry.INVALID_PARAMS, "user property does not exist in subscribeList item");
          throw fb.error("[".concat(this._clientId, "] user property does not exist in subscribeList item")), e10;
        }
        const a3 = this._users.find((e10) => e10 === o3);
        if (!a3) {
          const i3 = new yb(Ry.INVALID_REMOTE_USER, "user is not in the channel");
          fb.error("[".concat(this._clientId, "] can not massSubscribe ").concat(o3.uid, ", this user is not in the channel")), r2[t3].error = i3, e9.splice(t3, 1);
          continue;
        }
        if ("audio" === s3 && (!o3.hasAudio || void 0 === o3._audioSSRC) || "video" === s3 && (!o3.hasVideo || void 0 === o3._videoSSRC)) {
          const i3 = new yb(Ry.REMOTE_USER_IS_NOT_PUBLISHED);
          fb.error("[".concat(this._clientId, "] can not subscribe ").concat(o3.uid, " with mediaType ").concat(s3, ", remote user is not published")), r2[t3].error = i3, e9.splice(t3, 1);
          continue;
        }
        const c2 = tO.Video | tO.LwoVideo, d2 = i2.get(o3);
        if (d2) {
          if ("video" === s3 ? d2 & c2 : d2 & tO.Audio) {
            e9.splice(t3, 1), fb.warning("[".concat(this._clientId, "] repeat massSubscribe user:").concat(o3.uid, ", mediaType:").concat(s3, " twice"));
            continue;
          }
          i2.set(o3, d2 | ("video" === s3 ? c2 : tO.Audio));
        } else i2.set(o3, "video" === s3 ? c2 : tO.Audio);
      }
      for (let t3 = e9.length - 1; t3 >= 0; t3--) {
        const n3 = e9[t3], { user: r3, mediaType: o3 } = n3, s3 = tO.Video | tO.LwoVideo;
        if (this._p2pChannel.hasRemoteMedia(r3, o3)) {
          await this._p2pChannel.unmuteRemoteNoLock(r3, o3);
          const n4 = i2.get(r3);
          i2.set(r3, "video" === o3 ? n4 ^ s3 : n4 ^ tO.Audio), e9.splice(t3, 1);
        }
      }
      this.store.massSubscribe(e9.map((e10) => ({ userId: e10.user.uid, type: e10.mediaType })), t2);
      let a2 = Jn(s2 = Array.from(i2.entries())).call(s2, (e10, t3) => {
        let [i3, n3] = t3;
        if (0 === n3) return e10;
        const r3 = { stream_id: i3.uid, stream_type: n3 };
        return n3 & tO.Audio && (r3.audio_ssrc = i3._audioSSRC), n3 & tO.Video && (r3.video_ssrc = i3._videoSSRC), e10.push(r3), e10;
      }, []);
      try {
        e9.length > 0 && await this._p2pChannel.massSubscribeNoLock(e9.map((e10) => {
          let { user: t3, mediaType: i4 } = e10;
          return { user: t3, mediaType: i4, ssrcId: i4 === dO.VIDEO ? t3._videoSSRC : t3._audioSSRC, rtxSsrcId: i4 === dO.VIDEO ? t3._rtxSsrcId : void 0 };
        }));
        const i3 = /* @__PURE__ */ new Map();
        if (a2 = a2.filter((e10) => e10.video_ssrc && !this._p2pChannel.isPreSubScribe(e10.video_ssrc) || e10.audio_ssrc && !this._p2pChannel.isPreSubScribe(e10.audio_ssrc) || !e10.video_ssrc && !e10.audio_ssrc), a2.length > 0) {
          const e10 = await this._gateway.subscribeAll(a2, true);
          ((null == e10 ? void 0 : e10.users) || []).forEach((e11) => {
            let { stream_id: t3, video_error_code: n3, audio_error_code: r3, error_code: o3 } = e11;
            (n3 || r3 || o3) && i3.set(t3, { video_error_code: n3, audio_error_code: r3, error_code: o3 });
          });
        }
        if (Array.from(i3.entries()).length > 0) {
          const e10 = [];
          Array.from(i3.entries()).forEach((t3) => {
            let [i4, n3] = t3;
            const r3 = this.remoteUsers.find((e11) => e11.uid === i4);
            if (r3) {
              let t4;
              n3.error_code || n3.video_error_code && n3.audio_error_code ? t4 = void 0 : n3.video_error_code ? t4 = dO.VIDEO : n3.audio_error_code && (t4 = dO.AUDIO), e10.push({ user: r3, mediaType: t4 });
            }
          }), e10.length > 0 && await this._p2pChannel.massUnsubscribeNoLock(e10);
        }
        for (const e10 of r2) {
          const t3 = i3.get(e10.user.uid);
          if (t3) {
            const i4 = t3.error_code || "audio" === e10.mediaType && t3.audio_error_code || "video" === e10.mediaType && t3.video_error_code;
            if (i4) {
              const t4 = NO(i4);
              fb.error("user:".concat(e10.user.uid, " mediaType:").concat(e10.mediaType, " has massSubscribe error ").concat(t4.desc)), e10.error = new yb(Ry.SUBSCRIBE_FAILED, "code ".concat(i4, ": ").concat(t4.desc));
            }
          }
          e10.error || ("video" === e10.mediaType ? e10.track = e10.user.videoTrack : e10.track = e10.user.audioTrack);
        }
        return this.store.massSubscribe(r2.filter((e10) => !e10.error).map((e10) => ({ userId: e10.user.uid, type: e10.mediaType })), void 0, Date.now()), r2.forEach((e10) => {
          var i4;
          vb.subscribe(this.store.sessionId, { succ: !!e10.error, ec: (null === (i4 = e10.error) || void 0 === i4 ? void 0 : i4.code) || null, video: e10.mediaType === dO.VIDEO, audio: e10.mediaType === dO.AUDIO, peerid: e10.user.uid, subscribeRequestid: e10.mediaType === dO.VIDEO ? e10.user._videoSSRC : e10.user._audioSSRC, p2pid: this.store.p2pId, eventElapse: Math.floor(performance.now() - t2), preSsrc: this._p2pChannel.isPreSubScribe(e10.user._videoSSRC) }, true);
        }), fb.info("[".concat(this._clientId, "] massSubscribe success ").concat(e9.map((e10) => {
          let { user: t3, mediaType: i4 } = e10;
          return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i4);
        }).join("; "))), r2;
      } catch (t3) {
        throw await this._p2pChannel.massUnsubscribeNoLock(e9), t3;
      }
    } finally {
      o2(), n2();
    }
  }
  async unsubscribe(e9, t2, i2) {
    if (!(e9 instanceof cF)) {
      const t3 = this.remoteUsers.find((t4) => t4.uid === e9);
      if (!t3) throw new yb(Ry.INVALID_REMOTE_USER, "user is not in the channel");
      e9 = t3;
    }
    if (t2 || this.store.useP2P) {
      if ("datachannel" === t2) return this._unsubscribeDataChannel(e9, i2);
    } else await this._unsubscribeDataChannel(e9, i2);
    if (t2 && vy(t2, "mediaType", ["audio", "video"]), !this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "Can't unsubscribe stream, haven't joined yet!");
    const n2 = this._users.find((t3) => t3 === e9);
    if (!n2) {
      const t3 = new yb(Ry.INVALID_REMOTE_USER, "user is not in the channel");
      throw fb.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e9.uid, ", user is not in the channel")), t3;
    }
    fb.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e9.uid, ", mediaType: ").concat(t2));
    const r2 = await this._subscribeMutex.lock();
    try {
      if (this._p2pChannel instanceof bF) await this._p2pChannel.unsubscribe(e9, t2);
      else {
        const i3 = await this._p2pChannel.unsubscribe(e9, t2);
        i3 && await this._gateway.unsubscribe(i3, e9.uid), t2 && "audio" !== t2 || (e9._audio_pre_subscribed = false), t2 && "video" !== t2 || (e9._video_pre_subscribed = false), e9._is_pre_created && nA(this._users, e9), fb.info("[".concat(this._clientId, "] unsubscribe success uid: ").concat(e9.uid, ", mediaType: ").concat(t2));
      }
    } catch (t3) {
      if (t3.code === Ry.DISCONNECT_P2P) return void fb.warning("disconnecting p2p, abort unsubscribe request.");
      throw fb.error("[".concat(this._clientId, "] unsubscribe user ").concat(e9.uid, " error"), t3.toString()), t3;
    } finally {
      r2();
    }
  }
  async _unsubscribeDataChannel(e9, t2) {
    if (t2 && yy(t2, "id", 0, 65535, true), !this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "Can't unsubscribe datachannel, haven't joined yet!");
    const i2 = this._users.find((t3) => t3 === e9);
    if (!i2) {
      const t3 = new yb(Ry.INVALID_REMOTE_USER, "user is not in the channel");
      throw fb.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e9.uid, ", user is not in the channel")), t3;
    }
    let n2;
    if ("number" == typeof t2) {
      const i3 = e9._dataChannels.find((e10) => e10.id === t2);
      i3 && (n2 = [i3]);
    } else n2 = e9._dataChannels;
    if (void 0 === n2) {
      const i3 = new yb(Ry.REMOTE_USER_IS_NOT_PUBLISHED);
      throw fb.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e9.uid, " with channelId ").concat(t2, ", remote datachannel is not published")), i3;
    }
    fb.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e9.uid, ", mediaType: datachannel, ids: ").concat(n2.map((e10) => e10.id)));
    try {
      const t3 = await this._p2pChannel.unsubscribeDataChannel(e9, n2);
      t3 && await this._gateway.unsubscribeDataChannel(t3, e9.uid), fb.info("[".concat(this._clientId, "] unsubscribe datachannel success uid: ").concat(e9.uid, ", mediaType: datachannel, ids: ").concat(t3));
    } catch (t3) {
      if (t3.code === Ry.DISCONNECT_P2P) return void fb.warning("disconnecting p2p, abort unsubscribe request.");
      throw fb.error("[".concat(this._clientId, "] unsubscribe user ").concat(e9.uid, " error"), t3.toString()), t3;
    }
  }
  async massUnsubscribe(e9) {
    if (wy(e9, "unsubscribeList"), !this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "Can't unsubscribeAll stream, haven't joined yet!");
    fb.info("[".concat(this._clientId, "] start massUnsubscribe ").concat(e9.map((e10) => {
      let { user: t3, mediaType: i2 } = e10;
      return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i2, ";");
    }).join())), e9 = [...e9];
    const t2 = /* @__PURE__ */ new Map();
    for (let i2 = e9.length - 1; i2 >= 0; i2--) {
      const { user: n2, mediaType: r2 } = e9[i2];
      if (!n2) {
        const e10 = new yb(Ry.INVALID_PARAMS, "user property does not exist in unsubscribeList item");
        throw fb.error("[".concat(this._clientId, "] user property does not exist in unsubscribeList item")), e10;
      }
      vy(r2, "mediaType", ["video", "audio", void 0]);
      const o2 = this._users.find((e10) => e10 === n2);
      if (!o2) {
        fb.warning("[".concat(this._clientId, "] can not unsubscribe ").concat(n2.uid, ", user is not in the channel")), e9.splice(i2, 1);
        continue;
      }
      const s2 = tO.Video | tO.LwoVideo;
      if (t2.has(n2)) {
        const o3 = t2.get(n2);
        let a2;
        switch (r2) {
          case "video":
            a2 = o3 & s2;
            break;
          case "audio":
            a2 = o3 & tO.Audio;
            break;
          default:
            a2 = o3 & (tO.Audio | s2);
        }
        if (a2) {
          fb.warning("[".concat(this._clientId, "] repeat massUnsubscribe user:").concat(n2.uid, ",mediaType:").concat(r2, " twice.")), e9.splice(i2, 1);
          continue;
        }
        r2 ? "audio" === r2 ? t2.set(n2, o3 | tO.Audio) : "video" === r2 && t2.set(n2, o3 | s2) : t2.set(n2, o3 | tO.Audio | s2);
      } else r2 ? "audio" === r2 ? t2.set(n2, tO.Audio) : "video" === r2 && t2.set(n2, s2) : t2.set(n2, tO.Audio | s2);
    }
    try {
      const t3 = await this._p2pChannel.massUnsubscribe(e9);
      t3 && await this._gateway.massUnsubscribe(t3), fb.info("[".concat(this._clientId, "] massUnsubscribe success ").concat(e9.map((e10) => {
        let { user: t4, mediaType: i2 } = e10;
        return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i2, ";");
      }).join()));
    } catch (e10) {
      if (e10.code === Ry.DISCONNECT_P2P) return void fb.warning("[".concat(this._clientId, "] disconnecting p2p, abort unsubscribe request."));
      throw fb.error("[".concat(this._clientId, "] massUnsubscribe error"), e10.toString()), e10;
    }
  }
  async setLowStreamParameter(e9) {
    !function(e10) {
      if (!e10) throw new Cy(Ry.INVALID_PARAMS);
      Oy(e10.width) || Ay(e10.width, "streamParameter.width"), Oy(e10.height) || Ay(e10.height, "streamParameter.height"), Oy(e10.framerate) || Ay(e10.framerate, "streamParameter.framerate"), Oy(e10.bitrate) || yy(e10.bitrate, "streamParameter.bitrate");
    }(e9), (!e9.width && e9.height || e9.width && !e9.height) && fb.warning("[".concat(this._clientId, "] The width and height parameters take effect only when both are set")), fb.info("[".concat(this._clientId, "] set low stream parameter to"), JSON.stringify(e9));
    const t2 = this._configDistribute.getLowStreamConfigDistribute();
    if (t2 && t2.bitrate && e9.bitrate && t2.bitrate < e9.bitrate && (e9.bitrate = t2.bitrate), this._lowStreamParameter = e9, this._isDualStreamEnabled) return this._p2pChannel.updateVideoStreamParameter(e9, hO.LocalVideoLowTrack);
  }
  async enableDualStream() {
    if (!ZP().supportDualStream) throw vb.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), new yb(Ry.NOT_SUPPORTED, "Your browser is not support dual stream");
    if (this._isDualStreamEnabled) throw new yb(Ry.INVALID_OPERATION, "Dual stream is already enabled");
    if (this._p2pChannel.canPublishLowStream()) try {
      await this._publishLowStream();
    } catch (e9) {
      throw vb.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), e9;
    }
    this._isDualStreamEnabled = true, vb.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: true }), fb.info("[".concat(this._clientId, "] enable dual stream"));
  }
  async disableDualStream() {
    if (this._isDualStreamEnabled) {
      if (!this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
      if (this._p2pChannel.getLocalMedia(hO.LocalVideoLowTrack)) try {
        const e9 = await this._p2pChannel.unpublishLowStream();
        e9 && await this._gateway.unpublish(e9, this._joinInfo.stringUid || this._joinInfo.uid);
      } catch (e9) {
        throw vb.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: false }), e9;
      }
      this._isDualStreamEnabled = false, vb.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: true }), fb.info("[".concat(this._clientId, "] disable dual stream"));
    }
  }
  async setClientRole(e9, t2) {
    if (function(e10) {
      vy(e10, "role", ["audience", "host"]);
    }(e9), t2 && qy(t2), "rtc" === this.mode || "p2p" === this.mode) throw fb.warning("[".concat(this._clientId, "]").concat(this.mode, " mode can not use setClientRole")), new yb(Ry.INVALID_OPERATION, "".concat(this.mode, " mode can not use setClientRole"));
    if (t2 && t2.level && "host" === e9) throw new yb(Ry.INVALID_OPERATION, "host mode can not set audience latency level");
    if ("audience" === e9 && this._p2pChannel.hasLocalMedia()) throw new yb(Ry.INVALID_OPERATION, "can not set client role to audience when publishing stream");
    await this._gateway.setClientRole(e9, t2), this._config.role = e9, fb.info("[".concat(this._clientId, "] set client role to ").concat(e9, ", level: ").concat(t2 && t2.level));
  }
  getRemoteInboundOffset() {
    var e9;
    const t2 = null === (e9 = this._p2pChannel.getStats()) || void 0 === e9 ? void 0 : e9.audioSend[0];
    if (!t2 || !t2.timestamp) return 0;
    const i2 = t2.timestamp - Date.now();
    return Math.abs(i2) > 1e3 + t2.rttMs + 100 ? this.ntpAlignErrorCount += 1 : this.ntpAlignErrorCount = 0, this.ntpAlignErrorCount >= 3 ? i2 : 0;
  }
  getNtpWallTimeInMs() {
    return "visible" === document.visibilityState && (this.remoteInboundOffset = this.getRemoteInboundOffset()), this.remoteInboundOffset + Date.now() + this._gateway.ntpOffset;
  }
  setProxyServer(e9, t2) {
    if (by(e9, "proxyServer"), !t2) {
      if ("DISCONNECTED" !== this.connectionState) throw new yb(Ry.INVALID_OPERATION, "Set proxy server before join channel");
      if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new yb(Ry.INVALID_OPERATION, "You have already set the proxy");
    }
    this._proxyServer = e9, vb.setProxyServer(this._proxyServer), fb.setProxyServer(this._proxyServer), fb.info("[".concat(this._clientId, "] Set proxy server ").concat(t2 ? "by initialize call" : "", " success."));
  }
  setTurnServer(e9, t2) {
    if (Array.isArray(e9) || (e9 = [e9]), !t2) {
      if ("DISCONNECTED" !== this.connectionState) throw new yb(Ry.INVALID_OPERATION, "Set turn server before join channel");
      if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new yb(Ry.INVALID_OPERATION, "You have already set the proxy");
    }
    if (Ky(e9)) return this._turnServer = { servers: e9, mode: "original-manual" }, void fb.info("[".concat(this._clientId, "] Set original turnserver ").concat(t2 ? "by initialize call" : "", " success: ").concat(e9.map((e10) => e10.urls).join(","), "."));
    e9.forEach((e10) => Yy(e10)), this._turnServer = { servers: e9, mode: "manual" }, fb.info("[".concat(this._clientId, "] Set turnserver ").concat(t2 ? "by initialize call" : "", " success."));
  }
  setLicense(e9) {
    if ("DISCONNECTED" !== this.connectionState) {
      throw new yb(Ry.INVALID_OPERATION, "you should set license before join channel");
    }
    if (by(e9, "license", 32, 32), !/^[A-Za-z\d]+$/.test(e9)) throw new yb(Ry.INVALID_PARAMS, "license should only contains characters from A-Z a-z 0-9");
    this._license = e9, fb.info("[".concat(this._clientId, "] set license success"), e9);
  }
  startProxyServer(e9) {
    if ("DISCONNECTED" !== this.connectionState) throw new yb(Ry.INVALID_OPERATION, "Start proxy server before join channel");
    if (this._proxyServer || "manual" === this._turnServer.mode || this._useLocalAccessPoint) throw new yb(Ry.INVALID_OPERATION, "You have already set the proxy");
    const t2 = [3, 4, 5];
    let i2;
    switch (void 0 === e9 && (e9 = 3), e9) {
      case 1:
      case 2:
        throw new yb(Ry.NOT_SUPPORTED, "proxy mode 1/2 has been deprecated and not supported.");
      case 3:
        i2 = "proxy3";
        break;
      case 4:
        i2 = "proxy4";
        break;
      case 5:
        i2 = "proxy5";
        break;
      default:
        throw new yb(Ry.INVALID_PARAMS, "proxy server mode must be ".concat(t2.join("|")));
    }
    this._cloudProxyServerMode = i2, this.store.cloudProxyServerMode = i2, fb.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode);
  }
  stopProxyServer() {
    if ("DISCONNECTED" !== this.connectionState) throw new yb(Ry.INVALID_OPERATION, "Stop proxy server after leave channel");
    vb.setProxyServer(), fb.setProxyServer(), this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled", fb.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = { mode: "auto", servers: [] };
  }
  setLocalAccessPointsV2(e9) {
    if (!e9.accessPoints) throw new yb(Ry.INVALID_PARAMS, "accessPoints is required.");
    wy(e9.accessPoints.serverList, "accessPoints.serverList"), by(e9.accessPoints.domain, "accessPoints.domain");
    const t2 = (e10, t3) => {
      yy(e10, t3, 0, 65535, true);
    };
    let i2 = 443;
    if (e9.accessPoints.port && (t2(e9.accessPoints.port, "accessPoints.port"), i2 = e9.accessPoints.port), this._proxyServer || "disabled" !== this._cloudProxyServerMode) throw new yb(Ry.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
    XA("CLOSE_AFB_FOR_LOCAL_AP") && (JA("JOIN_WITH_FALLBACK_SIGNAL_PROXY", false), JA("JOIN_WITH_FALLBACK_MEDIA_PROXY", false));
    const n2 = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/, r2 = e9.accessPoints.domain, o2 = e9.accessPoints.serverList.map((e10) => n2.test(e10) ? "".concat(e10.replace(/\./g, "-"), ".").concat(r2) : e10), s2 = o2.map((e10) => "".concat(e10, ":").concat(i2));
    this._useLocalAccessPoint = true, this._setLocalAPVersion = 2, JA("WEBCS_DOMAIN", s2), JA("WEBCS_DOMAIN_BACKUP_LIST", s2), JA("GATEWAY_DOMAINS", [r2]), e9.report && e9.report.hostname && Array.isArray(e9.report.hostname) && e9.report.hostname.length ? (wy(e9.report.hostname, "report.hostname"), JA("EVENT_REPORT_DOMAIN", e9.report.hostname[0]), JA("EVENT_REPORT_BACKUP_DOMAIN", e9.report.hostname[1] || e9.report.hostname[0])) : (JA("EVENT_REPORT_DOMAIN", o2[0]), JA("EVENT_REPORT_BACKUP_DOMAIN", o2[1] || o2[0]));
    let a2 = 6443;
    e9.report && e9.report.port && (t2(e9.report.port, "report.port"), a2 = e9.report.port), JA("STATS_COLLECTOR_PORT", a2), e9.report ? JA("ENABLE_EVENT_REPORT", true) : JA("ENABLE_EVENT_REPORT", false);
    let c2 = "";
    e9.log && e9.log.hostname && Array.isArray(e9.log.hostname) && e9.log.hostname.length ? (wy(e9.log.hostname, "log.hostname"), c2 = e9.log.hostname[0]) : c2 = o2[0];
    let d2 = 6444;
    e9.log && e9.log.port && (t2(e9.log.port, "log.port"), d2 = e9.log.port), JA("LOG_UPLOAD_SERVER", "".concat(c2, ":").concat(d2));
    let l2 = [];
    e9.cds && e9.cds.hostname && Array.isArray(e9.cds.hostname) && e9.cds.hostname.length ? (wy(e9.cds.hostname, "cds.hostname"), l2 = e9.cds.hostname) : l2 = o2;
    let u2 = 443;
    e9.cds && e9.cds.port && (t2(e9.cds.port, "cds.port"), u2 = e9.cds.port), JA("CDS_AP", l2.map((e10) => "".concat(e10, ":").concat(u2))), e9.cds ? JA("ENABLE_CONFIG_DISTRIBUTE", true) : JA("ENABLE_CONFIG_DISTRIBUTE", false), fb.info("set local access point v2 success");
  }
  setLocalAccessPoints(e9, t2) {
    if (wy(e9, "serverList"), by(t2, "domain"), this._proxyServer || "disabled" !== this._cloudProxyServerMode) throw new yb(Ry.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
    const i2 = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
    e9 = e9.map((e10) => i2.test(e10) ? "".concat(e10.replace(/\./g, "-"), ".").concat(t2) : e10), this._useLocalAccessPoint = true, this._setLocalAPVersion = 1, JA("WEBCS_DOMAIN", e9), JA("WEBCS_DOMAIN_BACKUP_LIST", e9), JA("GATEWAY_DOMAINS", [t2]), JA("EVENT_REPORT_DOMAIN", e9[0]), JA("EVENT_REPORT_BACKUP_DOMAIN", e9[1] || e9[0]), JA("LOG_UPLOAD_SERVER", "".concat(e9[0], ":6444")), fb.info("[".concat(this._clientId, "] set local access point success"));
  }
  async setRemoteDefaultVideoStreamType(e9) {
    if (vy(e9, "streamType", [0, 1, 4, 5, 6, 7, 8, 9]), this._remoteDefaultVideoStreamType = e9, this._joinInfo) try {
      await this._gateway.setDefaultRemoteVideoStreamType(e9), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType;
    } catch (e10) {
      throw fb.error("[".concat(this._clientId, "] set default remote video stream type error"), e10.toString()), e10;
    }
    else fb.debug("[".concat(this._clientId, "] haven't joined yet, cache remoteDefaultVideoStreamType ").concat(e9));
  }
  async setRemoteVideoStreamType(e9, t2) {
    vy(t2, "streamType", [0, 1, 4, 5, 6, 7, 8, 9]);
    try {
      await this._gateway.setRemoteVideoStreamType(e9, t2), setTimeout(() => {
        const t3 = this._users.find((t4) => t4.uid === e9);
        t3 && t3.videoTrack && t3.videoTrack.updateMediaStreamTrackResolution();
      }, 2e3);
    } catch (e10) {
      throw fb.error("[".concat(this._clientId, "] set remote video stream type error"), e10.toString()), e10;
    }
    fb.info("[".concat(this._clientId, "] set remote ").concat(e9, " video stream type to ").concat(t2)), this._remoteStreamTypeCacheMap.set(e9, t2);
  }
  async setStreamFallbackOption(e9, t2) {
    vy(t2, "fallbackType", [0, 1, 2, 3, 4, 5, 6, 7, 8]);
    try {
      await this._gateway.setStreamFallbackOption(e9, t2);
    } catch (e10) {
      throw fb.error("[".concat(this._clientId, "] set stream fallback option"), e10.toString()), e10;
    }
    fb.info("[".concat(this._clientId, "] set remote ").concat(e9, " stream fallback type to ").concat(t2)), this._streamFallbackTypeCacheMap.set(e9, t2);
  }
  setEncryptionConfig(e9, t2, i2, n2) {
    !function(e10) {
      vy(e10, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "aes-128-gcm", "aes-256-gcm", "aes-128-gcm2", "aes-256-gcm2", "none"]);
    }(e9), by(t2, "secret");
    const r2 = ["aes-128-gcm2", "aes-256-gcm2"];
    if (Dn(r2).call(r2, e9)) {
      if (!i2 || !(i2 instanceof Uint8Array && 32 === i2.length)) throw new yb(Ry.INVALID_PARAMS, "salt must be an Uint8Array and exactly equal to 32 bytes");
    } else if (i2) throw new yb(Ry.INVALID_PARAMS, "current encrypt mode does not need salt");
    if (n2) {
      if (Iy(n2, "encryptDataStream"), !Dn(r2).call(r2, e9)) throw new yb(Ry.INVALID_PARAMS, "current encrypt mode does not support data stream");
      this._encryptDataStream = true;
    }
    new RegExp(`^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'"|{}\\[\\]])(?=.{8,})`).test(t2) || fb.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "), this._encryptionMode = e9, this._encryptionSecret = t2, i2 && (this._encryptionSalt = uA(i2));
  }
  async renewToken(e9) {
    if (by(e9, "token", 1, 2047), !this._key || !this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "renewToken should not be called before user join");
    const t2 = this._key;
    this._key = e9, this._joinInfo && (this._joinInfo.token = e9);
    const i2 = await this._renewTokenMutex.lock();
    try {
      if (XA("USE_NEW_TOKEN")) {
        fb.debug("[".concat(this._clientId, "] start renew token with ticket from unilbs"));
        const t3 = await Zx(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || PA);
        fb.debug("[".concat(this._clientId, "] get ticket from unilbs success")), await this._gateway.renewToken({ token: e9, ticket: t3 });
      } else fb.debug("[".concat(this._clientId, "] start renew token without ticket")), await this._gateway.renewToken({ token: e9 });
      fb.debug("[".concat(this._clientId, "] renewToken success"));
    } catch (e10) {
      throw this._key = t2, this._joinInfo.token = t2, fb.error("[".concat(this._clientId, "] renewToken failed"), e10.toString()), e10;
    } finally {
      i2();
    }
  }
  enableAudioVolumeIndicator() {
    this._audioVolumeIndicationInterval ? fb.warning("you have already enabled audio volume indicator!") : this._audioVolumeIndicationInterval = window.setInterval(() => {
      const e9 = this._p2pChannel.getAudioLevels();
      this.safeEmit(zy.VOLUME_INDICATOR, e9);
    }, XA("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3);
  }
  getRTCStats() {
    const e9 = this._statsCollector.getRTCStats(), t2 = this._gateway.getInChannelInfo();
    return e9.Duration = Math.round(t2.duration / 1e3), e9;
  }
  async startLiveStreaming(e9, t2) {
    if (!t2) {
      if ("h264" !== this.codec) throw new yb(Ry.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264");
      if (!this._p2pChannel.hasLocalMedia()) throw new yb(Ry.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming");
    }
    if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e9) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e9)) throw new yb(Ry.LIVE_STREAMING_TASK_CONFLICT);
    const i2 = t2 ? Fw.TRANSCODE : Fw.RAW;
    return this._createLiveStreamingClient(i2).startLiveStreamingTask(e9, i2);
  }
  setLiveTranscoding(e9) {
    return this._createLiveStreamingClient(Fw.TRANSCODE).setTranscodingConfig(e9);
  }
  async stopLiveStreaming(e9) {
    const t2 = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter((t3) => t3 && t3.hasUrl(e9));
    if (!t2.length) throw new yb(Ry.INVALID_PARAMS, "can not find live streaming url to stop");
    await Gh.all(t2.map((t3) => t3 && t3.stopLiveStreamingTask(e9)));
  }
  async startChannelMediaRelay(e9) {
    LF(e9);
    const t2 = this._createChannelMediaRelayClient();
    await t2.startChannelMediaRelay(e9);
  }
  async updateChannelMediaRelay(e9) {
    LF(e9);
    const t2 = this._createChannelMediaRelayClient();
    await t2.updateChannelMediaRelay(e9);
  }
  async stopChannelMediaRelay() {
    const e9 = this._createChannelMediaRelayClient();
    await e9.stopChannelMediaRelay(), this._statsCollector.onStatsChanged && (this._statsCollector.onStatsChanged = void 0);
  }
  async sendStreamMessage(e9) {
    var t2;
    let i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if (!this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "can not send data stream, not joined");
    if (("string" == typeof e9 || e9 instanceof Uint8Array) && (e9 = { payload: e9 }), "string" == typeof e9.payload) {
      const t3 = new TextEncoder();
      e9.payload = t3.encode(e9.payload);
    }
    let n2 = false;
    this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && Dn(t2 = ["aes-128-gcm2", "aes-256-gcm2"]).call(t2, this._encryptionMode) && (n2 = true, e9.payload = await async function(e10, t3, i3) {
      var n3;
      const r2 = Jn(n3 = Array.from(i3)).call(n3, (e11, t4) => e11 + t4, 0), o2 = { serverTs: 0, seq: ob++, length: i3.length, checkSum: r2 }, s2 = new Uint8Array(yA(r2, 2)), a2 = new ArrayBuffer(rb), c2 = new DataView(a2);
      c2.setUint32(0, o2.serverTs), c2.setUint16(4, o2.seq), c2.setUint16(6, o2.length), c2.setUint16(8, o2.checkSum);
      const d2 = 16 - i3.length % 16;
      i3 = pA(i3, new Uint8Array(d2));
      const l2 = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: e10, tagLength: tb, additionalData: s2 }, t3, i3);
      return pA(new Uint8Array(a2), new Uint8Array(l2));
    }(this._encryptDataStreamIv, this._encryptDataStreamKey, e9.payload));
    if (new Blob([e9.payload]).size > 1024) throw new yb(Ry.INVALID_PARAMS, n2 ? "encrypted stream message out of range." : "stream message out of range.");
    return this._gateway.signal.request(Pw.DATA_STREAM, { payload: uA(e9.payload), syncWithAudio: e9.syncWithAudio, sendTs: Date.now() - vB }, !i2);
  }
  sendMetadata(e9) {
    if (!this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "can not send metadata, not joined");
    if (new Blob([e9]).size > 1024) throw new yb(Ry.METADATA_OUT_OF_RANGE);
    return this._gateway.signal.request(Pw.SEND_METADATA, { session_id: this._joinInfo.sid, metadata: uA(e9) });
  }
  async sendCustomReportMessage(e9) {
    if (Array.isArray(e9) || (e9 = [e9]), e9.forEach(Tb), !this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "can not send custom report, not joined");
    await vb.sendCustomReportMessage(this._joinInfo.sid, e9);
  }
  getLocalAudioStats() {
    return this._statsCollector.getLocalAudioTrackStats();
  }
  getRemoteAudioStats() {
    return this._statsCollector.getRemoteAudioTrackStats();
  }
  getLocalVideoStats() {
    return this._statsCollector.getLocalVideoTrackStats();
  }
  getRemoteVideoStats() {
    return this._statsCollector.getRemoteVideoTrackStats();
  }
  getRemoteNetworkQuality() {
    return this._statsCollector.getRemoteNetworkQualityStats();
  }
  async pickSVCLayer(e9, t2) {
    vy(t2.spatialLayer, "spatialLayer", [0, 1, 2, 3]), vy(t2.temporalLayer, "temporalLayer", [0, 1, 2, 3]);
    try {
      await this._gateway.pickSVCLayer(e9, t2);
    } catch (e10) {
      throw fb.error("[".concat(this._clientId, "] pick SVC layer failed"), e10.toString()), e10;
    }
  }
  async setRTMConfig(e9) {
    const { apRTM: t2 = false, rtmFlag: i2 } = e9;
    if (Iy(t2, "apRTM"), yy(i2, "rtmFlag", 0), this._rtmConfig.apRTM = t2, this._rtmConfig.rtmFlag = i2, fb.debug("[".concat(this._clientId, "] setRTMconfig ").concat(JSON.stringify(e9), " in ").concat(this.connectionState, " state")), ("CONNECTED" === this.connectionState || "RECONNECTING" === this.connectionState) && this._joinInfo) return this._joinInfo.apRTM = t2, this._joinInfo.rtmFlag = i2, this._gateway.setRTM2Flag(i2);
  }
  _reset() {
    if (fb.debug("[".concat(this._clientId, "] reset client")), this._axiosCancelSource.cancel(), this._axiosCancelSource = Lv.CancelToken.source(), this._streamFallbackTypeCacheMap = /* @__PURE__ */ new Map(), this._remoteStreamTypeCacheMap = /* @__PURE__ */ new Map(), this._configDistribute.stopGetConfigDistribute(), this._joinInfo && JB(this._joinInfo), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId && vb.removeSid(this._sessionId), this._sessionId = null, this.store.sessionId = null, this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = "none", this._encryptionSecret = null, this._encryptionSalt = null, this._encryptDataStreamKey = null, this._encryptDataStreamIv = null, this._pendingPublishedUsers = [], this._users.forEach((e9) => {
      e9._audioTrack && e9._audioTrack._destroy(), e9._videoTrack && e9._videoTrack._destroy(), e9._dataChannels && (e9._dataChannels.forEach((e10) => e10._close()), e9._dataChannels.length = 0);
    }), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), "fallback" === this._cloudProxyServerMode && (this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled"), this._p2pChannel.reset(), this._publishMutex = new NA("client-publish"), this._subscribeMutex = new NA("client-subscribe"), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect) try {
      this._inspect.close(), this._inspect = void 0;
    } catch (e9) {
    }
    if (this._moderation) try {
      this.setImageModeration(false);
    } catch (e9) {
    }
  }
  _startSession(e9, t2) {
    var i2;
    const n2 = e9 || SA();
    e9 ? fb.debug("[".concat(this._clientId, "] new Session ").concat(n2)) : fb.debug("[".concat(this._clientId, "] renewSession ").concat(this._sessionId, " => ").concat(n2));
    const r2 = e9 ? "" : this._sessionId || "";
    this._sessionId = n2, this.store.sessionId = n2, vb.addSid(n2);
    const o2 = { lts: (/* @__PURE__ */ new Date()).getTime(), mode: this.mode, buildFormat: 2, stringUid: (null == t2 ? void 0 : t2.stringUid) || (null === (i2 = this._joinInfo) || void 0 === i2 ? void 0 : i2.stringUid), channelProfile: "live" === this.mode ? 1 : 0, channelMode: 0, isABTestSuccess: Number(this._configDistribute.isSuccess), lsid: r2, clientRole: "audience" === this.role ? 2 : 1 };
    vb.sessionInit(this._sessionId, IG({ cname: t2.channel, appid: t2.appId }, o2)), this._joinInfo && (this._joinInfo.sid = n2), this._gateway.joinInfo && (this._gateway.joinInfo.sid = n2);
  }
  async _publishHighStream(e9) {
    if (!this._joinInfo || void 0 === this._uid) throw new yb(Ry.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
    if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new yb(Ry.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
    if ("auto" === this._turnServer.mode && XA("FORCE_TURN") && !XA("TURN_ENABLE_TCP") && !XA("TURN_ENABLE_UDP")) throw new yb(Ry.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
    fb.debug("[".concat(this._clientId, "] publish high stream"));
    try {
      const i2 = await this._p2pChannel.publish(e9, this._isDualStreamEnabled, this._lowStreamParameter);
      if (this._p2pChannel instanceof bF) {
        const e10 = (await i2.next()).value;
        if (e10) {
          try {
            await this._gateway.sendExtensionMessage(IO.PUBLISH, e10, true);
          } catch (e11) {
            throw i2.throw(e11), e11;
          }
          await i2.next();
        }
        this._p2pChannel.reportPublishEvent(true, null);
      } else {
        const n2 = (await i2.next()).value;
        if (n2) {
          var t2;
          let e10;
          try {
            e10 = await this._gateway.publish(this._uid, n2, true);
          } catch (e11) {
            if (e11.code !== Ry.DISCONNECT_P2P) throw i2.throw(e11), e11;
          }
          await i2.next((null === (t2 = e10) || void 0 === t2 ? void 0 : t2.ortc) || []);
        }
        this._p2pChannel.reportPublishEvent(true, null);
        for (const t3 of e9) t3 instanceof aU && t3._encoderConfig && this._gateway.setVideoProfile(t3._encoderConfig), !t3.muted && t3.enabled || await this._p2pChannel.muteLocalTrack(t3);
      }
    } catch (t3) {
      if (this._p2pChannel.reportPublishEvent(false, null == t3 ? void 0 : t3.code, e9), (null == t3 ? void 0 : t3.code) === Ry.WS_ABORT) return;
      throw t3;
    }
  }
  async _publishLowStream() {
    if (!this._joinInfo || void 0 === this._uid) throw new yb(Ry.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
    if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new yb(Ry.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
    fb.debug("[".concat(this._clientId, "] publish low stream"));
    const e9 = this._configDistribute.getLowStreamConfigDistribute();
    e9 && e9.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = { width: 160, height: 120, framerate: 15, bitrate: 50 }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e9.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e9.bitrate));
    try {
      const e10 = await this._p2pChannel.publishLowStream(this._lowStreamParameter), i2 = (await e10.next()).value;
      if (i2) {
        var t2;
        let n2;
        try {
          n2 = await this._gateway.publish(this._uid, i2, true);
        } catch (t3) {
          if (t3.code !== Ry.DISCONNECT_P2P) throw e10.throw(t3), t3;
        }
        e10.next((null === (t2 = n2) || void 0 === t2 ? void 0 : t2.ortc) || []), this._p2pChannel.reportPublishEvent(true, null, void 0, true);
      }
    } catch (e10) {
      if (this._p2pChannel.reportPublishEvent(false, null == e10 ? void 0 : e10.code, void 0, true), (null == e10 ? void 0 : e10.code) === Ry.WS_ABORT) return;
      throw e10;
    }
  }
  _createLiveStreamingClient(e9) {
    const t2 = () => {
      if (!this._joinInfo || !this._appId) {
        return new yb(Ry.INVALID_OPERATION, "can not create live streaming client, please join channel first").throw();
      }
      const e10 = (t3 = { joinInfo: this._joinInfo, appId: this._appId, websocketRetryConfig: this._config.websocketRetryConfig, httpRetryConfig: this._config.httpRetryConfig }, gB("LiveStreaming").create(t3));
      var t3;
      return e10.onLiveStreamError = (e11, t4) => {
        vb.reportApiInvoke(this._sessionId, { name: By.ON_LIVE_STREAM_ERROR, options: [e11, t4], tag: jy.TRACER }).onSuccess(), this.safeEmit(zy.LIVE_STREAMING_ERROR, e11, t4);
      }, e10.onLiveStreamWarning = (e11, t4) => {
        vb.reportApiInvoke(this._sessionId, { name: By.ON_LIVE_STREAM_WARNING, options: [e11, t4], tag: jy.TRACER }).onSuccess(), this.safeEmit(zy.LIVE_STREAMING_WARNING, e11, t4);
      }, e10.on(Kw.REQUEST_WORKER_MANAGER_LIST, (e11, t4, i2) => {
        if (!this._joinInfo) return i2(new yb(Ry.INVALID_OPERATION, "can not find join info to get worker manager"));
        (async function(e12, t5, i3, n2) {
          const r2 = XA("UAP_AP").slice(0, XA("AJAX_REQUEST_CONCURRENT")).map((e13) => t5.proxyServer ? "https://".concat(t5.proxyServer, "/ap/?url=").concat(e13 + "/api/v1?action=uap") : "https://".concat(e13, "/api/v1?action=uap"));
          return await Dx(r2, e12, t5, i3, n2);
        })(e11, this._joinInfo, this._axiosCancelSource.token, PA).then(t4).catch(i2);
      }), e10;
    };
    return e9 === Fw.RAW ? (this._liveRawStreamingClient = this._liveRawStreamingClient || t2(), this._liveRawStreamingClient) : (this._liveTranscodeStreamingClient = this._liveTranscodeStreamingClient || t2(), this._liveTranscodeStreamingClient);
  }
  _createChannelMediaRelayClient() {
    if (!this._joinInfo) {
      return new yb(Ry.INVALID_OPERATION, "can not create channel media relay client, please join channel first").throw();
    }
    if (!this._channelMediaRelayClient) {
      const { sendResolutionWidth: t2, sendResolutionHeight: i2 } = this.getLocalVideoStats(), n2 = (e9 = { joinInfo: this._joinInfo, clientId: this._clientId, websocketRetryConfig: this._config.websocketRetryConfig, httpRetryConfig: this._config.httpRetryConfig, resolution: { width: t2, height: i2 } }, gB("ChannelMediaRelay").create(e9));
      n2.on("state", (e10) => {
        e10 === Xw.RELAY_STATE_FAILURE && n2 && n2.dispose(), this.safeEmit(zy.CHANNEL_MEDIA_RELAY_STATE, e10);
      }), n2.on("event", (e10) => {
        this.safeEmit(zy.CHANNEL_MEDIA_RELAY_EVENT, e10);
      }), this._channelMediaRelayClient = n2, this._statsCollector.onStatsChanged = (e10, t3) => {
        var i3;
        "resolution" === e10 && (null === (i3 = this._channelMediaRelayClient) || void 0 === i3 || i3.setVideoProfile(t3));
      };
    }
    var e9;
    return this._channelMediaRelayClient;
  }
  _handleUpdateDataChannel(e9, t2) {
    const { added: i2, deleted: n2 } = e9, r2 = [];
    if (t2) {
      const e10 = [];
      this._users.forEach((t3) => {
        t3._dataChannels.forEach((n3) => {
          i2.every((e11) => e11.uid !== t3._uintid || e11.stream_id !== n3.id) && e10.push({ uid: t3._uintid, stream_id: n3.id, ordered: n3.ordered, max_retrans_times: n3.maxRetransmits, metadata: n3.metadata });
        });
      }), e10.length > 0 && this._handleUpdateDataChannel({ added: [], deleted: e10 });
    }
    Array.isArray(i2) && i2.length > 0 && i2.forEach((e10) => {
      const { uid: i3, stream_id: n3, ordered: o2, max_retrans_times: s2, metadata: a2 } = e10, c2 = this._users.find((e11) => e11._uintid === i3);
      if (!c2) return void fb.error("[".concat(this._clientId, "] can not find target user!(on_add_data_channel)"));
      fb.debug("[".concat(this._clientId, "] data_channel added with uid ").concat(i3)), Dn(r2).call(r2, c2) || r2.push(c2), c2._uintid || (c2._uintid = i3);
      if (!(-1 !== c2._dataChannels.findIndex((t3) => t3.id === e10.stream_id))) {
        const e11 = { id: n3, ordered: !!o2, maxRetransmits: s2, metadata: a2 }, i4 = function(e12) {
          return RB(e12, true);
        }(e11);
        c2._dataChannels.push(i4), fb.info("[".concat(this._clientId, "] remote user ").concat(c2.uid, " published datachannel")), t2 || this.safeEmit(zy.USER_PUBLISHED, c2, "datachannel", e11);
      }
      this._p2pChannel.hasPendingRemoteDataChannel(c2, e10.stream_id) && (fb.debug("[".concat(this._clientId, "] resubscribe datachannel for user ").concat(c2.uid, " after reconnect.")), this._subscribeDataChannel(c2, e10.stream_id).catch((e11) => {
        fb.error("[".concat(this._clientId, "] resubscribe datachannel error"), e11.toString());
      }));
    }), t2 && (this.safeEmit(zy.PUBLISHED_USER_LIST, this._pendingPublishedUsers), this._pendingPublishedUsers = []), Array.isArray(n2) && n2.length > 0 && n2.forEach((e10) => {
      const { uid: t3, stream_id: i3 } = e10, n3 = this._users.find((e11) => e11._uintid === t3);
      if (!n3) return void fb.error("[".concat(this._clientId, "] can not find target user!(on_delete_data_channel)"));
      const r3 = n3._dataChannels.find((t4) => t4.id === e10.stream_id);
      r3 && (fb.debug("[".concat(this._clientId, "] data_stream delete with uid ").concat(t3)), this._p2pChannel.unsubscribeDataChannel(n3, [r3]).then((e11) => {
        if (n3._dataChannels = n3._dataChannels.filter((e12) => e12 !== r3), e11) return this._gateway.unsubscribeDataChannel(e11, n3.uid);
      }), fb.info("[".concat(this._clientId, "] remote user ").concat(t3, " unpublished datachannel ,id:").concat(r3.id)), this.safeEmit(zy.USER_UNPUBLISHED, n3, "datachannel", r3._config));
    });
  }
  _handleRemoveDataChannels(e9) {
    const t2 = this._users.find((t3) => t3.uid === e9.uid);
    if (t2) {
      if (void 0 !== t2._dataChannels && t2._dataChannels.length > 0) {
        fb.debug("[".concat(this._clientId, "] datachannel removed with uid ").concat(e9.uid));
        const i2 = () => {
          fb.info("[".concat(this._clientId, "] remote user ").concat(t2.uid, " unpublished datachannel")), t2._dataChannels.forEach((e10) => {
            this.safeEmit(zy.USER_UNPUBLISHED, t2, "datachannel", e10._config);
          });
        };
        this._p2pChannel.unsubscribeDataChannel(t2, t2._dataChannels).then((e10) => {
          if (e10) return this._gateway.unsubscribeDataChannel(e10, t2.uid);
        }), i2();
      }
    } else fb.warning("[".concat(this._clientId, "] can not find target user!(on_remove_datachannel)"));
  }
  _handleGatewayEvents() {
    this._gateway.on($w.DISCONNECT_P2P, async () => {
      await this._p2pChannel.disconnectForReconnect();
    }), this._gateway.on($w.CONNECTION_STATE_CHANGE, (e9, t2, i2) => {
      var n2;
      if (i2 === Hy.FALLBACK) return;
      const r2 = () => {
        this.safeEmit(zy.CONNECTION_STATE_CHANGE, e9, t2, i2);
      };
      if (vb.reportApiInvoke(this._sessionId || (null === (n2 = this._gateway.joinInfo) || void 0 === n2 ? void 0 : n2.sid) || null, { name: By.CONNECTION_STATE_CHANGE, options: [e9, t2, i2], tag: jy.TRACER }).onSuccess(JSON.stringify({ cur: e9, prev: t2, reason: i2 })), fb.info("[".concat(this._clientId, "] connection state change: ").concat(t2, " -> ").concat(e9)), "DISCONNECTED" === e9) return this._reset(), void r2();
      if ("RECONNECTING" === e9) this._users.forEach((e10) => {
        e10._trust_in_room_ = false, e10._trust_audio_enabled_state_ = false, e10._trust_video_enabled_state_ = false, e10._trust_audio_mute_state_ = false, e10._trust_video_mute_state_ = false, e10._trust_audio_stream_added_state_ = false, e10._trust_video_stream_added_state_ = false, e10._is_pre_created || (e10._audio_pre_subscribed || (e10._audioSSRC = void 0, e10._audioOrtc = void 0), e10._video_pre_subscribed || (e10._videoSSRC = void 0, e10._videoOrtc = void 0, e10._rtxSsrcId = void 0), e10._cname = void 0);
      }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0;
      else if ("CONNECTED" === e9) {
        var o2;
        this._streamFallbackTypeCacheMap.forEach((e10, t3) => {
          this._gateway.setStreamFallbackOption(t3, e10).catch((e11) => {
            fb.warning("[".concat(this._clientId, "] auto set stream fallback option failed"), e11);
          });
        }), this._remoteStreamTypeCacheMap.forEach((e10, t3) => {
          this._gateway.setRemoteVideoStreamType(t3, e10).catch((e11) => {
            fb.warning("[".concat(this._clientId, "] auto set remote stream type failed"), e11);
          });
        }), void 0 !== this._remoteDefaultVideoStreamType && void 0 === (null === (o2 = this._joinInfo) || void 0 === o2 ? void 0 : o2.defaultVideoStream) && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(() => {
          fb.debug("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway connected"));
        }).catch((e10) => {
          fb.error("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e10));
        }), this.store.useP2P || (this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout(() => {
          if ("CONNECTED" !== this.connectionState) return;
          this._userOfflineTimeout = void 0;
          this._users.filter((e10) => !e10._trust_in_room_).forEach((e10) => {
            fb.debug("[".concat(this._clientId, "] user offline timeout, emit user offline ").concat(e10.uid)), this._handleUserOffline({ uid: e10.uid });
          });
        }, 3e3), this._streamRemovedTimeout = window.setTimeout(() => {
          "CONNECTED" === this.connectionState && (this._streamRemovedTimeout = void 0, this._users.forEach((e10) => {
            e10._trust_audio_mute_state_ || (fb.debug("[".concat(this._clientId, "] auto dispatch audio unmute event ").concat(e10.uid)), this._handleMuteStream(e10.uid, dO.AUDIO, false)), e10._trust_video_mute_state_ || (fb.debug("[".concat(this._clientId, "] auto dispatch video unmute event ").concat(e10.uid)), this._handleMuteStream(e10.uid, dO.VIDEO, false)), e10._trust_audio_enabled_state_ || (fb.debug("[".concat(this._clientId, "] auto dispatch enable local audio ").concat(e10.uid)), this._handleSetStreamLocalEnable("audio", e10.uid, true)), e10._trust_video_enabled_state_ || (fb.debug("[".concat(this._clientId, "] auto dispatch enable local video ").concat(e10.uid)), this._handleSetStreamLocalEnable("video", e10.uid, true)), e10._trust_video_stream_added_state_ || (fb.debug("[".concat(this._clientId, "] auto dispatch reset video stream added ").concat(e10.uid)), this._handleResetAddStream(e10, "video")), e10._trust_audio_stream_added_state_ || (fb.debug("[".concat(this._clientId, "] auto dispatch reset audio stream added ").concat(e10.uid)), this._handleResetAddStream(e10, "audio")), e10._video_added_ || e10._audio_added_ || (fb.debug("[".concat(this._clientId, "] auto dispatch stream remove ").concat(e10.uid)), this._handleRemoveStream({ uid: e10.uid, uint_id: e10._uintid }));
          }));
        }, 1e3));
      }
      r2();
    }), this._gateway.on($w.REQUEST_NEW_GATEWAY_LIST, async (e9, t2) => {
      if (!this._joinInfo) return t2(new yb(Ry.UNEXPECTED_ERROR, "can not recover, no join info"));
      try {
        let t3;
        const i2 = await YB(IG(IG({}, this._joinInfo), {}, { uid: this._joinInfo.uid, stringUid: void 0 }));
        i2 ? (t3 = i2.ap, XB(i2), this._joinInfo.preload = true) : (t3 = await Hx(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || PA, this.store), this._joinInfo.preload = false), this._joinInfo && (this._joinInfo.apResponse = t3.gatewayInfo.res, this._joinInfo.gatewayAddrs = t3.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t3.gatewayInfo.uni_lbs_ip);
        const n2 = [];
        t3.gatewayInfo.gatewayAddrs.forEach((e10) => {
          let { address: t4 } = e10;
          const [i3, r2] = t4.split(":");
          this._joinInfo && this._joinInfo.proxyServer ? n2.push({ proxy: this._joinInfo.proxyServer, host: i3, port: r2 }) : n2.push({ host: i3, port: r2 });
        }), e9(n2);
      } catch (e10) {
        t2(e10);
      }
    }), this._gateway.on($w.NETWORK_QUALITY, (e9) => {
      "normal" === this._networkQualitySensitivity && this.safeEmit(zy.NETWORK_QUALITY, e9);
    }), this._gateway.on($w.STREAM_TYPE_CHANGE, (e9, t2) => {
      this.safeEmit(zy.STREAM_TYPE_CHANGED, e9, t2);
      vb.reportApiInvoke(this._sessionId, { name: By.STREAM_TYPE_CHANGE, options: [e9, t2], tag: jy.TRACER }).onSuccess(JSON.stringify({ uid: e9, streamType: t2 }));
    }), this._gateway.on($w.IS_P2P_DISCONNECTED, (e9) => {
      this._p2pChannel.isP2PDisconnected() ? e9(true) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e9(false) : e9(true);
    }), this._gateway.on($w.REQUEST_P2P_CONNECTION_PARAMS, async (e9, t2, i2) => {
      try {
        let i3 = await this._p2pChannel.getEstablishParams();
        XA("ENABLE_PREALLOC_PC") && i3 || (i3 = await this._p2pChannel.startP2PConnection(e9)), t2(i3);
      } catch (e10) {
        i2(e10);
      }
    }), this._gateway.on($w.JOIN_RESPONSE, (e9, t2) => {
      if (this.store.useP2P) return;
      const i2 = YU(e9.ortc, t2, e9.attributes.userAttributes.preSubSsrcs);
      this._p2pChannel.connect(i2);
    }), this._gateway.on($w.PRE_CONNECT_PC, async (e9) => {
      const { candidates: t2, fingerprint: i2 } = e9;
      if (this._joinInfo && t2.length > 0 && !this._p2pChannel.isPlanB) {
        var n2;
        await this._p2pChannel.startP2PConnection({ turnServer: this._joinInfo.turnServer });
        const { cert: e10, cid: r2 } = this._joinInfo.apResponse;
        await this._p2pChannel.connect({ iceParameters: { iceUfrag: "".concat(r2, "_").concat(e10), icePwd: "".concat(r2, "_").concat(e10) }, dtlsParameters: { fingerprints: [{ hashFunction: "sha-256", fingerprint: null !== (n2 = XA("FINGERPRINT")) && void 0 !== n2 ? n2 : i2 }] }, candidates: t2, rtpCapabilities: { send: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, recv: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] } }, setup: "active", cname: "o/i14u9pJrxRKAsu", preallocation: true });
      }
    });
  }
  _handleGatewaySignalEvents() {
    this._gateway.signal.on(kw.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(kw.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(kw.ON_ADD_AUDIO_STREAM, (e9) => this._handleAddAudioOrVideoStream("audio", e9.uid, e9.ssrcId, e9.cname, e9.uint_id, e9.ortc)), this._gateway.signal.on(kw.ON_ADD_VIDEO_STREAM, (e9) => this._handleAddAudioOrVideoStream("video", e9.uid, e9.ssrcId, e9.cname, e9.uint_id, e9.ortc, e9.rtxSsrcId)), this._gateway.signal.on(kw.ON_REMOTE_DATASTREAM_UPDATE, (e9) => {
      this._handleUpdateDataChannel(e9);
    }), this._gateway.signal.on(kw.ON_REMOTE_FULL_DATASTREAM_INFO, (e9) => {
      this._handleUpdateDataChannel({ added: e9.datastreams || [], deleted: [] }, true);
    }), this._gateway.signal.on(kw.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(kw.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(kw.MUTE_AUDIO, (e9) => this._handleMuteStream(e9.uid, dO.AUDIO, true)), this._gateway.signal.on(kw.UNMUTE_AUDIO, (e9) => this._handleMuteStream(e9.uid, dO.AUDIO, false)), this._gateway.signal.on(kw.MUTE_VIDEO, (e9) => this._handleMuteStream(e9.uid, dO.VIDEO, true)), this._gateway.signal.on(kw.UNMUTE_VIDEO, (e9) => this._handleMuteStream(e9.uid, dO.VIDEO, false)), this._gateway.signal.on(kw.RECEIVE_METADATA, (e9) => {
      const t2 = lA(e9.metadata);
      this.safeEmit(zy.RECEIVE_METADATA, e9.uid, t2);
    }), this._gateway.signal.on(kw.ON_DATA_STREAM, async (e9) => {
      var t2;
      if (!e9) return;
      let i2 = lA(e9.payload);
      if (this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && Dn(t2 = ["aes-128-gcm2", "aes-256-gcm2"]).call(t2, this._encryptionMode)) {
        if (e9.payload.length < rb) throw new yb(Ry.UNEXPECTED_RESPONSE, "payload length ".concat(e9.payload.length, " is less than header length ").concat(rb));
        const t3 = await async function(e10, t4, i3) {
          const n3 = i3.subarray(0, rb), r2 = n3.slice(8, rb), o2 = (r2[0] << 8) + r2[1], s2 = (n3[6] << 8) + n3[7], a2 = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: e10, tagLength: tb, additionalData: new Uint8Array(yA(o2, 2)) }, t4, i3.subarray(rb));
          return new Uint8Array(a2).subarray(0, s2);
        }(this._encryptDataStreamIv, this._encryptDataStreamKey, i2);
        i2 = t3;
      }
      let n2 = 0;
      if (e9.ordered || e9.syncWithAudio) {
        const t3 = this._p2pChannel.getStats(), i3 = this.remoteUsers.find((t4) => t4.uid === e9.uid), r2 = null == t3 ? void 0 : t3.audioRecv.find((e10) => e10.ssrc === (null == i3 ? void 0 : i3._audioSSRC));
        n2 = null == r2 ? void 0 : r2.jitterBufferMs;
      }
      null == n2 && (n2 = 0), NB(IG(IG({}, e9), {}, { payload: i2 }), n2, { id: this._clientId, onStreamMessage: "function" == typeof this.onStreamMessage ? this.onStreamMessage.bind(this) : void 0, safeEmit: this.safeEmit.bind(this) });
    }), this._gateway.signal.on(kw.ON_CRYPT_ERROR, () => {
      dA(() => {
        fb.warning("[".concat(this._clientId, "] on crypt error")), this.safeEmit(zy.CRYPT_ERROR);
      }, this._sessionId);
    }), this._gateway.signal.on(kw.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(kw.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
      fb.warning("[".concat(this._clientId, "] received message onTokenPrivilegeDidExpire, please get new token and join again")), this._gateway.leave(true, Hy.TOKEN_EXPIRE), this.safeEmit(zy.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset();
    }), this._gateway.signal.on(kw.ON_STREAM_FALLBACK_UPDATE, (e9) => {
      fb.debug("[".concat(this._clientId, "] stream fallback peerId: ").concat(e9.stream_id, ", attr: ").concat(e9.stream_type)), this.safeEmit(zy.STREAM_FALLBACK, e9.stream_id, 1 === e9.stream_type ? "fallback" : "recover");
    }), this._gateway.signal.on(kw.ON_PUBLISH_STREAM, (e9) => {
      this.uid === this._uid && (this._p2pChannel.reportPublishEvent(true, null, void 0, false, JSON.stringify({ proxy: e9.proxy })), fb.info("[".concat(this._clientId, "] on publish stream, ").concat(JSON.stringify(e9))));
    }), this._gateway.signal.on(kw.ENABLE_LOCAL_VIDEO, (e9) => {
      this._handleSetStreamLocalEnable("video", e9.uid, true);
    }), this._gateway.signal.on(kw.DISABLE_LOCAL_VIDEO, (e9) => {
      this._handleSetStreamLocalEnable("video", e9.uid, false);
    }), this._gateway.signal.on(Dw.REQUEST_TIMEOUT, (e9, t2) => {
      if (this._joinInfo) switch (e9) {
        case Pw.PUBLISH: {
          if (!t2) return;
          const e10 = t2.ortc;
          if (e10) {
            var i2, n2;
            const r2 = e10.some((e11) => {
              let { stream_type: t3 } = e11;
              return t3 === Zw.Audio;
            }), o2 = e10.some((e11) => {
              let { stream_type: t3 } = e11;
              return t3 !== Zw.Audio;
            }), s2 = e10.some((e11) => {
              let { stream_type: t3 } = e11;
              return t3 === Zw.Screen || t3 === Zw.ScreenLow;
            });
            "offer" === t2.state && vb.publish(this._joinInfo.sid, { eventElapse: rV.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: false, ec: Ry.TIMEOUT, audio: r2, video: o2, p2pid: t2.p2p_id, publishRequestid: this.store.pubId, screenshare: s2, audioName: r2 ? null === (i2 = e10.find((e11) => {
              let { stream_type: t3 } = e11;
              return t3 === Zw.Audio;
            })) || void 0 === i2 || null === (i2 = i2.ssrcs[0]) || void 0 === i2 ? void 0 : i2.ssrcId.toString() : void 0, videoName: o2 ? null === (n2 = e10.find((e11) => {
              let { stream_type: t3 } = e11;
              return t3 !== Zw.Audio;
            })) || void 0 === n2 || null === (n2 = n2.ssrcs[0]) || void 0 === n2 ? void 0 : n2.ssrcId.toString() : void 0 });
          }
          break;
        }
        case Pw.SUBSCRIBE:
          t2 && vb.subscribe(this._joinInfo.sid, { succ: false, ec: Ry.TIMEOUT, audio: t2.stream_type === dO.AUDIO, video: t2.stream_type === dO.VIDEO, peerid: t2.stream_id, subscribeRequestid: t2.ssrcId, p2pid: this.store.p2pId, eventElapse: rV.measureFromSubscribeStart(this.store.clientId, t2.ssrcId), preSsrc: this._p2pChannel.isPreSubScribe(t2.ssrcId) });
      }
    }), this._gateway.signal.on(kw.ON_P2P_OK, (e9) => {
      this.uid, this._uid;
    }), this._gateway.signal.on(kw.ON_PUBLISHED_USER_LIST, (e9) => {
      if (null == e9 || !e9.users) return;
      XA("BLOCK_LOCAL_CLIENT") && (e9.users = e9.users.filter((e10) => !Ob(e10.string_id || e10.stream_id, this.channelName)));
      const t2 = [], i2 = [];
      for (const n2 of e9.users) {
        let e10 = this._users.find((e11) => e11._uintid === n2.stream_id);
        e10 ? e10._trust_in_room_ = true : (e10 = new cF(n2.string_id || n2.stream_id, n2.stream_id), this._users.push(e10), 0 === this.getListeners(zy.PUBLISHED_USER_LIST).length && (fb.debug("[".concat(this._clientId, "] user online"), n2.stream_id), this.safeEmit(zy.USER_JOINED, e10)));
        const r2 = tO.Audio & n2.stream_type, o2 = (tO.Video | tO.LwoVideo) & n2.stream_type, s2 = 0 != (65280 & n2.stream_type), a2 = r2 && e10.hasAudio, c2 = o2 && e10.hasVideo;
        o2 && (e10._trust_video_stream_added_state_ = true, e10._video_added_ = true, e10._videoSSRC = n2.video_ssrc, e10._rtxSsrcId = n2.video_rtx), r2 && (e10._trust_audio_stream_added_state_ = true, e10._audio_added_ = true, e10._audioSSRC = n2.audio_ssrc), r2 && !a2 && 0 === this.getListeners(zy.PUBLISHED_USER_LIST).length && (fb.info("[".concat(this._clientId, "] remote user ").concat(e10.uid, " published audio")), this.safeEmit(zy.USER_PUBLISHED, e10, "audio")), o2 && !c2 && 0 === this.getListeners(zy.PUBLISHED_USER_LIST).length && (fb.info("[".concat(this._clientId, "] remote user ").concat(e10.uid, " published video")), this.safeEmit(zy.USER_PUBLISHED, e10, "video")), (r2 && !a2 || o2 && !c2 || s2) && t2.push(e10), o2 && this._p2pChannel.hasPendingRemoteMedia(e10, "video") && i2.push({ user: e10, mediaType: "video" }), r2 && this._p2pChannel.hasPendingRemoteMedia(e10, "audio") && i2.push({ user: e10, mediaType: "audio" });
      }
      i2.length > 0 && (fb.debug("[".concat(this._clientId, "] RE massSubscribe after reconnect ").concat(i2.map((e10) => "user: ".concat(e10.user.uid, ", mediaType: ").concat(e10.mediaType)).join("; "), " ")), this.massSubscribe(i2).catch((e10) => {
        fb.error("[".concat(this._clientId, "] mass resubscribe error"), e10.toString());
      })), this.getListeners(zy.PUBLISHED_USER_LIST).length > 0 ? XA("ENABLE_DATASTREAM_2") ? this._pendingPublishedUsers = t2 : (fb.info("[".concat(this._clientId, "] client emit user-list event, users: ").concat(t2.map((e10) => e10.uid).join(", "))), this.safeEmit(zy.PUBLISHED_USER_LIST, t2)) : fb.info("[".concat(this._clientId, "] client not emit user-list event case there is no user-list listener, users: ").concat(t2.map((e10) => e10.uid).join(", ")));
    }), this._gateway.signal.on(kw.ON_RTP_CAPABILITY_CHANGE, (e9) => {
      const { video_codec: t2 } = e9;
      this._p2pChannel instanceof fB && this._p2pChannel.updateRemoteRTPCapabilities(t2.map((e10) => e10.toLowerCase()).filter((e10) => {
        var t3;
        return Dn(t3 = Object.keys(eb)).call(t3, e10);
      }));
    });
  }
  _handleP2PEvents() {
    this._gateway.signal.on(kw.ON_USER_OFFLINE, () => {
      this._p2pChannel.disconnectForReconnect();
    }), this._gateway.signal.on(IO.PUBLISH, (e9, t2, i2) => {
      const { uid: n2 } = e9;
      e9.forEach((e10) => {
        const { kind: r2, ssrcs: o2, mid: s2, isMuted: a2 } = e10;
        this._handleP2PAddAudioOrVideoStream(r2, n2, o2[0].ssrcId, s2);
        const c2 = this._users.find((e11) => e11.uid === n2);
        return c2 && this._p2pChannel instanceof bF ? this._p2pChannel.mockSubscribe(c2, r2, o2[0].ssrcId, s2).then(() => {
          t2();
        }).catch(i2) : t2(), this._handleMuteStream(n2, r2, !!a2);
      });
    }), this._gateway.signal.on(IO.CALL, async (e9, t2, i2) => {
      if (this._p2pChannel instanceof bF) try {
        var n2;
        t2(await this._p2pChannel.startP2P({ turnServer: null === (n2 = this._joinInfo) || void 0 === n2 ? void 0 : n2.turnServer }, e9));
      } catch (e10) {
        i2(e10);
      }
    }), this._gateway.signal.on(Dw.P2P_CONNECTION, async (e9) => {
      this._p2pChannel instanceof bF && await this._p2pChannel.p2pConnect(e9);
    }), this._gateway.signal.on(IO.UNPUBLISH, async (e9, t2, i2) => {
      if (this._p2pChannel instanceof bF) {
        const { unpubMsg: n2, uid: r2 } = e9, o2 = this._users.find((e10) => e10.uid === r2);
        if (!o2) return fb.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(r2)), void t2();
        try {
          n2.forEach(async (e10) => {
            let { stream_type: t3 } = e10;
            const i3 = t3 === Zw.Audio ? dO.AUDIO : dO.VIDEO;
            await this._p2pChannel.unsubscribe(o2, i3), this._handleMuteStream(r2, i3, true);
          }), t2();
        } catch (e10) {
          i2(e10);
        }
      }
    }), this._gateway.signal.on(IO.CONTROL, async (e9, t2) => {
      const { action: i2 } = e9;
      switch (i2) {
        case yO.MUTE_LOCAL_VIDEO:
          this._handleMuteStream(t2, dO.VIDEO, true);
          break;
        case yO.MUTE_LOCAL_AUDIO:
          this._handleMuteStream(t2, dO.AUDIO, true);
          break;
        case yO.UNMUTE_LOCAL_VIDEO:
          this._handleP2PAddAudioOrVideoStream("video", t2), this._handleMuteStream(t2, dO.VIDEO, false);
          break;
        case yO.UNMUTE_LOCAL_AUDIO:
          this._handleP2PAddAudioOrVideoStream("audio", t2), this._handleMuteStream(t2, dO.AUDIO, false);
      }
    }), this._gateway.signal.on(IO.RESTART_ICE, async (e9, t2, i2) => {
      if (this._p2pChannel instanceof bF) try {
        const { direction: i3, iceParameter: n2 } = e9;
        if (i3 !== Mw.SEND_ONLY || n2) {
          t2(await this._p2pChannel.restartICE(i3, n2));
        } else this._p2pChannel.handleDisconnect(i3), t2();
      } catch (e10) {
        i2(e10);
      }
    }), this._gateway.signal.on(IO.CANDIDATE, (e9) => {
      if (this._p2pChannel instanceof bF) {
        const { candidate: t2, direction: i2 } = e9;
        this._p2pChannel.addRemoteCandidate(t2, i2);
      }
    }), this._p2pChannel.on(_O.RequestP2PRestartICE, async (e9, t2, i2) => {
      try {
        const { direction: i3 } = e9;
        t2(await this._gateway.sendExtensionMessage(IO.RESTART_ICE, e9, i3 === Mw.SEND_ONLY));
      } catch (e10) {
        i2(e10);
      }
    }), this._p2pChannel.on(_O.LocalCandidate, (e9) => {
      this._gateway.sendExtensionMessage(IO.CANDIDATE, JSON.stringify(e9), true);
    }), this._p2pChannel.on(_O.RequestP2PMuteLocal, async (e9, t2, i2) => {
      try {
        await this._gateway.sendExtensionMessage(IO.CONTROL, e9, true), t2();
      } catch (e10) {
        i2(e10);
      }
    }), this._p2pChannel.on(_O.RequestP2PUnmuteRemote, async (e9, t2, i2) => {
      if (this._joinInfo) try {
        await this._gateway.unmuteRemote(e9, this._joinInfo.stringUid || this._joinInfo.uid), t2();
      } catch (e10) {
        e10.code === Ry.DISCONNECT_P2P ? t2() : i2(e10);
      }
      else t2();
    }), this._p2pChannel.on(_O.RequestP2PMuteRemote, async (e9, t2, i2) => {
      if (this._joinInfo) try {
        await this._gateway.muteRemote(e9, this._joinInfo.stringUid || this._joinInfo.uid), t2();
      } catch (e10) {
        e10.code === Ry.DISCONNECT_P2P ? t2() : i2(e10);
      }
      else t2();
    }), this._p2pChannel.on(_O.StateChange, (e9, t2) => {
      t2 === pO.Connected && this._p2pChannel.republish();
    });
  }
  _handleP2PChannelEvents() {
    this._p2pChannel.on(_O.RequestMuteLocal, async (e9, t2, i2) => {
      if (this._joinInfo) try {
        await this._gateway.muteLocal(e9, this._joinInfo.stringUid || this._joinInfo.uid), t2();
      } catch (e10) {
        e10.code === Ry.DISCONNECT_P2P ? t2() : i2(e10);
      }
      else t2();
    }), this._p2pChannel.on(_O.RequestUnmuteLocal, async (e9, t2, i2) => {
      if (this._joinInfo) try {
        await this._gateway.unmuteLocal(e9, this._joinInfo.stringUid || this._joinInfo.uid), t2();
      } catch (e10) {
        e10.code === Ry.DISCONNECT_P2P ? t2() : i2(e10);
      }
      else t2();
    }), this._p2pChannel.on(_O.RequestRePublish, (e9, t2, i2) => {
      this.publish(e9, false).then(t2).catch(i2);
    }), this._p2pChannel.on(_O.RequestRePublishDataChannel, (e9, t2, i2) => {
      Gh.all(e9.map(async (e10) => {
        const t3 = await this._p2pChannel.publishDataChannel([e10]);
        try {
          t3.forEach((e11) => {
            this._uid && this._gateway.publishDataChannel(this._uid, e11, true);
          });
        } catch (e11) {
          if (e11.code !== Ry.DISCONNECT_P2P) throw e11;
        }
      })).then(t2).catch(i2);
    }), this._p2pChannel.on(_O.RequestReSubscribe, async (e9, t2, i2) => {
      try {
        for (const { user: t3, kind: i3 } of e9) i3 === dO.VIDEO ? await this.subscribe(t3, "video") : await this.subscribe(t3, "audio");
        t2();
      } catch (e10) {
        i2(e10);
      }
    }), this._p2pChannel.on(_O.RequestUpload, (e9, t2) => {
      this._gateway.upload(e9, t2);
    }), this._p2pChannel.on(_O.RequestUploadStats, (e9) => {
      this._gateway.uploadWRTCStats(e9);
    }), this._p2pChannel.on(_O.MediaReconnectStart, (e9) => {
      this.safeEmit(zy.MEDIA_RECONNECT_START, e9);
    }), this._p2pChannel.on(_O.MediaReconnectEnd, (e9) => {
      this.safeEmit(zy.MEDIA_RECONNECT_END, e9);
    }), this._p2pChannel.on(_O.NeedSignalRTT, (e9) => {
      e9(this._gateway.getSignalRTT());
    }), this._p2pChannel.on(_O.RequestRestartICE, async (e9) => {
      if (this._p2pChannel instanceof bF) return;
      const t2 = await this._p2pChannel.restartICE(e9), i2 = await t2.next();
      if (i2.done) return;
      const n2 = i2.value;
      let r2;
      try {
        r2 = await this._gateway.restartICE({ iceParameters: n2 });
      } catch (e10) {
        return void t2.throw(e10);
      }
      const { iceParameters: o2 } = function(e10) {
        const t3 = e10.iceParameters;
        return { iceParameters: { iceUfrag: t3.iceUfrag, icePwd: t3.icePwd } };
      }(r2);
      await t2.next({ remoteIceParameters: o2 });
    }), this._p2pChannel.on(_O.RequestReconnect, async () => {
      this._gateway.reconnect();
    }), this._p2pChannel.on(_O.RequestReconnectPC, async () => {
      var e9;
      const { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } = await this._p2pChannel.startP2PConnection({ turnServer: null === (e9 = this._joinInfo) || void 0 === e9 ? void 0 : e9.turnServer }), { gatewayEstablishParams: r2, gatewayAddress: o2 } = await this._gateway.reconnectPC({ iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 }), s2 = YU(r2, o2);
      await this._p2pChannel.connect(s2), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe();
    }), this._p2pChannel.on(_O.RequestUnpublishForReconnectPC, async (e9, t2, i2) => {
      this._joinInfo && void 0 !== this._uid ? (await this._gateway.unpublish(e9, this._uid), t2()) : i2();
    }), this._p2pChannel.on(_O.P2PLost, () => {
      this.safeEmit(zy.P2P_LOST, this.store.uid);
    }), this._p2pChannel.on(_O.UpdateVideoEncoder, (e9) => {
      e9._encoderConfig && this._gateway.setVideoProfile(e9._encoderConfig);
    }), this._p2pChannel.on(_O.ConnectionTypeChange, (e9) => {
      this.safeEmit(zy.IS_USING_CLOUD_PROXY, e9);
    }), this._p2pChannel.on(_O.RequestLowStreamParameter, (e9) => {
      e9(this._lowStreamParameter || { width: 160, height: 120, framerate: 15, bitrate: 50 });
    }), this._p2pChannel.on(_O.QueryClientConnectionState, (e9) => {
      e9(this.connectionState);
    });
  }
  getKeyMetrics() {
    return this.store.keyMetrics;
  }
  async enableContentInspect(e9) {
    if (!this._joinInfo || "CONNECTED" !== this.connectionState) throw new yb(Ry.INVALID_OPERATION, "[".concat(this._clientId, "] can not create content inspect, please join channel first"));
    if (this._inspect) throw new yb(Ry.INVALID_OPERATION, "[".concat(this._clientId, "] Inspect content service already in connecting/connected state"));
    try {
      const i2 = (t2 = { config: e9 }, gB("ContentInspect").create(t2));
      this._inspect = i2, this.handleVideoInspectEvents(i2);
      const { appId: n2, cname: r2, sid: o2, token: s2, uid: a2, cid: c2, vid: d2 } = this._joinInfo;
      await i2.init({ appId: n2, areaCode: "", cname: r2, sid: o2, token: s2, uid: a2, cid: c2, vid: d2 ? Number(d2) : 0 }, PA);
    } catch (e10) {
      throw Array.isArray(e10) ? e10[0] : e10;
    }
    var t2;
  }
  handleVideoInspectEvents(e9) {
    e9.on(mO.CONNECTION_STATE_CHANGE, (t2, i2) => {
      if (this.safeEmit(zy.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t2, i2), i2 === EO.CONNECTED) {
        if ("CONNECTED" !== this.connectionState) return void this.safeEmit(zy.CONTENT_INSPECT_ERROR, new yb(Ry.OPERATION_ABORTED, "Content inspect was cancelled because it left the channel"));
        e9.inspectImage();
      }
    }), e9.on(mO.INSPECT_RESULT, (e10, t2) => {
      var i2;
      if ((null == t2 ? void 0 : t2.code) === Ry.INVALID_OPERATION && "DISCONNECTED" === this.connectionState) return fb.debug("Stop inspect content because that has left channel"), null == this || null === (i2 = this._inspect) || void 0 === i2 || i2.close(), void (this._inspect = void 0);
      this.safeEmit(zy.CONTENT_INSPECT_RESULT, e10, t2);
    }), e9.on(mO.CLIENT_LOCAL_VIDEO_TRACK, (e10) => {
      e10(this.localTracks.filter((e11) => "video" === e11.trackMediaType)[0]);
    });
  }
  async disableContentInspect() {
    if (!this._inspect) throw new yb(Ry.INVALID_OPERATION, "[".concat(this._clientId, "] inspectVideoContent not started"));
    try {
      this._inspect.close(), this._inspect = void 0;
    } catch (e9) {
      throw Array.isArray(e9) ? e9[0] : e9;
    }
  }
  async setImageModeration(e9, t2) {
    if (Iy(e9, "enabled"), e9) {
      if (!t2) throw new yb(Ry.INVALID_PARAMS, "config is required");
      if (Lj(t2), !this._joinInfo) throw new yb(Ry.INVALID_OPERATION, "can not create image moderation, please join channel first");
      try {
        if (this._moderation) this._moderation.updateConfig(t2);
        else {
          const e10 = (i2 = { config: t2 }, gB("ImageModeration").create(i2));
          this._moderation = e10, this.handleImageModerationEvents(e10);
          const { appId: n2, cname: r2, sid: o2, token: s2, uid: a2, cid: c2, vid: d2 } = this._joinInfo;
          await e10.init({ appId: n2, areaCode: "", cname: r2, sid: o2, token: s2, uid: a2, cid: c2, vid: d2 ? Number(d2) : 0 }, PA);
        }
      } catch (e10) {
        throw Array.isArray(e10) ? e10[0] : e10;
      }
    } else {
      var i2;
      if (!this._moderation) throw new yb(Ry.INVALID_OPERATION, "[".concat(this._clientId, "] image moderation not started"));
      try {
        this._moderation.close(), this._moderation.removeAllListeners(), this._moderation = void 0;
      } catch (e10) {
        throw Array.isArray(e10) ? e10[0] : e10;
      }
    }
  }
  handleImageModerationEvents(e9) {
    e9.on(RO.CONNECTION_STATE_CHANGE, (t2, i2) => {
      if (this.safeEmit(zy.IMAGE_MODERATION_CONNECTION_STATE_CHANGE, t2, i2), t2 === gO.CONNECTED) {
        if ("CONNECTED" !== this.connectionState) throw this.setImageModeration(false), new yb(Ry.OPERATION_ABORTED, "Image moderation was cancelled because it left the channel");
        e9.inspectImage();
      }
    }), e9.on(RO.CLIENT_LOCAL_VIDEO_TRACK, (e10) => {
      e10(this.localTracks.filter((e11) => "video" === e11.trackMediaType)[0]);
    });
  }
  setP2PTransport(e9) {
    if (function(e10) {
      vy(e10, "transport", ["default", "auto", "relay", "sd-rtn"]);
    }(e9), "p2p" !== this.mode) throw new yb(Ry.INVALID_OPERATION, "only p2p mode can set p2pTransport");
    this.store.p2pTransport = e9, fb.info("[".concat(this._clientId, "] set client p2pTransport to ").concat(e9));
  }
  getJoinChannelServiceRecords() {
    return fb.debug("getJoinChannelServiceRecords"), this.store.joinChannelServiceRecords;
  }
  async setPublishAudioFilterEnabled(e9) {
    Iy(e9, "enabled"), JA("ENABLE_PUBLISH_AUDIO_FILTER", e9), this._joinInfo && await this._gateway.setPublishAudioFilterEnabled(e9);
  }
  _handleResetAddStream(e9, t2) {
    switch (t2) {
      case "audio":
        e9._audio_added_ = false, e9._trust_audio_stream_added_state_ = true;
        break;
      case "video":
        e9._video_added_ = false, e9._trust_video_stream_added_state_ = true;
    }
  }
}, Cw(RG.prototype, "leave", [Mj], Object.getOwnPropertyDescriptor(RG.prototype, "leave"), RG.prototype), Cw(RG.prototype, "publish", [Uj], Object.getOwnPropertyDescriptor(RG.prototype, "publish"), RG.prototype), Cw(RG.prototype, "unpublish", [xj], Object.getOwnPropertyDescriptor(RG.prototype, "unpublish"), RG.prototype), Cw(RG.prototype, "subscribe", [Vj], Object.getOwnPropertyDescriptor(RG.prototype, "subscribe"), RG.prototype), Cw(RG.prototype, "presubscribe", [Fj], Object.getOwnPropertyDescriptor(RG.prototype, "presubscribe"), RG.prototype), Cw(RG.prototype, "massSubscribe", [Bj], Object.getOwnPropertyDescriptor(RG.prototype, "massSubscribe"), RG.prototype), Cw(RG.prototype, "unsubscribe", [jj], Object.getOwnPropertyDescriptor(RG.prototype, "unsubscribe"), RG.prototype), Cw(RG.prototype, "massUnsubscribe", [Gj], Object.getOwnPropertyDescriptor(RG.prototype, "massUnsubscribe"), RG.prototype), Cw(RG.prototype, "setLowStreamParameter", [Wj], Object.getOwnPropertyDescriptor(RG.prototype, "setLowStreamParameter"), RG.prototype), Cw(RG.prototype, "enableDualStream", [Hj], Object.getOwnPropertyDescriptor(RG.prototype, "enableDualStream"), RG.prototype), Cw(RG.prototype, "disableDualStream", [Kj], Object.getOwnPropertyDescriptor(RG.prototype, "disableDualStream"), RG.prototype), Cw(RG.prototype, "setClientRole", [Yj], Object.getOwnPropertyDescriptor(RG.prototype, "setClientRole"), RG.prototype), Cw(RG.prototype, "setProxyServer", [qj], Object.getOwnPropertyDescriptor(RG.prototype, "setProxyServer"), RG.prototype), Cw(RG.prototype, "setTurnServer", [zj], Object.getOwnPropertyDescriptor(RG.prototype, "setTurnServer"), RG.prototype), Cw(RG.prototype, "setLicense", [Jj], Object.getOwnPropertyDescriptor(RG.prototype, "setLicense"), RG.prototype), Cw(RG.prototype, "startProxyServer", [Xj], Object.getOwnPropertyDescriptor(RG.prototype, "startProxyServer"), RG.prototype), Cw(RG.prototype, "stopProxyServer", [Qj], Object.getOwnPropertyDescriptor(RG.prototype, "stopProxyServer"), RG.prototype), Cw(RG.prototype, "setLocalAccessPointsV2", [Zj], Object.getOwnPropertyDescriptor(RG.prototype, "setLocalAccessPointsV2"), RG.prototype), Cw(RG.prototype, "setLocalAccessPoints", [$j], Object.getOwnPropertyDescriptor(RG.prototype, "setLocalAccessPoints"), RG.prototype), Cw(RG.prototype, "setRemoteDefaultVideoStreamType", [eG], Object.getOwnPropertyDescriptor(RG.prototype, "setRemoteDefaultVideoStreamType"), RG.prototype), Cw(RG.prototype, "setRemoteVideoStreamType", [tG], Object.getOwnPropertyDescriptor(RG.prototype, "setRemoteVideoStreamType"), RG.prototype), Cw(RG.prototype, "setStreamFallbackOption", [iG], Object.getOwnPropertyDescriptor(RG.prototype, "setStreamFallbackOption"), RG.prototype), Cw(RG.prototype, "setEncryptionConfig", [nG], Object.getOwnPropertyDescriptor(RG.prototype, "setEncryptionConfig"), RG.prototype), Cw(RG.prototype, "renewToken", [rG], Object.getOwnPropertyDescriptor(RG.prototype, "renewToken"), RG.prototype), Cw(RG.prototype, "enableAudioVolumeIndicator", [oG], Object.getOwnPropertyDescriptor(RG.prototype, "enableAudioVolumeIndicator"), RG.prototype), Cw(RG.prototype, "startLiveStreaming", [sG], Object.getOwnPropertyDescriptor(RG.prototype, "startLiveStreaming"), RG.prototype), Cw(RG.prototype, "setLiveTranscoding", [aG], Object.getOwnPropertyDescriptor(RG.prototype, "setLiveTranscoding"), RG.prototype), Cw(RG.prototype, "stopLiveStreaming", [cG], Object.getOwnPropertyDescriptor(RG.prototype, "stopLiveStreaming"), RG.prototype), Cw(RG.prototype, "startChannelMediaRelay", [dG], Object.getOwnPropertyDescriptor(RG.prototype, "startChannelMediaRelay"), RG.prototype), Cw(RG.prototype, "updateChannelMediaRelay", [lG], Object.getOwnPropertyDescriptor(RG.prototype, "updateChannelMediaRelay"), RG.prototype), Cw(RG.prototype, "stopChannelMediaRelay", [uG], Object.getOwnPropertyDescriptor(RG.prototype, "stopChannelMediaRelay"), RG.prototype), Cw(RG.prototype, "sendCustomReportMessage", [hG], Object.getOwnPropertyDescriptor(RG.prototype, "sendCustomReportMessage"), RG.prototype), Cw(RG.prototype, "pickSVCLayer", [pG], Object.getOwnPropertyDescriptor(RG.prototype, "pickSVCLayer"), RG.prototype), Cw(RG.prototype, "setRTMConfig", [_G], Object.getOwnPropertyDescriptor(RG.prototype, "setRTMConfig"), RG.prototype), Cw(RG.prototype, "enableContentInspect", [EG], Object.getOwnPropertyDescriptor(RG.prototype, "enableContentInspect"), RG.prototype), Cw(RG.prototype, "disableContentInspect", [fG], Object.getOwnPropertyDescriptor(RG.prototype, "disableContentInspect"), RG.prototype), Cw(RG.prototype, "setImageModeration", [mG], Object.getOwnPropertyDescriptor(RG.prototype, "setImageModeration"), RG.prototype), Cw(RG.prototype, "setP2PTransport", [TG], Object.getOwnPropertyDescriptor(RG.prototype, "setP2PTransport"), RG.prototype), Cw(RG.prototype, "getJoinChannelServiceRecords", [SG], Object.getOwnPropertyDescriptor(RG.prototype, "getJoinChannelServiceRecords"), RG.prototype), Cw(RG.prototype, "setPublishAudioFilterEnabled", [gG], Object.getOwnPropertyDescriptor(RG.prototype, "setPublishAudioFilterEnabled"), RG.prototype), RG);
var yG = class _yG {
  constructor(e9, t2) {
    Fg(this, "id", 0), Fg(this, "element", void 0), Fg(this, "peerPair", void 0), Fg(this, "context", void 0), Fg(this, "audioPlayerElement", void 0), Fg(this, "audioTrack", void 0), _yG.count += 1, this.id = _yG.count, this.element = e9, this.context = t2;
  }
  initPeers() {
    this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()], this.peerPair[1].ontrack = (e9) => {
      const t2 = document.createElement("audio");
      t2.srcObject = new MediaStream([e9.track]), t2.play(), this.audioPlayerElement = t2;
    };
  }
  async switchSdp() {
    if (!this.peerPair) return;
    const e9 = async (e10, t3) => {
      const i2 = "offer" === t3 ? await e10.createOffer() : await e10.createAnswer();
      return await e10.setLocalDescription(i2), "complete" === e10.iceGatheringState ? e10.localDescription : new Gh((t4) => {
        e10.onicegatheringstatechange = () => {
          "complete" === e10.iceGatheringState && t4(e10.localDescription);
        };
      });
    }, t2 = async (e10, t3) => await e10.setRemoteDescription(t3);
    try {
      const i2 = await e9(this.peerPair[0], "offer");
      await t2(this.peerPair[1], i2);
      const n2 = await e9(this.peerPair[1], "answer");
      await t2(this.peerPair[0], n2);
    } catch (e10) {
      throw new yb(Ry.LOCAL_AEC_ERROR, e10.toString()).print();
    }
  }
  async getTracksFromMediaElement(e9) {
    if (this.audioTrack) return this.audioTrack;
    let t2;
    try {
      e9 instanceof HTMLVideoElement && (e9.captureStream ? e9.captureStream() : e9.mozCaptureStream()), t2 = this.context.createMediaStreamDestination();
      this.context.createMediaElementSource(e9).connect(t2);
    } catch (e10) {
      throw new yb(Ry.LOCAL_AEC_ERROR, e10.toString()).print();
    }
    if (!t2) {
      throw new yb(Ry.LOCAL_AEC_ERROR, "no dest node when local aec").print();
    }
    const i2 = t2.stream.getAudioTracks()[0];
    return this.audioTrack = i2, i2;
  }
  getElement() {
    return this.element;
  }
  async startEchoCancellation() {
    this.context.resume(), this.peerPair && this.close(), this.initPeers();
    const e9 = this.element, t2 = await this.getTracksFromMediaElement(e9);
    this.peerPair && this.peerPair[0].addTrack(t2), await this.switchSdp();
  }
  close() {
    fb.debug("close echo cancellation unit, id is", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach((e9) => {
      e9.close();
    }), this.peerPair = void 0, this.audioPlayerElement = void 0;
  }
};
var AG;
var bG;
Fg(yG, "count", 0);
var wG = window.AudioContext || window.webkitAudioContext;
var OG = new (AG = Ib({ report: vb }), Cw((bG = class {
  constructor() {
    Fg(this, "units", []), Fg(this, "context", void 0);
  }
  processExternalMediaAEC(e9) {
    if (!this._doesEnvironmentNeedAEC()) return fb.debug("the system does not need to process local aec"), -1;
    this.context || (this.context = new wG());
    let t2 = this.units.find((t3) => t3 && t3.getElement() === e9);
    return t2 || (t2 = new yG(e9, this.context), this.units.push(t2)), t2.startEchoCancellation(), fb.debug("start processing local audio echo cancellation, id is", t2.id), t2.id;
  }
  _doesEnvironmentNeedAEC() {
    return Hv().name !== Bv.SAFARI;
  }
}).prototype, "processExternalMediaAEC", [AG], Object.getOwnPropertyDescriptor(bG.prototype, "processExternalMediaAEC"), bG.prototype), bG)();
function NG(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function DG(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? NG(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : NG(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var PG = window || document;
function LG(e9) {
  let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
  if (!PG) return;
  const i2 = nq._cspEventHandlerPointer;
  if (i2 && t2) return void console.error(i2, t2);
  const n2 = (e10) => {
    if (!(e10 && e10.blockedURI && (nq.onSecurityPolicyViolation || nq.getListeners(SO.SECURITY_POLICY_VIOLATION).length > 0))) return;
    const t3 = e10.blockedURI;
    XA("CSP_DETECTED_HOSTNAME_LIST").some((e11) => Dn(t3).call(t3, e11)) && (nq.onSecurityPolicyViolation && "function" == typeof nq.onSecurityPolicyViolation && nq.onSecurityPolicyViolation(e10), nq.getListeners(SO.SECURITY_POLICY_VIOLATION).length > 0 && nq.safeEmit(SO.SECURITY_POLICY_VIOLATION, e10));
  };
  i2 && PG.removeEventListener("securitypolicyviolation", i2), (t2 || e9 && "function" == typeof e9 || nq.getListeners(SO.SECURITY_POLICY_VIOLATION).length > 0) && PG.addEventListener("securitypolicyviolation", n2), nq._cspEventHandlerPointer = n2;
}
var kG = l;
var MG = RC;
var UG = RegExp.prototype;
var xG = function(e9) {
  return e9 === UG || kG(UG, e9) ? MG(e9) : e9.flags;
};
var VG = i(xG);
function FG(e9) {
  let t2 = e9.length;
  for (; --t2 >= 0; ) e9[t2] = 0;
}
var BG = 256;
var jG = 286;
var GG = 30;
var WG = 15;
var HG = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
var KG = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
var YG = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
var qG = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var zG = new Array(576);
FG(zG);
var JG = new Array(60);
FG(JG);
var XG = new Array(512);
FG(XG);
var QG = new Array(256);
FG(QG);
var ZG = new Array(29);
FG(ZG);
var $G = new Array(GG);
function eW(e9, t2, i2, n2, r2) {
  this.static_tree = e9, this.extra_bits = t2, this.extra_base = i2, this.elems = n2, this.max_length = r2, this.has_stree = e9 && e9.length;
}
var tW;
var iW;
var nW;
function rW(e9, t2) {
  this.dyn_tree = e9, this.max_code = 0, this.stat_desc = t2;
}
FG($G);
var oW = (e9) => e9 < 256 ? XG[e9] : XG[256 + (e9 >>> 7)];
var sW = (e9, t2) => {
  e9.pending_buf[e9.pending++] = 255 & t2, e9.pending_buf[e9.pending++] = t2 >>> 8 & 255;
};
var aW = (e9, t2, i2) => {
  e9.bi_valid > 16 - i2 ? (e9.bi_buf |= t2 << e9.bi_valid & 65535, sW(e9, e9.bi_buf), e9.bi_buf = t2 >> 16 - e9.bi_valid, e9.bi_valid += i2 - 16) : (e9.bi_buf |= t2 << e9.bi_valid & 65535, e9.bi_valid += i2);
};
var cW = (e9, t2, i2) => {
  aW(e9, i2[2 * t2], i2[2 * t2 + 1]);
};
var dW = (e9, t2) => {
  let i2 = 0;
  do {
    i2 |= 1 & e9, e9 >>>= 1, i2 <<= 1;
  } while (--t2 > 0);
  return i2 >>> 1;
};
var lW = (e9, t2, i2) => {
  const n2 = new Array(16);
  let r2, o2, s2 = 0;
  for (r2 = 1; r2 <= WG; r2++) s2 = s2 + i2[r2 - 1] << 1, n2[r2] = s2;
  for (o2 = 0; o2 <= t2; o2++) {
    let t3 = e9[2 * o2 + 1];
    0 !== t3 && (e9[2 * o2] = dW(n2[t3]++, t3));
  }
};
var uW = (e9) => {
  let t2;
  for (t2 = 0; t2 < jG; t2++) e9.dyn_ltree[2 * t2] = 0;
  for (t2 = 0; t2 < GG; t2++) e9.dyn_dtree[2 * t2] = 0;
  for (t2 = 0; t2 < 19; t2++) e9.bl_tree[2 * t2] = 0;
  e9.dyn_ltree[512] = 1, e9.opt_len = e9.static_len = 0, e9.sym_next = e9.matches = 0;
};
var hW = (e9) => {
  e9.bi_valid > 8 ? sW(e9, e9.bi_buf) : e9.bi_valid > 0 && (e9.pending_buf[e9.pending++] = e9.bi_buf), e9.bi_buf = 0, e9.bi_valid = 0;
};
var pW = (e9, t2, i2, n2) => {
  const r2 = 2 * t2, o2 = 2 * i2;
  return e9[r2] < e9[o2] || e9[r2] === e9[o2] && n2[t2] <= n2[i2];
};
var _W = (e9, t2, i2) => {
  const n2 = e9.heap[i2];
  let r2 = i2 << 1;
  for (; r2 <= e9.heap_len && (r2 < e9.heap_len && pW(t2, e9.heap[r2 + 1], e9.heap[r2], e9.depth) && r2++, !pW(t2, n2, e9.heap[r2], e9.depth)); ) e9.heap[i2] = e9.heap[r2], i2 = r2, r2 <<= 1;
  e9.heap[i2] = n2;
};
var EW = (e9, t2, i2) => {
  let n2, r2, o2, s2, a2 = 0;
  if (0 !== e9.sym_next) do {
    n2 = 255 & e9.pending_buf[e9.sym_buf + a2++], n2 += (255 & e9.pending_buf[e9.sym_buf + a2++]) << 8, r2 = e9.pending_buf[e9.sym_buf + a2++], 0 === n2 ? cW(e9, r2, t2) : (o2 = QG[r2], cW(e9, o2 + BG + 1, t2), s2 = HG[o2], 0 !== s2 && (r2 -= ZG[o2], aW(e9, r2, s2)), n2--, o2 = oW(n2), cW(e9, o2, i2), s2 = KG[o2], 0 !== s2 && (n2 -= $G[o2], aW(e9, n2, s2)));
  } while (a2 < e9.sym_next);
  cW(e9, 256, t2);
};
var fW = (e9, t2) => {
  const i2 = t2.dyn_tree, n2 = t2.stat_desc.static_tree, r2 = t2.stat_desc.has_stree, o2 = t2.stat_desc.elems;
  let s2, a2, c2, d2 = -1;
  for (e9.heap_len = 0, e9.heap_max = 573, s2 = 0; s2 < o2; s2++) 0 !== i2[2 * s2] ? (e9.heap[++e9.heap_len] = d2 = s2, e9.depth[s2] = 0) : i2[2 * s2 + 1] = 0;
  for (; e9.heap_len < 2; ) c2 = e9.heap[++e9.heap_len] = d2 < 2 ? ++d2 : 0, i2[2 * c2] = 1, e9.depth[c2] = 0, e9.opt_len--, r2 && (e9.static_len -= n2[2 * c2 + 1]);
  for (t2.max_code = d2, s2 = e9.heap_len >> 1; s2 >= 1; s2--) _W(e9, i2, s2);
  c2 = o2;
  do {
    s2 = e9.heap[1], e9.heap[1] = e9.heap[e9.heap_len--], _W(e9, i2, 1), a2 = e9.heap[1], e9.heap[--e9.heap_max] = s2, e9.heap[--e9.heap_max] = a2, i2[2 * c2] = i2[2 * s2] + i2[2 * a2], e9.depth[c2] = (e9.depth[s2] >= e9.depth[a2] ? e9.depth[s2] : e9.depth[a2]) + 1, i2[2 * s2 + 1] = i2[2 * a2 + 1] = c2, e9.heap[1] = c2++, _W(e9, i2, 1);
  } while (e9.heap_len >= 2);
  e9.heap[--e9.heap_max] = e9.heap[1], ((e10, t3) => {
    const i3 = t3.dyn_tree, n3 = t3.max_code, r3 = t3.stat_desc.static_tree, o3 = t3.stat_desc.has_stree, s3 = t3.stat_desc.extra_bits, a3 = t3.stat_desc.extra_base, c3 = t3.stat_desc.max_length;
    let d3, l2, u2, h2, p2, _2, E2 = 0;
    for (h2 = 0; h2 <= WG; h2++) e10.bl_count[h2] = 0;
    for (i3[2 * e10.heap[e10.heap_max] + 1] = 0, d3 = e10.heap_max + 1; d3 < 573; d3++) l2 = e10.heap[d3], h2 = i3[2 * i3[2 * l2 + 1] + 1] + 1, h2 > c3 && (h2 = c3, E2++), i3[2 * l2 + 1] = h2, l2 > n3 || (e10.bl_count[h2]++, p2 = 0, l2 >= a3 && (p2 = s3[l2 - a3]), _2 = i3[2 * l2], e10.opt_len += _2 * (h2 + p2), o3 && (e10.static_len += _2 * (r3[2 * l2 + 1] + p2)));
    if (0 !== E2) {
      do {
        for (h2 = c3 - 1; 0 === e10.bl_count[h2]; ) h2--;
        e10.bl_count[h2]--, e10.bl_count[h2 + 1] += 2, e10.bl_count[c3]--, E2 -= 2;
      } while (E2 > 0);
      for (h2 = c3; 0 !== h2; h2--) for (l2 = e10.bl_count[h2]; 0 !== l2; ) u2 = e10.heap[--d3], u2 > n3 || (i3[2 * u2 + 1] !== h2 && (e10.opt_len += (h2 - i3[2 * u2 + 1]) * i3[2 * u2], i3[2 * u2 + 1] = h2), l2--);
    }
  })(e9, t2), lW(i2, d2, e9.bl_count);
};
var mW = (e9, t2, i2) => {
  let n2, r2, o2 = -1, s2 = t2[1], a2 = 0, c2 = 7, d2 = 4;
  for (0 === s2 && (c2 = 138, d2 = 3), t2[2 * (i2 + 1) + 1] = 65535, n2 = 0; n2 <= i2; n2++) r2 = s2, s2 = t2[2 * (n2 + 1) + 1], ++a2 < c2 && r2 === s2 || (a2 < d2 ? e9.bl_tree[2 * r2] += a2 : 0 !== r2 ? (r2 !== o2 && e9.bl_tree[2 * r2]++, e9.bl_tree[32]++) : a2 <= 10 ? e9.bl_tree[34]++ : e9.bl_tree[36]++, a2 = 0, o2 = r2, 0 === s2 ? (c2 = 138, d2 = 3) : r2 === s2 ? (c2 = 6, d2 = 3) : (c2 = 7, d2 = 4));
};
var TW = (e9, t2, i2) => {
  let n2, r2, o2 = -1, s2 = t2[1], a2 = 0, c2 = 7, d2 = 4;
  for (0 === s2 && (c2 = 138, d2 = 3), n2 = 0; n2 <= i2; n2++) if (r2 = s2, s2 = t2[2 * (n2 + 1) + 1], !(++a2 < c2 && r2 === s2)) {
    if (a2 < d2) do {
      cW(e9, r2, e9.bl_tree);
    } while (0 != --a2);
    else 0 !== r2 ? (r2 !== o2 && (cW(e9, r2, e9.bl_tree), a2--), cW(e9, 16, e9.bl_tree), aW(e9, a2 - 3, 2)) : a2 <= 10 ? (cW(e9, 17, e9.bl_tree), aW(e9, a2 - 3, 3)) : (cW(e9, 18, e9.bl_tree), aW(e9, a2 - 11, 7));
    a2 = 0, o2 = r2, 0 === s2 ? (c2 = 138, d2 = 3) : r2 === s2 ? (c2 = 6, d2 = 3) : (c2 = 7, d2 = 4);
  }
};
var SW = false;
var gW = (e9, t2, i2, n2) => {
  aW(e9, 0 + (n2 ? 1 : 0), 3), hW(e9), sW(e9, i2), sW(e9, ~i2), i2 && e9.pending_buf.set(e9.window.subarray(t2, t2 + i2), e9.pending), e9.pending += i2;
};
var RW = (e9) => {
  SW || ((() => {
    let e10, t2, i2, n2, r2;
    const o2 = new Array(16);
    for (i2 = 0, n2 = 0; n2 < 28; n2++) for (ZG[n2] = i2, e10 = 0; e10 < 1 << HG[n2]; e10++) QG[i2++] = n2;
    for (QG[i2 - 1] = n2, r2 = 0, n2 = 0; n2 < 16; n2++) for ($G[n2] = r2, e10 = 0; e10 < 1 << KG[n2]; e10++) XG[r2++] = n2;
    for (r2 >>= 7; n2 < GG; n2++) for ($G[n2] = r2 << 7, e10 = 0; e10 < 1 << KG[n2] - 7; e10++) XG[256 + r2++] = n2;
    for (t2 = 0; t2 <= WG; t2++) o2[t2] = 0;
    for (e10 = 0; e10 <= 143; ) zG[2 * e10 + 1] = 8, e10++, o2[8]++;
    for (; e10 <= 255; ) zG[2 * e10 + 1] = 9, e10++, o2[9]++;
    for (; e10 <= 279; ) zG[2 * e10 + 1] = 7, e10++, o2[7]++;
    for (; e10 <= 287; ) zG[2 * e10 + 1] = 8, e10++, o2[8]++;
    for (lW(zG, 287, o2), e10 = 0; e10 < GG; e10++) JG[2 * e10 + 1] = 5, JG[2 * e10] = dW(e10, 5);
    tW = new eW(zG, HG, 257, jG, WG), iW = new eW(JG, KG, 0, GG, WG), nW = new eW(new Array(0), YG, 0, 19, 7);
  })(), SW = true), e9.l_desc = new rW(e9.dyn_ltree, tW), e9.d_desc = new rW(e9.dyn_dtree, iW), e9.bl_desc = new rW(e9.bl_tree, nW), e9.bi_buf = 0, e9.bi_valid = 0, uW(e9);
};
var CW = (e9, t2, i2, n2) => {
  let r2, o2, s2 = 0;
  e9.level > 0 ? (2 === e9.strm.data_type && (e9.strm.data_type = ((e10) => {
    let t3, i3 = 4093624447;
    for (t3 = 0; t3 <= 31; t3++, i3 >>>= 1) if (1 & i3 && 0 !== e10.dyn_ltree[2 * t3]) return 0;
    if (0 !== e10.dyn_ltree[18] || 0 !== e10.dyn_ltree[20] || 0 !== e10.dyn_ltree[26]) return 1;
    for (t3 = 32; t3 < BG; t3++) if (0 !== e10.dyn_ltree[2 * t3]) return 1;
    return 0;
  })(e9)), fW(e9, e9.l_desc), fW(e9, e9.d_desc), s2 = ((e10) => {
    let t3;
    for (mW(e10, e10.dyn_ltree, e10.l_desc.max_code), mW(e10, e10.dyn_dtree, e10.d_desc.max_code), fW(e10, e10.bl_desc), t3 = 18; t3 >= 3 && 0 === e10.bl_tree[2 * qG[t3] + 1]; t3--) ;
    return e10.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
  })(e9), r2 = e9.opt_len + 3 + 7 >>> 3, o2 = e9.static_len + 3 + 7 >>> 3, o2 <= r2 && (r2 = o2)) : r2 = o2 = i2 + 5, i2 + 4 <= r2 && -1 !== t2 ? gW(e9, t2, i2, n2) : 4 === e9.strategy || o2 === r2 ? (aW(e9, 2 + (n2 ? 1 : 0), 3), EW(e9, zG, JG)) : (aW(e9, 4 + (n2 ? 1 : 0), 3), ((e10, t3, i3, n3) => {
    let r3;
    for (aW(e10, t3 - 257, 5), aW(e10, i3 - 1, 5), aW(e10, n3 - 4, 4), r3 = 0; r3 < n3; r3++) aW(e10, e10.bl_tree[2 * qG[r3] + 1], 3);
    TW(e10, e10.dyn_ltree, t3 - 1), TW(e10, e10.dyn_dtree, i3 - 1);
  })(e9, e9.l_desc.max_code + 1, e9.d_desc.max_code + 1, s2 + 1), EW(e9, e9.dyn_ltree, e9.dyn_dtree)), uW(e9), n2 && hW(e9);
};
var IW = (e9, t2, i2) => (e9.pending_buf[e9.sym_buf + e9.sym_next++] = t2, e9.pending_buf[e9.sym_buf + e9.sym_next++] = t2 >> 8, e9.pending_buf[e9.sym_buf + e9.sym_next++] = i2, 0 === t2 ? e9.dyn_ltree[2 * i2]++ : (e9.matches++, t2--, e9.dyn_ltree[2 * (QG[i2] + BG + 1)]++, e9.dyn_dtree[2 * oW(t2)]++), e9.sym_next === e9.sym_end);
var vW = (e9) => {
  aW(e9, 2, 3), cW(e9, 256, zG), ((e10) => {
    16 === e10.bi_valid ? (sW(e10, e10.bi_buf), e10.bi_buf = 0, e10.bi_valid = 0) : e10.bi_valid >= 8 && (e10.pending_buf[e10.pending++] = 255 & e10.bi_buf, e10.bi_buf >>= 8, e10.bi_valid -= 8);
  })(e9);
};
var yW = { _tr_init: RW, _tr_stored_block: gW, _tr_flush_block: CW, _tr_tally: IW, _tr_align: vW };
var AW = (e9, t2, i2, n2) => {
  let r2 = 65535 & e9 | 0, o2 = e9 >>> 16 & 65535 | 0, s2 = 0;
  for (; 0 !== i2; ) {
    s2 = i2 > 2e3 ? 2e3 : i2, i2 -= s2;
    do {
      r2 = r2 + t2[n2++] | 0, o2 = o2 + r2 | 0;
    } while (--s2);
    r2 %= 65521, o2 %= 65521;
  }
  return r2 | o2 << 16 | 0;
};
var bW = new Uint32Array((() => {
  let e9, t2 = [];
  for (var i2 = 0; i2 < 256; i2++) {
    e9 = i2;
    for (var n2 = 0; n2 < 8; n2++) e9 = 1 & e9 ? 3988292384 ^ e9 >>> 1 : e9 >>> 1;
    t2[i2] = e9;
  }
  return t2;
})());
var wW = (e9, t2, i2, n2) => {
  const r2 = bW, o2 = n2 + i2;
  e9 ^= -1;
  for (let i3 = n2; i3 < o2; i3++) e9 = e9 >>> 8 ^ r2[255 & (e9 ^ t2[i3])];
  return -1 ^ e9;
};
var OW = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
var NW = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
var { _tr_init: DW, _tr_stored_block: PW, _tr_flush_block: LW, _tr_tally: kW, _tr_align: MW } = yW;
var { Z_NO_FLUSH: UW, Z_PARTIAL_FLUSH: xW, Z_FULL_FLUSH: VW, Z_FINISH: FW, Z_BLOCK: BW, Z_OK: jW, Z_STREAM_END: GW, Z_STREAM_ERROR: WW, Z_DATA_ERROR: HW, Z_BUF_ERROR: KW, Z_DEFAULT_COMPRESSION: YW, Z_FILTERED: qW, Z_HUFFMAN_ONLY: zW, Z_RLE: JW, Z_FIXED: XW, Z_DEFAULT_STRATEGY: QW, Z_UNKNOWN: ZW, Z_DEFLATED: $W } = NW;
var eH = 286;
var tH = 30;
var iH = 19;
var nH = 2 * eH + 1;
var rH = 15;
var oH = 258;
var sH = 262;
var aH = 42;
var cH = 113;
var dH = 666;
var lH = (e9, t2) => (e9.msg = OW[t2], t2);
var uH = (e9) => 2 * e9 - (e9 > 4 ? 9 : 0);
var hH = (e9) => {
  let t2 = e9.length;
  for (; --t2 >= 0; ) e9[t2] = 0;
};
var pH = (e9) => {
  let t2, i2, n2, r2 = e9.w_size;
  t2 = e9.hash_size, n2 = t2;
  do {
    i2 = e9.head[--n2], e9.head[n2] = i2 >= r2 ? i2 - r2 : 0;
  } while (--t2);
  t2 = r2, n2 = t2;
  do {
    i2 = e9.prev[--n2], e9.prev[n2] = i2 >= r2 ? i2 - r2 : 0;
  } while (--t2);
};
var _H = (e9, t2, i2) => (t2 << e9.hash_shift ^ i2) & e9.hash_mask;
var EH = (e9) => {
  const t2 = e9.state;
  let i2 = t2.pending;
  i2 > e9.avail_out && (i2 = e9.avail_out), 0 !== i2 && (e9.output.set(t2.pending_buf.subarray(t2.pending_out, t2.pending_out + i2), e9.next_out), e9.next_out += i2, t2.pending_out += i2, e9.total_out += i2, e9.avail_out -= i2, t2.pending -= i2, 0 === t2.pending && (t2.pending_out = 0));
};
var fH = (e9, t2) => {
  LW(e9, e9.block_start >= 0 ? e9.block_start : -1, e9.strstart - e9.block_start, t2), e9.block_start = e9.strstart, EH(e9.strm);
};
var mH = (e9, t2) => {
  e9.pending_buf[e9.pending++] = t2;
};
var TH = (e9, t2) => {
  e9.pending_buf[e9.pending++] = t2 >>> 8 & 255, e9.pending_buf[e9.pending++] = 255 & t2;
};
var SH = (e9, t2, i2, n2) => {
  let r2 = e9.avail_in;
  return r2 > n2 && (r2 = n2), 0 === r2 ? 0 : (e9.avail_in -= r2, t2.set(e9.input.subarray(e9.next_in, e9.next_in + r2), i2), 1 === e9.state.wrap ? e9.adler = AW(e9.adler, t2, r2, i2) : 2 === e9.state.wrap && (e9.adler = wW(e9.adler, t2, r2, i2)), e9.next_in += r2, e9.total_in += r2, r2);
};
var gH = (e9, t2) => {
  let i2, n2, r2 = e9.max_chain_length, o2 = e9.strstart, s2 = e9.prev_length, a2 = e9.nice_match;
  const c2 = e9.strstart > e9.w_size - sH ? e9.strstart - (e9.w_size - sH) : 0, d2 = e9.window, l2 = e9.w_mask, u2 = e9.prev, h2 = e9.strstart + oH;
  let p2 = d2[o2 + s2 - 1], _2 = d2[o2 + s2];
  e9.prev_length >= e9.good_match && (r2 >>= 2), a2 > e9.lookahead && (a2 = e9.lookahead);
  do {
    if (i2 = t2, d2[i2 + s2] === _2 && d2[i2 + s2 - 1] === p2 && d2[i2] === d2[o2] && d2[++i2] === d2[o2 + 1]) {
      o2 += 2, i2++;
      do {
      } while (d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && o2 < h2);
      if (n2 = oH - (h2 - o2), o2 = h2 - oH, n2 > s2) {
        if (e9.match_start = t2, s2 = n2, n2 >= a2) break;
        p2 = d2[o2 + s2 - 1], _2 = d2[o2 + s2];
      }
    }
  } while ((t2 = u2[t2 & l2]) > c2 && 0 != --r2);
  return s2 <= e9.lookahead ? s2 : e9.lookahead;
};
var RH = (e9) => {
  const t2 = e9.w_size;
  let i2, n2, r2;
  do {
    if (n2 = e9.window_size - e9.lookahead - e9.strstart, e9.strstart >= t2 + (t2 - sH) && (e9.window.set(e9.window.subarray(t2, t2 + t2 - n2), 0), e9.match_start -= t2, e9.strstart -= t2, e9.block_start -= t2, e9.insert > e9.strstart && (e9.insert = e9.strstart), pH(e9), n2 += t2), 0 === e9.strm.avail_in) break;
    if (i2 = SH(e9.strm, e9.window, e9.strstart + e9.lookahead, n2), e9.lookahead += i2, e9.lookahead + e9.insert >= 3) for (r2 = e9.strstart - e9.insert, e9.ins_h = e9.window[r2], e9.ins_h = _H(e9, e9.ins_h, e9.window[r2 + 1]); e9.insert && (e9.ins_h = _H(e9, e9.ins_h, e9.window[r2 + 3 - 1]), e9.prev[r2 & e9.w_mask] = e9.head[e9.ins_h], e9.head[e9.ins_h] = r2, r2++, e9.insert--, !(e9.lookahead + e9.insert < 3)); ) ;
  } while (e9.lookahead < sH && 0 !== e9.strm.avail_in);
};
var CH = (e9, t2) => {
  let i2, n2, r2, o2 = e9.pending_buf_size - 5 > e9.w_size ? e9.w_size : e9.pending_buf_size - 5, s2 = 0, a2 = e9.strm.avail_in;
  do {
    if (i2 = 65535, r2 = e9.bi_valid + 42 >> 3, e9.strm.avail_out < r2) break;
    if (r2 = e9.strm.avail_out - r2, n2 = e9.strstart - e9.block_start, i2 > n2 + e9.strm.avail_in && (i2 = n2 + e9.strm.avail_in), i2 > r2 && (i2 = r2), i2 < o2 && (0 === i2 && t2 !== FW || t2 === UW || i2 !== n2 + e9.strm.avail_in)) break;
    s2 = t2 === FW && i2 === n2 + e9.strm.avail_in ? 1 : 0, PW(e9, 0, 0, s2), e9.pending_buf[e9.pending - 4] = i2, e9.pending_buf[e9.pending - 3] = i2 >> 8, e9.pending_buf[e9.pending - 2] = ~i2, e9.pending_buf[e9.pending - 1] = ~i2 >> 8, EH(e9.strm), n2 && (n2 > i2 && (n2 = i2), e9.strm.output.set(e9.window.subarray(e9.block_start, e9.block_start + n2), e9.strm.next_out), e9.strm.next_out += n2, e9.strm.avail_out -= n2, e9.strm.total_out += n2, e9.block_start += n2, i2 -= n2), i2 && (SH(e9.strm, e9.strm.output, e9.strm.next_out, i2), e9.strm.next_out += i2, e9.strm.avail_out -= i2, e9.strm.total_out += i2);
  } while (0 === s2);
  return a2 -= e9.strm.avail_in, a2 && (a2 >= e9.w_size ? (e9.matches = 2, e9.window.set(e9.strm.input.subarray(e9.strm.next_in - e9.w_size, e9.strm.next_in), 0), e9.strstart = e9.w_size, e9.insert = e9.strstart) : (e9.window_size - e9.strstart <= a2 && (e9.strstart -= e9.w_size, e9.window.set(e9.window.subarray(e9.w_size, e9.w_size + e9.strstart), 0), e9.matches < 2 && e9.matches++, e9.insert > e9.strstart && (e9.insert = e9.strstart)), e9.window.set(e9.strm.input.subarray(e9.strm.next_in - a2, e9.strm.next_in), e9.strstart), e9.strstart += a2, e9.insert += a2 > e9.w_size - e9.insert ? e9.w_size - e9.insert : a2), e9.block_start = e9.strstart), e9.high_water < e9.strstart && (e9.high_water = e9.strstart), s2 ? 4 : t2 !== UW && t2 !== FW && 0 === e9.strm.avail_in && e9.strstart === e9.block_start ? 2 : (r2 = e9.window_size - e9.strstart, e9.strm.avail_in > r2 && e9.block_start >= e9.w_size && (e9.block_start -= e9.w_size, e9.strstart -= e9.w_size, e9.window.set(e9.window.subarray(e9.w_size, e9.w_size + e9.strstart), 0), e9.matches < 2 && e9.matches++, r2 += e9.w_size, e9.insert > e9.strstart && (e9.insert = e9.strstart)), r2 > e9.strm.avail_in && (r2 = e9.strm.avail_in), r2 && (SH(e9.strm, e9.window, e9.strstart, r2), e9.strstart += r2, e9.insert += r2 > e9.w_size - e9.insert ? e9.w_size - e9.insert : r2), e9.high_water < e9.strstart && (e9.high_water = e9.strstart), r2 = e9.bi_valid + 42 >> 3, r2 = e9.pending_buf_size - r2 > 65535 ? 65535 : e9.pending_buf_size - r2, o2 = r2 > e9.w_size ? e9.w_size : r2, n2 = e9.strstart - e9.block_start, (n2 >= o2 || (n2 || t2 === FW) && t2 !== UW && 0 === e9.strm.avail_in && n2 <= r2) && (i2 = n2 > r2 ? r2 : n2, s2 = t2 === FW && 0 === e9.strm.avail_in && i2 === n2 ? 1 : 0, PW(e9, e9.block_start, i2, s2), e9.block_start += i2, EH(e9.strm)), s2 ? 3 : 1);
};
var IH = (e9, t2) => {
  let i2, n2;
  for (; ; ) {
    if (e9.lookahead < sH) {
      if (RH(e9), e9.lookahead < sH && t2 === UW) return 1;
      if (0 === e9.lookahead) break;
    }
    if (i2 = 0, e9.lookahead >= 3 && (e9.ins_h = _H(e9, e9.ins_h, e9.window[e9.strstart + 3 - 1]), i2 = e9.prev[e9.strstart & e9.w_mask] = e9.head[e9.ins_h], e9.head[e9.ins_h] = e9.strstart), 0 !== i2 && e9.strstart - i2 <= e9.w_size - sH && (e9.match_length = gH(e9, i2)), e9.match_length >= 3) if (n2 = kW(e9, e9.strstart - e9.match_start, e9.match_length - 3), e9.lookahead -= e9.match_length, e9.match_length <= e9.max_lazy_match && e9.lookahead >= 3) {
      e9.match_length--;
      do {
        e9.strstart++, e9.ins_h = _H(e9, e9.ins_h, e9.window[e9.strstart + 3 - 1]), i2 = e9.prev[e9.strstart & e9.w_mask] = e9.head[e9.ins_h], e9.head[e9.ins_h] = e9.strstart;
      } while (0 != --e9.match_length);
      e9.strstart++;
    } else e9.strstart += e9.match_length, e9.match_length = 0, e9.ins_h = e9.window[e9.strstart], e9.ins_h = _H(e9, e9.ins_h, e9.window[e9.strstart + 1]);
    else n2 = kW(e9, 0, e9.window[e9.strstart]), e9.lookahead--, e9.strstart++;
    if (n2 && (fH(e9, false), 0 === e9.strm.avail_out)) return 1;
  }
  return e9.insert = e9.strstart < 2 ? e9.strstart : 2, t2 === FW ? (fH(e9, true), 0 === e9.strm.avail_out ? 3 : 4) : e9.sym_next && (fH(e9, false), 0 === e9.strm.avail_out) ? 1 : 2;
};
var vH = (e9, t2) => {
  let i2, n2, r2;
  for (; ; ) {
    if (e9.lookahead < sH) {
      if (RH(e9), e9.lookahead < sH && t2 === UW) return 1;
      if (0 === e9.lookahead) break;
    }
    if (i2 = 0, e9.lookahead >= 3 && (e9.ins_h = _H(e9, e9.ins_h, e9.window[e9.strstart + 3 - 1]), i2 = e9.prev[e9.strstart & e9.w_mask] = e9.head[e9.ins_h], e9.head[e9.ins_h] = e9.strstart), e9.prev_length = e9.match_length, e9.prev_match = e9.match_start, e9.match_length = 2, 0 !== i2 && e9.prev_length < e9.max_lazy_match && e9.strstart - i2 <= e9.w_size - sH && (e9.match_length = gH(e9, i2), e9.match_length <= 5 && (e9.strategy === qW || 3 === e9.match_length && e9.strstart - e9.match_start > 4096) && (e9.match_length = 2)), e9.prev_length >= 3 && e9.match_length <= e9.prev_length) {
      r2 = e9.strstart + e9.lookahead - 3, n2 = kW(e9, e9.strstart - 1 - e9.prev_match, e9.prev_length - 3), e9.lookahead -= e9.prev_length - 1, e9.prev_length -= 2;
      do {
        ++e9.strstart <= r2 && (e9.ins_h = _H(e9, e9.ins_h, e9.window[e9.strstart + 3 - 1]), i2 = e9.prev[e9.strstart & e9.w_mask] = e9.head[e9.ins_h], e9.head[e9.ins_h] = e9.strstart);
      } while (0 != --e9.prev_length);
      if (e9.match_available = 0, e9.match_length = 2, e9.strstart++, n2 && (fH(e9, false), 0 === e9.strm.avail_out)) return 1;
    } else if (e9.match_available) {
      if (n2 = kW(e9, 0, e9.window[e9.strstart - 1]), n2 && fH(e9, false), e9.strstart++, e9.lookahead--, 0 === e9.strm.avail_out) return 1;
    } else e9.match_available = 1, e9.strstart++, e9.lookahead--;
  }
  return e9.match_available && (n2 = kW(e9, 0, e9.window[e9.strstart - 1]), e9.match_available = 0), e9.insert = e9.strstart < 2 ? e9.strstart : 2, t2 === FW ? (fH(e9, true), 0 === e9.strm.avail_out ? 3 : 4) : e9.sym_next && (fH(e9, false), 0 === e9.strm.avail_out) ? 1 : 2;
};
function yH(e9, t2, i2, n2, r2) {
  this.good_length = e9, this.max_lazy = t2, this.nice_length = i2, this.max_chain = n2, this.func = r2;
}
var AH = [new yH(0, 0, 0, 0, CH), new yH(4, 4, 8, 4, IH), new yH(4, 5, 16, 8, IH), new yH(4, 6, 32, 32, IH), new yH(4, 4, 16, 16, vH), new yH(8, 16, 32, 32, vH), new yH(8, 16, 128, 128, vH), new yH(8, 32, 128, 256, vH), new yH(32, 128, 258, 1024, vH), new yH(32, 258, 258, 4096, vH)];
function bH() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = $W, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(2 * nH), this.dyn_dtree = new Uint16Array(2 * (2 * tH + 1)), this.bl_tree = new Uint16Array(2 * (2 * iH + 1)), hH(this.dyn_ltree), hH(this.dyn_dtree), hH(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(rH + 1), this.heap = new Uint16Array(2 * eH + 1), hH(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * eH + 1), hH(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
var wH = (e9) => {
  if (!e9) return 1;
  const t2 = e9.state;
  return !t2 || t2.strm !== e9 || t2.status !== aH && 57 !== t2.status && 69 !== t2.status && 73 !== t2.status && 91 !== t2.status && 103 !== t2.status && t2.status !== cH && t2.status !== dH ? 1 : 0;
};
var OH = (e9) => {
  if (wH(e9)) return lH(e9, WW);
  e9.total_in = e9.total_out = 0, e9.data_type = ZW;
  const t2 = e9.state;
  return t2.pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = 2 === t2.wrap ? 57 : t2.wrap ? aH : cH, e9.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = -2, DW(t2), jW;
};
var NH = (e9) => {
  const t2 = OH(e9);
  return t2 === jW && ((e10) => {
    e10.window_size = 2 * e10.w_size, hH(e10.head), e10.max_lazy_match = AH[e10.level].max_lazy, e10.good_match = AH[e10.level].good_length, e10.nice_match = AH[e10.level].nice_length, e10.max_chain_length = AH[e10.level].max_chain, e10.strstart = 0, e10.block_start = 0, e10.lookahead = 0, e10.insert = 0, e10.match_length = e10.prev_length = 2, e10.match_available = 0, e10.ins_h = 0;
  })(e9.state), t2;
};
var DH = (e9, t2, i2, n2, r2, o2) => {
  if (!e9) return WW;
  let s2 = 1;
  if (t2 === YW && (t2 = 6), n2 < 0 ? (s2 = 0, n2 = -n2) : n2 > 15 && (s2 = 2, n2 -= 16), r2 < 1 || r2 > 9 || i2 !== $W || n2 < 8 || n2 > 15 || t2 < 0 || t2 > 9 || o2 < 0 || o2 > XW || 8 === n2 && 1 !== s2) return lH(e9, WW);
  8 === n2 && (n2 = 9);
  const a2 = new bH();
  return e9.state = a2, a2.strm = e9, a2.status = aH, a2.wrap = s2, a2.gzhead = null, a2.w_bits = n2, a2.w_size = 1 << a2.w_bits, a2.w_mask = a2.w_size - 1, a2.hash_bits = r2 + 7, a2.hash_size = 1 << a2.hash_bits, a2.hash_mask = a2.hash_size - 1, a2.hash_shift = ~~((a2.hash_bits + 3 - 1) / 3), a2.window = new Uint8Array(2 * a2.w_size), a2.head = new Uint16Array(a2.hash_size), a2.prev = new Uint16Array(a2.w_size), a2.lit_bufsize = 1 << r2 + 6, a2.pending_buf_size = 4 * a2.lit_bufsize, a2.pending_buf = new Uint8Array(a2.pending_buf_size), a2.sym_buf = a2.lit_bufsize, a2.sym_end = 3 * (a2.lit_bufsize - 1), a2.level = t2, a2.strategy = o2, a2.method = i2, NH(e9);
};
var PH = (e9, t2) => {
  if (wH(e9) || t2 > BW || t2 < 0) return e9 ? lH(e9, WW) : WW;
  const i2 = e9.state;
  if (!e9.output || 0 !== e9.avail_in && !e9.input || i2.status === dH && t2 !== FW) return lH(e9, 0 === e9.avail_out ? KW : WW);
  const n2 = i2.last_flush;
  if (i2.last_flush = t2, 0 !== i2.pending) {
    if (EH(e9), 0 === e9.avail_out) return i2.last_flush = -1, jW;
  } else if (0 === e9.avail_in && uH(t2) <= uH(n2) && t2 !== FW) return lH(e9, KW);
  if (i2.status === dH && 0 !== e9.avail_in) return lH(e9, KW);
  if (i2.status === aH && 0 === i2.wrap && (i2.status = cH), i2.status === aH) {
    let t3 = $W + (i2.w_bits - 8 << 4) << 8, n3 = -1;
    if (n3 = i2.strategy >= zW || i2.level < 2 ? 0 : i2.level < 6 ? 1 : 6 === i2.level ? 2 : 3, t3 |= n3 << 6, 0 !== i2.strstart && (t3 |= 32), t3 += 31 - t3 % 31, TH(i2, t3), 0 !== i2.strstart && (TH(i2, e9.adler >>> 16), TH(i2, 65535 & e9.adler)), e9.adler = 1, i2.status = cH, EH(e9), 0 !== i2.pending) return i2.last_flush = -1, jW;
  }
  if (57 === i2.status) {
    if (e9.adler = 0, mH(i2, 31), mH(i2, 139), mH(i2, 8), i2.gzhead) mH(i2, (i2.gzhead.text ? 1 : 0) + (i2.gzhead.hcrc ? 2 : 0) + (i2.gzhead.extra ? 4 : 0) + (i2.gzhead.name ? 8 : 0) + (i2.gzhead.comment ? 16 : 0)), mH(i2, 255 & i2.gzhead.time), mH(i2, i2.gzhead.time >> 8 & 255), mH(i2, i2.gzhead.time >> 16 & 255), mH(i2, i2.gzhead.time >> 24 & 255), mH(i2, 9 === i2.level ? 2 : i2.strategy >= zW || i2.level < 2 ? 4 : 0), mH(i2, 255 & i2.gzhead.os), i2.gzhead.extra && i2.gzhead.extra.length && (mH(i2, 255 & i2.gzhead.extra.length), mH(i2, i2.gzhead.extra.length >> 8 & 255)), i2.gzhead.hcrc && (e9.adler = wW(e9.adler, i2.pending_buf, i2.pending, 0)), i2.gzindex = 0, i2.status = 69;
    else if (mH(i2, 0), mH(i2, 0), mH(i2, 0), mH(i2, 0), mH(i2, 0), mH(i2, 9 === i2.level ? 2 : i2.strategy >= zW || i2.level < 2 ? 4 : 0), mH(i2, 3), i2.status = cH, EH(e9), 0 !== i2.pending) return i2.last_flush = -1, jW;
  }
  if (69 === i2.status) {
    if (i2.gzhead.extra) {
      let t3 = i2.pending, n3 = (65535 & i2.gzhead.extra.length) - i2.gzindex;
      for (; i2.pending + n3 > i2.pending_buf_size; ) {
        let r3 = i2.pending_buf_size - i2.pending;
        if (i2.pending_buf.set(i2.gzhead.extra.subarray(i2.gzindex, i2.gzindex + r3), i2.pending), i2.pending = i2.pending_buf_size, i2.gzhead.hcrc && i2.pending > t3 && (e9.adler = wW(e9.adler, i2.pending_buf, i2.pending - t3, t3)), i2.gzindex += r3, EH(e9), 0 !== i2.pending) return i2.last_flush = -1, jW;
        t3 = 0, n3 -= r3;
      }
      let r2 = new Uint8Array(i2.gzhead.extra);
      i2.pending_buf.set(r2.subarray(i2.gzindex, i2.gzindex + n3), i2.pending), i2.pending += n3, i2.gzhead.hcrc && i2.pending > t3 && (e9.adler = wW(e9.adler, i2.pending_buf, i2.pending - t3, t3)), i2.gzindex = 0;
    }
    i2.status = 73;
  }
  if (73 === i2.status) {
    if (i2.gzhead.name) {
      let t3, n3 = i2.pending;
      do {
        if (i2.pending === i2.pending_buf_size) {
          if (i2.gzhead.hcrc && i2.pending > n3 && (e9.adler = wW(e9.adler, i2.pending_buf, i2.pending - n3, n3)), EH(e9), 0 !== i2.pending) return i2.last_flush = -1, jW;
          n3 = 0;
        }
        t3 = i2.gzindex < i2.gzhead.name.length ? 255 & i2.gzhead.name.charCodeAt(i2.gzindex++) : 0, mH(i2, t3);
      } while (0 !== t3);
      i2.gzhead.hcrc && i2.pending > n3 && (e9.adler = wW(e9.adler, i2.pending_buf, i2.pending - n3, n3)), i2.gzindex = 0;
    }
    i2.status = 91;
  }
  if (91 === i2.status) {
    if (i2.gzhead.comment) {
      let t3, n3 = i2.pending;
      do {
        if (i2.pending === i2.pending_buf_size) {
          if (i2.gzhead.hcrc && i2.pending > n3 && (e9.adler = wW(e9.adler, i2.pending_buf, i2.pending - n3, n3)), EH(e9), 0 !== i2.pending) return i2.last_flush = -1, jW;
          n3 = 0;
        }
        t3 = i2.gzindex < i2.gzhead.comment.length ? 255 & i2.gzhead.comment.charCodeAt(i2.gzindex++) : 0, mH(i2, t3);
      } while (0 !== t3);
      i2.gzhead.hcrc && i2.pending > n3 && (e9.adler = wW(e9.adler, i2.pending_buf, i2.pending - n3, n3));
    }
    i2.status = 103;
  }
  if (103 === i2.status) {
    if (i2.gzhead.hcrc) {
      if (i2.pending + 2 > i2.pending_buf_size && (EH(e9), 0 !== i2.pending)) return i2.last_flush = -1, jW;
      mH(i2, 255 & e9.adler), mH(i2, e9.adler >> 8 & 255), e9.adler = 0;
    }
    if (i2.status = cH, EH(e9), 0 !== i2.pending) return i2.last_flush = -1, jW;
  }
  if (0 !== e9.avail_in || 0 !== i2.lookahead || t2 !== UW && i2.status !== dH) {
    let n3 = 0 === i2.level ? CH(i2, t2) : i2.strategy === zW ? ((e10, t3) => {
      let i3;
      for (; ; ) {
        if (0 === e10.lookahead && (RH(e10), 0 === e10.lookahead)) {
          if (t3 === UW) return 1;
          break;
        }
        if (e10.match_length = 0, i3 = kW(e10, 0, e10.window[e10.strstart]), e10.lookahead--, e10.strstart++, i3 && (fH(e10, false), 0 === e10.strm.avail_out)) return 1;
      }
      return e10.insert = 0, t3 === FW ? (fH(e10, true), 0 === e10.strm.avail_out ? 3 : 4) : e10.sym_next && (fH(e10, false), 0 === e10.strm.avail_out) ? 1 : 2;
    })(i2, t2) : i2.strategy === JW ? ((e10, t3) => {
      let i3, n4, r2, o2;
      const s2 = e10.window;
      for (; ; ) {
        if (e10.lookahead <= oH) {
          if (RH(e10), e10.lookahead <= oH && t3 === UW) return 1;
          if (0 === e10.lookahead) break;
        }
        if (e10.match_length = 0, e10.lookahead >= 3 && e10.strstart > 0 && (r2 = e10.strstart - 1, n4 = s2[r2], n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2])) {
          o2 = e10.strstart + oH;
          do {
          } while (n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && r2 < o2);
          e10.match_length = oH - (o2 - r2), e10.match_length > e10.lookahead && (e10.match_length = e10.lookahead);
        }
        if (e10.match_length >= 3 ? (i3 = kW(e10, 1, e10.match_length - 3), e10.lookahead -= e10.match_length, e10.strstart += e10.match_length, e10.match_length = 0) : (i3 = kW(e10, 0, e10.window[e10.strstart]), e10.lookahead--, e10.strstart++), i3 && (fH(e10, false), 0 === e10.strm.avail_out)) return 1;
      }
      return e10.insert = 0, t3 === FW ? (fH(e10, true), 0 === e10.strm.avail_out ? 3 : 4) : e10.sym_next && (fH(e10, false), 0 === e10.strm.avail_out) ? 1 : 2;
    })(i2, t2) : AH[i2.level].func(i2, t2);
    if (3 !== n3 && 4 !== n3 || (i2.status = dH), 1 === n3 || 3 === n3) return 0 === e9.avail_out && (i2.last_flush = -1), jW;
    if (2 === n3 && (t2 === xW ? MW(i2) : t2 !== BW && (PW(i2, 0, 0, false), t2 === VW && (hH(i2.head), 0 === i2.lookahead && (i2.strstart = 0, i2.block_start = 0, i2.insert = 0))), EH(e9), 0 === e9.avail_out)) return i2.last_flush = -1, jW;
  }
  return t2 !== FW ? jW : i2.wrap <= 0 ? GW : (2 === i2.wrap ? (mH(i2, 255 & e9.adler), mH(i2, e9.adler >> 8 & 255), mH(i2, e9.adler >> 16 & 255), mH(i2, e9.adler >> 24 & 255), mH(i2, 255 & e9.total_in), mH(i2, e9.total_in >> 8 & 255), mH(i2, e9.total_in >> 16 & 255), mH(i2, e9.total_in >> 24 & 255)) : (TH(i2, e9.adler >>> 16), TH(i2, 65535 & e9.adler)), EH(e9), i2.wrap > 0 && (i2.wrap = -i2.wrap), 0 !== i2.pending ? jW : GW);
};
var LH = (e9, t2) => {
  let i2 = t2.length;
  if (wH(e9)) return WW;
  const n2 = e9.state, r2 = n2.wrap;
  if (2 === r2 || 1 === r2 && n2.status !== aH || n2.lookahead) return WW;
  if (1 === r2 && (e9.adler = AW(e9.adler, t2, i2, 0)), n2.wrap = 0, i2 >= n2.w_size) {
    0 === r2 && (hH(n2.head), n2.strstart = 0, n2.block_start = 0, n2.insert = 0);
    let e10 = new Uint8Array(n2.w_size);
    e10.set(t2.subarray(i2 - n2.w_size, i2), 0), t2 = e10, i2 = n2.w_size;
  }
  const o2 = e9.avail_in, s2 = e9.next_in, a2 = e9.input;
  for (e9.avail_in = i2, e9.next_in = 0, e9.input = t2, RH(n2); n2.lookahead >= 3; ) {
    let e10 = n2.strstart, t3 = n2.lookahead - 2;
    do {
      n2.ins_h = _H(n2, n2.ins_h, n2.window[e10 + 3 - 1]), n2.prev[e10 & n2.w_mask] = n2.head[n2.ins_h], n2.head[n2.ins_h] = e10, e10++;
    } while (--t3);
    n2.strstart = e10, n2.lookahead = 2, RH(n2);
  }
  return n2.strstart += n2.lookahead, n2.block_start = n2.strstart, n2.insert = n2.lookahead, n2.lookahead = 0, n2.match_length = n2.prev_length = 2, n2.match_available = 0, e9.next_in = s2, e9.input = a2, e9.avail_in = o2, n2.wrap = r2, jW;
};
var kH = { deflateInit: (e9, t2) => DH(e9, t2, $W, 15, 8, QW), deflateInit2: DH, deflateReset: NH, deflateResetKeep: OH, deflateSetHeader: (e9, t2) => wH(e9) || 2 !== e9.state.wrap ? WW : (e9.state.gzhead = t2, jW), deflate: PH, deflateEnd: (e9) => {
  if (wH(e9)) return WW;
  const t2 = e9.state.status;
  return e9.state = null, t2 === cH ? lH(e9, HW) : jW;
}, deflateSetDictionary: LH, deflateInfo: "pako deflate (from Nodeca project)" };
var MH = (e9, t2) => Object.prototype.hasOwnProperty.call(e9, t2);
var UH = { assign: function(e9) {
  const t2 = Array.prototype.slice.call(arguments, 1);
  for (; t2.length; ) {
    const i2 = t2.shift();
    if (i2) {
      if ("object" != typeof i2) throw new TypeError(i2 + "must be non-object");
      for (const t3 in i2) MH(i2, t3) && (e9[t3] = i2[t3]);
    }
  }
  return e9;
}, flattenChunks: (e9) => {
  let t2 = 0;
  for (let i3 = 0, n2 = e9.length; i3 < n2; i3++) t2 += e9[i3].length;
  const i2 = new Uint8Array(t2);
  for (let t3 = 0, n2 = 0, r2 = e9.length; t3 < r2; t3++) {
    let r3 = e9[t3];
    i2.set(r3, n2), n2 += r3.length;
  }
  return i2;
} };
var xH = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (e9) {
  xH = false;
}
var VH = new Uint8Array(256);
for (let e9 = 0; e9 < 256; e9++) VH[e9] = e9 >= 252 ? 6 : e9 >= 248 ? 5 : e9 >= 240 ? 4 : e9 >= 224 ? 3 : e9 >= 192 ? 2 : 1;
VH[254] = VH[254] = 1;
var FH = { string2buf: (e9) => {
  if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return new TextEncoder().encode(e9);
  let t2, i2, n2, r2, o2, s2 = e9.length, a2 = 0;
  for (r2 = 0; r2 < s2; r2++) i2 = e9.charCodeAt(r2), 55296 == (64512 & i2) && r2 + 1 < s2 && (n2 = e9.charCodeAt(r2 + 1), 56320 == (64512 & n2) && (i2 = 65536 + (i2 - 55296 << 10) + (n2 - 56320), r2++)), a2 += i2 < 128 ? 1 : i2 < 2048 ? 2 : i2 < 65536 ? 3 : 4;
  for (t2 = new Uint8Array(a2), o2 = 0, r2 = 0; o2 < a2; r2++) i2 = e9.charCodeAt(r2), 55296 == (64512 & i2) && r2 + 1 < s2 && (n2 = e9.charCodeAt(r2 + 1), 56320 == (64512 & n2) && (i2 = 65536 + (i2 - 55296 << 10) + (n2 - 56320), r2++)), i2 < 128 ? t2[o2++] = i2 : i2 < 2048 ? (t2[o2++] = 192 | i2 >>> 6, t2[o2++] = 128 | 63 & i2) : i2 < 65536 ? (t2[o2++] = 224 | i2 >>> 12, t2[o2++] = 128 | i2 >>> 6 & 63, t2[o2++] = 128 | 63 & i2) : (t2[o2++] = 240 | i2 >>> 18, t2[o2++] = 128 | i2 >>> 12 & 63, t2[o2++] = 128 | i2 >>> 6 & 63, t2[o2++] = 128 | 63 & i2);
  return t2;
}, buf2string: (e9, t2) => {
  const i2 = t2 || e9.length;
  if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return new TextDecoder().decode(e9.subarray(0, t2));
  let n2, r2;
  const o2 = new Array(2 * i2);
  for (r2 = 0, n2 = 0; n2 < i2; ) {
    let t3 = e9[n2++];
    if (t3 < 128) {
      o2[r2++] = t3;
      continue;
    }
    let s2 = VH[t3];
    if (s2 > 4) o2[r2++] = 65533, n2 += s2 - 1;
    else {
      for (t3 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; s2 > 1 && n2 < i2; ) t3 = t3 << 6 | 63 & e9[n2++], s2--;
      s2 > 1 ? o2[r2++] = 65533 : t3 < 65536 ? o2[r2++] = t3 : (t3 -= 65536, o2[r2++] = 55296 | t3 >> 10 & 1023, o2[r2++] = 56320 | 1023 & t3);
    }
  }
  return ((e10, t3) => {
    if (t3 < 65534 && e10.subarray && xH) return String.fromCharCode.apply(null, e10.length === t3 ? e10 : e10.subarray(0, t3));
    let i3 = "";
    for (let n3 = 0; n3 < t3; n3++) i3 += String.fromCharCode(e10[n3]);
    return i3;
  })(o2, r2);
}, utf8border: (e9, t2) => {
  (t2 = t2 || e9.length) > e9.length && (t2 = e9.length);
  let i2 = t2 - 1;
  for (; i2 >= 0 && 128 == (192 & e9[i2]); ) i2--;
  return i2 < 0 || 0 === i2 ? t2 : i2 + VH[e9[i2]] > t2 ? i2 : t2;
} };
var BH = function() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
};
var jH = Object.prototype.toString;
var { Z_NO_FLUSH: GH, Z_SYNC_FLUSH: WH, Z_FULL_FLUSH: HH, Z_FINISH: KH, Z_OK: YH, Z_STREAM_END: qH, Z_DEFAULT_COMPRESSION: zH, Z_DEFAULT_STRATEGY: JH, Z_DEFLATED: XH } = NW;
function QH(e9) {
  this.options = UH.assign({ level: zH, method: XH, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: JH }, e9 || {});
  let t2 = this.options;
  t2.raw && t2.windowBits > 0 ? t2.windowBits = -t2.windowBits : t2.gzip && t2.windowBits > 0 && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new BH(), this.strm.avail_out = 0;
  let i2 = kH.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
  if (i2 !== YH) throw new Error(OW[i2]);
  if (t2.header && kH.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
    let e10;
    if (e10 = "string" == typeof t2.dictionary ? FH.string2buf(t2.dictionary) : "[object ArrayBuffer]" === jH.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, i2 = kH.deflateSetDictionary(this.strm, e10), i2 !== YH) throw new Error(OW[i2]);
    this._dict_set = true;
  }
}
function ZH(e9, t2) {
  const i2 = new QH(t2);
  if (i2.push(e9, true), i2.err) throw i2.msg || OW[i2.err];
  return i2.result;
}
QH.prototype.push = function(e9, t2) {
  const i2 = this.strm, n2 = this.options.chunkSize;
  let r2, o2;
  if (this.ended) return false;
  for (o2 = t2 === ~~t2 ? t2 : true === t2 ? KH : GH, "string" == typeof e9 ? i2.input = FH.string2buf(e9) : "[object ArrayBuffer]" === jH.call(e9) ? i2.input = new Uint8Array(e9) : i2.input = e9, i2.next_in = 0, i2.avail_in = i2.input.length; ; ) if (0 === i2.avail_out && (i2.output = new Uint8Array(n2), i2.next_out = 0, i2.avail_out = n2), (o2 === WH || o2 === HH) && i2.avail_out <= 6) this.onData(i2.output.subarray(0, i2.next_out)), i2.avail_out = 0;
  else {
    if (r2 = kH.deflate(i2, o2), r2 === qH) return i2.next_out > 0 && this.onData(i2.output.subarray(0, i2.next_out)), r2 = kH.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === YH;
    if (0 !== i2.avail_out) {
      if (o2 > 0 && i2.next_out > 0) this.onData(i2.output.subarray(0, i2.next_out)), i2.avail_out = 0;
      else if (0 === i2.avail_in) break;
    } else this.onData(i2.output);
  }
  return true;
}, QH.prototype.onData = function(e9) {
  this.chunks.push(e9);
}, QH.prototype.onEnd = function(e9) {
  e9 === YH && (this.result = UH.flattenChunks(this.chunks)), this.chunks = [], this.err = e9, this.msg = this.strm.msg;
};
var $H = { Deflate: QH, deflate: ZH, deflateRaw: function(e9, t2) {
  return (t2 = t2 || {}).raw = true, ZH(e9, t2);
}, gzip: function(e9, t2) {
  return (t2 = t2 || {}).gzip = true, ZH(e9, t2);
}, constants: NW };
var eK = 16209;
var tK = function(e9, t2) {
  let i2, n2, r2, o2, s2, a2, c2, d2, l2, u2, h2, p2, _2, E2, f2, m2, T2, S2, g2, R2, C2, I2, v2, y2;
  const A2 = e9.state;
  i2 = e9.next_in, v2 = e9.input, n2 = i2 + (e9.avail_in - 5), r2 = e9.next_out, y2 = e9.output, o2 = r2 - (t2 - e9.avail_out), s2 = r2 + (e9.avail_out - 257), a2 = A2.dmax, c2 = A2.wsize, d2 = A2.whave, l2 = A2.wnext, u2 = A2.window, h2 = A2.hold, p2 = A2.bits, _2 = A2.lencode, E2 = A2.distcode, f2 = (1 << A2.lenbits) - 1, m2 = (1 << A2.distbits) - 1;
  e: do {
    p2 < 15 && (h2 += v2[i2++] << p2, p2 += 8, h2 += v2[i2++] << p2, p2 += 8), T2 = _2[h2 & f2];
    t: for (; ; ) {
      if (S2 = T2 >>> 24, h2 >>>= S2, p2 -= S2, S2 = T2 >>> 16 & 255, 0 === S2) y2[r2++] = 65535 & T2;
      else {
        if (!(16 & S2)) {
          if (0 == (64 & S2)) {
            T2 = _2[(65535 & T2) + (h2 & (1 << S2) - 1)];
            continue t;
          }
          if (32 & S2) {
            A2.mode = 16191;
            break e;
          }
          e9.msg = "invalid literal/length code", A2.mode = eK;
          break e;
        }
        g2 = 65535 & T2, S2 &= 15, S2 && (p2 < S2 && (h2 += v2[i2++] << p2, p2 += 8), g2 += h2 & (1 << S2) - 1, h2 >>>= S2, p2 -= S2), p2 < 15 && (h2 += v2[i2++] << p2, p2 += 8, h2 += v2[i2++] << p2, p2 += 8), T2 = E2[h2 & m2];
        i: for (; ; ) {
          if (S2 = T2 >>> 24, h2 >>>= S2, p2 -= S2, S2 = T2 >>> 16 & 255, !(16 & S2)) {
            if (0 == (64 & S2)) {
              T2 = E2[(65535 & T2) + (h2 & (1 << S2) - 1)];
              continue i;
            }
            e9.msg = "invalid distance code", A2.mode = eK;
            break e;
          }
          if (R2 = 65535 & T2, S2 &= 15, p2 < S2 && (h2 += v2[i2++] << p2, p2 += 8, p2 < S2 && (h2 += v2[i2++] << p2, p2 += 8)), R2 += h2 & (1 << S2) - 1, R2 > a2) {
            e9.msg = "invalid distance too far back", A2.mode = eK;
            break e;
          }
          if (h2 >>>= S2, p2 -= S2, S2 = r2 - o2, R2 > S2) {
            if (S2 = R2 - S2, S2 > d2 && A2.sane) {
              e9.msg = "invalid distance too far back", A2.mode = eK;
              break e;
            }
            if (C2 = 0, I2 = u2, 0 === l2) {
              if (C2 += c2 - S2, S2 < g2) {
                g2 -= S2;
                do {
                  y2[r2++] = u2[C2++];
                } while (--S2);
                C2 = r2 - R2, I2 = y2;
              }
            } else if (l2 < S2) {
              if (C2 += c2 + l2 - S2, S2 -= l2, S2 < g2) {
                g2 -= S2;
                do {
                  y2[r2++] = u2[C2++];
                } while (--S2);
                if (C2 = 0, l2 < g2) {
                  S2 = l2, g2 -= S2;
                  do {
                    y2[r2++] = u2[C2++];
                  } while (--S2);
                  C2 = r2 - R2, I2 = y2;
                }
              }
            } else if (C2 += l2 - S2, S2 < g2) {
              g2 -= S2;
              do {
                y2[r2++] = u2[C2++];
              } while (--S2);
              C2 = r2 - R2, I2 = y2;
            }
            for (; g2 > 2; ) y2[r2++] = I2[C2++], y2[r2++] = I2[C2++], y2[r2++] = I2[C2++], g2 -= 3;
            g2 && (y2[r2++] = I2[C2++], g2 > 1 && (y2[r2++] = I2[C2++]));
          } else {
            C2 = r2 - R2;
            do {
              y2[r2++] = y2[C2++], y2[r2++] = y2[C2++], y2[r2++] = y2[C2++], g2 -= 3;
            } while (g2 > 2);
            g2 && (y2[r2++] = y2[C2++], g2 > 1 && (y2[r2++] = y2[C2++]));
          }
          break;
        }
      }
      break;
    }
  } while (i2 < n2 && r2 < s2);
  g2 = p2 >> 3, i2 -= g2, p2 -= g2 << 3, h2 &= (1 << p2) - 1, e9.next_in = i2, e9.next_out = r2, e9.avail_in = i2 < n2 ? n2 - i2 + 5 : 5 - (i2 - n2), e9.avail_out = r2 < s2 ? s2 - r2 + 257 : 257 - (r2 - s2), A2.hold = h2, A2.bits = p2;
};
var iK = 15;
var nK = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]);
var rK = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]);
var oK = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]);
var sK = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
var aK = (e9, t2, i2, n2, r2, o2, s2, a2) => {
  const c2 = a2.bits;
  let d2, l2, u2, h2, p2, _2, E2 = 0, f2 = 0, m2 = 0, T2 = 0, S2 = 0, g2 = 0, R2 = 0, C2 = 0, I2 = 0, v2 = 0, y2 = null;
  const A2 = new Uint16Array(16), b2 = new Uint16Array(16);
  let w2, O2, N2, D2 = null;
  for (E2 = 0; E2 <= iK; E2++) A2[E2] = 0;
  for (f2 = 0; f2 < n2; f2++) A2[t2[i2 + f2]]++;
  for (S2 = c2, T2 = iK; T2 >= 1 && 0 === A2[T2]; T2--) ;
  if (S2 > T2 && (S2 = T2), 0 === T2) return r2[o2++] = 20971520, r2[o2++] = 20971520, a2.bits = 1, 0;
  for (m2 = 1; m2 < T2 && 0 === A2[m2]; m2++) ;
  for (S2 < m2 && (S2 = m2), C2 = 1, E2 = 1; E2 <= iK; E2++) if (C2 <<= 1, C2 -= A2[E2], C2 < 0) return -1;
  if (C2 > 0 && (0 === e9 || 1 !== T2)) return -1;
  for (b2[1] = 0, E2 = 1; E2 < iK; E2++) b2[E2 + 1] = b2[E2] + A2[E2];
  for (f2 = 0; f2 < n2; f2++) 0 !== t2[i2 + f2] && (s2[b2[t2[i2 + f2]]++] = f2);
  if (0 === e9 ? (y2 = D2 = s2, _2 = 20) : 1 === e9 ? (y2 = nK, D2 = rK, _2 = 257) : (y2 = oK, D2 = sK, _2 = 0), v2 = 0, f2 = 0, E2 = m2, p2 = o2, g2 = S2, R2 = 0, u2 = -1, I2 = 1 << S2, h2 = I2 - 1, 1 === e9 && I2 > 852 || 2 === e9 && I2 > 592) return 1;
  for (; ; ) {
    w2 = E2 - R2, s2[f2] + 1 < _2 ? (O2 = 0, N2 = s2[f2]) : s2[f2] >= _2 ? (O2 = D2[s2[f2] - _2], N2 = y2[s2[f2] - _2]) : (O2 = 96, N2 = 0), d2 = 1 << E2 - R2, l2 = 1 << g2, m2 = l2;
    do {
      l2 -= d2, r2[p2 + (v2 >> R2) + l2] = w2 << 24 | O2 << 16 | N2 | 0;
    } while (0 !== l2);
    for (d2 = 1 << E2 - 1; v2 & d2; ) d2 >>= 1;
    if (0 !== d2 ? (v2 &= d2 - 1, v2 += d2) : v2 = 0, f2++, 0 == --A2[E2]) {
      if (E2 === T2) break;
      E2 = t2[i2 + s2[f2]];
    }
    if (E2 > S2 && (v2 & h2) !== u2) {
      for (0 === R2 && (R2 = S2), p2 += m2, g2 = E2 - R2, C2 = 1 << g2; g2 + R2 < T2 && (C2 -= A2[g2 + R2], !(C2 <= 0)); ) g2++, C2 <<= 1;
      if (I2 += 1 << g2, 1 === e9 && I2 > 852 || 2 === e9 && I2 > 592) return 1;
      u2 = v2 & h2, r2[u2] = S2 << 24 | g2 << 16 | p2 - o2 | 0;
    }
  }
  return 0 !== v2 && (r2[p2 + v2] = E2 - R2 << 24 | 64 << 16 | 0), a2.bits = S2, 0;
};
var { Z_FINISH: cK, Z_BLOCK: dK, Z_TREES: lK, Z_OK: uK, Z_STREAM_END: hK, Z_NEED_DICT: pK, Z_STREAM_ERROR: _K, Z_DATA_ERROR: EK, Z_MEM_ERROR: fK, Z_BUF_ERROR: mK, Z_DEFLATED: TK } = NW;
var SK = 16180;
var gK = 16190;
var RK = 16191;
var CK = 16192;
var IK = 16194;
var vK = 16199;
var yK = 16200;
var AK = 16206;
var bK = 16209;
var wK = (e9) => (e9 >>> 24 & 255) + (e9 >>> 8 & 65280) + ((65280 & e9) << 8) + ((255 & e9) << 24);
function OK() {
  this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
var NK = (e9) => {
  if (!e9) return 1;
  const t2 = e9.state;
  return !t2 || t2.strm !== e9 || t2.mode < SK || t2.mode > 16211 ? 1 : 0;
};
var DK = (e9) => {
  if (NK(e9)) return _K;
  const t2 = e9.state;
  return e9.total_in = e9.total_out = t2.total = 0, e9.msg = "", t2.wrap && (e9.adler = 1 & t2.wrap), t2.mode = SK, t2.last = 0, t2.havedict = 0, t2.flags = -1, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new Int32Array(852), t2.distcode = t2.distdyn = new Int32Array(592), t2.sane = 1, t2.back = -1, uK;
};
var PK = (e9) => {
  if (NK(e9)) return _K;
  const t2 = e9.state;
  return t2.wsize = 0, t2.whave = 0, t2.wnext = 0, DK(e9);
};
var LK = (e9, t2) => {
  let i2;
  if (NK(e9)) return _K;
  const n2 = e9.state;
  return t2 < 0 ? (i2 = 0, t2 = -t2) : (i2 = 5 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || t2 > 15) ? _K : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = i2, n2.wbits = t2, PK(e9));
};
var kK = (e9, t2) => {
  if (!e9) return _K;
  const i2 = new OK();
  e9.state = i2, i2.strm = e9, i2.window = null, i2.mode = SK;
  const n2 = LK(e9, t2);
  return n2 !== uK && (e9.state = null), n2;
};
var MK;
var UK;
var xK = true;
var VK = (e9) => {
  if (xK) {
    MK = new Int32Array(512), UK = new Int32Array(32);
    let t2 = 0;
    for (; t2 < 144; ) e9.lens[t2++] = 8;
    for (; t2 < 256; ) e9.lens[t2++] = 9;
    for (; t2 < 280; ) e9.lens[t2++] = 7;
    for (; t2 < 288; ) e9.lens[t2++] = 8;
    for (aK(1, e9.lens, 0, 288, MK, 0, e9.work, { bits: 9 }), t2 = 0; t2 < 32; ) e9.lens[t2++] = 5;
    aK(2, e9.lens, 0, 32, UK, 0, e9.work, { bits: 5 }), xK = false;
  }
  e9.lencode = MK, e9.lenbits = 9, e9.distcode = UK, e9.distbits = 5;
};
var FK = (e9, t2, i2, n2) => {
  let r2;
  const o2 = e9.state;
  return null === o2.window && (o2.wsize = 1 << o2.wbits, o2.wnext = 0, o2.whave = 0, o2.window = new Uint8Array(o2.wsize)), n2 >= o2.wsize ? (o2.window.set(t2.subarray(i2 - o2.wsize, i2), 0), o2.wnext = 0, o2.whave = o2.wsize) : (r2 = o2.wsize - o2.wnext, r2 > n2 && (r2 = n2), o2.window.set(t2.subarray(i2 - n2, i2 - n2 + r2), o2.wnext), (n2 -= r2) ? (o2.window.set(t2.subarray(i2 - n2, i2), 0), o2.wnext = n2, o2.whave = o2.wsize) : (o2.wnext += r2, o2.wnext === o2.wsize && (o2.wnext = 0), o2.whave < o2.wsize && (o2.whave += r2))), 0;
};
var BK = (e9, t2) => {
  let i2, n2, r2, o2, s2, a2, c2, d2, l2, u2, h2, p2, _2, E2, f2, m2, T2, S2, g2, R2, C2, I2, v2 = 0;
  const y2 = new Uint8Array(4);
  let A2, b2;
  const w2 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (NK(e9) || !e9.output || !e9.input && 0 !== e9.avail_in) return _K;
  i2 = e9.state, i2.mode === RK && (i2.mode = CK), s2 = e9.next_out, r2 = e9.output, c2 = e9.avail_out, o2 = e9.next_in, n2 = e9.input, a2 = e9.avail_in, d2 = i2.hold, l2 = i2.bits, u2 = a2, h2 = c2, I2 = uK;
  e: for (; ; ) switch (i2.mode) {
    case SK:
      if (0 === i2.wrap) {
        i2.mode = CK;
        break;
      }
      for (; l2 < 16; ) {
        if (0 === a2) break e;
        a2--, d2 += n2[o2++] << l2, l2 += 8;
      }
      if (2 & i2.wrap && 35615 === d2) {
        0 === i2.wbits && (i2.wbits = 15), i2.check = 0, y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i2.check = wW(i2.check, y2, 2, 0), d2 = 0, l2 = 0, i2.mode = 16181;
        break;
      }
      if (i2.head && (i2.head.done = false), !(1 & i2.wrap) || (((255 & d2) << 8) + (d2 >> 8)) % 31) {
        e9.msg = "incorrect header check", i2.mode = bK;
        break;
      }
      if ((15 & d2) !== TK) {
        e9.msg = "unknown compression method", i2.mode = bK;
        break;
      }
      if (d2 >>>= 4, l2 -= 4, C2 = 8 + (15 & d2), 0 === i2.wbits && (i2.wbits = C2), C2 > 15 || C2 > i2.wbits) {
        e9.msg = "invalid window size", i2.mode = bK;
        break;
      }
      i2.dmax = 1 << i2.wbits, i2.flags = 0, e9.adler = i2.check = 1, i2.mode = 512 & d2 ? 16189 : RK, d2 = 0, l2 = 0;
      break;
    case 16181:
      for (; l2 < 16; ) {
        if (0 === a2) break e;
        a2--, d2 += n2[o2++] << l2, l2 += 8;
      }
      if (i2.flags = d2, (255 & VG(i2)) !== TK) {
        e9.msg = "unknown compression method", i2.mode = bK;
        break;
      }
      if (57344 & VG(i2)) {
        e9.msg = "unknown header flags set", i2.mode = bK;
        break;
      }
      i2.head && (i2.head.text = d2 >> 8 & 1), 512 & VG(i2) && 4 & i2.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i2.check = wW(i2.check, y2, 2, 0)), d2 = 0, l2 = 0, i2.mode = 16182;
    case 16182:
      for (; l2 < 32; ) {
        if (0 === a2) break e;
        a2--, d2 += n2[o2++] << l2, l2 += 8;
      }
      i2.head && (i2.head.time = d2), 512 & VG(i2) && 4 & i2.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, y2[2] = d2 >>> 16 & 255, y2[3] = d2 >>> 24 & 255, i2.check = wW(i2.check, y2, 4, 0)), d2 = 0, l2 = 0, i2.mode = 16183;
    case 16183:
      for (; l2 < 16; ) {
        if (0 === a2) break e;
        a2--, d2 += n2[o2++] << l2, l2 += 8;
      }
      i2.head && (i2.head.xflags = 255 & d2, i2.head.os = d2 >> 8), 512 & VG(i2) && 4 & i2.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i2.check = wW(i2.check, y2, 2, 0)), d2 = 0, l2 = 0, i2.mode = 16184;
    case 16184:
      if (1024 & VG(i2)) {
        for (; l2 < 16; ) {
          if (0 === a2) break e;
          a2--, d2 += n2[o2++] << l2, l2 += 8;
        }
        i2.length = d2, i2.head && (i2.head.extra_len = d2), 512 & VG(i2) && 4 & i2.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i2.check = wW(i2.check, y2, 2, 0)), d2 = 0, l2 = 0;
      } else i2.head && (i2.head.extra = null);
      i2.mode = 16185;
    case 16185:
      if (1024 & VG(i2) && (p2 = i2.length, p2 > a2 && (p2 = a2), p2 && (i2.head && (C2 = i2.head.extra_len - i2.length, i2.head.extra || (i2.head.extra = new Uint8Array(i2.head.extra_len)), i2.head.extra.set(n2.subarray(o2, o2 + p2), C2)), 512 & VG(i2) && 4 & i2.wrap && (i2.check = wW(i2.check, n2, p2, o2)), a2 -= p2, o2 += p2, i2.length -= p2), i2.length)) break e;
      i2.length = 0, i2.mode = 16186;
    case 16186:
      if (2048 & VG(i2)) {
        if (0 === a2) break e;
        p2 = 0;
        do {
          C2 = n2[o2 + p2++], i2.head && C2 && i2.length < 65536 && (i2.head.name += String.fromCharCode(C2));
        } while (C2 && p2 < a2);
        if (512 & VG(i2) && 4 & i2.wrap && (i2.check = wW(i2.check, n2, p2, o2)), a2 -= p2, o2 += p2, C2) break e;
      } else i2.head && (i2.head.name = null);
      i2.length = 0, i2.mode = 16187;
    case 16187:
      if (4096 & VG(i2)) {
        if (0 === a2) break e;
        p2 = 0;
        do {
          C2 = n2[o2 + p2++], i2.head && C2 && i2.length < 65536 && (i2.head.comment += String.fromCharCode(C2));
        } while (C2 && p2 < a2);
        if (512 & VG(i2) && 4 & i2.wrap && (i2.check = wW(i2.check, n2, p2, o2)), a2 -= p2, o2 += p2, C2) break e;
      } else i2.head && (i2.head.comment = null);
      i2.mode = 16188;
    case 16188:
      if (512 & VG(i2)) {
        for (; l2 < 16; ) {
          if (0 === a2) break e;
          a2--, d2 += n2[o2++] << l2, l2 += 8;
        }
        if (4 & i2.wrap && d2 !== (65535 & i2.check)) {
          e9.msg = "header crc mismatch", i2.mode = bK;
          break;
        }
        d2 = 0, l2 = 0;
      }
      i2.head && (i2.head.hcrc = VG(i2) >> 9 & 1, i2.head.done = true), e9.adler = i2.check = 0, i2.mode = RK;
      break;
    case 16189:
      for (; l2 < 32; ) {
        if (0 === a2) break e;
        a2--, d2 += n2[o2++] << l2, l2 += 8;
      }
      e9.adler = i2.check = wK(d2), d2 = 0, l2 = 0, i2.mode = gK;
    case gK:
      if (0 === i2.havedict) return e9.next_out = s2, e9.avail_out = c2, e9.next_in = o2, e9.avail_in = a2, i2.hold = d2, i2.bits = l2, pK;
      e9.adler = i2.check = 1, i2.mode = RK;
    case RK:
      if (t2 === dK || t2 === lK) break e;
    case CK:
      if (i2.last) {
        d2 >>>= 7 & l2, l2 -= 7 & l2, i2.mode = AK;
        break;
      }
      for (; l2 < 3; ) {
        if (0 === a2) break e;
        a2--, d2 += n2[o2++] << l2, l2 += 8;
      }
      switch (i2.last = 1 & d2, d2 >>>= 1, l2 -= 1, 3 & d2) {
        case 0:
          i2.mode = 16193;
          break;
        case 1:
          if (VK(i2), i2.mode = vK, t2 === lK) {
            d2 >>>= 2, l2 -= 2;
            break e;
          }
          break;
        case 2:
          i2.mode = 16196;
          break;
        case 3:
          e9.msg = "invalid block type", i2.mode = bK;
      }
      d2 >>>= 2, l2 -= 2;
      break;
    case 16193:
      for (d2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
        if (0 === a2) break e;
        a2--, d2 += n2[o2++] << l2, l2 += 8;
      }
      if ((65535 & d2) != (d2 >>> 16 ^ 65535)) {
        e9.msg = "invalid stored block lengths", i2.mode = bK;
        break;
      }
      if (i2.length = 65535 & d2, d2 = 0, l2 = 0, i2.mode = IK, t2 === lK) break e;
    case IK:
      i2.mode = 16195;
    case 16195:
      if (p2 = i2.length, p2) {
        if (p2 > a2 && (p2 = a2), p2 > c2 && (p2 = c2), 0 === p2) break e;
        r2.set(n2.subarray(o2, o2 + p2), s2), a2 -= p2, o2 += p2, c2 -= p2, s2 += p2, i2.length -= p2;
        break;
      }
      i2.mode = RK;
      break;
    case 16196:
      for (; l2 < 14; ) {
        if (0 === a2) break e;
        a2--, d2 += n2[o2++] << l2, l2 += 8;
      }
      if (i2.nlen = 257 + (31 & d2), d2 >>>= 5, l2 -= 5, i2.ndist = 1 + (31 & d2), d2 >>>= 5, l2 -= 5, i2.ncode = 4 + (15 & d2), d2 >>>= 4, l2 -= 4, i2.nlen > 286 || i2.ndist > 30) {
        e9.msg = "too many length or distance symbols", i2.mode = bK;
        break;
      }
      i2.have = 0, i2.mode = 16197;
    case 16197:
      for (; i2.have < i2.ncode; ) {
        for (; l2 < 3; ) {
          if (0 === a2) break e;
          a2--, d2 += n2[o2++] << l2, l2 += 8;
        }
        i2.lens[w2[i2.have++]] = 7 & d2, d2 >>>= 3, l2 -= 3;
      }
      for (; i2.have < 19; ) i2.lens[w2[i2.have++]] = 0;
      if (i2.lencode = i2.lendyn, i2.lenbits = 7, A2 = { bits: i2.lenbits }, I2 = aK(0, i2.lens, 0, 19, i2.lencode, 0, i2.work, A2), i2.lenbits = A2.bits, I2) {
        e9.msg = "invalid code lengths set", i2.mode = bK;
        break;
      }
      i2.have = 0, i2.mode = 16198;
    case 16198:
      for (; i2.have < i2.nlen + i2.ndist; ) {
        for (; v2 = i2.lencode[d2 & (1 << i2.lenbits) - 1], f2 = v2 >>> 24, m2 = v2 >>> 16 & 255, T2 = 65535 & v2, !(f2 <= l2); ) {
          if (0 === a2) break e;
          a2--, d2 += n2[o2++] << l2, l2 += 8;
        }
        if (T2 < 16) d2 >>>= f2, l2 -= f2, i2.lens[i2.have++] = T2;
        else {
          if (16 === T2) {
            for (b2 = f2 + 2; l2 < b2; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[o2++] << l2, l2 += 8;
            }
            if (d2 >>>= f2, l2 -= f2, 0 === i2.have) {
              e9.msg = "invalid bit length repeat", i2.mode = bK;
              break;
            }
            C2 = i2.lens[i2.have - 1], p2 = 3 + (3 & d2), d2 >>>= 2, l2 -= 2;
          } else if (17 === T2) {
            for (b2 = f2 + 3; l2 < b2; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[o2++] << l2, l2 += 8;
            }
            d2 >>>= f2, l2 -= f2, C2 = 0, p2 = 3 + (7 & d2), d2 >>>= 3, l2 -= 3;
          } else {
            for (b2 = f2 + 7; l2 < b2; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[o2++] << l2, l2 += 8;
            }
            d2 >>>= f2, l2 -= f2, C2 = 0, p2 = 11 + (127 & d2), d2 >>>= 7, l2 -= 7;
          }
          if (i2.have + p2 > i2.nlen + i2.ndist) {
            e9.msg = "invalid bit length repeat", i2.mode = bK;
            break;
          }
          for (; p2--; ) i2.lens[i2.have++] = C2;
        }
      }
      if (i2.mode === bK) break;
      if (0 === i2.lens[256]) {
        e9.msg = "invalid code -- missing end-of-block", i2.mode = bK;
        break;
      }
      if (i2.lenbits = 9, A2 = { bits: i2.lenbits }, I2 = aK(1, i2.lens, 0, i2.nlen, i2.lencode, 0, i2.work, A2), i2.lenbits = A2.bits, I2) {
        e9.msg = "invalid literal/lengths set", i2.mode = bK;
        break;
      }
      if (i2.distbits = 6, i2.distcode = i2.distdyn, A2 = { bits: i2.distbits }, I2 = aK(2, i2.lens, i2.nlen, i2.ndist, i2.distcode, 0, i2.work, A2), i2.distbits = A2.bits, I2) {
        e9.msg = "invalid distances set", i2.mode = bK;
        break;
      }
      if (i2.mode = vK, t2 === lK) break e;
    case vK:
      i2.mode = yK;
    case yK:
      if (a2 >= 6 && c2 >= 258) {
        e9.next_out = s2, e9.avail_out = c2, e9.next_in = o2, e9.avail_in = a2, i2.hold = d2, i2.bits = l2, tK(e9, h2), s2 = e9.next_out, r2 = e9.output, c2 = e9.avail_out, o2 = e9.next_in, n2 = e9.input, a2 = e9.avail_in, d2 = i2.hold, l2 = i2.bits, i2.mode === RK && (i2.back = -1);
        break;
      }
      for (i2.back = 0; v2 = i2.lencode[d2 & (1 << i2.lenbits) - 1], f2 = v2 >>> 24, m2 = v2 >>> 16 & 255, T2 = 65535 & v2, !(f2 <= l2); ) {
        if (0 === a2) break e;
        a2--, d2 += n2[o2++] << l2, l2 += 8;
      }
      if (m2 && 0 == (240 & m2)) {
        for (S2 = f2, g2 = m2, R2 = T2; v2 = i2.lencode[R2 + ((d2 & (1 << S2 + g2) - 1) >> S2)], f2 = v2 >>> 24, m2 = v2 >>> 16 & 255, T2 = 65535 & v2, !(S2 + f2 <= l2); ) {
          if (0 === a2) break e;
          a2--, d2 += n2[o2++] << l2, l2 += 8;
        }
        d2 >>>= S2, l2 -= S2, i2.back += S2;
      }
      if (d2 >>>= f2, l2 -= f2, i2.back += f2, i2.length = T2, 0 === m2) {
        i2.mode = 16205;
        break;
      }
      if (32 & m2) {
        i2.back = -1, i2.mode = RK;
        break;
      }
      if (64 & m2) {
        e9.msg = "invalid literal/length code", i2.mode = bK;
        break;
      }
      i2.extra = 15 & m2, i2.mode = 16201;
    case 16201:
      if (i2.extra) {
        for (b2 = i2.extra; l2 < b2; ) {
          if (0 === a2) break e;
          a2--, d2 += n2[o2++] << l2, l2 += 8;
        }
        i2.length += d2 & (1 << i2.extra) - 1, d2 >>>= i2.extra, l2 -= i2.extra, i2.back += i2.extra;
      }
      i2.was = i2.length, i2.mode = 16202;
    case 16202:
      for (; v2 = i2.distcode[d2 & (1 << i2.distbits) - 1], f2 = v2 >>> 24, m2 = v2 >>> 16 & 255, T2 = 65535 & v2, !(f2 <= l2); ) {
        if (0 === a2) break e;
        a2--, d2 += n2[o2++] << l2, l2 += 8;
      }
      if (0 == (240 & m2)) {
        for (S2 = f2, g2 = m2, R2 = T2; v2 = i2.distcode[R2 + ((d2 & (1 << S2 + g2) - 1) >> S2)], f2 = v2 >>> 24, m2 = v2 >>> 16 & 255, T2 = 65535 & v2, !(S2 + f2 <= l2); ) {
          if (0 === a2) break e;
          a2--, d2 += n2[o2++] << l2, l2 += 8;
        }
        d2 >>>= S2, l2 -= S2, i2.back += S2;
      }
      if (d2 >>>= f2, l2 -= f2, i2.back += f2, 64 & m2) {
        e9.msg = "invalid distance code", i2.mode = bK;
        break;
      }
      i2.offset = T2, i2.extra = 15 & m2, i2.mode = 16203;
    case 16203:
      if (i2.extra) {
        for (b2 = i2.extra; l2 < b2; ) {
          if (0 === a2) break e;
          a2--, d2 += n2[o2++] << l2, l2 += 8;
        }
        i2.offset += d2 & (1 << i2.extra) - 1, d2 >>>= i2.extra, l2 -= i2.extra, i2.back += i2.extra;
      }
      if (i2.offset > i2.dmax) {
        e9.msg = "invalid distance too far back", i2.mode = bK;
        break;
      }
      i2.mode = 16204;
    case 16204:
      if (0 === c2) break e;
      if (p2 = h2 - c2, i2.offset > p2) {
        if (p2 = i2.offset - p2, p2 > i2.whave && i2.sane) {
          e9.msg = "invalid distance too far back", i2.mode = bK;
          break;
        }
        p2 > i2.wnext ? (p2 -= i2.wnext, _2 = i2.wsize - p2) : _2 = i2.wnext - p2, p2 > i2.length && (p2 = i2.length), E2 = i2.window;
      } else E2 = r2, _2 = s2 - i2.offset, p2 = i2.length;
      p2 > c2 && (p2 = c2), c2 -= p2, i2.length -= p2;
      do {
        r2[s2++] = E2[_2++];
      } while (--p2);
      0 === i2.length && (i2.mode = yK);
      break;
    case 16205:
      if (0 === c2) break e;
      r2[s2++] = i2.length, c2--, i2.mode = yK;
      break;
    case AK:
      if (i2.wrap) {
        for (; l2 < 32; ) {
          if (0 === a2) break e;
          a2--, d2 |= n2[o2++] << l2, l2 += 8;
        }
        if (h2 -= c2, e9.total_out += h2, i2.total += h2, 4 & i2.wrap && h2 && (e9.adler = i2.check = VG(i2) ? wW(i2.check, r2, h2, s2 - h2) : AW(i2.check, r2, h2, s2 - h2)), h2 = c2, 4 & i2.wrap && (VG(i2) ? d2 : wK(d2)) !== i2.check) {
          e9.msg = "incorrect data check", i2.mode = bK;
          break;
        }
        d2 = 0, l2 = 0;
      }
      i2.mode = 16207;
    case 16207:
      if (i2.wrap && VG(i2)) {
        for (; l2 < 32; ) {
          if (0 === a2) break e;
          a2--, d2 += n2[o2++] << l2, l2 += 8;
        }
        if (4 & i2.wrap && d2 !== (4294967295 & i2.total)) {
          e9.msg = "incorrect length check", i2.mode = bK;
          break;
        }
        d2 = 0, l2 = 0;
      }
      i2.mode = 16208;
    case 16208:
      I2 = hK;
      break e;
    case bK:
      I2 = EK;
      break e;
    case 16210:
      return fK;
    default:
      return _K;
  }
  return e9.next_out = s2, e9.avail_out = c2, e9.next_in = o2, e9.avail_in = a2, i2.hold = d2, i2.bits = l2, (i2.wsize || h2 !== e9.avail_out && i2.mode < bK && (i2.mode < AK || t2 !== cK)) && FK(e9, e9.output, e9.next_out, h2 - e9.avail_out), u2 -= e9.avail_in, h2 -= e9.avail_out, e9.total_in += u2, e9.total_out += h2, i2.total += h2, 4 & i2.wrap && h2 && (e9.adler = i2.check = VG(i2) ? wW(i2.check, r2, h2, e9.next_out - h2) : AW(i2.check, r2, h2, e9.next_out - h2)), e9.data_type = i2.bits + (i2.last ? 64 : 0) + (i2.mode === RK ? 128 : 0) + (i2.mode === vK || i2.mode === IK ? 256 : 0), (0 === u2 && 0 === h2 || t2 === cK) && I2 === uK && (I2 = mK), I2;
};
var jK = { inflateReset: PK, inflateReset2: LK, inflateResetKeep: DK, inflateInit: (e9) => kK(e9, 15), inflateInit2: kK, inflate: BK, inflateEnd: (e9) => {
  if (NK(e9)) return _K;
  let t2 = e9.state;
  return t2.window && (t2.window = null), e9.state = null, uK;
}, inflateGetHeader: (e9, t2) => {
  if (NK(e9)) return _K;
  const i2 = e9.state;
  return 0 == (2 & i2.wrap) ? _K : (i2.head = t2, t2.done = false, uK);
}, inflateSetDictionary: (e9, t2) => {
  const i2 = t2.length;
  let n2, r2, o2;
  return NK(e9) ? _K : (n2 = e9.state, 0 !== n2.wrap && n2.mode !== gK ? _K : n2.mode === gK && (r2 = 1, r2 = AW(r2, t2, i2, 0), r2 !== n2.check) ? EK : (o2 = FK(e9, t2, i2, i2), o2 ? (n2.mode = 16210, fK) : (n2.havedict = 1, uK)));
}, inflateInfo: "pako inflate (from Nodeca project)" };
var GK = function() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
};
var WK = Object.prototype.toString;
var { Z_NO_FLUSH: HK, Z_FINISH: KK, Z_OK: YK, Z_STREAM_END: qK, Z_NEED_DICT: zK, Z_STREAM_ERROR: JK, Z_DATA_ERROR: XK, Z_MEM_ERROR: QK } = NW;
function ZK(e9) {
  this.options = UH.assign({ chunkSize: 65536, windowBits: 15, to: "" }, e9 || {});
  const t2 = this.options;
  t2.raw && t2.windowBits >= 0 && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(t2.windowBits >= 0 && t2.windowBits < 16) || e9 && e9.windowBits || (t2.windowBits += 32), t2.windowBits > 15 && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new BH(), this.strm.avail_out = 0;
  let i2 = jK.inflateInit2(this.strm, t2.windowBits);
  if (i2 !== YK) throw new Error(OW[i2]);
  if (this.header = new GK(), jK.inflateGetHeader(this.strm, this.header), t2.dictionary && ("string" == typeof t2.dictionary ? t2.dictionary = FH.string2buf(t2.dictionary) : "[object ArrayBuffer]" === WK.call(t2.dictionary) && (t2.dictionary = new Uint8Array(t2.dictionary)), t2.raw && (i2 = jK.inflateSetDictionary(this.strm, t2.dictionary), i2 !== YK))) throw new Error(OW[i2]);
}
function $K(e9, t2) {
  const i2 = new ZK(t2);
  if (i2.push(e9), i2.err) throw i2.msg || OW[i2.err];
  return i2.result;
}
ZK.prototype.push = function(e9, t2) {
  const i2 = this.strm, n2 = this.options.chunkSize, r2 = this.options.dictionary;
  let o2, s2, a2;
  if (this.ended) return false;
  for (s2 = t2 === ~~t2 ? t2 : true === t2 ? KK : HK, "[object ArrayBuffer]" === WK.call(e9) ? i2.input = new Uint8Array(e9) : i2.input = e9, i2.next_in = 0, i2.avail_in = i2.input.length; ; ) {
    for (0 === i2.avail_out && (i2.output = new Uint8Array(n2), i2.next_out = 0, i2.avail_out = n2), o2 = jK.inflate(i2, s2), o2 === zK && r2 && (o2 = jK.inflateSetDictionary(i2, r2), o2 === YK ? o2 = jK.inflate(i2, s2) : o2 === XK && (o2 = zK)); i2.avail_in > 0 && o2 === qK && i2.state.wrap > 0 && 0 !== e9[i2.next_in]; ) jK.inflateReset(i2), o2 = jK.inflate(i2, s2);
    switch (o2) {
      case JK:
      case XK:
      case zK:
      case QK:
        return this.onEnd(o2), this.ended = true, false;
    }
    if (a2 = i2.avail_out, i2.next_out && (0 === i2.avail_out || o2 === qK)) if ("string" === this.options.to) {
      let e10 = FH.utf8border(i2.output, i2.next_out), t3 = i2.next_out - e10, r3 = FH.buf2string(i2.output, e10);
      i2.next_out = t3, i2.avail_out = n2 - t3, t3 && i2.output.set(i2.output.subarray(e10, e10 + t3), 0), this.onData(r3);
    } else this.onData(i2.output.length === i2.next_out ? i2.output : i2.output.subarray(0, i2.next_out));
    if (o2 !== YK || 0 !== a2) {
      if (o2 === qK) return o2 = jK.inflateEnd(this.strm), this.onEnd(o2), this.ended = true, true;
      if (0 === i2.avail_in) break;
    }
  }
  return true;
}, ZK.prototype.onData = function(e9) {
  this.chunks.push(e9);
}, ZK.prototype.onEnd = function(e9) {
  e9 === YK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = UH.flattenChunks(this.chunks)), this.chunks = [], this.err = e9, this.msg = this.strm.msg;
};
var eY = { Inflate: ZK, inflate: $K, inflateRaw: function(e9, t2) {
  return (t2 = t2 || {}).raw = true, $K(e9, t2);
}, ungzip: $K, constants: NW };
var { Deflate: tY, deflate: iY, deflateRaw: nY, gzip: rY } = $H;
var { Inflate: oY, inflate: sY, inflateRaw: aY, ungzip: cY } = eY;
var dY = iY;
var lY = sY;
var uY = function(e9) {
  return e9[e9.ONE_BYTE = 0] = "ONE_BYTE", e9[e9.TWO_BYTE = 1] = "TWO_BYTE", e9;
}(uY || {});
var hY = class {
  constructor() {
    Fg(this, "_sequence", 0), Fg(this, "_startTime", Date.now()), Fg(this, "isUseOneByte", true);
  }
  get startTime() {
    const e9 = Date.now() - this._startTime;
    return e9 < Math.pow(2, 16) ? e9 : (this._startTime += Math.pow(2, 16), this.startTime);
  }
  get sequence() {
    return this._sequence < Math.pow(2, 32) ? this._sequence++ : (this._sequence -= Math.pow(2, 32), this.sequence);
  }
  serialize(e9) {
    const t2 = { commonPacketHeader: { length: 0, reserved: 0, extension: 0, sequence: this.sequence }, commonStreamHeader: this.startTime, extension: void 0, payload: e9 };
    if (e9.byteLength > 128) {
      const i3 = new Uint8Array(4);
      i3.set([1, 0, 0, 0]);
      const n3 = { id: 0, length: 4, data: i3.buffer }, r3 = { profile: this.isUseOneByte ? 0 : 1, length: this.isUseOneByte ? 5 : 6, datas: [n3] };
      t2.commonPacketHeader.extension = 1, t2.extension = r3, t2.payload = this.compress(e9), t2.commonPacketHeader.length = 8 + (t2.extension.length + 2) + t2.payload.byteLength;
    } else t2.commonPacketHeader.length = 8 + t2.payload.byteLength;
    XA("SHOW_DATASTREAM2_LOG") && fb.debug("send data header: ".concat(JSON.stringify(t2.commonPacketHeader)));
    const i2 = new ArrayBuffer(t2.commonPacketHeader.length), n2 = new Uint8Array(i2), r2 = new DataView(i2);
    let o2 = 0;
    if (r2.setUint16(o2, t2.commonPacketHeader.extension << 15 | t2.commonPacketHeader.reserved << 14 | t2.commonPacketHeader.length, true), o2 += 2, r2.setUint32(o2, t2.commonPacketHeader.sequence, true), o2 += 4, r2.setUint16(o2, t2.commonStreamHeader, true), o2 += 2, t2.extension) {
      const e10 = this.serializeExtension(t2.extension);
      n2.set(new Uint8Array(e10), o2), o2 += e10.byteLength;
    }
    if (n2.set(new Uint8Array(t2.payload), o2), o2 += t2.payload.byteLength, o2 !== t2.commonPacketHeader.length) throw Error("serialize error!");
    return i2;
  }
  deserialize(e9) {
    if (e9.byteLength < 4) return new ArrayBuffer(0);
    const t2 = new DataView(e9);
    let i2 = 0;
    const n2 = t2.getUint16(i2, true);
    i2 += 2;
    const r2 = { length: 16383 & n2, reserved: (16384 & n2) >> 14, extension: (32768 & n2) >> 15, sequence: t2.getUint16(i2 + 2, true) << 16 | t2.getUint16(i2, true) };
    let o2, s2;
    if (i2 += 4, XA("SHOW_DATASTREAM2_LOG") && fb.debug("receive data header: ".concat(JSON.stringify(r2))), t2.getUint16(i2, true), i2 += 2, r2.extension) {
      s2 = this.deserializeExtension(e9.slice(i2)), i2 += 2 + s2.length, o2 = e9.slice(i2);
      let t3 = false;
      if (s2.datas.length > 0) {
        const e10 = s2.datas.find((e11) => 0 === e11.id);
        if (e10) {
          t3 = 1 == (1 & new DataView(e10.data).getUint32(0, true));
        }
      }
      o2 = t3 ? this.decompress(o2) : o2;
    } else o2 = e9.slice(8);
    return o2;
  }
  serializeExtension(e9) {
    const { profile: t2, length: i2, datas: n2 } = e9, r2 = new ArrayBuffer(i2 + 2), o2 = new Uint8Array(r2), s2 = new DataView(r2);
    let a2 = 0;
    if (s2.setUint8(a2++, t2), s2.setUint8(a2++, i2), n2.forEach((e10) => {
      t2 ? (s2.setUint8(a2++, e10.id), s2.setUint8(a2++, e10.length), o2.set(new Uint8Array(e10.data), a2), a2 += e10.data.byteLength) : (s2.setUint8(a2++, e10.id | e10.length << 4), o2.set(new Uint8Array(e10.data), a2), a2 += e10.data.byteLength);
    }), a2 !== i2 + 2) throw Error("serialize extension error, is ".concat(a2, "!==").concat(i2 + 2));
    return r2;
  }
  deserializeExtension(e9) {
    const t2 = new DataView(e9);
    let i2 = 0;
    const n2 = t2.getUint8(i2);
    i2++;
    const r2 = t2.getUint8(i2);
    i2++;
    const o2 = n2 === uY.TWO_BYTE, s2 = [], a2 = new DataView(e9, 2);
    let c2 = 0;
    for (; c2 < r2; ) {
      let e10 = 0, t3 = 0, i3 = new ArrayBuffer(0);
      o2 ? (e10 = a2.getUint8(c2), c2++, t3 = a2.getUint8(c2), c2++) : (e10 = 15 & a2.getUint8(c2), t3 = a2.getUint8(c2) >> 4, c2++), t3 > 0 && (i3 = a2.buffer.slice(c2 + 2, c2 + 2 + t3), c2 += i3.byteLength), s2.push({ id: e10, length: t3, data: i3 });
    }
    if (c2 !== r2) throw Error("parse error");
    return { profile: n2, length: r2, datas: s2 };
  }
  decompress(e9) {
    return lY(new Uint8Array(e9));
  }
  compress(e9) {
    return dY(new Uint8Array(e9));
  }
};
var pY = { name: "DataStream", create: (e9, t2) => {
  const i2 = t2 ? new bU(e9) : new wU(e9);
  return i2.useDataStream(new hY()), i2;
} };
var _Y = class extends xy {
  constructor(e9, t2, i2) {
    super(), Fg(this, "ws", void 0), Fg(this, "requestId", 1), Fg(this, "heartBeatTimer", void 0), Fg(this, "joinInfo", void 0), Fg(this, "clientId", void 0), Fg(this, "onOpen", () => {
      this.emit("open"), this.startHeartBeatCheck();
    }), Fg(this, "onClose", (e10) => {
      this.emit("close"), this.dispose();
    }), Fg(this, "onMessage", (e10) => {
      const t3 = JSON.parse(e10.data);
      if (!t3 || "serverResponse" !== t3.command || !t3.requestId) return t3 && "serverStatus" === t3.command && t3.serverStatus && t3.serverStatus.command ? (this.emit("status", t3.serverStatus), void this.emit(t3.serverStatus.command, t3.serverStatus)) : void 0;
      this.emit("req_".concat(t3.requestId), t3);
    }), this.joinInfo = e9, this.clientId = t2, this.ws = new HO("cross-channel-".concat(this.clientId), i2), this.ws.on(Uw.RECONNECTING, () => {
      this.ws.reconnectMode = "retry", this.emit("reconnecting");
    }), this.ws.on(Uw.CONNECTED, this.onOpen), this.ws.on(Uw.ON_MESSAGE, this.onMessage), this.ws.on(Uw.CLOSED, this.onClose);
  }
  isConnect() {
    return "connected" === this.ws.state;
  }
  sendMessage(e9) {
    const t2 = this.requestId++;
    return e9.requestId = t2, e9.seq = t2, this.ws.sendMessage(e9), t2;
  }
  waitStatus(e9) {
    return new Gh((t2, i2) => {
      const n2 = window.setTimeout(() => {
        i2(new yb(Ry.TIMEOUT, "wait status timeout, status: ".concat(e9)));
      }, 5e3);
      this.once(e9, (r2) => {
        window.clearTimeout(n2), r2.state && 0 !== r2.state ? i2(new yb(Ry.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: ".concat(e9))) : t2(void 0);
      }), this.once("dispose", () => {
        window.clearTimeout(n2), i2(new yb(Ry.WS_ABORT));
      });
    });
  }
  async request(e9) {
    if ("closed" === this.ws.state) throw new yb(Ry.WS_DISCONNECT);
    const t2 = () => new Gh((e10, t3) => {
      this.ws.once(Uw.CLOSED, () => t3(new yb(Ry.WS_ABORT))), this.ws.once(Uw.CONNECTED, e10);
    });
    "connected" !== this.ws.state && await t2();
    const i2 = this.sendMessage(e9), n2 = new Gh((e10, t3) => {
      const n3 = () => {
        t3(new yb(Ry.WS_ABORT));
      };
      this.ws.once(Uw.RECONNECTING, n3), this.ws.once(Uw.CLOSED, n3), this.once("req_".concat(i2), e10), mA(3e3).then(() => {
        this.removeAllListeners("req_".concat(i2)), this.ws.off(Uw.RECONNECTING, n3), this.ws.off(Uw.CLOSED, n3), t3(new yb(Ry.TIMEOUT, "cross channel ws request timeout"));
      });
    }), r2 = await n2;
    if (!r2 || 200 !== r2.code) throw new yb(Ry.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: ".concat(JSON.stringify(r2)));
    return r2;
  }
  async connect(e9) {
    this.ws.removeAllListeners(Uw.REQUEST_NEW_URLS), this.ws.on(Uw.REQUEST_NEW_URLS, (t2) => {
      t2(e9);
    }), await this.ws.init(e9);
  }
  dispose() {
    this.clearHeartBeatCheck(), this.emit("dispose"), this.removeAllListeners(), this.ws.close();
  }
  sendPing(e9) {
    const t2 = this.requestId++;
    return e9.requestId = t2, this.ws.sendMessage(e9), t2;
  }
  startHeartBeatCheck() {
    this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval(() => {
      this.sendPing({ command: "ping", appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sid: this.joinInfo.sid, ts: +/* @__PURE__ */ new Date(), requestId: 0 });
    }, 3e3);
  }
  clearHeartBeatCheck() {
    window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0;
  }
};
var EY = class extends xy {
  set state(e9) {
    e9 !== this._state && (e9 !== Xw.RELAY_STATE_FAILURE && (this.errorCode = Qw.RELAY_OK), this.emit("state", e9, this.errorCode), this._state = e9);
  }
  get state() {
    return this._state;
  }
  constructor(e9, t2, i2, n2, r2) {
    super(), Fg(this, "joinInfo", void 0), Fg(this, "sid", void 0), Fg(this, "clientId", void 0), Fg(this, "cancelToken", Lv.CancelToken.source()), Fg(this, "workerToken", void 0), Fg(this, "requestId", 0), Fg(this, "signal", void 0), Fg(this, "prevChannelMediaConfig", void 0), Fg(this, "httpRetryConfig", void 0), Fg(this, "_resolution", void 0), Fg(this, "_state", Xw.RELAY_STATE_IDLE), Fg(this, "errorCode", Qw.RELAY_OK), Fg(this, "onStatus", (e10) => {
      fb.debug("[".concat(this.clientId, "] ChannelMediaStatus: ").concat(JSON.stringify(e10))), e10 && e10.command && ("onAudioPacketReceived" === e10.command && this.emit("event", Jw.PACKET_RECEIVED_AUDIO_FROM_SRC), "onVideoPacketReceived" === e10.command && this.emit("event", Jw.PACKET_RECEIVED_VIDEO_FROM_SRC), "onSrcTokenPrivilegeDidExpire" === e10.command && (this.errorCode = Qw.SRC_TOKEN_EXPIRED, this.state = Xw.RELAY_STATE_FAILURE), "onDestTokenPrivilegeDidExpire" === e10.command && (this.errorCode = Qw.DEST_TOKEN_EXPIRED, this.state = Xw.RELAY_STATE_FAILURE));
    }), Fg(this, "onReconnect", async () => {
      fb.debug("[".concat(this.clientId, "] ChannelMediaSocket disconnect, reconnecting")), this.emit("event", Jw.NETWORK_DISCONNECTED), this.state = Xw.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch((e10) => {
        this.state !== Xw.RELAY_STATE_IDLE && (fb.error("auto restart channel media relay failed", e10.toString()), this.errorCode = Qw.SERVER_CONNECTION_LOST, this.state = Xw.RELAY_STATE_FAILURE);
      });
    }), this.joinInfo = e9, this.clientId = t2, this.sid = SA(), this.signal = new _Y(this.joinInfo, this.clientId, i2), this.httpRetryConfig = n2, this._resolution = r2;
  }
  async startChannelMediaRelay(e9) {
    if (this.state !== Xw.RELAY_STATE_IDLE) throw new yb(Ry.INVALID_OPERATION);
    this.state = Xw.RELAY_STATE_CONNECTING, await this.connect(), fb.debug("[".concat(this.clientId, "] startChannelMediaRelay: connect success"));
    try {
      await this.sendStartRelayMessage(e9);
    } catch (e10) {
      if (e10.data && e10.data.serverResponse && "SetSourceChannel" === e10.data.serverResponse.command) throw new yb(Ry.CROSS_CHANNEL_FAILED_JOIN_SRC);
      if (e10.data && e10.data.serverResponse && "SetDestChannelStatus" === e10.serverResponse.command) throw new yb(Ry.CROSS_CHANNEL_FAILED_JOIN_DEST);
      if (e10.data && e10.data.serverResponse && "StartPacketTransfer" === e10.serverResponse.command) throw new yb(Ry.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);
      throw e10;
    }
    this.prevChannelMediaConfig = e9;
  }
  async updateChannelMediaRelay(e9) {
    if (this.state !== Xw.RELAY_STATE_RUNNING) throw new yb(Ry.INVALID_OPERATION);
    await this.sendUpdateMessage(e9), this.prevChannelMediaConfig = e9;
  }
  async setVideoProfile(e9) {
    if (this._resolution = e9, this.state !== Xw.RELAY_STATE_RUNNING) throw new yb(Ry.INVALID_OPERATION);
    const t2 = this.genMessage(zw.SetVideoProfile);
    await this.signal.request(t2), fb.debug("[".concat(this.clientId, "] startChannelMediaRelay: setVideoProfile success"));
  }
  async stopChannelMediaRelay() {
    await this.sendStopRelayMessage(), fb.debug("[".concat(this.clientId, "] stopChannelMediaRelay: send stop message success")), this.state = Xw.RELAY_STATE_IDLE, this.dispose();
  }
  dispose() {
    fb.debug("[".concat(this.clientId, "] disposeChannelMediaRelay")), this.cancelToken.cancel(), this.cancelToken = Lv.CancelToken.source(), this.state = Xw.RELAY_STATE_IDLE, this.emit("dispose"), this.signal.dispose(), this.prevChannelMediaConfig = void 0;
  }
  async connect() {
    const e9 = await Qx(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);
    this.workerToken = e9.workerToken, await this.signal.connect(e9.addressList), this.emit("event", Jw.NETWORK_CONNECTED), this.signal.on("status", this.onStatus), this.signal.on("reconnecting", this.onReconnect);
  }
  async sendStartRelayMessage(e9) {
    const t2 = this.genMessage(zw.StopPacketTransfer);
    await this.signal.request(t2), await this.signal.waitStatus("Normal Quit"), fb.debug("[".concat(this.clientId, "] startChannelMediaRelay: StopPacketTransfer success"));
    const i2 = this.genMessage(zw.SetSdkProfile, e9);
    await this.signal.request(i2), fb.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSdkProfile success"));
    const n2 = this.genMessage(zw.SetSourceChannel, e9);
    await this.signal.request(n2), await this.signal.waitStatus("SetSourceChannelStatus"), this.emit("event", Jw.PACKET_JOINED_SRC_CHANNEL), fb.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceChannel success"));
    const r2 = this.genMessage(zw.SetSourceUserId, e9);
    await this.signal.request(r2), fb.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceUserId success"));
    const o2 = this.genMessage(zw.SetDestChannel, e9);
    await this.signal.request(o2), await this.signal.waitStatus("SetDestChannelStatus"), this.emit("event", Jw.PACKET_JOINED_DEST_CHANNEL), fb.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetDestChannel success"));
    const s2 = this.genMessage(zw.StartPacketTransfer, e9);
    await this.signal.request(s2), this.emit("event", Jw.PACKET_SENT_TO_DEST_CHANNEL), this.state = Xw.RELAY_STATE_RUNNING, fb.debug("[".concat(this.clientId, "] startChannelMediaRelay: StartPacketTransfer success")), this.setVideoProfile(this._resolution);
  }
  async sendUpdateMessage(e9) {
    const t2 = this.genMessage(zw.UpdateDestChannel, e9);
    await this.signal.request(t2), this.emit("event", Jw.PACKET_UPDATE_DEST_CHANNEL), fb.debug("[".concat(this.clientId, "] sendUpdateMessage: UpdateDestChannel success"));
  }
  async sendStopRelayMessage() {
    const e9 = this.genMessage(zw.StopPacketTransfer);
    await this.signal.request(e9), fb.debug("[".concat(this.clientId, "] sendStopRelayMessage: StopPacketTransfer success"));
  }
  genMessage(e9, t2) {
    const i2 = [], n2 = [], r2 = [];
    this.requestId += 1;
    const o2 = { appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sdkVersion: GA, sid: this.sid, ts: Date.now(), requestId: this.requestId, seq: this.requestId, allocate: true, clientRequest: {} };
    "4.22.1" === o2.sdkVersion && (o2.sdkVersion = "0.0.1");
    let s2 = null, a2 = null;
    switch (e9) {
      case zw.SetSdkProfile:
        return o2.clientRequest = { command: "SetSdkProfile", type: "multi_channel" }, o2;
      case zw.SetSourceChannel:
        if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2) throw new yb(Ry.UNEXPECTED_ERROR, "can not find source config");
        return o2.clientRequest = { command: "SetSourceChannel", uid: "0", channelName: a2.channelName, token: a2.token || this.joinInfo.appId }, o2;
      case zw.SetSourceUserId:
        if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2) throw new yb(Ry.UNEXPECTED_ERROR, "can not find source config");
        return o2.clientRequest = { command: "SetSourceUserId", uid: a2.uid + "" }, o2;
      case zw.SetDestChannel:
        if (s2 = t2 && t2.getDestChannelMediaInfo(), !s2) throw new yb(Ry.UNEXPECTED_ERROR, "can not find dest config");
        return s2.forEach((e10) => {
          i2.push(e10.channelName), n2.push(e10.uid + ""), r2.push(e10.token || this.joinInfo.appId);
        }), o2.clientRequest = { command: "SetDestChannel", channelName: i2, uid: n2, token: r2 }, o2;
      case zw.StartPacketTransfer:
        return o2.clientRequest = { command: "StartPacketTransfer" }, o2;
      case zw.Reconnect:
        return o2.clientRequest = { command: "Reconnect" }, o2;
      case zw.StopPacketTransfer:
        return o2.clientRequest = { command: "StopPacketTransfer" }, o2;
      case zw.UpdateDestChannel:
        if (s2 = t2 && t2.getDestChannelMediaInfo(), !s2) throw new yb(Ry.UNEXPECTED_ERROR, "can not find dest config");
        return s2.forEach((e10) => {
          i2.push(e10.channelName), n2.push(e10.uid + ""), r2.push(e10.token || this.joinInfo.appId);
        }), o2.clientRequest = { command: "UpdateDestChannel", channelName: i2, uid: n2, token: r2 }, o2;
      case zw.SetVideoProfile:
        o2.clientRequest = { command: "SetVideoProfile", width: this._resolution.width, height: this._resolution.height };
    }
    return o2;
  }
};
var fY = { name: "ChannelMediaRelay", create: function(e9) {
  return new EY(e9.joinInfo, e9.clientId, e9.websocketRetryConfig || PA, e9.httpRetryConfig || PA, e9.resolution);
} };
function mY(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function TY(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? mY(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : mY(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var SY = class extends xy {
  constructor(e9, t2, i2, n2) {
    super(), Fg(this, "spec", void 0), Fg(this, "token", void 0), Fg(this, "websocket", void 0), Fg(this, "pingpongTimer", void 0), Fg(this, "reconnectMode", "retry"), Fg(this, "serviceMode", void 0), Fg(this, "reqId", 0), Fg(this, "commandReqId", 0), Fg(this, "handleWebSocketOpen", () => {
      this.reconnectMode = "retry", this.startPingPong();
    }), Fg(this, "handleWebSocketMessage", (e10) => {
      if (!e10.data) return;
      const t3 = JSON.parse(e10.data);
      t3.requestId ? this.emit("@".concat(t3.requestId, "-").concat(t3.sid), t3) : (vb.workerEvent(this.spec.sid, { actionType: "status", serverCode: t3.code, workerType: this.serviceMode === Fw.TRANSCODE ? 1 : 2 }), this.emit(Hw.PUBLISH_STREAM_STATUS, t3));
    }), this.spec = t2, this.token = e9, this.serviceMode = n2, this.websocket = new HO("live-streaming", i2), this.websocket.on(Uw.CONNECTED, this.handleWebSocketOpen), this.websocket.on(Uw.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(Uw.REQUEST_NEW_URLS, (e10, t3) => {
      Zy(this, Hw.REQUEST_NEW_ADDRESS).then(e10).catch(t3);
    }), this.websocket.on(Uw.RECONNECTING, () => {
      this.websocket.reconnectMode = this.reconnectMode;
    });
  }
  init(e9) {
    return this.websocket.init(e9);
  }
  async request(e9, t2, i2, n2) {
    this.reqId += 1, "request" === e9 && (this.commandReqId += 1);
    const r2 = this.commandReqId, o2 = this.reqId;
    if (!o2 || !this.websocket) throw new yb(Ry.UNEXPECTED_ERROR);
    const s2 = TY({ command: e9, sdkVersion: "4.22.1" === GA ? "0.0.1" : GA, seq: o2, requestId: o2, allocate: i2, cname: this.spec.cname, appId: this.spec.appId, sid: this.spec.sid, uid: this.spec.uid.toString(), ts: Math.floor(Date.now() / 1e3) }, t2);
    if ("closed" === this.websocket.state) throw new yb(Ry.WS_DISCONNECT);
    const a2 = () => new Gh((e10, t3) => {
      this.websocket.once(Uw.CLOSED, () => t3(new yb(Ry.WS_ABORT))), this.websocket.once(Uw.CONNECTED, e10);
    });
    "connected" !== this.websocket.state && await a2(), s2.clientRequest && (s2.clientRequest.workerToken = this.token);
    const c2 = new Gh((e10, t3) => {
      const i3 = () => {
        t3(new yb(Ry.WS_ABORT));
      };
      this.websocket.once(Uw.RECONNECTING, i3), this.websocket.once(Uw.CLOSED, i3), this.once("@".concat(o2, "-").concat(this.spec.sid), (t4) => {
        e10(t4);
      });
    });
    n2 && vb.workerEvent(this.spec.sid, TY(TY({}, n2), {}, { requestId: r2, actionType: "request", payload: JSON.stringify(t2.clientRequest), serverCode: 0, code: 0 }));
    const d2 = Date.now();
    this.websocket.sendMessage(s2);
    let l2 = null;
    try {
      l2 = await c2;
    } catch (n3) {
      if ("closed" === this.websocket.state) throw n3;
      return await a2(), await this.request(e9, t2, i2);
    }
    return n2 && vb.workerEvent(this.spec.sid, TY(TY({}, n2), {}, { requestId: r2, actionType: "response", payload: JSON.stringify(l2.serverResponse), serverCode: l2.code, success: 200 === l2.code, responseTime: Date.now() - d2 })), 200 !== l2.code && this.handleResponseError(l2), l2;
  }
  tryNextAddress() {
    this.reconnectMode = "tryNext", this.websocket.reconnect("tryNext");
  }
  close() {
    const e9 = "4.22.1" === GA ? "0.0.1" : GA;
    this.reqId += 1, "connected" === this.websocket.state ? (this.websocket.sendMessage({ command: "request", appId: this.spec.appId, cname: this.spec.cname, uid: this.spec.uid.toString(), sdkVersion: e9, sid: this.spec.sid, seq: this.reqId, ts: Math.floor(Date.now() / 1e3), requestId: this.reqId, clientRequest: { command: "DestroyWorker" } }), this.websocket.close(false, true)) : this.websocket.close(false), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);
  }
  handleResponseError(e9) {
    switch (e9.code) {
      case Yw.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:
        return void fb.warning("live stream response already exists stream");
      case Yw.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:
      case Yw.LIVE_STREAM_RESPONSE_BAD_STREAM:
      case Yw.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:
        return new yb(Ry.LIVE_STREAMING_INVALID_ARGUMENT, "", { code: e9.code }).throw();
      case Yw.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:
        if ("UnpublishStream" === e9.serverResponse.command) return;
        throw new yb(Ry.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
      case Yw.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:
        return new yb(Ry.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", { code: e9.code }).throw();
      case Yw.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
        const t2 = new yb(Ry.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);
        return this.emit(Hw.WARNING, t2, e9.serverResponse.url);
      }
      case Yw.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN: {
        const t2 = new yb(Ry.LIVE_STREAMING_WARN_FREQUENT_REQUEST);
        return this.emit(Hw.WARNING, t2, e9.serverResponse.url);
      }
      case Yw.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:
        throw new yb(Ry.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
      case Yw.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:
        return new yb(Ry.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", { code: e9.code }).throw();
      case Yw.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM: {
        const t2 = new yb(Ry.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);
        return this.emit(Hw.WARNING, t2, e9.serverResponse.url);
      }
      case Yw.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:
        return new yb(Ry.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e9.code }).throw();
      case Yw.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:
        throw new yb(Ry.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", { retry: true, changeAddress: true });
      case Yw.LIVE_STREAM_RESPONSE_WORKER_LOST:
      case Yw.LIVE_STREAM_RESPONSE_WORKER_QUIT:
        if ("UnpublishStream" === e9.serverResponse.command) return;
        throw new yb(Ry.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
      case Yw.ERROR_FAIL_SEND_MESSAGE:
        if ("UnpublishStream" === e9.serverResponse.command) return;
        if ("UpdateTranscoding" === e9.serverResponse.command || "ControlStream" === e9.serverResponse.command) return new yb(Ry.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { code: e9.code }).throw();
        throw new yb(Ry.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
      case Yw.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
      case Yw.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
      case Yw.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
      case Yw.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
        return new yb(Ry.LIVE_STREAMING_CDN_ERROR, "", { code: e9.code }).throw();
    }
  }
  startPingPong() {
    this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(() => {
      "connected" === this.websocket.state && this.request("ping", {}).catch(gA);
    }, 6e3);
  }
};
function gY(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function RY(e9) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? gY(Object(i2), true).forEach(function(t3) {
      Fg(e9, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(i2)) : gY(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e9, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e9;
}
var CY = class extends xy {
  constructor(e9) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : PA, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : PA;
    super(), Fg(this, "onLiveStreamWarning", void 0), Fg(this, "onLiveStreamError", void 0), Fg(this, "spec", void 0), Fg(this, "retryTimeout", 1e4), Fg(this, "connection", void 0), Fg(this, "httpRetryConfig", void 0), Fg(this, "wsRetryConfig", void 0), Fg(this, "streamingTasks", /* @__PURE__ */ new Map()), Fg(this, "isStartingStreamingTask", false), Fg(this, "taskMutex", new NA("live-streaming")), Fg(this, "cancelToken", Lv.CancelToken.source()), Fg(this, "transcodingConfig", void 0), Fg(this, "uapResponse", void 0), Fg(this, "lastTaskId", 1), Fg(this, "statusError", /* @__PURE__ */ new Map()), this.spec = e9, this.httpRetryConfig = i2, this.wsRetryConfig = t2;
  }
  async setTranscodingConfig(e9) {
    const t2 = RY(RY({}, Ww), e9);
    66 !== t2.videoCodecProfile && 77 !== t2.videoCodecProfile && 100 !== t2.videoCodecProfile && (fb.debug("[".concat(this.spec.clientId, "] set transcoding config, fix video codec profile: ").concat(t2.videoCodecProfile, " -> 100")), t2.videoCodecProfile = 100), t2.transcodingUsers || (t2.transcodingUsers = t2.userConfigs), t2.transcodingUsers && (t2.transcodingUsers = t2.transcodingUsers.map((e10) => RY(RY(RY({}, Bw), e10), {}, { zOrder: e10.zOrder ? e10.zOrder + 1 : 1 }))), function(e10) {
      Oy(e10.width) || yy(e10.width, "config.width", 0, 1e4), Oy(e10.height) || yy(e10.height, "config.height", 0, 1e4), Oy(e10.videoBitrate) || yy(e10.videoBitrate, "config.videoBitrate", 1, 1e6), Oy(e10.videoFrameRate) || yy(e10.videoFrameRate, "config.videoFrameRate"), Oy(e10.lowLatency) || Iy(e10.lowLatency, "config.lowLatency"), Oy(e10.audioSampleRate) || vy(e10.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), Oy(e10.audioBitrate) || yy(e10.audioBitrate, "config.audioBitrate", 1, 128), Oy(e10.audioChannels) || vy(e10.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]), Oy(e10.videoGop) || yy(e10.videoGop, "config.videoGop"), Oy(e10.videoCodecProfile) || vy(e10.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]), Oy(e10.userCount) || yy(e10.userCount, "config.userCount", 0, 17), Oy(e10.backgroundColor) || yy(e10.backgroundColor, "config.backgroundColor", 0, 16777215), Oy(e10.userConfigExtraInfo) || by(e10.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, false), e10.transcodingUsers && !Oy(e10.transcodingUsers) && (wy(e10.transcodingUsers, "config.transcodingUsers"), e10.transcodingUsers.forEach((e11, t3) => {
        Vw(e11.uid), Oy(e11.x) || yy(e11.x, "transcodingUser[".concat(t3, "].x"), 0, 1e4), Oy(e11.y) || yy(e11.y, "transcodingUser[".concat(t3, "].y"), 0, 1e4), Oy(e11.width) || yy(e11.width, "transcodingUser[".concat(t3, "].width"), 0, 1e4), Oy(e11.height) || yy(e11.height, "transcodingUser[".concat(t3, "].height"), 0, 1e4), Oy(e11.zOrder) || yy(e11.zOrder - 1, "transcodingUser[".concat(t3, "].zOrder"), 0, 100), Oy(e11.alpha) || yy(e11.alpha, "transcodingUser[".concat(t3, "].alpha"), 0, 1, false);
      })), Oy(e10.watermark) || Gw(e10.watermark, "watermark"), Oy(e10.backgroundImage) || Gw(e10.backgroundImage, "backgroundImage"), e10.images && !Oy(e10.images) && (wy(e10.images, "config.images"), e10.images.forEach((e11, t3) => {
        Gw(e11, "images[".concat(t3, "]"));
      }));
    }(t2);
    const i2 = [];
    t2.images && i2.push(...t2.images.map((e10) => RY(RY(RY({}, jw), e10), {}, { zOrder: 255 }))), t2.backgroundImage && (i2.push(RY(RY(RY({}, jw), t2.backgroundImage), {}, { zOrder: 0 })), delete t2.backgroundImage), t2.watermark && (i2.push(RY(RY(RY({}, jw), t2.watermark), {}, { zOrder: 255 })), delete t2.watermark), t2.images = i2, t2.transcodingUsers && (t2.userConfigs = t2.transcodingUsers.map((e10) => RY({}, e10)), t2.userCount = t2.transcodingUsers.length, delete t2.transcodingUsers);
    const n2 = (t2.userConfigs || []).map((e10) => "number" == typeof e10.uid ? Gh.resolve(e10.uid) : Yx(e10.uid, this.spec, this.cancelToken.token, this.httpRetryConfig));
    if ((await Gh.all(n2)).forEach((e10, i3) => {
      t2.userConfigs && t2.userConfigs[i3] && (t2.userConfigs[i3].uid = e10);
    }), this.transcodingConfig = t2, this.connection) try {
      var r2;
      const e10 = await this.connection.request("request", { clientRequest: { command: "UpdateTranscoding", transcodingConfig: this.transcodingConfig } }, false, { command: "UpdateTranscoding", workerType: 1, requestByUser: true, tid: Array.from(_N(r2 = this.streamingTasks).call(r2)).map((e11) => e11.taskId).join("#") });
      fb.debug("[".concat(this.spec.clientId, "] update live transcoding config success, code: ").concat(e10.code, ", config:"), JSON.stringify(this.transcodingConfig));
    } catch (e10) {
      if (!e10.data || !e10.data.retry) throw e10;
      e10.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach((t3) => {
        fb.warning("[".concat(this.spec.clientId, "] live streaming receive error"), e10.toString(), "try to republish", t3.url), this.startLiveStreamingTask(t3.url, t3.mode, e10).then(() => {
          fb.debug("[".concat(this.spec.clientId, "] live streaming republish ").concat(t3.url, " success"));
        }).catch((e11) => {
          fb.error("[".concat(this.spec.clientId, "] live streaming republish failed"), t3.url, e11.toString()), this.onLiveStreamError && this.onLiveStreamError(t3.url, e11);
        });
      });
    }
  }
  async startLiveStreamingTask(e9, t2, i2) {
    if (!this.transcodingConfig && t2 === Fw.TRANSCODE) throw new yb(Ry.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task");
    const n2 = { command: "PublishStream", ts: Date.now(), url: e9, uid: this.spec.uid.toString(), autoDestroyTime: 100, acceptImageTimeout: true };
    fb.debug("[".concat(this.spec.clientId, "] start live streaming ").concat(e9, ", mode: ").concat(t2));
    const r2 = await this.taskMutex.lock();
    if (!this.connection && i2) return void r2();
    if (this.streamingTasks.get(e9) && !i2) return r2(), new yb(Ry.LIVE_STREAMING_TASK_CONFLICT).throw();
    try {
      this.connection || (this.connection = await this.connect(t2));
    } catch (e10) {
      throw r2(), e10;
    }
    switch (t2) {
      case Fw.TRANSCODE:
        n2.transcodingConfig = RY({}, this.transcodingConfig);
      case Fw.RAW:
    }
    this.uapResponse && this.uapResponse.vid && (n2.vid = this.uapResponse.vid), this.isStartingStreamingTask = true;
    const o2 = this.lastTaskId++;
    try {
      const s2 = new Gh((t3, n3) => {
        mA(this.retryTimeout).then(() => {
          if (i2) return n3(i2);
          const t4 = this.statusError.get(e9);
          return t4 ? (this.statusError.delete(e9), n3(t4)) : void 0;
        });
      }), a2 = await Gh.race([this.connection.request("request", { clientRequest: n2 }, true, { url: e9, command: "PublishStream", workerType: t2 === Fw.TRANSCODE ? 1 : 2, requestByUser: !i2, tid: o2.toString() }), s2]);
      this.isStartingStreamingTask = false, fb.debug("[".concat(this.spec.clientId, "] live streaming started, code: ").concat(a2.code)), this.streamingTasks.set(e9, { clientRequest: n2, mode: t2, url: e9, taskId: o2 }), r2();
    } catch (n3) {
      if (r2(), this.isStartingStreamingTask = false, !n3.data || !n3.data.retry || i2) throw n3;
      return n3.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e9, t2, n3)) : await this.startLiveStreamingTask(e9, t2, n3);
    }
  }
  stopLiveStreamingTask(e9) {
    return new Gh((t2, i2) => {
      const n2 = this.streamingTasks.get(e9);
      if (!n2 || !this.connection) return new yb(Ry.UNEXPECTED_ERROR, "can not find streaming task to stop").throw();
      const r2 = n2.mode;
      n2.abortTask = () => {
        fb.debug("[".concat(this.spec.clientId, "] stop live streaming success(worker exception)")), this.streamingTasks.delete(e9), t2();
      }, this.connection.request("request", { clientRequest: { command: "UnpublishStream", url: n2.url } }, false, { url: e9, command: "UnPublishStream", workerType: r2 === Fw.TRANSCODE ? 1 : 2, requestByUser: true, tid: (this.lastTaskId++).toString() }).then((i3) => {
        fb.debug("[".concat(this.spec.clientId, "] stop live streaming success, code: ").concat(i3.code)), this.streamingTasks.delete(e9), 0 === this.streamingTasks.size && (this.connection && this.connection.close(), this.connection = void 0), t2();
      }).catch(i2);
    });
  }
  resetAllTask() {
    var e9;
    const t2 = Array.from(_N(e9 = this.streamingTasks).call(e9));
    this.terminate();
    for (const e10 of t2) this.startLiveStreamingTask(e10.url, e10.mode).catch((t3) => {
      this.onLiveStreamError && this.onLiveStreamError(e10.url, t3);
    });
  }
  terminate() {
    this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = /* @__PURE__ */ new Map(), this.isStartingStreamingTask = false, this.statusError = /* @__PURE__ */ new Map(), this.cancelToken = Lv.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0;
  }
  async connect(e9) {
    if (this.connection) throw new yb(Ry.UNEXPECTED_ERROR, "live streaming connection has already connected");
    const t2 = await Zy(this, Kw.REQUEST_WORKER_MANAGER_LIST, e9);
    return this.uapResponse = t2, this.connection = new SY(t2.workerToken, this.spec, this.wsRetryConfig, e9), this.connection.on(Hw.WARNING, (e10, t3) => this.onLiveStreamWarning && this.onLiveStreamWarning(t3, e10)), this.connection.on(Hw.PUBLISH_STREAM_STATUS, (e10) => this.handlePublishStreamServer(e10)), this.connection.on(Hw.REQUEST_NEW_ADDRESS, (t3, i2) => {
      if (!this.connection) return i2(new yb(Ry.UNEXPECTED_ERROR, "can not get new live streaming address list"));
      Zy(this, Kw.REQUEST_WORKER_MANAGER_LIST, e9).then((e10) => {
        this.uapResponse = e10, t3(e10.addressList);
      }).catch(i2);
    }), await this.connection.init(t2.addressList), this.connection;
  }
  handlePublishStreamServer(e9) {
    const t2 = e9.serverStatus && e9.serverStatus.url || "empty_url", i2 = this.streamingTasks.get(t2), n2 = e9.reason;
    switch (e9.code) {
      case Yw.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
      case Yw.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
      case Yw.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
      case Yw.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: {
        const n3 = new yb(Ry.LIVE_STREAMING_CDN_ERROR, "", { code: e9.code });
        if (i2) return fb.error(n3.toString()), this.onLiveStreamError && this.onLiveStreamError(t2, n3);
        if (!this.isStartingStreamingTask) return;
        this.statusError.set(t2, n3);
      }
      case Yw.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
        const e10 = new yb(Ry.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, n2);
        return this.onLiveStreamWarning && this.onLiveStreamWarning(t2, e10);
      }
      case Yw.LIVE_STREAM_RESPONSE_WORKER_LOST:
      case Yw.LIVE_STREAM_RESPONSE_WORKER_QUIT: {
        var r2;
        if (!this.connection) return;
        this.connection.tryNextAddress();
        const t3 = Array.from(_N(r2 = this.streamingTasks).call(r2));
        for (const i3 of t3) i3.abortTask ? i3.abortTask() : (fb.warning("[".concat(this.spec.clientId, "] publish stream status code"), e9.code, "try to republish", i3.url), this.startLiveStreamingTask(i3.url, i3.mode, new yb(Ry.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e9.code })).then(() => {
          fb.debug("[".concat(this.spec.clientId, "] republish live stream success"), i3.url);
        }).catch((e10) => {
          fb.error(e10.toString()), this.onLiveStreamError && this.onLiveStreamError(i3.url, e10);
        }));
        return;
      }
    }
  }
  hasUrl(e9) {
    return this.streamingTasks.has(e9);
  }
};
var IY = { name: "LiveStreaming", create: function(e9) {
  return new CY(e9.joinInfo, e9.websocketRetryConfig || PA, e9.httpRetryConfig || PA);
} };
function vY(e9) {
  let t2 = MY();
  return function(e10, t3) {
    let i2 = e10.appId;
    void 0 !== i2 && (JY(t3, 10), GY(t3, i2));
    let n2 = e10.cid;
    void 0 !== n2 && (JY(t3, 16), JY(t3, n2));
    let r2 = e10.cname;
    void 0 !== r2 && (JY(t3, 26), GY(t3, r2));
    let o2 = e10.deviceId;
    void 0 !== o2 && (JY(t3, 34), GY(t3, o2));
    let s2 = e10.elapse;
    void 0 !== s2 && (JY(t3, 40), XY(t3, s2));
    let a2 = e10.fileSize;
    void 0 !== a2 && (JY(t3, 48), XY(t3, LY(a2)));
    let c2 = e10.height;
    void 0 !== c2 && (JY(t3, 56), XY(t3, LY(c2)));
    let d2 = e10.jpg;
    void 0 !== d2 && (JY(t3, 66), JY(t3, d2.length), function(e11, t4) {
      let i3 = FY(e11, t4.length);
      e11.bytes.set(t4, i3);
    }(t3, d2));
    let l2 = e10.networkType;
    void 0 !== l2 && (JY(t3, 72), XY(t3, LY(l2)));
    let u2 = e10.osType;
    void 0 !== u2 && (JY(t3, 80), XY(t3, LY(u2)));
    let h2 = e10.requestId;
    void 0 !== h2 && (JY(t3, 90), GY(t3, h2));
    let p2 = e10.sdkVersion;
    void 0 !== p2 && (JY(t3, 98), GY(t3, p2));
    let _2 = e10.sequence;
    void 0 !== _2 && (JY(t3, 104), XY(t3, LY(_2)));
    let E2 = e10.sid;
    void 0 !== E2 && (JY(t3, 114), GY(t3, E2));
    let f2 = e10.timestamp;
    void 0 !== f2 && (JY(t3, 120), XY(t3, f2));
    let m2 = e10.uid;
    void 0 !== m2 && (JY(t3, 128), JY(t3, m2));
    let T2 = e10.vid;
    void 0 !== T2 && (JY(t3, 136), JY(t3, T2));
    let S2 = e10.width;
    void 0 !== S2 && (JY(t3, 144), XY(t3, LY(S2)));
    let g2 = e10.service;
    void 0 !== g2 && (JY(t3, 152), JY(t3, g2));
    let R2 = e10.callbackData;
    void 0 !== R2 && (JY(t3, 162), GY(t3, R2));
    let C2 = e10.jpgEncryption;
    void 0 !== C2 && (JY(t3, 168), JY(t3, C2));
    let I2 = e10.requestType;
    void 0 !== I2 && (JY(t3, 176), JY(t3, I2));
    let v2 = e10.scorePorn;
    void 0 !== v2 && (JY(t3, 185), qY(t3, v2));
    let y2 = e10.scoreSexy;
    void 0 !== y2 && (JY(t3, 193), qY(t3, y2));
    let A2 = e10.scoreNeutral;
    void 0 !== A2 && (JY(t3, 201), qY(t3, A2));
    let b2 = e10.scene;
    void 0 !== b2 && (JY(t3, 208), JY(t3, b2));
    let w2 = e10.ossFilePrefix;
    void 0 !== w2 && (JY(t3, 218), GY(t3, w2));
    let O2 = e10.serviceVendor;
    if (void 0 !== O2) for (let e11 of O2) {
      JY(t3, 226);
      let i3 = MY();
      bY(e11, i3), JY(t3, i3.limit), WY(t3, i3), UY(i3);
    }
  }(e9, t2), function(e10) {
    let t3 = e10.bytes, i2 = e10.limit;
    return t3.length === i2 ? t3 : t3.subarray(0, i2);
  }(t2);
}
function yY(e9) {
  return function(e10) {
    let t3 = {};
    e: for (; !VY(e10); ) {
      let i2 = zY(e10);
      switch (i2 >>> 3) {
        case 0:
          break e;
        case 1:
          t3.code = zY(e10);
          break;
        case 2:
          t3.msg = jY(e10, zY(e10));
          break;
        case 3: {
          let i3 = wY(e10);
          t3.data = AY(e10), e10.limit = i3;
          break;
        }
        default:
          OY(e10, 7 & i2);
      }
    }
    return t3;
  }({ bytes: t2 = e9, offset: 0, limit: t2.length });
  var t2;
}
function AY(e9) {
  let t2 = {};
  e: for (; !VY(e9); ) {
    let i2 = zY(e9);
    switch (i2 >>> 3) {
      case 0:
        break e;
      case 1:
        t2.requestId = jY(e9, zY(e9));
        break;
      case 2:
        t2.requestType = zY(e9) >>> 0;
        break;
      case 3:
        t2.scorePorn = YY(e9);
        break;
      case 4:
        t2.scoreSexy = YY(e9);
        break;
      case 5:
        t2.scoreNeutral = YY(e9);
        break;
      case 6:
        t2.requestScene = zY(e9) >>> 0;
        break;
      case 7:
        t2.scene = zY(e9) >>> 0;
        break;
      default:
        OY(e9, 7 & i2);
    }
  }
  return t2;
}
function bY(e9, t2) {
  let i2 = e9.service;
  void 0 !== i2 && (JY(t2, 8), JY(t2, i2));
  let n2 = e9.vendor;
  void 0 !== n2 && (JY(t2, 16), JY(t2, n2));
  let r2 = e9.token;
  void 0 !== r2 && (JY(t2, 26), GY(t2, r2));
  let o2 = e9.callbackUrl;
  void 0 !== o2 && (JY(t2, 34), GY(t2, o2));
}
function wY(e9) {
  let t2 = zY(e9), i2 = e9.limit;
  return e9.limit = e9.offset + t2, i2;
}
function OY(e9, t2) {
  switch (t2) {
    case 0:
      for (; 128 & HY(e9); ) ;
      break;
    case 2:
      xY(e9, zY(e9));
      break;
    case 5:
      xY(e9, 4);
      break;
    case 1:
      xY(e9, 8);
      break;
    default:
      throw new Error("Unimplemented type: " + t2);
  }
}
var NY = new Float32Array(1);
new Uint8Array(NY.buffer);
var DY = new Float64Array(1);
var PY = new Uint8Array(DY.buffer);
function LY(e9) {
  return { low: e9 |= 0, high: e9 >> 31, unsigned: e9 >= 0 };
}
var kY = [];
function MY() {
  const e9 = kY.pop();
  return e9 ? (e9.offset = e9.limit = 0, e9) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
}
function UY(e9) {
  kY.push(e9);
}
function xY(e9, t2) {
  if (e9.offset + t2 > e9.limit) throw new Error("Skip past limit");
  e9.offset += t2;
}
function VY(e9) {
  return e9.offset >= e9.limit;
}
function FY(e9, t2) {
  let i2 = e9.bytes, n2 = e9.offset, r2 = e9.limit, o2 = n2 + t2;
  if (o2 > i2.length) {
    let t3 = new Uint8Array(2 * o2);
    t3.set(i2), e9.bytes = t3;
  }
  return e9.offset = o2, o2 > r2 && (e9.limit = o2), n2;
}
function BY(e9, t2) {
  let i2 = e9.offset;
  if (i2 + t2 > e9.limit) throw new Error("Read past limit");
  return e9.offset += t2, i2;
}
function jY(e9, t2) {
  let i2 = BY(e9, t2), n2 = String.fromCharCode, r2 = e9.bytes, o2 = "ï¿½", s2 = "";
  for (let e10 = 0; e10 < t2; e10++) {
    let a2, c2, d2, l2, u2 = r2[e10 + i2];
    0 == (128 & u2) ? s2 += n2(u2) : 192 == (224 & u2) ? e10 + 1 >= t2 ? s2 += o2 : (a2 = r2[e10 + i2 + 1], 128 != (192 & a2) ? s2 += o2 : (l2 = (31 & u2) << 6 | 63 & a2, l2 < 128 ? s2 += o2 : (s2 += n2(l2), e10++))) : 224 == (240 & u2) ? e10 + 2 >= t2 ? s2 += o2 : (a2 = r2[e10 + i2 + 1], c2 = r2[e10 + i2 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? s2 += o2 : (l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & c2, l2 < 2048 || l2 >= 55296 && l2 <= 57343 ? s2 += o2 : (s2 += n2(l2), e10 += 2))) : 240 == (248 & u2) ? e10 + 3 >= t2 ? s2 += o2 : (a2 = r2[e10 + i2 + 1], c2 = r2[e10 + i2 + 2], d2 = r2[e10 + i2 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? s2 += o2 : (l2 = (7 & u2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, l2 < 65536 || l2 > 1114111 ? s2 += o2 : (l2 -= 65536, s2 += n2(55296 + (l2 >> 10), 56320 + (1023 & l2)), e10 += 3))) : s2 += o2;
  }
  return s2;
}
function GY(e9, t2) {
  let i2 = t2.length, n2 = 0;
  for (let e10 = 0; e10 < i2; e10++) {
    let r3 = t2.charCodeAt(e10);
    r3 >= 55296 && r3 <= 56319 && e10 + 1 < i2 && (r3 = (r3 << 10) + t2.charCodeAt(++e10) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
  }
  JY(e9, n2);
  let r2 = FY(e9, n2), o2 = e9.bytes;
  for (let e10 = 0; e10 < i2; e10++) {
    let n3 = t2.charCodeAt(e10);
    n3 >= 55296 && n3 <= 56319 && e10 + 1 < i2 && (n3 = (n3 << 10) + t2.charCodeAt(++e10) - 56613888), n3 < 128 ? o2[r2++] = n3 : (n3 < 2048 ? o2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? o2[r2++] = n3 >> 12 & 15 | 224 : (o2[r2++] = n3 >> 18 & 7 | 240, o2[r2++] = n3 >> 12 & 63 | 128), o2[r2++] = n3 >> 6 & 63 | 128), o2[r2++] = 63 & n3 | 128);
  }
}
function WY(e9, t2) {
  let i2 = FY(e9, t2.limit), n2 = e9.bytes, r2 = t2.bytes;
  for (let e10 = 0, o2 = t2.limit; e10 < o2; e10++) n2[e10 + i2] = r2[e10];
}
function HY(e9) {
  return e9.bytes[BY(e9, 1)];
}
function KY(e9, t2) {
  let i2 = FY(e9, 1);
  e9.bytes[i2] = t2;
}
function YY(e9) {
  let t2 = BY(e9, 8), i2 = e9.bytes;
  return PY[0] = i2[t2++], PY[1] = i2[t2++], PY[2] = i2[t2++], PY[3] = i2[t2++], PY[4] = i2[t2++], PY[5] = i2[t2++], PY[6] = i2[t2++], PY[7] = i2[t2++], DY[0];
}
function qY(e9, t2) {
  let i2 = FY(e9, 8), n2 = e9.bytes;
  DY[0] = t2, n2[i2++] = PY[0], n2[i2++] = PY[1], n2[i2++] = PY[2], n2[i2++] = PY[3], n2[i2++] = PY[4], n2[i2++] = PY[5], n2[i2++] = PY[6], n2[i2++] = PY[7];
}
function zY(e9) {
  let t2, i2 = 0, n2 = 0;
  do {
    t2 = HY(e9), i2 < 32 && (n2 |= (127 & t2) << i2), i2 += 7;
  } while (128 & t2);
  return n2;
}
function JY(e9, t2) {
  for (t2 >>>= 0; t2 >= 128; ) KY(e9, 127 & t2 | 128), t2 >>>= 7;
  KY(e9, t2);
}
function XY(e9, t2) {
  let i2 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, o2 = 0 === r2 ? 0 === n2 ? i2 < 16384 ? i2 < 128 ? 1 : 2 : i2 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, s2 = FY(e9, o2), a2 = e9.bytes;
  switch (o2) {
    case 10:
      a2[s2 + 9] = r2 >>> 7 & 1;
    case 9:
      a2[s2 + 8] = 9 !== o2 ? 128 | r2 : 127 & r2;
    case 8:
      a2[s2 + 7] = 8 !== o2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
    case 7:
      a2[s2 + 6] = 7 !== o2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
    case 6:
      a2[s2 + 5] = 6 !== o2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
    case 5:
      a2[s2 + 4] = 5 !== o2 ? 128 | n2 : 127 & n2;
    case 4:
      a2[s2 + 3] = 4 !== o2 ? i2 >>> 21 | 128 : i2 >>> 21 & 127;
    case 3:
      a2[s2 + 2] = 3 !== o2 ? i2 >>> 14 | 128 : i2 >>> 14 & 127;
    case 2:
      a2[s2 + 1] = 2 !== o2 ? i2 >>> 7 | 128 : i2 >>> 7 & 127;
    case 1:
      a2[s2] = 1 !== o2 ? 128 | i2 : 127 & i2;
  }
}
function QY(e9, t2) {
  var i2 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e9);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e9, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
var ZY = /* @__PURE__ */ new Map([["moderation", 1], ["supervise", 2]]);
function $Y(e9) {
  return { low: e9 |= 0, high: e9 >> 31, unsigned: e9 >= 0 };
}
var eq = class extends xy {
  get connectionState() {
    return this._connectionState;
  }
  set connectionState(e9) {
    if (this._connectionState === e9) return;
    const t2 = this._connectionState;
    this._connectionState = e9, this.emit(mO.CONNECTION_STATE_CHANGE, t2, e9);
  }
  get inspectType() {
    return this._inspectType;
  }
  set inspectType(e9) {
    var t2;
    this._inspectMode = Jn(t2 = e9.map((e10) => ZY.get(e10) || 0)).call(t2, (e10, t3) => e10 + t3), this._inspectType = e9;
  }
  get quality() {
    return this._quality;
  }
  set quality(e9) {
    this._quality = e9 > 1 ? 1 : e9 < 0.1 ? 0.1 : e9, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout(() => {
      this.quality = this._quality / this.qualityRatio;
    }, 6e4));
  }
  constructor(e9) {
    super(), Fg(this, "name", "AgoraRTCVideoContentInspect"), Fg(this, "_connectionState", EO.CONNECTING), Fg(this, "_innerConnectionState", void 0), Fg(this, "sequence", 0), Fg(this, "inspectStartTime", void 0), Fg(this, "workerManagerConnection", void 0), Fg(this, "workerConnection", void 0), Fg(this, "workerMessageLengthLimit", void 0), Fg(this, "inspectIntervalMinimum", void 0), Fg(this, "qualityRatio", void 0), Fg(this, "_connectInfo", void 0), Fg(this, "_cancelTokenSource", Lv.CancelToken.source()), Fg(this, "_retryConfig", void 0), Fg(this, "wmSequence", 0), Fg(this, "inspectInterval", void 0), Fg(this, "inspectTimer", null), Fg(this, "ossFilePrefix", void 0), Fg(this, "extraInfo", void 0), Fg(this, "_inspectType", void 0), Fg(this, "_inspectMode", void 0), Fg(this, "_quality", 1), Fg(this, "qualityTimer", null), Fg(this, "_inspectId", void 0), Fg(this, "_needWorkUrlOnly", false), Fg(this, "inspectImage", () => {
      if (this.connectionState !== EO.CONNECTED) throw new yb(Ry.OPERATION_ABORTED, "content inspect service connection status is ".concat(this.connectionState));
      this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval(() => {
        this.connectionState === EO.CONNECTED ? this.requestToInspectImage() : fb.debug("[".concat(this._inspectId, "] Inspect State is not connected , "), this.connectionState);
      }, this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage();
    }), this._inspectId = TA(5, "inspect-"), this.workerMessageLengthLimit = XA("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"), this.inspectIntervalMinimum = XA("VIDEO_INSPECT_INTERVAL_MINIMUM"), this.qualityRatio = XA("VIDEO_INSPECT_QUALITY_RATIO"), this.inspectInterval = e9.interval, this.ossFilePrefix = e9.ossFilePrefix, this.extraInfo = e9.extraInfo, this.inspectType = e9.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new HO("worker-manager-" + this._inspectId, PA), this.on(mO.STATE_CHANGE, (e10, t2) => {
      this._innerConnectionState = e10, fb.debug("[".concat(this._inspectId, "] Inspect operation :").concat(fO[e10], " ").concat(t2 || ""));
    }), this.handleWorkerManagerEvents(), this.workerConnection = new HO("worker-" + this._inspectId, PA), this.handleWorkerEvents();
  }
  async init(e9, t2) {
    this.emit(mO.STATE_CHANGE, fO.CONNECT_AP), this._connectInfo = e9;
    const i2 = this._cancelTokenSource.token;
    return this._retryConfig = t2, new Gh((n2, r2) => {
      this.on(mO.CONNECTION_STATE_CHANGE, (e10, t3) => {
        t3 === EO.CONNECTED && n2();
      }), this.requestAP(e9, i2, t2).then((e10) => {
        this.connectWorkerManager(e10);
      }).catch((e10) => {
        r2(e10);
      });
    });
  }
  async requestAP(e9, t2, i2) {
    const n2 = XA("WEBCS_DOMAIN").map((e10) => "https://".concat(e10, "/api/v1")), r2 = await function(e10, t3, i3, n3) {
      let { appId: r3, areaCode: o3, cname: s2, sid: a2, token: c2, uid: d2 } = t3;
      Bx++;
      const l2 = "image_moderation_api", u2 = { service_name: l2, json_body: JSON.stringify({ appId: r3, areaCode: o3, cname: s2, command: "allocateEdge", requestId: Bx, seq: Bx, sid: a2, token: c2, ts: Date.now(), uid: d2 + "" }) };
      let h2, p2, _2 = e10[0];
      return kA(async () => {
        h2 = Date.now();
        const e11 = await Tx(_2, { data: u2, cancelToken: i3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
        if (p2 = Date.now() - h2, 0 !== e11.code) {
          const t5 = new yb(Ry.UNEXPECTED_RESPONSE, "image inspect ap error, code" + e11.code, { retry: true, responseTime: p2 });
          throw fb.error(t5.toString()), t5;
        }
        const t4 = JSON.parse(e11.json_body);
        if (200 !== t4.code) {
          const e12 = new yb(Ry.UNEXPECTED_RESPONSE, "image inspect ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p2 });
          throw fb.error(e12.toString()), e12;
        }
        if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
          const e12 = new yb(Ry.UNEXPECTED_RESPONSE, "image inspect ap empty server", { code: t4.code, responseTime: p2 });
          throw fb.error(e12.toString()), e12;
        }
        const n4 = XA("VIDEO_INSPECT_WORKER_MANAGER_HOST"), r4 = XA("VIDEO_INSPECT_WORKER_MANAGER_PORT");
        return { addressList: t4.servers.map((e12) => {
          let { address: t5, wss: i4 } = e12;
          if (t5 && i4) return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(n4, ":").concat(r4 || i4);
        }).filter((e12) => !!e12), workerToken: t4.workerToken, vid: t4.vid, responseTime: p2 };
      }, (t4, i4) => (vb.apworkerEvent(a2, { success: true, sc: 200, serviceName: l2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i4, responseTime: p2, serverIp: e10[i4 % e10.length] }), false), (t4, i4) => (vb.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: l2, responseTime: p2, serverIp: e10[i4 % e10.length] }), !!(t4.code !== Ry.OPERATION_ABORTED && t4.code !== Ry.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e10[(i4 + 1) % e10.length], true)), n3);
    }(n2, e9, t2, i2);
    this.emit(mO.STATE_CHANGE, fO.AP_CONNECTED);
    const { addressList: o2 } = r2;
    return this.wmSequence++, o2;
  }
  async connectWorkerManager(e9) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this._needWorkUrlOnly = t2, this.emit(mO.STATE_CHANGE, fO.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e9, 1e4);
  }
  async connectWorker(e9) {
    await this.workerConnection.init([e9]);
  }
  handleWorkerManagerEvents() {
    this.workerManagerConnection.on(Uw.CONNECTED, async () => {
      this.emit(mO.STATE_CHANGE, fO.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({ appId: this._connectInfo.appId, cname: this._connectInfo.cname, uid: this._connectInfo.uid + "", sdkVersion: "4.22.1", sid: this._connectInfo.sid, seq: this.wmSequence, ts: Number(Date.now()), requestId: Math.floor(1e12 * Math.random()), allocate: true, clientRequest: { command: "join" } }, true);
    }), this.workerManagerConnection.on(Uw.CLOSED, () => {
      this._innerConnectionState < fO.GET_WORKER_MANAGER_RESPONSE && fb.debug("[".concat(this._inspectId, "] Inspect worker manager is closed before connecting worker"));
    }), this.workerManagerConnection.on(Uw.FAILED, () => {
      this._innerConnectionState < fO.GET_WORKER_MANAGER_RESPONSE && fb.debug("[".concat(this._inspectId, "] Connecting inspect worker manager is failed before connecting worker"));
    }), this.workerManagerConnection.on(Uw.RECONNECTING, () => {
      this._innerConnectionState < fO.GET_WORKER_MANAGER_RESPONSE && fb.debug("[".concat(this._inspectId, "] Inspect worker manager is reconnecting before connecting worker"));
    }), this.workerManagerConnection.on(Uw.ON_MESSAGE, async (e9) => {
      this.emit(mO.STATE_CHANGE, fO.GET_WORKER_MANAGER_RESPONSE);
      const t2 = this.workerManagerConnection.url;
      this.workerManagerConnection.close();
      const i2 = JSON.parse(e9.data);
      if (200 !== i2.code) throw fb.error("[".concat(this._inspectId, "] Unexpected code ").concat(i2.code, " from worker manager")), new yb(Ry.UNEXPECTED_RESPONSE, "response code of worker is unexpected", i2);
      if (!(i2.serverResponse && i2.serverResponse.portWss && t2)) throw fb.error("[".concat(this._inspectId, "] Unexpected content from worker manager : ").concat(JSON.stringify(i2))), new yb(Ry.UNEXPECTED_RESPONSE, "response content of worker is unexpected", i2);
      {
        const e10 = XA("VIDEO_INSPECT_WORKER_PORT") || i2.serverResponse.portWss, n2 = t2.replace(/:\d+\/?$/, ":".concat(e10));
        this.emit(mO.STATE_CHANGE, fO.CONNECT_WORKER, n2), this._needWorkUrlOnly ? this.emit(mO.REQUEST_NEW_WORKER_URL, n2) : await this.connectWorker(n2);
      }
    }), this.workerManagerConnection.on(Uw.WILL_RECONNECT, (e9, t2, i2) => {
      i2(e9);
    }), this.workerManagerConnection.on(Uw.REQUEST_NEW_URLS, (e9, t2) => {
      this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e9).catch(t2);
    });
  }
  handleWorkerEvents() {
    this.workerConnection.on(Uw.CONNECTED, async () => {
      this.emit(mO.STATE_CHANGE, fO.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = EO.CONNECTED;
    }), this.workerConnection.on(Uw.ON_MESSAGE, async (e9) => {
      if (e9.data instanceof ArrayBuffer) {
        const i2 = yY(new Uint8Array(e9.data));
        if (XA("SHOW_VIDEO_INSPECT_WORKER_MESSAGE") && fb.debug("[".concat(this._inspectId, "] Response message for worker of inspect content "), JSON.stringify(i2)), 200 === i2.code) {
          if (Array.isArray(this.inspectType) && 1 === this.inspectType.length && "supervise" === this.inspectType[0]) return void this.emit(mO.INSPECT_RESULT, void 0, void 0);
          if (i2.data && i2.data.scorePorn && i2.data.scoreSexy && i2.data.scoreNeutral) {
            var t2;
            const e10 = { porn: i2.data.scorePorn, sexy: i2.data.scoreSexy, neutral: i2.data.scoreNeutral }, n2 = Jn(t2 = Object.keys(e10)).call(t2, (t3, i3) => e10[t3] > e10[i3] ? t3 : i3, "porn"), r2 = Object.keys(e10).find((e11) => e11 === n2);
            this.emit(mO.INSPECT_RESULT, r2);
          } else this.emit(mO.INSPECT_RESULT, void 0, new yb(Ry.UNEXPECTED_RESPONSE, i2.code + "", "There is an unexpected data on message"));
        } else this.emit(mO.INSPECT_RESULT, void 0, new yb(Ry.UNEXPECTED_RESPONSE, i2.code + "", i2.msg));
      } else fb.error("[".concat(this._inspectId, "] Unexpected message type from worker")), this.emit(mO.INSPECT_RESULT, void 0, new yb(Ry.UNEXPECTED_RESPONSE, "invalid worker message type"));
    }), this.workerConnection.on(Uw.CLOSED, () => {
      this.connectionState = EO.CLOSED;
    }), this.workerConnection.on(Uw.FAILED, () => {
      this.connectionState = EO.CLOSED;
    }), this.workerConnection.on(Uw.RECONNECTING, () => {
      this.connectionState = this.connectionState === EO.CONNECTED ? EO.RECONNECTING : EO.CONNECTING;
    }), this.workerConnection.on(Uw.WILL_RECONNECT, (e9, t2, i2) => {
      "recover" === e9 && i2(e9), i2("tryNext");
    }), this.workerConnection.on(Uw.REQUEST_NEW_URLS, (e9, t2) => {
      this.workerManagerConnection.close(), this.once(mO.REQUEST_NEW_WORKER_URL, (t3) => {
        e9([t3]);
      }), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then((e10) => {
        this.connectWorkerManager(e10, true);
      }).catch((e10) => {
        t2(e10);
      });
    });
  }
  async requestToInspectImage() {
    this.sequence++;
    const e9 = eA(this, mO.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
    if (e9) {
      if (!e9.isPlaying) return void this.emit(mO.INSPECT_RESULT, void 0, new yb(Ry.INVALID_OPERATION, "Only the track being played can be inspected"));
      const i2 = await this.generateRequestData(e9, t2);
      this.workerConnection.sendMessage(i2, true, true);
    } else this.emit(mO.INSPECT_RESULT, void 0, new yb(Ry.INVALID_OPERATION, "Only the track being published can be inspected"));
  }
  async generateRequestData(e9, t2) {
    let { appId: i2, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 } = t2;
    const c2 = Date.now(), d2 = await e9.getCurrentFrameImage("image/jpeg", this.quality), l2 = await Ok(d2, i2, n2), u2 = this.sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + TA(12, ""), h2 = { appId: i2, cid: r2, cname: n2, deviceId: "", elapse: $Y(Number(c2 - this.inspectStartTime)), fileSize: l2.byteLength, jpgEncryption: 2, height: d2.height, width: d2.width, jpg: l2, networkType: 6, osType: 7, requestId: u2, sdkVersion: "4.22.1", sequence: this.sequence, sid: s2, timestamp: $Y(c2), uid: a2, vid: o2, service: this._inspectMode, callbackData: this.extraInfo, ossFilePrefix: this.ossFilePrefix };
    void 0 === this.extraInfo && delete h2.callbackData, void 0 === this.ossFilePrefix && delete h2.ossFilePrefix;
    const p2 = vY(h2);
    if (p2.byteLength < this.workerMessageLengthLimit) {
      if (XA("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")) {
        const e10 = function(e11) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var i3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? QY(Object(i3), true).forEach(function(t4) {
              Fg(e11, t4, i3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e11, Object.getOwnPropertyDescriptors(i3)) : QY(Object(i3)).forEach(function(t4) {
              Object.defineProperty(e11, t4, Object.getOwnPropertyDescriptor(i3, t4));
            });
          }
          return e11;
        }({}, h2);
        delete e10.jpg, fb.debug("[".concat(this._inspectId, "] Request message for worker of inspect content "), JSON.stringify(e10));
      }
      return p2;
    }
    {
      const t3 = this.quality * this.qualityRatio;
      return this.quality = t3, await this.generateRequestData(e9, { appId: i2, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 });
    }
  }
  close() {
    this._cancelTokenSource.cancel(), this._cancelTokenSource = Lv.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = EO.CLOSED, this.emit(mO.STATE_CHANGE, fO.CLOSED);
  }
};
var tq = { name: "ContentInspect", create: function(e9) {
  let { config: t2 } = e9;
  return function(e10) {
    if (!e10) throw new yb(Ry.INVALID_PARAMS, "inspectConfig is necessary.");
    if (!e10.inspectType || !Array.isArray(e10.inspectType)) throw new yb(Ry.INVALID_PARAMS, "inspectConfig.inspectType is necessary and is an instance of Array.");
    {
      const t3 = [...new Set(e10.inspectType)];
      t3.forEach((e11) => {
        var t4;
        if (!Dn(t4 = ["supervise", "moderation"]).call(t4, e11)) throw new yb(Ry.INVALID_PARAMS, "".concat(e11, " is not a valid inspect type."));
      }), e10.inspectType = t3;
    }
    if (e10 && e10.extraInfo && e10.extraInfo.length > 1024) throw new yb(Ry.INVALID_PARAMS, "inspectConfig.extraInfo length cannot exceed 1024 bytes");
  }(t2), new eq(t2);
} };
JA("PROCESS_ID", "process-".concat(TA(8, ""), "-").concat(TA(4, ""), "-").concat(TA(4, ""), "-").concat(TA(4, ""), "-").concat(TA(12, ""))), function() {
  let e9;
  try {
    e9 = window.localStorage.getItem("websdk_ng_global_parameter");
  } catch (e10) {
    return void fb.error("Error loading sdk config", e10.message);
  }
  if (e9) try {
    const t2 = JSON.parse(window.atob(e9)), i2 = Date.now();
    fb.debug("Loading global parameters from cache", t2), Object.keys(t2).forEach((e10) => {
      if (Object.prototype.hasOwnProperty.call(zA, e10)) {
        const { value: n2, expires: r2 } = t2[e10];
        if (r2 && r2 <= i2) return;
        QA[e10] = n2, zA[e10] = n2;
      }
    });
  } catch (t2) {
    fb.error("Error loading mutableParamsCache: ".concat(e9), t2.message);
  }
}(), Array.isArray(QA.AREAS) && QA.AREAS.length > 0 && bx(QA.AREAS, true);
var iq = (e9, t2, i2) => {
  fb.debug("setParameter key:".concat(e9, ", value:").concat(JSON.stringify(t2))), JA(e9, t2, i2);
};
SB(fY, false), SB(IY, false), SB(kj, false), SB(tq, false), SB(pY, false);
var nq = function(e9) {
  const t2 = new xy(), i2 = e9, n2 = { getListeners: t2.getListeners.bind(t2), on: (e10, i3) => (function(e11, t3) {
    e11 === SO.SECURITY_POLICY_VIOLATION && LG(t3, true);
  }(e10, i3), t2.on.bind(t2)(e10, i3)), addListener: t2.addListener.bind(t2), once: t2.once.bind(t2), off: t2.off.bind(t2), removeAllListeners: t2.removeAllListeners.bind(t2), emit: t2.emit.bind(t2), safeEmit: t2.safeEmit.bind(t2) };
  return DG(DG({}, i2), n2);
}({ __TRACK_LIST__: _L, VERSION: GA, BUILD: qA, ESM_BUNDLER: false, ESM: true, UMD: false, DEV: false, setParameter: iq, getParameter: XA, getSupportedCodec: async function() {
  let e9 = { audio: [], video: [] };
  try {
    let t2 = new RTCPeerConnection();
    const i2 = await async function(e10) {
      let t3;
      return ZP().supportUnifiedPlan ? (e10.addTransceiver("video", { direction: "recvonly" }), e10.addTransceiver("audio", { direction: "recvonly" }), t3 = (await e10.createOffer()).sdp) : t3 = (await e10.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true })).sdp, t3;
    }(t2);
    if (!i2) return e9;
    t2.close(), t2 = null, e9 = function(e10) {
      const t3 = { video: [], audio: [] };
      return e10.match(/ VP8/i) && t3.video.push("VP8"), e10.match(/ VP9/i) && t3.video.push("VP9"), e10.match(/ AV1/i) && t3.video.push("AV1"), e10.match(/ H264/i) && t3.video.push("H264"), e10.match(/ H265/i) && t3.video.push("H265"), e10.match(/ opus/i) && t3.audio.push("OPUS"), e10.match(/ PCMU/i) && t3.audio.push("PCMU"), e10.match(/ PCMA/i) && t3.audio.push("PCMA"), e10.match(/ G722/i) && t3.audio.push("G722"), t3;
    }(i2);
  } catch (e10) {
    throw new yb(Ry.CREATE_OFFER_FAILED, e10.toString && e10.toString()).print();
  }
  return e9;
}, checkSystemRequirements: function() {
  const e9 = vb.reportApiInvoke(null, { name: By.CHECK_SYSTEM_REQUIREMENTS, options: [], tag: jy.TRACER });
  let t2 = false;
  try {
    const e10 = window.RTCPeerConnection, i3 = navigator.mediaDevices && navigator.mediaDevices.getUserMedia, n3 = window.WebSocket;
    t2 = !!(e10 && i3 && n3), t2 && _y() && ty(75) && new e10().close();
  } catch (e10) {
    return fb.error("check system requirement failed: ", e10), false;
  }
  let i2 = false;
  const n2 = Hv();
  n2.name === Bv.CHROME && Number(n2.version) >= 58 && ("WebKit" !== Gv.engine.name || function() {
    const e10 = Hv();
    if (zv()) {
      if (e10.os === Fv.MAC_OS) return true;
      if (e10.os === Fv.IOS) {
        const e11 = Gv.os.version && Gv.os.version.split(".");
        if (e11 && 14 === Number(e11[0]) && e11[1] && Number(e11[1]) >= 3) return true;
        if (e11 && Number(e11[0]) > 14) return true;
      }
    }
    return false;
  }()) && (i2 = true), (n2.name === Bv.FIREFOX && Number(n2.version) >= 56 || n2.name === Bv.OPERA && Number(n2.version) >= 45 || n2.name === Bv.SAFARI && Number(n2.version) >= 11 || "WebKit" === n2.name && ($v() || uy()) && n2.osVersion && Number(n2.osVersion.split(".")[0]) >= 11 || hy() || Hv().name === Bv.QQ) && (i2 = true), fb.debug("checkSystemRequirements, api:", t2, "browser", i2);
  const r2 = t2 && i2;
  return e9.onSuccess(r2), r2;
}, getDevices: function(e9) {
  return uk.enumerateDevices(true, true, e9);
}, getMicrophones: function(e9) {
  return uk.getRecordingDevices(e9);
}, getCameras: function(e9) {
  return uk.getCamerasDevices(e9);
}, getElectronScreenSources: nk, getPlaybackDevices: function(e9) {
  return uk.getSpeakers(e9);
}, createClient: function() {
  var e9;
  let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { codec: "vp8", audioCodec: "opus", mode: "rtc" };
  const i2 = vb.reportApiInvoke(null, { name: By.CREATE_CLIENT, options: [t2], tag: jy.TRACER });
  try {
    !function(e10) {
      vy(e10.codec, "config.codec", ["vp8", "vp9", "av1", "h264", "h265"]), vy(e10.mode, "config.mode", ["rtc", "live", "p2p"]), void 0 !== e10.audioCodec && vy(e10.audioCodec, "config.audioCodec", ["opus", "pcmu", "pcma", "g722"]), void 0 !== e10.proxyServer && by(e10.proxyServer, "config.proxyServer", 1, 1e4), void 0 !== e10.turnServer && Yy(e10.turnServer), void 0 !== e10.httpRetryConfig && Gy(e10.httpRetryConfig), void 0 !== e10.websocketRetryConfig && Gy(e10.websocketRetryConfig);
    }(t2);
  } catch (e10) {
    throw i2.onError(e10), e10;
  }
  return (ry(16, 0, true) || oy(16, 0, true)) && ("vp9" === t2.codec && (t2.codec = "vp8", fb.debug("browser not support vp9, force use vp8")), JA("UNSUPPORTED_VIDEO_CODEC", ["vp9"])), void 0 === t2.audioCodec && (t2.audioCodec = "opus"), i2.onSuccess(), new vG(IG(IG({ forceWaitGatewayResponse: true }, t2), {}, { role: Dn(e9 = ["rtc", "p2p"]).call(e9, t2.mode) ? "host" : t2.role || "audience" }));
}, createCameraVideoTrack: async function() {
  let e9 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  const t2 = XA("CAMERA_CAPTURE_CONFIG"), i2 = vb.reportApiInvoke(null, { tag: jy.TRACER, name: By.CREATE_CAM_VIDEO_TRACK, options: [GL({}, e9), t2] });
  t2 && (e9.encoderConfig = t2);
  const n2 = Ak(e9), r2 = TA(8, "track-cam-");
  let o2 = null;
  fb.info("start create camera video track with config", JSON.stringify(e9), "trackId", r2);
  try {
    o2 = (await ak({ video: n2 }, r2)).getVideoTracks()[0] || null;
  } catch (e10) {
    throw i2.onError(e10), e10;
  }
  if (!o2) {
    const e10 = new Cy(Ry.UNEXPECTED_ERROR, "can not find track in media stream");
    return i2.onError(e10), e10.throw(fb);
  }
  e9.optimizationMode && dU(r2, o2, e9, dL(e9.encoderConfig));
  const s2 = new cU(o2, e9, n2, e9.scalabiltyMode ? uL(e9.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e9.optimizationMode, r2);
  return i2.onSuccess(s2.getTrackId()), fb.info("create camera video success, trackId:", r2), s2;
}, createCustomVideoTrack: function(e9) {
  const t2 = vb.reportApiInvoke(null, { tag: jy.TRACER, name: By.CREATE_CUSTOM_VIDEO_TRACK, options: [e9] }), i2 = new aU(e9.mediaStreamTrack, { width: e9.width, height: e9.height, frameRate: e9.frameRate, bitrateMax: e9.bitrateMax, bitrateMin: e9.bitrateMin }, e9.scalabiltyMode ? uL(e9.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e9.optimizationMode, TA(8, "track-cus-"), [mL.CUSTOM_TRACK]);
  return t2.onSuccess(i2.getTrackId()), fb.info("create custom video track success with config", e9, "trackId", i2.getTrackId()), i2;
}, createScreenVideoTrack: async function() {
  let e9 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "disable";
  const i2 = vb.reportApiInvoke(null, { tag: jy.TRACER, name: By.CREATE_SCREEN_VIDEO_TRACK, options: [GL({}, e9), t2] });
  e9.encoderConfig ? "string" == typeof e9.encoderConfig || e9.encoderConfig.width && e9.encoderConfig.height || (e9.encoderConfig.width = { max: 1920 }, e9.encoderConfig.height = { max: 1080 }) : e9.encoderConfig = "1080p_2";
  const n2 = function(e10) {
    const t3 = {};
    e10.screenSourceType && (t3.mediaSource = e10.screenSourceType), e10.extensionId && Jv() && (t3.extensionId = e10.extensionId);
    const { displaySurface: i3, selfBrowserSurface: n3, surfaceSwitching: r3, systemAudio: o3 } = e10;
    (ey(107) || iy(107) || sy(93)) && (i3 && (vy(i3, "displaySurface", ["browser", "window", "monitor"]), t3.displaySurface = i3), n3 ? (vy(n3, "selfBrowserSurface", ["exclude", "include"]), t3.selfBrowserSurface = n3) : t3.selfBrowserSurface = "include", r3 && (vy(r3, "surfaceSwitching", ["exclude", "include"]), t3.surfaceSwitching = r3)), (ey(105) || iy(105) || sy(91)) && o3 && (vy(o3, "systemAudio", ["exclude", "include"]), t3.systemAudio = o3), e10.electronScreenSourceId && (t3.sourceId = e10.electronScreenSourceId);
    const s3 = e10.encoderConfig ? lL(e10.encoderConfig) : null;
    return t3.mandatory = { chromeMediaSource: "desktop", maxWidth: s3 ? s3.width : void 0, maxHeight: s3 ? s3.height : void 0 }, s3 && (s3.frameRate && ("number" == typeof s3.frameRate ? (t3.mandatory.maxFrameRate = s3.frameRate, t3.mandatory.minFrameRate = s3.frameRate) : (t3.mandatory.maxFrameRate = s3.frameRate.max || s3.frameRate.ideal || s3.frameRate.exact || void 0, t3.mandatory.minFrameRate = s3.frameRate.min || s3.frameRate.ideal || s3.frameRate.exact || void 0), t3.frameRate = s3.frameRate), s3.width && (t3.width = s3.width), s3.height && (t3.height = s3.height)), t3;
  }(e9), r2 = TA(8, "track-scr-v-");
  let o2 = null, s2 = null;
  const a2 = ZP();
  if (!a2.supportShareAudio && "enable" === t2) {
    const e10 = new Cy(Ry.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio");
    return i2.onError(e10), e10.throw(fb);
  }
  fb.info("start create screen video track with config", e9, "withAudio", t2, "trackId", r2);
  try {
    const e10 = await ak({ screen: n2, screenAudio: "auto" === t2 ? a2.supportShareAudio : "enable" === t2 }, r2);
    o2 = e10.getVideoTracks()[0] || null, s2 = e10.getAudioTracks()[0] || null;
  } catch (e10) {
    throw i2.onError(e10), e10;
  }
  if (!o2) {
    const e10 = new Cy(Ry.UNEXPECTED_ERROR, "can not find track in media stream");
    return i2.onError(e10), e10.throw(fb);
  }
  if (!s2 && "enable" === t2) {
    o2 && o2.stop();
    const e10 = new Cy(Ry.SHARE_AUDIO_NOT_ALLOWED);
    return i2.onError(e10), e10.throw(fb);
  }
  e9.optimizationMode || (e9.optimizationMode = "detail"), e9.optimizationMode && (dU(r2, o2, e9, e9.encoderConfig && lL(e9.encoderConfig) || void 0), e9.encoderConfig && "string" != typeof e9.encoderConfig && (e9.encoderConfig.bitrateMin = e9.encoderConfig.bitrateMax));
  const c2 = new aU(o2, e9.encoderConfig ? lL(e9.encoderConfig) : {}, e9.scalabiltyMode ? uL(e9.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e9.optimizationMode, r2, [mL.SCREEN_TRACK]);
  if (!s2) return i2.onSuccess(c2.getTrackId()), fb.info("create screen video track success", "video:", c2.getTrackId()), c2;
  const d2 = new TM(s2, void 0, TA(8, "track-scr-a-"), false);
  return i2.onSuccess([c2.getTrackId(), d2.getTrackId()]), fb.info("create screen video track success", "video:", c2.getTrackId(), "audio:", d2.getTrackId()), [c2, d2];
}, createMicrophoneAndCameraTracks: async function() {
  let e9 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  const i2 = XA("CAMERA_CAPTURE_CONFIG"), n2 = vb.reportApiInvoke(null, { tag: jy.TRACER, name: By.CREATE_MIC_AND_CAM_TRACKS, options: [e9, t2, i2] });
  i2 && (t2.encoderConfig = i2);
  const r2 = Ak(t2), o2 = bk(e9), s2 = TA(8, "track-mic-"), a2 = TA(8, "track-cam-");
  let c2 = null, d2 = null;
  fb.info("start create camera video track(".concat(a2, ") and microphone audio track(").concat(s2, ") with config, audio: ").concat(JSON.stringify(e9), ", video: ").concat(JSON.stringify(t2)));
  try {
    const e10 = await ak({ audio: o2, video: r2 }, "".concat(s2, "-").concat(a2));
    c2 = e10.getAudioTracks()[0], d2 = e10.getVideoTracks()[0];
  } catch (e10) {
    throw n2.onError(e10), e10;
  }
  if (!c2 || !d2) {
    const e10 = new Cy(Ry.UNEXPECTED_ERROR, "can not find tracks in media stream");
    return n2.onError(e10), e10.throw(fb);
  }
  t2.optimizationMode && dU(a2, d2, t2, dL(t2.encoderConfig));
  const l2 = new SM(c2, e9, o2, s2), u2 = new cU(d2, t2, r2, t2.scalabiltyMode ? uL(t2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t2.optimizationMode, a2);
  return n2.onSuccess([l2.getTrackId(), u2.getTrackId()]), fb.info("create camera video track(".concat(a2, ") and microphone audio track(").concat(s2, ") success")), [l2, u2];
}, createMicrophoneAudioTrack: async function() {
  let e9 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  const t2 = vb.reportApiInvoke(null, { tag: jy.TRACER, name: By.CREATE_MIC_AUDIO_TRACK, options: [e9] }), i2 = bk(e9), n2 = TA(8, "track-mic-");
  let r2 = null;
  fb.info("start create microphone audio track with config", JSON.stringify(e9), "trackId", n2);
  try {
    r2 = (await ak({ audio: i2 }, n2)).getAudioTracks()[0] || null;
  } catch (e10) {
    throw t2.onError(e10), e10;
  }
  if (!r2) {
    const e10 = new Cy(Ry.UNEXPECTED_ERROR, "can not find track in media stream");
    return t2.onError(e10), e10.throw(fb);
  }
  const o2 = new SM(r2, e9, i2, n2);
  return t2.onSuccess(o2.getTrackId()), fb.info("create microphone audio track success, trackId:", n2), o2;
}, createCustomAudioTrack: function(e9) {
  const t2 = vb.reportApiInvoke(null, { tag: jy.TRACER, name: By.CREATE_CUSTOM_AUDIO_TRACK, options: [e9] }), i2 = new TM(e9.mediaStreamTrack, e9.encoderConfig ? pL(e9.encoderConfig) : {}, TA(8, "track-cus-"), false);
  return fb.info("create custom audio track success with config", e9, "trackId", i2.getTrackId()), t2.onSuccess(i2.getTrackId()), i2;
}, createBufferSourceAudioTrack: async function(e9) {
  var t2;
  const { cacheOnlineFile: i2, encoderConfig: n2 } = e9;
  let { source: r2 } = e9;
  const o2 = { source: r2 instanceof AudioBuffer ? "AudioBuffer" : r2 instanceof File ? null !== (t2 = File.name) && void 0 !== t2 ? t2 : "File" : r2, cacheOnlineFile: i2, encoderConfig: n2 }, s2 = vb.reportApiInvoke(null, { tag: jy.TRACER, name: By.CREATE_BUFFER_AUDIO_TRACK, options: [o2] });
  if (XA("DISABLE_WEBAUDIO")) throw new Cy(Ry.NOT_SUPPORTED, "can not create BufferSourceAudioTrack when WebAudio disabled");
  const a2 = TA(8, "track-buf-");
  fb.info("start create buffer source audio track with config", JSON.stringify(o2), "trackId", a2);
  const c2 = r2;
  if (!(r2 instanceof AudioBuffer)) try {
    r2 = await async function(e10, t3) {
      let i3 = null;
      if ("string" == typeof e10) {
        const t4 = IM.get(e10);
        if (t4) return fb.debug("use cached audio resource: ", e10), t4;
        try {
          i3 = (await kA(() => Lv.get(e10, { responseType: "arraybuffer" }), void 0, void 0, { maxRetryCount: 3 })).data;
        } catch (e11) {
          throw new Cy(Ry.FETCH_AUDIO_FILE_FAILED, e11.toString());
        }
      } else {
        const t4 = new Gh((t5, i4) => {
          const n4 = new FileReader();
          n4.onload = (e11) => {
            e11.target ? t5(e11.target.result) : i4(new Cy(Ry.READ_LOCAL_AUDIO_FILE_ERROR));
          }, n4.onerror = () => {
            i4(new Cy(Ry.READ_LOCAL_AUDIO_FILE_ERROR));
          }, n4.readAsArrayBuffer(e10);
        });
        i3 = await t4;
      }
      const n3 = await function(e11) {
        const t4 = zL();
        return new Gh((i4, n4) => {
          t4.decodeAudioData(e11, (e12) => {
            i4(e12);
          }, (e12) => {
            n4(new Cy(Ry.DECODE_AUDIO_FILE_FAILED, e12.toString()));
          });
        });
      }(i3);
      return "string" == typeof e10 && t3 && IM.set(e10, n3), n3;
    }(r2, i2);
  } catch (e10) {
    return s2.onError(e10), e10.throw(fb);
  }
  const d2 = new CM(r2), l2 = new gM(c2, d2, n2 ? pL(n2) : {}, a2);
  return fb.info("create buffer source audio track success, trackId:", a2), s2.onSuccess(l2.getTrackId()), l2;
}, setAppType: function(e9) {
  if (fb.debug("setAppType: ".concat(e9)), !(Number.isInteger(e9) && e9 >= 0)) throw fb.debug("Invalid appType"), new yb(Ry.INVALID_PARAMS, "invalid app type", e9);
  JA("APP_TYPE", Math.floor(e9));
}, setLogLevel: function(e9) {
  fb.setLogLevel(e9);
}, enableLogUpload: function() {
  XA("USE_NEW_LOG") ? JA("UPLOAD_LOG", true) : fb.enableLogUpload();
}, disableLogUpload: function() {
  XA("USE_NEW_LOG") ? JA("UPLOAD_LOG", false) : fb.disableLogUpload();
}, createChannelMediaRelayConfiguration: function() {
  return new PF();
}, checkAudioTrackIsActive: async function(e9) {
  let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
  const i2 = vb.reportApiInvoke(null, { tag: jy.TRACER, name: By.CHECK_AUDIO_TRACK_IS_ACTIVE, options: [t2] });
  if (!(e9 instanceof TM || e9 instanceof vU)) {
    const e10 = new yb(Ry.INVALID_TRACK, "the parameter is not a audio track");
    return i2.onError(e10), e10.throw();
  }
  t2 && t2 < 1e3 && (t2 = 1e3);
  const n2 = e9 instanceof TM ? e9.getTrackLabel() : "remote_track", r2 = e9.getVolumeLevel();
  let o2 = r2, s2 = r2;
  const a2 = Date.now();
  return new Gh((r3) => {
    const c2 = setInterval(() => {
      const d2 = e9.getVolumeLevel();
      o2 = d2 > o2 ? d2 : o2, s2 = d2 < s2 ? d2 : s2;
      const l2 = o2 - s2 > 1e-4, u2 = Date.now() - a2;
      if (l2 || u2 > t2) {
        clearInterval(c2);
        const t3 = l2, s3 = { duration: u2, deviceLabel: n2, maxVolumeLevel: o2, result: t3 };
        fb.info("[track-".concat(e9.getTrackId(), "] check audio track active completed. ").concat(JSON.stringify(s3))), i2.onSuccess(s3), r3(t3);
      }
    }, 200);
  });
}, checkVideoTrackIsActive: async function(e9) {
  let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
  const i2 = vb.reportApiInvoke(null, { tag: jy.TRACER, name: By.CHECK_VIDEO_TRACK_IS_ACTIVE, options: [t2] });
  if (!(e9 instanceof aU || e9 instanceof IU)) {
    const e10 = new yb(Ry.INVALID_TRACK, "the parameter is not a video track");
    return i2.onError(e10), e10.throw();
  }
  t2 && t2 < 1e3 && (t2 = 1e3);
  const n2 = e9 instanceof aU ? e9.getTrackLabel() : "remote_track", r2 = e9.getMediaStreamTrack(true), o2 = document.createElement("video");
  o2.style.width = "1px", o2.style.height = "1px", o2.setAttribute("muted", ""), o2.muted = true, o2.setAttribute("playsinline", ""), o2.controls = false, (Xv() || zv()) && (o2.style.opacity = "0.01", o2.style.position = "fixed", o2.style.left = "0", o2.style.top = "0", document.body.appendChild(o2)), o2.srcObject = new MediaStream([r2]), o2.play();
  const s2 = document.createElement("canvas");
  s2.width = 160, s2.height = 120;
  let a2 = 0, c2 = 0;
  try {
    const e10 = Date.now();
    a2 = await function(e11, t3, i3, n3) {
      let r3, o3 = 0, s3 = null;
      return new Gh((a3, c3) => {
        function d3() {
          o3 > n3 && r3 && (r3(), a3(o3));
          const t4 = i3.getContext("2d");
          if (!t4) {
            const e12 = new yb(Ry.UNEXPECTED_ERROR, "can not get canvas 2d context.");
            return fb.error(e12.toString()), void c3(e12);
          }
          t4.drawImage(e11, 0, 0, 160, 120);
          const d4 = t4.getImageData(0, 0, i3.width, i3.height), l3 = Math.floor(d4.data.length / 3);
          if (s3) {
            for (let e12 = 0; e12 < l3; e12 += 3) if (d4.data[e12] !== s3[e12]) return o3 += 1, void (s3 = d4.data);
            s3 = d4.data;
          } else s3 = d4.data;
        }
        setTimeout(() => {
          r3 && (r3(), a3(o3));
        }, t3), r3 = QL(() => {
          d3();
        }, 30);
      });
    }(o2, t2, s2, 4), c2 = Date.now() - e10;
  } catch (e10) {
    throw i2.onError(e10), e10;
  }
  DB === Bv.SAFARI && (o2.pause(), o2.remove()), o2.srcObject = null;
  const d2 = a2 > 4, l2 = { duration: c2, changedPicNum: a2, deviceLabel: n2, result: d2 };
  return fb.info("[track-".concat(e9.getTrackId(), "] check video track active completed. ").concat(JSON.stringify(l2))), i2.onSuccess(l2), d2;
}, setArea: bx, audioElementPlayCenter: mk, resumeAudioContext: function() {
  mk.autoResumeAfterInterruption(true);
}, processExternalMediaAEC: function(e9) {
  OG.processExternalMediaAEC(e9);
}, registerExtensions: function(e9) {
  const t2 = XA("PLUGIN_INFO") || [];
  e9.forEach((e10) => {
    "name" in e10 && !Dn(t2).call(t2, e10.name) && t2.push(e10.name);
    const i2 = e10;
    i2.__registered__ = true, i2.logger.hookLog = fb.extLog, i2.reporter.hookApiInvoke = vb.extApiInvoke, i2.parameters && Object.keys(i2.parameters).forEach((e11) => {
      i2.parameters[e11] = XA(e11);
    });
  }), iq("PLUGIN_INFO", t2);
}, ChannelMediaRelayError: Qw, ChannelMediaRelayEvent: Jw, ChannelMediaRelayState: Xw, RemoteStreamFallbackType: gL, RemoteStreamType: SL, ConnectionDisconnectedReason: Hy, AudienceLatencyLevelType: Wy, AREAS: iO, preload: async function(e9, t2, i2, n2) {
  return KB(e9, t2, i2, n2);
} });
Object.defineProperties(nq, { onAudioAutoplayFailed: { get: () => pk.onAudioAutoplayFailed, set: (e9) => {
  pk.onAudioAutoplayFailed = e9;
} }, onAutoplayFailed: { get: () => pk.onAutoplayFailed, set: (e9) => {
  pk.onAutoplayFailed = e9;
} }, _onSecurityPolicyViolation: { value: void 0, writable: true }, _cspEventHandlerPointer: { value: void 0, writable: true }, onSecurityPolicyViolation: { get: () => nq._onSecurityPolicyViolation, set(e9) {
  nq._onSecurityPolicyViolation = e9, LG(e9);
} }, __CLIENT_LIST__: { get: () => XA("SHOW_GLOBAL_CLIENT_LIST") ? wb : [] } }), uk.on(kL.CAMERA_DEVICE_CHANGED, (e9) => {
  fb.info("camera device changed", JSON.stringify(e9)), nq.onCameraChanged && nq.onCameraChanged(e9), nq.safeEmit(SO.CAMERA_CHANGED, e9);
}), uk.on(kL.RECORDING_DEVICE_CHANGED, (e9) => {
  fb.info("microphone device changed", JSON.stringify(e9)), nq.onMicrophoneChanged && nq.onMicrophoneChanged(e9), nq.safeEmit(SO.MICROPHONE_CHANGED, e9);
}), uk.on(kL.PLAYOUT_DEVICE_CHANGED, (e9) => {
  fb.debug("playout device changed", JSON.stringify(e9)), nq.onPlaybackDeviceChanged && nq.onPlaybackDeviceChanged(e9), nq.safeEmit(SO.PLAYBACK_DEVICE_CHANGED, e9);
}), mk.onAutoplayFailed = () => {
  fb.info("detect audio element autoplay failed"), pk.onAudioAutoplayFailed && pk.onAudioAutoplayFailed();
}, qL.on("autoplay-failed", () => {
  fb.info("detect webaudio autoplay failed"), pk.onAudioAutoplayFailed && pk.onAudioAutoplayFailed(), nq.safeEmit(SO.AUTOPLAY_FAILED);
}), qL.on(tL.STATE_CHANGE, (e9, t2) => {
  fb.info("audio context state changed: ".concat(t2, " => ").concat(e9)), nq.onAudioContextStateChanged && nq.onAudioContextStateChanged(e9, t2), nq.safeEmit(SO.AUDIO_CONTEXT_STATE_CHANGED, e9, t2);
}), iA.on(Qy.NETWORK_STATE_CHANGE, (e9, t2) => {
  fb.info("[network-indicator] network state changed, ".concat(t2, " => ").concat(e9));
}), window && (window.__ARTC__ = nq);
export {
  nq as default
};
/*! Bundled license information:

agora-rtc-sdk-ng/AgoraRTC_N-production.esm.mjs:
  (*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> *)
*/
//# sourceMappingURL=agora-rtc-sdk-ng.js.map
